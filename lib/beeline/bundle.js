/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** multi main ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! babel-polyfill */1);
	module.exports = __webpack_require__(/*! /Users/xujing/Desktop/beeline-frontend/beeline/main.js */298);


/***/ },
/* 1 */
/*!***************************************!*\
  !*** ./~/babel-polyfill/lib/index.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	__webpack_require__(/*! core-js/shim */ 2);
	
	__webpack_require__(/*! regenerator-runtime/runtime */ 293);
	
	__webpack_require__(/*! core-js/fn/regexp/escape */ 295);
	
	if (global._babelPolyfill) {
	  throw new Error("only one instance of babel-polyfill is allowed");
	}
	global._babelPolyfill = true;
	
	var DEFINE_PROPERTY = "defineProperty";
	function define(O, key, value) {
	  O[key] || Object[DEFINE_PROPERTY](O, key, {
	    writable: true,
	    configurable: true,
	    value: value
	  });
	}
	
	define(String.prototype, "padLeft", "".padStart);
	define(String.prototype, "padRight", "".padEnd);
	
	"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
	  [][key] && define(Array, key, Function.call.bind([][key]));
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 2 */
/*!***************************!*\
  !*** ./~/core-js/shim.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./modules/es6.symbol */ 3);
	__webpack_require__(/*! ./modules/es6.object.create */ 52);
	__webpack_require__(/*! ./modules/es6.object.define-property */ 53);
	__webpack_require__(/*! ./modules/es6.object.define-properties */ 54);
	__webpack_require__(/*! ./modules/es6.object.get-own-property-descriptor */ 55);
	__webpack_require__(/*! ./modules/es6.object.get-prototype-of */ 57);
	__webpack_require__(/*! ./modules/es6.object.keys */ 60);
	__webpack_require__(/*! ./modules/es6.object.get-own-property-names */ 61);
	__webpack_require__(/*! ./modules/es6.object.freeze */ 62);
	__webpack_require__(/*! ./modules/es6.object.seal */ 63);
	__webpack_require__(/*! ./modules/es6.object.prevent-extensions */ 64);
	__webpack_require__(/*! ./modules/es6.object.is-frozen */ 65);
	__webpack_require__(/*! ./modules/es6.object.is-sealed */ 66);
	__webpack_require__(/*! ./modules/es6.object.is-extensible */ 67);
	__webpack_require__(/*! ./modules/es6.object.assign */ 68);
	__webpack_require__(/*! ./modules/es6.object.is */ 70);
	__webpack_require__(/*! ./modules/es6.object.set-prototype-of */ 72);
	__webpack_require__(/*! ./modules/es6.object.to-string */ 74);
	__webpack_require__(/*! ./modules/es6.function.bind */ 76);
	__webpack_require__(/*! ./modules/es6.function.name */ 79);
	__webpack_require__(/*! ./modules/es6.function.has-instance */ 80);
	__webpack_require__(/*! ./modules/es6.parse-int */ 81);
	__webpack_require__(/*! ./modules/es6.parse-float */ 85);
	__webpack_require__(/*! ./modules/es6.number.constructor */ 87);
	__webpack_require__(/*! ./modules/es6.number.to-fixed */ 89);
	__webpack_require__(/*! ./modules/es6.number.to-precision */ 92);
	__webpack_require__(/*! ./modules/es6.number.epsilon */ 93);
	__webpack_require__(/*! ./modules/es6.number.is-finite */ 94);
	__webpack_require__(/*! ./modules/es6.number.is-integer */ 95);
	__webpack_require__(/*! ./modules/es6.number.is-nan */ 97);
	__webpack_require__(/*! ./modules/es6.number.is-safe-integer */ 98);
	__webpack_require__(/*! ./modules/es6.number.max-safe-integer */ 99);
	__webpack_require__(/*! ./modules/es6.number.min-safe-integer */ 100);
	__webpack_require__(/*! ./modules/es6.number.parse-float */ 101);
	__webpack_require__(/*! ./modules/es6.number.parse-int */ 102);
	__webpack_require__(/*! ./modules/es6.math.acosh */ 103);
	__webpack_require__(/*! ./modules/es6.math.asinh */ 105);
	__webpack_require__(/*! ./modules/es6.math.atanh */ 106);
	__webpack_require__(/*! ./modules/es6.math.cbrt */ 107);
	__webpack_require__(/*! ./modules/es6.math.clz32 */ 109);
	__webpack_require__(/*! ./modules/es6.math.cosh */ 110);
	__webpack_require__(/*! ./modules/es6.math.expm1 */ 111);
	__webpack_require__(/*! ./modules/es6.math.fround */ 113);
	__webpack_require__(/*! ./modules/es6.math.hypot */ 114);
	__webpack_require__(/*! ./modules/es6.math.imul */ 115);
	__webpack_require__(/*! ./modules/es6.math.log10 */ 116);
	__webpack_require__(/*! ./modules/es6.math.log1p */ 117);
	__webpack_require__(/*! ./modules/es6.math.log2 */ 118);
	__webpack_require__(/*! ./modules/es6.math.sign */ 119);
	__webpack_require__(/*! ./modules/es6.math.sinh */ 120);
	__webpack_require__(/*! ./modules/es6.math.tanh */ 121);
	__webpack_require__(/*! ./modules/es6.math.trunc */ 122);
	__webpack_require__(/*! ./modules/es6.string.from-code-point */ 123);
	__webpack_require__(/*! ./modules/es6.string.raw */ 124);
	__webpack_require__(/*! ./modules/es6.string.trim */ 125);
	__webpack_require__(/*! ./modules/es6.string.iterator */ 126);
	__webpack_require__(/*! ./modules/es6.string.code-point-at */ 131);
	__webpack_require__(/*! ./modules/es6.string.ends-with */ 132);
	__webpack_require__(/*! ./modules/es6.string.includes */ 136);
	__webpack_require__(/*! ./modules/es6.string.repeat */ 137);
	__webpack_require__(/*! ./modules/es6.string.starts-with */ 138);
	__webpack_require__(/*! ./modules/es6.string.anchor */ 139);
	__webpack_require__(/*! ./modules/es6.string.big */ 141);
	__webpack_require__(/*! ./modules/es6.string.blink */ 142);
	__webpack_require__(/*! ./modules/es6.string.bold */ 143);
	__webpack_require__(/*! ./modules/es6.string.fixed */ 144);
	__webpack_require__(/*! ./modules/es6.string.fontcolor */ 145);
	__webpack_require__(/*! ./modules/es6.string.fontsize */ 146);
	__webpack_require__(/*! ./modules/es6.string.italics */ 147);
	__webpack_require__(/*! ./modules/es6.string.link */ 148);
	__webpack_require__(/*! ./modules/es6.string.small */ 149);
	__webpack_require__(/*! ./modules/es6.string.strike */ 150);
	__webpack_require__(/*! ./modules/es6.string.sub */ 151);
	__webpack_require__(/*! ./modules/es6.string.sup */ 152);
	__webpack_require__(/*! ./modules/es6.date.now */ 153);
	__webpack_require__(/*! ./modules/es6.date.to-json */ 154);
	__webpack_require__(/*! ./modules/es6.date.to-iso-string */ 155);
	__webpack_require__(/*! ./modules/es6.date.to-string */ 156);
	__webpack_require__(/*! ./modules/es6.date.to-primitive */ 157);
	__webpack_require__(/*! ./modules/es6.array.is-array */ 159);
	__webpack_require__(/*! ./modules/es6.array.from */ 160);
	__webpack_require__(/*! ./modules/es6.array.of */ 166);
	__webpack_require__(/*! ./modules/es6.array.join */ 167);
	__webpack_require__(/*! ./modules/es6.array.slice */ 169);
	__webpack_require__(/*! ./modules/es6.array.sort */ 170);
	__webpack_require__(/*! ./modules/es6.array.for-each */ 171);
	__webpack_require__(/*! ./modules/es6.array.map */ 175);
	__webpack_require__(/*! ./modules/es6.array.filter */ 176);
	__webpack_require__(/*! ./modules/es6.array.some */ 177);
	__webpack_require__(/*! ./modules/es6.array.every */ 178);
	__webpack_require__(/*! ./modules/es6.array.reduce */ 179);
	__webpack_require__(/*! ./modules/es6.array.reduce-right */ 181);
	__webpack_require__(/*! ./modules/es6.array.index-of */ 182);
	__webpack_require__(/*! ./modules/es6.array.last-index-of */ 183);
	__webpack_require__(/*! ./modules/es6.array.copy-within */ 184);
	__webpack_require__(/*! ./modules/es6.array.fill */ 187);
	__webpack_require__(/*! ./modules/es6.array.find */ 189);
	__webpack_require__(/*! ./modules/es6.array.find-index */ 190);
	__webpack_require__(/*! ./modules/es6.array.species */ 191);
	__webpack_require__(/*! ./modules/es6.array.iterator */ 193);
	__webpack_require__(/*! ./modules/es6.regexp.constructor */ 195);
	__webpack_require__(/*! ./modules/es6.regexp.to-string */ 197);
	__webpack_require__(/*! ./modules/es6.regexp.flags */ 198);
	__webpack_require__(/*! ./modules/es6.regexp.match */ 199);
	__webpack_require__(/*! ./modules/es6.regexp.replace */ 201);
	__webpack_require__(/*! ./modules/es6.regexp.search */ 202);
	__webpack_require__(/*! ./modules/es6.regexp.split */ 203);
	__webpack_require__(/*! ./modules/es6.promise */ 204);
	__webpack_require__(/*! ./modules/es6.map */ 211);
	__webpack_require__(/*! ./modules/es6.set */ 214);
	__webpack_require__(/*! ./modules/es6.weak-map */ 215);
	__webpack_require__(/*! ./modules/es6.weak-set */ 217);
	__webpack_require__(/*! ./modules/es6.typed.array-buffer */ 218);
	__webpack_require__(/*! ./modules/es6.typed.data-view */ 221);
	__webpack_require__(/*! ./modules/es6.typed.int8-array */ 222);
	__webpack_require__(/*! ./modules/es6.typed.uint8-array */ 224);
	__webpack_require__(/*! ./modules/es6.typed.uint8-clamped-array */ 225);
	__webpack_require__(/*! ./modules/es6.typed.int16-array */ 226);
	__webpack_require__(/*! ./modules/es6.typed.uint16-array */ 227);
	__webpack_require__(/*! ./modules/es6.typed.int32-array */ 228);
	__webpack_require__(/*! ./modules/es6.typed.uint32-array */ 229);
	__webpack_require__(/*! ./modules/es6.typed.float32-array */ 230);
	__webpack_require__(/*! ./modules/es6.typed.float64-array */ 231);
	__webpack_require__(/*! ./modules/es6.reflect.apply */ 232);
	__webpack_require__(/*! ./modules/es6.reflect.construct */ 233);
	__webpack_require__(/*! ./modules/es6.reflect.define-property */ 234);
	__webpack_require__(/*! ./modules/es6.reflect.delete-property */ 235);
	__webpack_require__(/*! ./modules/es6.reflect.enumerate */ 236);
	__webpack_require__(/*! ./modules/es6.reflect.get */ 237);
	__webpack_require__(/*! ./modules/es6.reflect.get-own-property-descriptor */ 238);
	__webpack_require__(/*! ./modules/es6.reflect.get-prototype-of */ 239);
	__webpack_require__(/*! ./modules/es6.reflect.has */ 240);
	__webpack_require__(/*! ./modules/es6.reflect.is-extensible */ 241);
	__webpack_require__(/*! ./modules/es6.reflect.own-keys */ 242);
	__webpack_require__(/*! ./modules/es6.reflect.prevent-extensions */ 244);
	__webpack_require__(/*! ./modules/es6.reflect.set */ 245);
	__webpack_require__(/*! ./modules/es6.reflect.set-prototype-of */ 246);
	__webpack_require__(/*! ./modules/es7.array.includes */ 247);
	__webpack_require__(/*! ./modules/es7.string.at */ 248);
	__webpack_require__(/*! ./modules/es7.string.pad-start */ 249);
	__webpack_require__(/*! ./modules/es7.string.pad-end */ 251);
	__webpack_require__(/*! ./modules/es7.string.trim-left */ 252);
	__webpack_require__(/*! ./modules/es7.string.trim-right */ 253);
	__webpack_require__(/*! ./modules/es7.string.match-all */ 254);
	__webpack_require__(/*! ./modules/es7.symbol.async-iterator */ 255);
	__webpack_require__(/*! ./modules/es7.symbol.observable */ 256);
	__webpack_require__(/*! ./modules/es7.object.get-own-property-descriptors */ 257);
	__webpack_require__(/*! ./modules/es7.object.values */ 258);
	__webpack_require__(/*! ./modules/es7.object.entries */ 260);
	__webpack_require__(/*! ./modules/es7.object.define-getter */ 261);
	__webpack_require__(/*! ./modules/es7.object.define-setter */ 263);
	__webpack_require__(/*! ./modules/es7.object.lookup-getter */ 264);
	__webpack_require__(/*! ./modules/es7.object.lookup-setter */ 265);
	__webpack_require__(/*! ./modules/es7.map.to-json */ 266);
	__webpack_require__(/*! ./modules/es7.set.to-json */ 269);
	__webpack_require__(/*! ./modules/es7.system.global */ 270);
	__webpack_require__(/*! ./modules/es7.error.is-error */ 271);
	__webpack_require__(/*! ./modules/es7.math.iaddh */ 272);
	__webpack_require__(/*! ./modules/es7.math.isubh */ 273);
	__webpack_require__(/*! ./modules/es7.math.imulh */ 274);
	__webpack_require__(/*! ./modules/es7.math.umulh */ 275);
	__webpack_require__(/*! ./modules/es7.reflect.define-metadata */ 276);
	__webpack_require__(/*! ./modules/es7.reflect.delete-metadata */ 278);
	__webpack_require__(/*! ./modules/es7.reflect.get-metadata */ 279);
	__webpack_require__(/*! ./modules/es7.reflect.get-metadata-keys */ 280);
	__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata */ 281);
	__webpack_require__(/*! ./modules/es7.reflect.get-own-metadata-keys */ 282);
	__webpack_require__(/*! ./modules/es7.reflect.has-metadata */ 283);
	__webpack_require__(/*! ./modules/es7.reflect.has-own-metadata */ 284);
	__webpack_require__(/*! ./modules/es7.reflect.metadata */ 285);
	__webpack_require__(/*! ./modules/es7.asap */ 286);
	__webpack_require__(/*! ./modules/es7.observable */ 287);
	__webpack_require__(/*! ./modules/web.timers */ 288);
	__webpack_require__(/*! ./modules/web.immediate */ 291);
	__webpack_require__(/*! ./modules/web.dom.iterable */ 292);
	module.exports = __webpack_require__(/*! ./modules/_core */ 9);

/***/ },
/* 3 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/es6.symbol.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(/*! ./_global */ 4)
	  , has            = __webpack_require__(/*! ./_has */ 5)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 6)
	  , $export        = __webpack_require__(/*! ./_export */ 8)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 18)
	  , META           = __webpack_require__(/*! ./_meta */ 22).KEY
	  , $fails         = __webpack_require__(/*! ./_fails */ 7)
	  , shared         = __webpack_require__(/*! ./_shared */ 23)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 24)
	  , uid            = __webpack_require__(/*! ./_uid */ 19)
	  , wks            = __webpack_require__(/*! ./_wks */ 25)
	  , wksExt         = __webpack_require__(/*! ./_wks-ext */ 26)
	  , wksDefine      = __webpack_require__(/*! ./_wks-define */ 27)
	  , keyOf          = __webpack_require__(/*! ./_keyof */ 29)
	  , enumKeys       = __webpack_require__(/*! ./_enum-keys */ 42)
	  , isArray        = __webpack_require__(/*! ./_is-array */ 45)
	  , anObject       = __webpack_require__(/*! ./_an-object */ 12)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 32)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 16)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 17)
	  , _create        = __webpack_require__(/*! ./_object-create */ 46)
	  , gOPNExt        = __webpack_require__(/*! ./_object-gopn-ext */ 49)
	  , $GOPD          = __webpack_require__(/*! ./_object-gopd */ 51)
	  , $DP            = __webpack_require__(/*! ./_object-dp */ 11)
	  , $keys          = __webpack_require__(/*! ./_object-keys */ 30)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(/*! ./_object-gopn */ 50).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(/*! ./_object-pie */ 44).f  = $propertyIsEnumerable;
	  __webpack_require__(/*! ./_object-gops */ 43).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(/*! ./_library */ 28)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ 10)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 4 */
/*!**************************************!*\
  !*** ./~/core-js/modules/_global.js ***!
  \**************************************/
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 5 */
/*!***********************************!*\
  !*** ./~/core-js/modules/_has.js ***!
  \***********************************/
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 6 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_descriptors.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(/*! ./_fails */ 7)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 7 */
/*!*************************************!*\
  !*** ./~/core-js/modules/_fails.js ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 8 */
/*!**************************************!*\
  !*** ./~/core-js/modules/_export.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 4)
	  , core      = __webpack_require__(/*! ./_core */ 9)
	  , hide      = __webpack_require__(/*! ./_hide */ 10)
	  , redefine  = __webpack_require__(/*! ./_redefine */ 18)
	  , ctx       = __webpack_require__(/*! ./_ctx */ 20)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
	    , key, own, out, exp;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    // export native or passed
	    out = (own ? target : source)[key];
	    // bind timers to global for call from export context
	    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // extend global
	    if(target)redefine(target, key, out, type & $export.U);
	    // export
	    if(exports[key] != out)hide(exports, key, exp);
	    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
	  }
	};
	global.core = core;
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 9 */
/*!************************************!*\
  !*** ./~/core-js/modules/_core.js ***!
  \************************************/
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 10 */
/*!************************************!*\
  !*** ./~/core-js/modules/_hide.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(/*! ./_object-dp */ 11)
	  , createDesc = __webpack_require__(/*! ./_property-desc */ 17);
	module.exports = __webpack_require__(/*! ./_descriptors */ 6) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 11 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_object-dp.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(/*! ./_an-object */ 12)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 14)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 16)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(/*! ./_descriptors */ 6) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 12 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_an-object.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 13);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 13 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_is-object.js ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 14 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/_ie8-dom-define.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(/*! ./_descriptors */ 6) && !__webpack_require__(/*! ./_fails */ 7)(function(){
	  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ 15)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 15 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_dom-create.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , document = __webpack_require__(/*! ./_global */ 4).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 16 */
/*!********************************************!*\
  !*** ./~/core-js/modules/_to-primitive.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(/*! ./_is-object */ 13);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 17 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_property-desc.js ***!
  \*********************************************/
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 18 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_redefine.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 4)
	  , hide      = __webpack_require__(/*! ./_hide */ 10)
	  , has       = __webpack_require__(/*! ./_has */ 5)
	  , SRC       = __webpack_require__(/*! ./_uid */ 19)('src')
	  , TO_STRING = 'toString'
	  , $toString = Function[TO_STRING]
	  , TPL       = ('' + $toString).split(TO_STRING);
	
	__webpack_require__(/*! ./_core */ 9).inspectSource = function(it){
	  return $toString.call(it);
	};
	
	(module.exports = function(O, key, val, safe){
	  var isFunction = typeof val == 'function';
	  if(isFunction)has(val, 'name') || hide(val, 'name', key);
	  if(O[key] === val)return;
	  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
	  if(O === global){
	    O[key] = val;
	  } else {
	    if(!safe){
	      delete O[key];
	      hide(O, key, val);
	    } else {
	      if(O[key])O[key] = val;
	      else hide(O, key, val);
	    }
	  }
	// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
	})(Function.prototype, TO_STRING, function toString(){
	  return typeof this == 'function' && this[SRC] || $toString.call(this);
	});

/***/ },
/* 19 */
/*!***********************************!*\
  !*** ./~/core-js/modules/_uid.js ***!
  \***********************************/
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 20 */
/*!***********************************!*\
  !*** ./~/core-js/modules/_ctx.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(/*! ./_a-function */ 21);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 21 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_a-function.js ***!
  \******************************************/
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 22 */
/*!************************************!*\
  !*** ./~/core-js/modules/_meta.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(/*! ./_uid */ 19)('meta')
	  , isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , has      = __webpack_require__(/*! ./_has */ 5)
	  , setDesc  = __webpack_require__(/*! ./_object-dp */ 11).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(/*! ./_fails */ 7)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 23 */
/*!**************************************!*\
  !*** ./~/core-js/modules/_shared.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./_global */ 4)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 24 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/_set-to-string-tag.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(/*! ./_object-dp */ 11).f
	  , has = __webpack_require__(/*! ./_has */ 5)
	  , TAG = __webpack_require__(/*! ./_wks */ 25)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 25 */
/*!***********************************!*\
  !*** ./~/core-js/modules/_wks.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(/*! ./_shared */ 23)('wks')
	  , uid        = __webpack_require__(/*! ./_uid */ 19)
	  , Symbol     = __webpack_require__(/*! ./_global */ 4).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 26 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_wks-ext.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(/*! ./_wks */ 25);

/***/ },
/* 27 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_wks-define.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(/*! ./_global */ 4)
	  , core           = __webpack_require__(/*! ./_core */ 9)
	  , LIBRARY        = __webpack_require__(/*! ./_library */ 28)
	  , wksExt         = __webpack_require__(/*! ./_wks-ext */ 26)
	  , defineProperty = __webpack_require__(/*! ./_object-dp */ 11).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 28 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_library.js ***!
  \***************************************/
/***/ function(module, exports) {

	module.exports = false;

/***/ },
/* 29 */
/*!*************************************!*\
  !*** ./~/core-js/modules/_keyof.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 30)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 32);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 30 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_object-keys.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(/*! ./_object-keys-internal */ 31)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 41);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 31 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/_object-keys-internal.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(/*! ./_has */ 5)
	  , toIObject    = __webpack_require__(/*! ./_to-iobject */ 32)
	  , arrayIndexOf = __webpack_require__(/*! ./_array-includes */ 36)(false)
	  , IE_PROTO     = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 32 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_to-iobject.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(/*! ./_iobject */ 33)
	  , defined = __webpack_require__(/*! ./_defined */ 35);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 33 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_iobject.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(/*! ./_cof */ 34);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 34 */
/*!***********************************!*\
  !*** ./~/core-js/modules/_cof.js ***!
  \***********************************/
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 35 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_defined.js ***!
  \***************************************/
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 36 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/_array-includes.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 32)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 37)
	  , toIndex   = __webpack_require__(/*! ./_to-index */ 39);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 37 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_to-length.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(/*! ./_to-integer */ 38)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 38 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_to-integer.js ***!
  \******************************************/
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 39 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_to-index.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 38)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 40 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_shared-key.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(/*! ./_shared */ 23)('keys')
	  , uid    = __webpack_require__(/*! ./_uid */ 19);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 41 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_enum-bug-keys.js ***!
  \*********************************************/
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 42 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_enum-keys.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(/*! ./_object-keys */ 30)
	  , gOPS    = __webpack_require__(/*! ./_object-gops */ 43)
	  , pIE     = __webpack_require__(/*! ./_object-pie */ 44);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 43 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_object-gops.js ***!
  \*******************************************/
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 44 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_object-pie.js ***!
  \******************************************/
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 45 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_is-array.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(/*! ./_cof */ 34);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 46 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_object-create.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , dPs         = __webpack_require__(/*! ./_object-dps */ 47)
	  , enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ 41)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(/*! ./_dom-create */ 15)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(/*! ./_html */ 48).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 47 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_object-dps.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(/*! ./_object-dp */ 11)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12)
	  , getKeys  = __webpack_require__(/*! ./_object-keys */ 30);
	
	module.exports = __webpack_require__(/*! ./_descriptors */ 6) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 48 */
/*!************************************!*\
  !*** ./~/core-js/modules/_html.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_global */ 4).document && document.documentElement;

/***/ },
/* 49 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/_object-gopn-ext.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(/*! ./_to-iobject */ 32)
	  , gOPN      = __webpack_require__(/*! ./_object-gopn */ 50).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 50 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_object-gopn.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(/*! ./_object-keys-internal */ 31)
	  , hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ 41).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 51 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_object-gopd.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(/*! ./_object-pie */ 44)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 17)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 32)
	  , toPrimitive    = __webpack_require__(/*! ./_to-primitive */ 16)
	  , has            = __webpack_require__(/*! ./_has */ 5)
	  , IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ 14)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(/*! ./_descriptors */ 6) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 52 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.object.create.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(/*! ./_object-create */ 46)});

/***/ },
/* 53 */
/*!*********************************************************!*\
  !*** ./~/core-js/modules/es6.object.define-property.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ 6), 'Object', {defineProperty: __webpack_require__(/*! ./_object-dp */ 11).f});

/***/ },
/* 54 */
/*!***********************************************************!*\
  !*** ./~/core-js/modules/es6.object.define-properties.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8);
	// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
	$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ 6), 'Object', {defineProperties: __webpack_require__(/*! ./_object-dps */ 47)});

/***/ },
/* 55 */
/*!*********************************************************************!*\
  !*** ./~/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \*********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	var toIObject                 = __webpack_require__(/*! ./_to-iobject */ 32)
	  , $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ 51).f;
	
	__webpack_require__(/*! ./_object-sap */ 56)('getOwnPropertyDescriptor', function(){
	  return function getOwnPropertyDescriptor(it, key){
	    return $getOwnPropertyDescriptor(toIObject(it), key);
	  };
	});

/***/ },
/* 56 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_object-sap.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , core    = __webpack_require__(/*! ./_core */ 9)
	  , fails   = __webpack_require__(/*! ./_fails */ 7);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 57 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.object.get-prototype-of.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(/*! ./_to-object */ 58)
	  , $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 59);
	
	__webpack_require__(/*! ./_object-sap */ 56)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 58 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_to-object.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(/*! ./_defined */ 35);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 59 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_object-gpo.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(/*! ./_has */ 5)
	  , toObject    = __webpack_require__(/*! ./_to-object */ 58)
	  , IE_PROTO    = __webpack_require__(/*! ./_shared-key */ 40)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 60 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.object.keys.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(/*! ./_to-object */ 58)
	  , $keys    = __webpack_require__(/*! ./_object-keys */ 30);
	
	__webpack_require__(/*! ./_object-sap */ 56)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 61 */
/*!****************************************************************!*\
  !*** ./~/core-js/modules/es6.object.get-own-property-names.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 Object.getOwnPropertyNames(O)
	__webpack_require__(/*! ./_object-sap */ 56)('getOwnPropertyNames', function(){
	  return __webpack_require__(/*! ./_object-gopn-ext */ 49).f;
	});

/***/ },
/* 62 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.object.freeze.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.5 Object.freeze(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , meta     = __webpack_require__(/*! ./_meta */ 22).onFreeze;
	
	__webpack_require__(/*! ./_object-sap */ 56)('freeze', function($freeze){
	  return function freeze(it){
	    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
	  };
	});

/***/ },
/* 63 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.object.seal.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.17 Object.seal(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , meta     = __webpack_require__(/*! ./_meta */ 22).onFreeze;
	
	__webpack_require__(/*! ./_object-sap */ 56)('seal', function($seal){
	  return function seal(it){
	    return $seal && isObject(it) ? $seal(meta(it)) : it;
	  };
	});

/***/ },
/* 64 */
/*!************************************************************!*\
  !*** ./~/core-js/modules/es6.object.prevent-extensions.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.15 Object.preventExtensions(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , meta     = __webpack_require__(/*! ./_meta */ 22).onFreeze;
	
	__webpack_require__(/*! ./_object-sap */ 56)('preventExtensions', function($preventExtensions){
	  return function preventExtensions(it){
	    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
	  };
	});

/***/ },
/* 65 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.object.is-frozen.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.12 Object.isFrozen(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13);
	
	__webpack_require__(/*! ./_object-sap */ 56)('isFrozen', function($isFrozen){
	  return function isFrozen(it){
	    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
	  };
	});

/***/ },
/* 66 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.object.is-sealed.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.13 Object.isSealed(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13);
	
	__webpack_require__(/*! ./_object-sap */ 56)('isSealed', function($isSealed){
	  return function isSealed(it){
	    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
	  };
	});

/***/ },
/* 67 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es6.object.is-extensible.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.11 Object.isExtensible(O)
	var isObject = __webpack_require__(/*! ./_is-object */ 13);
	
	__webpack_require__(/*! ./_object-sap */ 56)('isExtensible', function($isExtensible){
	  return function isExtensible(it){
	    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
	  };
	});

/***/ },
/* 68 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.object.assign.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(/*! ./_object-assign */ 69)});

/***/ },
/* 69 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_object-assign.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(/*! ./_object-keys */ 30)
	  , gOPS     = __webpack_require__(/*! ./_object-gops */ 43)
	  , pIE      = __webpack_require__(/*! ./_object-pie */ 44)
	  , toObject = __webpack_require__(/*! ./_to-object */ 58)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 33)
	  , $assign  = Object.assign;
	
	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(/*! ./_fails */ 7)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ },
/* 70 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.object.is.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.10 Object.is(value1, value2)
	var $export = __webpack_require__(/*! ./_export */ 8);
	$export($export.S, 'Object', {is: __webpack_require__(/*! ./_same-value */ 71)});

/***/ },
/* 71 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_same-value.js ***!
  \******************************************/
/***/ function(module, exports) {

	// 7.2.9 SameValue(x, y)
	module.exports = Object.is || function is(x, y){
	  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
	};

/***/ },
/* 72 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.object.set-prototype-of.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(/*! ./_export */ 8);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(/*! ./_set-proto */ 73).set});

/***/ },
/* 73 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_set-proto.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(/*! ./_ctx */ 20)(Function.call, __webpack_require__(/*! ./_object-gopd */ 51).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 74 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.object.to-string.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.3.6 Object.prototype.toString()
	var classof = __webpack_require__(/*! ./_classof */ 75)
	  , test    = {};
	test[__webpack_require__(/*! ./_wks */ 25)('toStringTag')] = 'z';
	if(test + '' != '[object z]'){
	  __webpack_require__(/*! ./_redefine */ 18)(Object.prototype, 'toString', function toString(){
	    return '[object ' + classof(this) + ']';
	  }, true);
	}

/***/ },
/* 75 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_classof.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(/*! ./_cof */ 34)
	  , TAG = __webpack_require__(/*! ./_wks */ 25)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 76 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.function.bind.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P, 'Function', {bind: __webpack_require__(/*! ./_bind */ 77)});

/***/ },
/* 77 */
/*!************************************!*\
  !*** ./~/core-js/modules/_bind.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var aFunction  = __webpack_require__(/*! ./_a-function */ 21)
	  , isObject   = __webpack_require__(/*! ./_is-object */ 13)
	  , invoke     = __webpack_require__(/*! ./_invoke */ 78)
	  , arraySlice = [].slice
	  , factories  = {};
	
	var construct = function(F, len, args){
	  if(!(len in factories)){
	    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
	    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
	  } return factories[len](F, args);
	};
	
	module.exports = Function.bind || function bind(that /*, args... */){
	  var fn       = aFunction(this)
	    , partArgs = arraySlice.call(arguments, 1);
	  var bound = function(/* args... */){
	    var args = partArgs.concat(arraySlice.call(arguments));
	    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
	  };
	  if(isObject(fn.prototype))bound.prototype = fn.prototype;
	  return bound;
	};

/***/ },
/* 78 */
/*!**************************************!*\
  !*** ./~/core-js/modules/_invoke.js ***!
  \**************************************/
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 79 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.function.name.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(/*! ./_object-dp */ 11).f
	  , createDesc = __webpack_require__(/*! ./_property-desc */ 17)
	  , has        = __webpack_require__(/*! ./_has */ 5)
	  , FProto     = Function.prototype
	  , nameRE     = /^\s*function ([^ (]*)/
	  , NAME       = 'name';
	
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	
	// 19.2.4.2 name
	NAME in FProto || __webpack_require__(/*! ./_descriptors */ 6) && dP(FProto, NAME, {
	  configurable: true,
	  get: function(){
	    try {
	      var that = this
	        , name = ('' + that).match(nameRE)[1];
	      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
	      return name;
	    } catch(e){
	      return '';
	    }
	  }
	});

/***/ },
/* 80 */
/*!********************************************************!*\
  !*** ./~/core-js/modules/es6.function.has-instance.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var isObject       = __webpack_require__(/*! ./_is-object */ 13)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 59)
	  , HAS_INSTANCE   = __webpack_require__(/*! ./_wks */ 25)('hasInstance')
	  , FunctionProto  = Function.prototype;
	// 19.2.3.6 Function.prototype[@@hasInstance](V)
	if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(/*! ./_object-dp */ 11).f(FunctionProto, HAS_INSTANCE, {value: function(O){
	  if(typeof this != 'function' || !isObject(O))return false;
	  if(!isObject(this.prototype))return O instanceof this;
	  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
	  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
	  return false;
	}});

/***/ },
/* 81 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.parse-int.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , $parseInt = __webpack_require__(/*! ./_parse-int */ 82);
	// 18.2.5 parseInt(string, radix)
	$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ },
/* 82 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_parse-int.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var $parseInt = __webpack_require__(/*! ./_global */ 4).parseInt
	  , $trim     = __webpack_require__(/*! ./_string-trim */ 83).trim
	  , ws        = __webpack_require__(/*! ./_string-ws */ 84)
	  , hex       = /^[\-+]?0[xX]/;
	
	module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
	  var string = $trim(String(str), 3);
	  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
	} : $parseInt;

/***/ },
/* 83 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_string-trim.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8)
	  , defined = __webpack_require__(/*! ./_defined */ 35)
	  , fails   = __webpack_require__(/*! ./_fails */ 7)
	  , spaces  = __webpack_require__(/*! ./_string-ws */ 84)
	  , space   = '[' + spaces + ']'
	  , non     = '\u200b\u0085'
	  , ltrim   = RegExp('^' + space + space + '*')
	  , rtrim   = RegExp(space + space + '*$');
	
	var exporter = function(KEY, exec, ALIAS){
	  var exp   = {};
	  var FORCE = fails(function(){
	    return !!spaces[KEY]() || non[KEY]() != non;
	  });
	  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
	  if(ALIAS)exp[ALIAS] = fn;
	  $export($export.P + $export.F * FORCE, 'String', exp);
	};
	
	// 1 -> String#trimLeft
	// 2 -> String#trimRight
	// 3 -> String#trim
	var trim = exporter.trim = function(string, TYPE){
	  string = String(defined(string));
	  if(TYPE & 1)string = string.replace(ltrim, '');
	  if(TYPE & 2)string = string.replace(rtrim, '');
	  return string;
	};
	
	module.exports = exporter;

/***/ },
/* 84 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_string-ws.js ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
	  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ },
/* 85 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.parse-float.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , $parseFloat = __webpack_require__(/*! ./_parse-float */ 86);
	// 18.2.4 parseFloat(string)
	$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ },
/* 86 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_parse-float.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var $parseFloat = __webpack_require__(/*! ./_global */ 4).parseFloat
	  , $trim       = __webpack_require__(/*! ./_string-trim */ 83).trim;
	
	module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ 84) + '-0') !== -Infinity ? function parseFloat(str){
	  var string = $trim(String(str), 3)
	    , result = $parseFloat(string);
	  return result === 0 && string.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

/***/ },
/* 87 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.number.constructor.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(/*! ./_global */ 4)
	  , has               = __webpack_require__(/*! ./_has */ 5)
	  , cof               = __webpack_require__(/*! ./_cof */ 34)
	  , inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ 88)
	  , toPrimitive       = __webpack_require__(/*! ./_to-primitive */ 16)
	  , fails             = __webpack_require__(/*! ./_fails */ 7)
	  , gOPN              = __webpack_require__(/*! ./_object-gopn */ 50).f
	  , gOPD              = __webpack_require__(/*! ./_object-gopd */ 51).f
	  , dP                = __webpack_require__(/*! ./_object-dp */ 11).f
	  , $trim             = __webpack_require__(/*! ./_string-trim */ 83).trim
	  , NUMBER            = 'Number'
	  , $Number           = global[NUMBER]
	  , Base              = $Number
	  , proto             = $Number.prototype
	  // Opera ~12 has broken Object#toString
	  , BROKEN_COF        = cof(__webpack_require__(/*! ./_object-create */ 46)(proto)) == NUMBER
	  , TRIM              = 'trim' in String.prototype;
	
	// 7.1.3 ToNumber(argument)
	var toNumber = function(argument){
	  var it = toPrimitive(argument, false);
	  if(typeof it == 'string' && it.length > 2){
	    it = TRIM ? it.trim() : $trim(it, 3);
	    var first = it.charCodeAt(0)
	      , third, radix, maxCode;
	    if(first === 43 || first === 45){
	      third = it.charCodeAt(2);
	      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
	    } else if(first === 48){
	      switch(it.charCodeAt(1)){
	        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
	        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
	        default : return +it;
	      }
	      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
	        code = digits.charCodeAt(i);
	        // parseInt parses a string to a first unavailable symbol
	        // but ToNumber should return NaN if a string contains unavailable symbols
	        if(code < 48 || code > maxCode)return NaN;
	      } return parseInt(digits, radix);
	    }
	  } return +it;
	};
	
	if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
	  $Number = function Number(value){
	    var it = arguments.length < 1 ? 0 : value
	      , that = this;
	    return that instanceof $Number
	      // check on 1..constructor(foo) case
	      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
	        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
	  };
	  for(var keys = __webpack_require__(/*! ./_descriptors */ 6) ? gOPN(Base) : (
	    // ES3:
	    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
	    // ES6 (in case, if modules with ES6 Number statics required before):
	    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
	    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
	  ).split(','), j = 0, key; keys.length > j; j++){
	    if(has(Base, key = keys[j]) && !has($Number, key)){
	      dP($Number, key, gOPD(Base, key));
	    }
	  }
	  $Number.prototype = proto;
	  proto.constructor = $Number;
	  __webpack_require__(/*! ./_redefine */ 18)(global, NUMBER, $Number);
	}

/***/ },
/* 88 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/_inherit-if-required.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject       = __webpack_require__(/*! ./_is-object */ 13)
	  , setPrototypeOf = __webpack_require__(/*! ./_set-proto */ 73).set;
	module.exports = function(that, target, C){
	  var P, S = target.constructor;
	  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
	    setPrototypeOf(that, P);
	  } return that;
	};

/***/ },
/* 89 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/es6.number.to-fixed.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(/*! ./_export */ 8)
	  , toInteger    = __webpack_require__(/*! ./_to-integer */ 38)
	  , aNumberValue = __webpack_require__(/*! ./_a-number-value */ 90)
	  , repeat       = __webpack_require__(/*! ./_string-repeat */ 91)
	  , $toFixed     = 1..toFixed
	  , floor        = Math.floor
	  , data         = [0, 0, 0, 0, 0, 0]
	  , ERROR        = 'Number.toFixed: incorrect invocation!'
	  , ZERO         = '0';
	
	var multiply = function(n, c){
	  var i  = -1
	    , c2 = c;
	  while(++i < 6){
	    c2 += n * data[i];
	    data[i] = c2 % 1e7;
	    c2 = floor(c2 / 1e7);
	  }
	};
	var divide = function(n){
	  var i = 6
	    , c = 0;
	  while(--i >= 0){
	    c += data[i];
	    data[i] = floor(c / n);
	    c = (c % n) * 1e7;
	  }
	};
	var numToString = function(){
	  var i = 6
	    , s = '';
	  while(--i >= 0){
	    if(s !== '' || i === 0 || data[i] !== 0){
	      var t = String(data[i]);
	      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
	    }
	  } return s;
	};
	var pow = function(x, n, acc){
	  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
	};
	var log = function(x){
	  var n  = 0
	    , x2 = x;
	  while(x2 >= 4096){
	    n += 12;
	    x2 /= 4096;
	  }
	  while(x2 >= 2){
	    n  += 1;
	    x2 /= 2;
	  } return n;
	};
	
	$export($export.P + $export.F * (!!$toFixed && (
	  0.00008.toFixed(3) !== '0.000' ||
	  0.9.toFixed(0) !== '1' ||
	  1.255.toFixed(2) !== '1.25' ||
	  1000000000000000128..toFixed(0) !== '1000000000000000128'
	) || !__webpack_require__(/*! ./_fails */ 7)(function(){
	  // V8 ~ Android 4.3-
	  $toFixed.call({});
	})), 'Number', {
	  toFixed: function toFixed(fractionDigits){
	    var x = aNumberValue(this, ERROR)
	      , f = toInteger(fractionDigits)
	      , s = ''
	      , m = ZERO
	      , e, z, j, k;
	    if(f < 0 || f > 20)throw RangeError(ERROR);
	    if(x != x)return 'NaN';
	    if(x <= -1e21 || x >= 1e21)return String(x);
	    if(x < 0){
	      s = '-';
	      x = -x;
	    }
	    if(x > 1e-21){
	      e = log(x * pow(2, 69, 1)) - 69;
	      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
	      z *= 0x10000000000000;
	      e = 52 - e;
	      if(e > 0){
	        multiply(0, z);
	        j = f;
	        while(j >= 7){
	          multiply(1e7, 0);
	          j -= 7;
	        }
	        multiply(pow(10, j, 1), 0);
	        j = e - 1;
	        while(j >= 23){
	          divide(1 << 23);
	          j -= 23;
	        }
	        divide(1 << j);
	        multiply(1, 1);
	        divide(2);
	        m = numToString();
	      } else {
	        multiply(0, z);
	        multiply(1 << -e, 0);
	        m = numToString() + repeat.call(ZERO, f);
	      }
	    }
	    if(f > 0){
	      k = m.length;
	      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
	    } else {
	      m = s + m;
	    } return m;
	  }
	});

/***/ },
/* 90 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/_a-number-value.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	var cof = __webpack_require__(/*! ./_cof */ 34);
	module.exports = function(it, msg){
	  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
	  return +it;
	};

/***/ },
/* 91 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_string-repeat.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var toInteger = __webpack_require__(/*! ./_to-integer */ 38)
	  , defined   = __webpack_require__(/*! ./_defined */ 35);
	
	module.exports = function repeat(count){
	  var str = String(defined(this))
	    , res = ''
	    , n   = toInteger(count);
	  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
	  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
	  return res;
	};

/***/ },
/* 92 */
/*!******************************************************!*\
  !*** ./~/core-js/modules/es6.number.to-precision.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(/*! ./_export */ 8)
	  , $fails       = __webpack_require__(/*! ./_fails */ 7)
	  , aNumberValue = __webpack_require__(/*! ./_a-number-value */ 90)
	  , $toPrecision = 1..toPrecision;
	
	$export($export.P + $export.F * ($fails(function(){
	  // IE7-
	  return $toPrecision.call(1, undefined) !== '1';
	}) || !$fails(function(){
	  // V8 ~ Android 4.3-
	  $toPrecision.call({});
	})), 'Number', {
	  toPrecision: function toPrecision(precision){
	    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
	    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
	  }
	});

/***/ },
/* 93 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.number.epsilon.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.1 Number.EPSILON
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ },
/* 94 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.number.is-finite.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , _isFinite = __webpack_require__(/*! ./_global */ 4).isFinite;
	
	$export($export.S, 'Number', {
	  isFinite: function isFinite(it){
	    return typeof it == 'number' && _isFinite(it);
	  }
	});

/***/ },
/* 95 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.number.is-integer.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Number', {isInteger: __webpack_require__(/*! ./_is-integer */ 96)});

/***/ },
/* 96 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_is-integer.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.3 Number.isInteger(number)
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , floor    = Math.floor;
	module.exports = function isInteger(it){
	  return !isObject(it) && isFinite(it) && floor(it) === it;
	};

/***/ },
/* 97 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.number.is-nan.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.4 Number.isNaN(number)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Number', {
	  isNaN: function isNaN(number){
	    return number != number;
	  }
	});

/***/ },
/* 98 */
/*!*********************************************************!*\
  !*** ./~/core-js/modules/es6.number.is-safe-integer.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.5 Number.isSafeInteger(number)
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , isInteger = __webpack_require__(/*! ./_is-integer */ 96)
	  , abs       = Math.abs;
	
	$export($export.S, 'Number', {
	  isSafeInteger: function isSafeInteger(number){
	    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
	  }
	});

/***/ },
/* 99 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.number.max-safe-integer.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.6 Number.MAX_SAFE_INTEGER
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ },
/* 100 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.number.min-safe-integer.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.1.2.10 Number.MIN_SAFE_INTEGER
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ },
/* 101 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.number.parse-float.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , $parseFloat = __webpack_require__(/*! ./_parse-float */ 86);
	// 20.1.2.12 Number.parseFloat(string)
	$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ },
/* 102 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.number.parse-int.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , $parseInt = __webpack_require__(/*! ./_parse-int */ 82);
	// 20.1.2.13 Number.parseInt(string, radix)
	$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ },
/* 103 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.acosh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.3 Math.acosh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , log1p   = __webpack_require__(/*! ./_math-log1p */ 104)
	  , sqrt    = Math.sqrt
	  , $acosh  = Math.acosh;
	
	$export($export.S + $export.F * !($acosh
	  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
	  && Math.floor($acosh(Number.MAX_VALUE)) == 710
	  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
	  && $acosh(Infinity) == Infinity
	), 'Math', {
	  acosh: function acosh(x){
	    return (x = +x) < 1 ? NaN : x > 94906265.62425156
	      ? Math.log(x) + Math.LN2
	      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
	  }
	});

/***/ },
/* 104 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_math-log1p.js ***!
  \******************************************/
/***/ function(module, exports) {

	// 20.2.2.20 Math.log1p(x)
	module.exports = Math.log1p || function log1p(x){
	  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
	};

/***/ },
/* 105 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.asinh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.5 Math.asinh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $asinh  = Math.asinh;
	
	function asinh(x){
	  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
	}
	
	// Tor Browser bug: Math.asinh(0) -> -0 
	$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ },
/* 106 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.atanh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.7 Math.atanh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $atanh  = Math.atanh;
	
	// Tor Browser bug: Math.atanh(-0) -> 0 
	$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
	  atanh: function atanh(x){
	    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
	  }
	});

/***/ },
/* 107 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.cbrt.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.9 Math.cbrt(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , sign    = __webpack_require__(/*! ./_math-sign */ 108);
	
	$export($export.S, 'Math', {
	  cbrt: function cbrt(x){
	    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
	  }
	});

/***/ },
/* 108 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_math-sign.js ***!
  \*****************************************/
/***/ function(module, exports) {

	// 20.2.2.28 Math.sign(x)
	module.exports = Math.sign || function sign(x){
	  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
	};

/***/ },
/* 109 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.clz32.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.11 Math.clz32(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  clz32: function clz32(x){
	    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
	  }
	});

/***/ },
/* 110 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.cosh.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.12 Math.cosh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  cosh: function cosh(x){
	    return (exp(x = +x) + exp(-x)) / 2;
	  }
	});

/***/ },
/* 111 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.expm1.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.14 Math.expm1(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $expm1  = __webpack_require__(/*! ./_math-expm1 */ 112);
	
	$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ },
/* 112 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_math-expm1.js ***!
  \******************************************/
/***/ function(module, exports) {

	// 20.2.2.14 Math.expm1(x)
	var $expm1 = Math.expm1;
	module.exports = (!$expm1
	  // Old FF bug
	  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
	  // Tor Browser bug
	  || $expm1(-2e-17) != -2e-17
	) ? function expm1(x){
	  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
	} : $expm1;

/***/ },
/* 113 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.math.fround.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.16 Math.fround(x)
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , sign      = __webpack_require__(/*! ./_math-sign */ 108)
	  , pow       = Math.pow
	  , EPSILON   = pow(2, -52)
	  , EPSILON32 = pow(2, -23)
	  , MAX32     = pow(2, 127) * (2 - EPSILON32)
	  , MIN32     = pow(2, -126);
	
	var roundTiesToEven = function(n){
	  return n + 1 / EPSILON - 1 / EPSILON;
	};
	
	
	$export($export.S, 'Math', {
	  fround: function fround(x){
	    var $abs  = Math.abs(x)
	      , $sign = sign(x)
	      , a, result;
	    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
	    a = (1 + EPSILON32 / EPSILON) * $abs;
	    result = a - (a - $abs);
	    if(result > MAX32 || result != result)return $sign * Infinity;
	    return $sign * result;
	  }
	});

/***/ },
/* 114 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.hypot.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , abs     = Math.abs;
	
	$export($export.S, 'Math', {
	  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
	    var sum  = 0
	      , i    = 0
	      , aLen = arguments.length
	      , larg = 0
	      , arg, div;
	    while(i < aLen){
	      arg = abs(arguments[i++]);
	      if(larg < arg){
	        div  = larg / arg;
	        sum  = sum * div * div + 1;
	        larg = arg;
	      } else if(arg > 0){
	        div  = arg / larg;
	        sum += div * div;
	      } else sum += arg;
	    }
	    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
	  }
	});

/***/ },
/* 115 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.imul.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.18 Math.imul(x, y)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $imul   = Math.imul;
	
	// some WebKit versions fails with big numbers, some has wrong arity
	$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
	}), 'Math', {
	  imul: function imul(x, y){
	    var UINT16 = 0xffff
	      , xn = +x
	      , yn = +y
	      , xl = UINT16 & xn
	      , yl = UINT16 & yn;
	    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
	  }
	});

/***/ },
/* 116 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.log10.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.21 Math.log10(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  log10: function log10(x){
	    return Math.log(x) / Math.LN10;
	  }
	});

/***/ },
/* 117 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.log1p.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.20 Math.log1p(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {log1p: __webpack_require__(/*! ./_math-log1p */ 104)});

/***/ },
/* 118 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.log2.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.22 Math.log2(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  log2: function log2(x){
	    return Math.log(x) / Math.LN2;
	  }
	});

/***/ },
/* 119 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.sign.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.28 Math.sign(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {sign: __webpack_require__(/*! ./_math-sign */ 108)});

/***/ },
/* 120 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.sinh.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.30 Math.sinh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , expm1   = __webpack_require__(/*! ./_math-expm1 */ 112)
	  , exp     = Math.exp;
	
	// V8 near Chromium 38 has a problem with very small numbers
	$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  return !Math.sinh(-2e-17) != -2e-17;
	}), 'Math', {
	  sinh: function sinh(x){
	    return Math.abs(x = +x) < 1
	      ? (expm1(x) - expm1(-x)) / 2
	      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
	  }
	});

/***/ },
/* 121 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.math.tanh.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.33 Math.tanh(x)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , expm1   = __webpack_require__(/*! ./_math-expm1 */ 112)
	  , exp     = Math.exp;
	
	$export($export.S, 'Math', {
	  tanh: function tanh(x){
	    var a = expm1(x = +x)
	      , b = expm1(-x);
	    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
	  }
	});

/***/ },
/* 122 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.math.trunc.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.2.2.34 Math.trunc(x)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  trunc: function trunc(it){
	    return (it > 0 ? Math.floor : Math.ceil)(it);
	  }
	});

/***/ },
/* 123 */
/*!*********************************************************!*\
  !*** ./~/core-js/modules/es6.string.from-code-point.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export        = __webpack_require__(/*! ./_export */ 8)
	  , toIndex        = __webpack_require__(/*! ./_to-index */ 39)
	  , fromCharCode   = String.fromCharCode
	  , $fromCodePoint = String.fromCodePoint;
	
	// length should be 1, old FF problem
	$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
	  // 21.1.2.2 String.fromCodePoint(...codePoints)
	  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
	    var res  = []
	      , aLen = arguments.length
	      , i    = 0
	      , code;
	    while(aLen > i){
	      code = +arguments[i++];
	      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
	      res.push(code < 0x10000
	        ? fromCharCode(code)
	        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
	      );
	    } return res.join('');
	  }
	});

/***/ },
/* 124 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.string.raw.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 32)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 37);
	
	$export($export.S, 'String', {
	  // 21.1.2.4 String.raw(callSite, ...substitutions)
	  raw: function raw(callSite){
	    var tpl  = toIObject(callSite.raw)
	      , len  = toLength(tpl.length)
	      , aLen = arguments.length
	      , res  = []
	      , i    = 0;
	    while(len > i){
	      res.push(String(tpl[i++]));
	      if(i < aLen)res.push(String(arguments[i]));
	    } return res.join('');
	  }
	});

/***/ },
/* 125 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.string.trim.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.1.3.25 String.prototype.trim()
	__webpack_require__(/*! ./_string-trim */ 83)('trim', function($trim){
	  return function trim(){
	    return $trim(this, 3);
	  };
	});

/***/ },
/* 126 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/es6.string.iterator.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(/*! ./_string-at */ 127)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(/*! ./_iter-define */ 128)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 127 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_string-at.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(/*! ./_to-integer */ 38)
	  , defined   = __webpack_require__(/*! ./_defined */ 35);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 128 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_iter-define.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(/*! ./_library */ 28)
	  , $export        = __webpack_require__(/*! ./_export */ 8)
	  , redefine       = __webpack_require__(/*! ./_redefine */ 18)
	  , hide           = __webpack_require__(/*! ./_hide */ 10)
	  , has            = __webpack_require__(/*! ./_has */ 5)
	  , Iterators      = __webpack_require__(/*! ./_iterators */ 129)
	  , $iterCreate    = __webpack_require__(/*! ./_iter-create */ 130)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 24)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 59)
	  , ITERATOR       = __webpack_require__(/*! ./_wks */ 25)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 129 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_iterators.js ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 130 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_iter-create.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(/*! ./_object-create */ 46)
	  , descriptor     = __webpack_require__(/*! ./_property-desc */ 17)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 24)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(/*! ./_hide */ 10)(IteratorPrototype, __webpack_require__(/*! ./_wks */ 25)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 131 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es6.string.code-point-at.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $at     = __webpack_require__(/*! ./_string-at */ 127)(false);
	$export($export.P, 'String', {
	  // 21.1.3.3 String.prototype.codePointAt(pos)
	  codePointAt: function codePointAt(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 132 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.string.ends-with.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
	'use strict';
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 37)
	  , context   = __webpack_require__(/*! ./_string-context */ 133)
	  , ENDS_WITH = 'endsWith'
	  , $endsWith = ''[ENDS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ 135)(ENDS_WITH), 'String', {
	  endsWith: function endsWith(searchString /*, endPosition = @length */){
	    var that = context(this, searchString, ENDS_WITH)
	      , endPosition = arguments.length > 1 ? arguments[1] : undefined
	      , len    = toLength(that.length)
	      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
	      , search = String(searchString);
	    return $endsWith
	      ? $endsWith.call(that, search, end)
	      : that.slice(end - search.length, end) === search;
	  }
	});

/***/ },
/* 133 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/_string-context.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// helper for String#{startsWith, endsWith, includes}
	var isRegExp = __webpack_require__(/*! ./_is-regexp */ 134)
	  , defined  = __webpack_require__(/*! ./_defined */ 35);
	
	module.exports = function(that, searchString, NAME){
	  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
	  return String(defined(that));
	};

/***/ },
/* 134 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_is-regexp.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.2.8 IsRegExp(argument)
	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , cof      = __webpack_require__(/*! ./_cof */ 34)
	  , MATCH    = __webpack_require__(/*! ./_wks */ 25)('match');
	module.exports = function(it){
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
	};

/***/ },
/* 135 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/_fails-is-regexp.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var MATCH = __webpack_require__(/*! ./_wks */ 25)('match');
	module.exports = function(KEY){
	  var re = /./;
	  try {
	    '/./'[KEY](re);
	  } catch(e){
	    try {
	      re[MATCH] = false;
	      return !'/./'[KEY](re);
	    } catch(f){ /* empty */ }
	  } return true;
	};

/***/ },
/* 136 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/es6.string.includes.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.7 String.prototype.includes(searchString, position = 0)
	'use strict';
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , context  = __webpack_require__(/*! ./_string-context */ 133)
	  , INCLUDES = 'includes';
	
	$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ 135)(INCLUDES), 'String', {
	  includes: function includes(searchString /*, position = 0 */){
	    return !!~context(this, searchString, INCLUDES)
	      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

/***/ },
/* 137 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.string.repeat.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P, 'String', {
	  // 21.1.3.13 String.prototype.repeat(count)
	  repeat: __webpack_require__(/*! ./_string-repeat */ 91)
	});

/***/ },
/* 138 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.string.starts-with.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
	'use strict';
	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , toLength    = __webpack_require__(/*! ./_to-length */ 37)
	  , context     = __webpack_require__(/*! ./_string-context */ 133)
	  , STARTS_WITH = 'startsWith'
	  , $startsWith = ''[STARTS_WITH];
	
	$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ 135)(STARTS_WITH), 'String', {
	  startsWith: function startsWith(searchString /*, position = 0 */){
	    var that   = context(this, searchString, STARTS_WITH)
	      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
	      , search = String(searchString);
	    return $startsWith
	      ? $startsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

/***/ },
/* 139 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.string.anchor.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.2 String.prototype.anchor(name)
	__webpack_require__(/*! ./_string-html */ 140)('anchor', function(createHTML){
	  return function anchor(name){
	    return createHTML(this, 'a', 'name', name);
	  }
	});

/***/ },
/* 140 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_string-html.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8)
	  , fails   = __webpack_require__(/*! ./_fails */ 7)
	  , defined = __webpack_require__(/*! ./_defined */ 35)
	  , quot    = /"/g;
	// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
	var createHTML = function(string, tag, attribute, value) {
	  var S  = String(defined(string))
	    , p1 = '<' + tag;
	  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
	  return p1 + '>' + S + '</' + tag + '>';
	};
	module.exports = function(NAME, exec){
	  var O = {};
	  O[NAME] = exec(createHTML);
	  $export($export.P + $export.F * fails(function(){
	    var test = ''[NAME]('"');
	    return test !== test.toLowerCase() || test.split('"').length > 3;
	  }), 'String', O);
	};

/***/ },
/* 141 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.string.big.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.3 String.prototype.big()
	__webpack_require__(/*! ./_string-html */ 140)('big', function(createHTML){
	  return function big(){
	    return createHTML(this, 'big', '', '');
	  }
	});

/***/ },
/* 142 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.string.blink.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.4 String.prototype.blink()
	__webpack_require__(/*! ./_string-html */ 140)('blink', function(createHTML){
	  return function blink(){
	    return createHTML(this, 'blink', '', '');
	  }
	});

/***/ },
/* 143 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.string.bold.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.5 String.prototype.bold()
	__webpack_require__(/*! ./_string-html */ 140)('bold', function(createHTML){
	  return function bold(){
	    return createHTML(this, 'b', '', '');
	  }
	});

/***/ },
/* 144 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.string.fixed.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.6 String.prototype.fixed()
	__webpack_require__(/*! ./_string-html */ 140)('fixed', function(createHTML){
	  return function fixed(){
	    return createHTML(this, 'tt', '', '');
	  }
	});

/***/ },
/* 145 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.string.fontcolor.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.7 String.prototype.fontcolor(color)
	__webpack_require__(/*! ./_string-html */ 140)('fontcolor', function(createHTML){
	  return function fontcolor(color){
	    return createHTML(this, 'font', 'color', color);
	  }
	});

/***/ },
/* 146 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/es6.string.fontsize.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.8 String.prototype.fontsize(size)
	__webpack_require__(/*! ./_string-html */ 140)('fontsize', function(createHTML){
	  return function fontsize(size){
	    return createHTML(this, 'font', 'size', size);
	  }
	});

/***/ },
/* 147 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.string.italics.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.9 String.prototype.italics()
	__webpack_require__(/*! ./_string-html */ 140)('italics', function(createHTML){
	  return function italics(){
	    return createHTML(this, 'i', '', '');
	  }
	});

/***/ },
/* 148 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.string.link.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.10 String.prototype.link(url)
	__webpack_require__(/*! ./_string-html */ 140)('link', function(createHTML){
	  return function link(url){
	    return createHTML(this, 'a', 'href', url);
	  }
	});

/***/ },
/* 149 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.string.small.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.11 String.prototype.small()
	__webpack_require__(/*! ./_string-html */ 140)('small', function(createHTML){
	  return function small(){
	    return createHTML(this, 'small', '', '');
	  }
	});

/***/ },
/* 150 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.string.strike.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.12 String.prototype.strike()
	__webpack_require__(/*! ./_string-html */ 140)('strike', function(createHTML){
	  return function strike(){
	    return createHTML(this, 'strike', '', '');
	  }
	});

/***/ },
/* 151 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.string.sub.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.13 String.prototype.sub()
	__webpack_require__(/*! ./_string-html */ 140)('sub', function(createHTML){
	  return function sub(){
	    return createHTML(this, 'sub', '', '');
	  }
	});

/***/ },
/* 152 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.string.sup.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// B.2.3.14 String.prototype.sup()
	__webpack_require__(/*! ./_string-html */ 140)('sup', function(createHTML){
	  return function sup(){
	    return createHTML(this, 'sup', '', '');
	  }
	});

/***/ },
/* 153 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/es6.date.now.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 20.3.3.1 / 15.9.4.4 Date.now()
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ },
/* 154 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.date.to-json.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , toObject    = __webpack_require__(/*! ./_to-object */ 58)
	  , toPrimitive = __webpack_require__(/*! ./_to-primitive */ 16);
	
	$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
	}), 'Date', {
	  toJSON: function toJSON(key){
	    var O  = toObject(this)
	      , pv = toPrimitive(O);
	    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
	  }
	});

/***/ },
/* 155 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.date.to-iso-string.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , fails   = __webpack_require__(/*! ./_fails */ 7)
	  , getTime = Date.prototype.getTime;
	
	var lz = function(num){
	  return num > 9 ? num : '0' + num;
	};
	
	// PhantomJS / old WebKit has a broken implementations
	$export($export.P + $export.F * (fails(function(){
	  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
	}) || !fails(function(){
	  new Date(NaN).toISOString();
	})), 'Date', {
	  toISOString: function toISOString(){
	    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
	    var d = this
	      , y = d.getUTCFullYear()
	      , m = d.getUTCMilliseconds()
	      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
	    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
	      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
	      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
	      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
	  }
	});

/***/ },
/* 156 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.date.to-string.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	var DateProto    = Date.prototype
	  , INVALID_DATE = 'Invalid Date'
	  , TO_STRING    = 'toString'
	  , $toString    = DateProto[TO_STRING]
	  , getTime      = DateProto.getTime;
	if(new Date(NaN) + '' != INVALID_DATE){
	  __webpack_require__(/*! ./_redefine */ 18)(DateProto, TO_STRING, function toString(){
	    var value = getTime.call(this);
	    return value === value ? $toString.call(this) : INVALID_DATE;
	  });
	}

/***/ },
/* 157 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.date.to-primitive.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ 25)('toPrimitive')
	  , proto        = Date.prototype;
	
	if(!(TO_PRIMITIVE in proto))__webpack_require__(/*! ./_hide */ 10)(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ 158));

/***/ },
/* 158 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/_date-to-primitive.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , toPrimitive = __webpack_require__(/*! ./_to-primitive */ 16)
	  , NUMBER      = 'number';
	
	module.exports = function(hint){
	  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
	  return toPrimitive(anObject(this), hint != NUMBER);
	};

/***/ },
/* 159 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.array.is-array.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Array', {isArray: __webpack_require__(/*! ./_is-array */ 45)});

/***/ },
/* 160 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.from.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(/*! ./_ctx */ 20)
	  , $export        = __webpack_require__(/*! ./_export */ 8)
	  , toObject       = __webpack_require__(/*! ./_to-object */ 58)
	  , call           = __webpack_require__(/*! ./_iter-call */ 161)
	  , isArrayIter    = __webpack_require__(/*! ./_is-array-iter */ 162)
	  , toLength       = __webpack_require__(/*! ./_to-length */ 37)
	  , createProperty = __webpack_require__(/*! ./_create-property */ 163)
	  , getIterFn      = __webpack_require__(/*! ./core.get-iterator-method */ 164);
	
	$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ 165)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 161 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_iter-call.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(/*! ./_an-object */ 12);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 162 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_is-array-iter.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(/*! ./_iterators */ 129)
	  , ITERATOR   = __webpack_require__(/*! ./_wks */ 25)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 163 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/_create-property.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(/*! ./_object-dp */ 11)
	  , createDesc      = __webpack_require__(/*! ./_property-desc */ 17);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 164 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/core.get-iterator-method.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(/*! ./_classof */ 75)
	  , ITERATOR  = __webpack_require__(/*! ./_wks */ 25)('iterator')
	  , Iterators = __webpack_require__(/*! ./_iterators */ 129);
	module.exports = __webpack_require__(/*! ./_core */ 9).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 165 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_iter-detect.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(/*! ./_wks */ 25)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 166 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/es6.array.of.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export        = __webpack_require__(/*! ./_export */ 8)
	  , createProperty = __webpack_require__(/*! ./_create-property */ 163);
	
	// WebKit Array.of isn't generic
	$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  function F(){}
	  return !(Array.of.call(F) instanceof F);
	}), 'Array', {
	  // 22.1.2.3 Array.of( ...items)
	  of: function of(/* ...args */){
	    var index  = 0
	      , aLen   = arguments.length
	      , result = new (typeof this == 'function' ? this : Array)(aLen);
	    while(aLen > index)createProperty(result, index, arguments[index++]);
	    result.length = aLen;
	    return result;
	  }
	});

/***/ },
/* 167 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.join.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.13 Array.prototype.join(separator)
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 32)
	  , arrayJoin = [].join;
	
	// fallback for not array-like strings
	$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ 33) != Object || !__webpack_require__(/*! ./_strict-method */ 168)(arrayJoin)), 'Array', {
	  join: function join(separator){
	    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
	  }
	});

/***/ },
/* 168 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_strict-method.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	var fails = __webpack_require__(/*! ./_fails */ 7);
	
	module.exports = function(method, arg){
	  return !!method && fails(function(){
	    arg ? method.call(null, function(){}, 1) : method.call(null);
	  });
	};

/***/ },
/* 169 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.array.slice.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export    = __webpack_require__(/*! ./_export */ 8)
	  , html       = __webpack_require__(/*! ./_html */ 48)
	  , cof        = __webpack_require__(/*! ./_cof */ 34)
	  , toIndex    = __webpack_require__(/*! ./_to-index */ 39)
	  , toLength   = __webpack_require__(/*! ./_to-length */ 37)
	  , arraySlice = [].slice;
	
	// fallback for not array-like ES3 strings and DOM objects
	$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  if(html)arraySlice.call(html);
	}), 'Array', {
	  slice: function slice(begin, end){
	    var len   = toLength(this.length)
	      , klass = cof(this);
	    end = end === undefined ? len : end;
	    if(klass == 'Array')return arraySlice.call(this, begin, end);
	    var start  = toIndex(begin, len)
	      , upTo   = toIndex(end, len)
	      , size   = toLength(upTo - start)
	      , cloned = Array(size)
	      , i      = 0;
	    for(; i < size; i++)cloned[i] = klass == 'String'
	      ? this.charAt(start + i)
	      : this[start + i];
	    return cloned;
	  }
	});

/***/ },
/* 170 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.sort.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 21)
	  , toObject  = __webpack_require__(/*! ./_to-object */ 58)
	  , fails     = __webpack_require__(/*! ./_fails */ 7)
	  , $sort     = [].sort
	  , test      = [1, 2, 3];
	
	$export($export.P + $export.F * (fails(function(){
	  // IE8-
	  test.sort(undefined);
	}) || !fails(function(){
	  // V8 bug
	  test.sort(null);
	  // Old WebKit
	}) || !__webpack_require__(/*! ./_strict-method */ 168)($sort)), 'Array', {
	  // 22.1.3.25 Array.prototype.sort(comparefn)
	  sort: function sort(comparefn){
	    return comparefn === undefined
	      ? $sort.call(toObject(this))
	      : $sort.call(toObject(this), aFunction(comparefn));
	  }
	});

/***/ },
/* 171 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.array.for-each.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , $forEach = __webpack_require__(/*! ./_array-methods */ 172)(0)
	  , STRICT   = __webpack_require__(/*! ./_strict-method */ 168)([].forEach, true);
	
	$export($export.P + $export.F * !STRICT, 'Array', {
	  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
	  forEach: function forEach(callbackfn /* , thisArg */){
	    return $forEach(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 172 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/_array-methods.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(/*! ./_ctx */ 20)
	  , IObject  = __webpack_require__(/*! ./_iobject */ 33)
	  , toObject = __webpack_require__(/*! ./_to-object */ 58)
	  , toLength = __webpack_require__(/*! ./_to-length */ 37)
	  , asc      = __webpack_require__(/*! ./_array-species-create */ 173);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 173 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/_array-species-create.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ 174);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 174 */
/*!*********************************************************!*\
  !*** ./~/core-js/modules/_array-species-constructor.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(/*! ./_is-object */ 13)
	  , isArray  = __webpack_require__(/*! ./_is-array */ 45)
	  , SPECIES  = __webpack_require__(/*! ./_wks */ 25)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 175 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es6.array.map.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $map    = __webpack_require__(/*! ./_array-methods */ 172)(1);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].map, true), 'Array', {
	  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
	  map: function map(callbackfn /* , thisArg */){
	    return $map(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 176 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.array.filter.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $filter = __webpack_require__(/*! ./_array-methods */ 172)(2);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].filter, true), 'Array', {
	  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
	  filter: function filter(callbackfn /* , thisArg */){
	    return $filter(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 177 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.some.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $some   = __webpack_require__(/*! ./_array-methods */ 172)(3);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].some, true), 'Array', {
	  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
	  some: function some(callbackfn /* , thisArg */){
	    return $some(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 178 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.array.every.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $every  = __webpack_require__(/*! ./_array-methods */ 172)(4);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].every, true), 'Array', {
	  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
	  every: function every(callbackfn /* , thisArg */){
	    return $every(this, callbackfn, arguments[1]);
	  }
	});

/***/ },
/* 179 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.array.reduce.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $reduce = __webpack_require__(/*! ./_array-reduce */ 180);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].reduce, true), 'Array', {
	  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
	  reduce: function reduce(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
	  }
	});

/***/ },
/* 180 */
/*!********************************************!*\
  !*** ./~/core-js/modules/_array-reduce.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var aFunction = __webpack_require__(/*! ./_a-function */ 21)
	  , toObject  = __webpack_require__(/*! ./_to-object */ 58)
	  , IObject   = __webpack_require__(/*! ./_iobject */ 33)
	  , toLength  = __webpack_require__(/*! ./_to-length */ 37);
	
	module.exports = function(that, callbackfn, aLen, memo, isRight){
	  aFunction(callbackfn);
	  var O      = toObject(that)
	    , self   = IObject(O)
	    , length = toLength(O.length)
	    , index  = isRight ? length - 1 : 0
	    , i      = isRight ? -1 : 1;
	  if(aLen < 2)for(;;){
	    if(index in self){
	      memo = self[index];
	      index += i;
	      break;
	    }
	    index += i;
	    if(isRight ? index < 0 : length <= index){
	      throw TypeError('Reduce of empty array with no initial value');
	    }
	  }
	  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
	    memo = callbackfn(memo, self[index], index, O);
	  }
	  return memo;
	};

/***/ },
/* 181 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.array.reduce-right.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $reduce = __webpack_require__(/*! ./_array-reduce */ 180);
	
	$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ 168)([].reduceRight, true), 'Array', {
	  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
	  reduceRight: function reduceRight(callbackfn /* , initialValue */){
	    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
	  }
	});

/***/ },
/* 182 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.array.index-of.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(/*! ./_export */ 8)
	  , $indexOf      = __webpack_require__(/*! ./_array-includes */ 36)(false)
	  , $native       = [].indexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ 168)($native)), 'Array', {
	  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
	  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? $native.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments[1]);
	  }
	});

/***/ },
/* 183 */
/*!******************************************************!*\
  !*** ./~/core-js/modules/es6.array.last-index-of.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export       = __webpack_require__(/*! ./_export */ 8)
	  , toIObject     = __webpack_require__(/*! ./_to-iobject */ 32)
	  , toInteger     = __webpack_require__(/*! ./_to-integer */ 38)
	  , toLength      = __webpack_require__(/*! ./_to-length */ 37)
	  , $native       = [].lastIndexOf
	  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
	
	$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ 168)($native)), 'Array', {
	  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
	  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
	    // convert -0 to +0
	    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
	    var O      = toIObject(this)
	      , length = toLength(O.length)
	      , index  = length - 1;
	    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
	    if(index < 0)index = length + index;
	    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
	    return -1;
	  }
	});

/***/ },
/* 184 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.array.copy-within.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P, 'Array', {copyWithin: __webpack_require__(/*! ./_array-copy-within */ 185)});
	
	__webpack_require__(/*! ./_add-to-unscopables */ 186)('copyWithin');

/***/ },
/* 185 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/_array-copy-within.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
	'use strict';
	var toObject = __webpack_require__(/*! ./_to-object */ 58)
	  , toIndex  = __webpack_require__(/*! ./_to-index */ 39)
	  , toLength = __webpack_require__(/*! ./_to-length */ 37);
	
	module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
	  var O     = toObject(this)
	    , len   = toLength(O.length)
	    , to    = toIndex(target, len)
	    , from  = toIndex(start, len)
	    , end   = arguments.length > 2 ? arguments[2] : undefined
	    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
	    , inc   = 1;
	  if(from < to && to < from + count){
	    inc  = -1;
	    from += count - 1;
	    to   += count - 1;
	  }
	  while(count-- > 0){
	    if(from in O)O[to] = O[from];
	    else delete O[to];
	    to   += inc;
	    from += inc;
	  } return O;
	};

/***/ },
/* 186 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/_add-to-unscopables.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.31 Array.prototype[@@unscopables]
	var UNSCOPABLES = __webpack_require__(/*! ./_wks */ 25)('unscopables')
	  , ArrayProto  = Array.prototype;
	if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(/*! ./_hide */ 10)(ArrayProto, UNSCOPABLES, {});
	module.exports = function(key){
	  ArrayProto[UNSCOPABLES][key] = true;
	};

/***/ },
/* 187 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.fill.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P, 'Array', {fill: __webpack_require__(/*! ./_array-fill */ 188)});
	
	__webpack_require__(/*! ./_add-to-unscopables */ 186)('fill');

/***/ },
/* 188 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_array-fill.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
	'use strict';
	var toObject = __webpack_require__(/*! ./_to-object */ 58)
	  , toIndex  = __webpack_require__(/*! ./_to-index */ 39)
	  , toLength = __webpack_require__(/*! ./_to-length */ 37);
	module.exports = function fill(value /*, start = 0, end = @length */){
	  var O      = toObject(this)
	    , length = toLength(O.length)
	    , aLen   = arguments.length
	    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
	    , end    = aLen > 2 ? arguments[2] : undefined
	    , endPos = end === undefined ? length : toIndex(end, length);
	  while(endPos > index)O[index++] = value;
	  return O;
	};

/***/ },
/* 189 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es6.array.find.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $find   = __webpack_require__(/*! ./_array-methods */ 172)(5)
	  , KEY     = 'find'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  find: function find(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(/*! ./_add-to-unscopables */ 186)(KEY);

/***/ },
/* 190 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.array.find-index.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $find   = __webpack_require__(/*! ./_array-methods */ 172)(6)
	  , KEY     = 'findIndex'
	  , forced  = true;
	// Shouldn't skip holes
	if(KEY in [])Array(1)[KEY](function(){ forced = false; });
	$export($export.P + $export.F * forced, 'Array', {
	  findIndex: function findIndex(callbackfn/*, that = undefined */){
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	__webpack_require__(/*! ./_add-to-unscopables */ 186)(KEY);

/***/ },
/* 191 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.array.species.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_set-species */ 192)('Array');

/***/ },
/* 192 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_set-species.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(/*! ./_global */ 4)
	  , dP          = __webpack_require__(/*! ./_object-dp */ 11)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 6)
	  , SPECIES     = __webpack_require__(/*! ./_wks */ 25)('species');
	
	module.exports = function(KEY){
	  var C = global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 193 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.array.iterator.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ 186)
	  , step             = __webpack_require__(/*! ./_iter-step */ 194)
	  , Iterators        = __webpack_require__(/*! ./_iterators */ 129)
	  , toIObject        = __webpack_require__(/*! ./_to-iobject */ 32);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(/*! ./_iter-define */ 128)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 194 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_iter-step.js ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 195 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.regexp.constructor.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	var global            = __webpack_require__(/*! ./_global */ 4)
	  , inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ 88)
	  , dP                = __webpack_require__(/*! ./_object-dp */ 11).f
	  , gOPN              = __webpack_require__(/*! ./_object-gopn */ 50).f
	  , isRegExp          = __webpack_require__(/*! ./_is-regexp */ 134)
	  , $flags            = __webpack_require__(/*! ./_flags */ 196)
	  , $RegExp           = global.RegExp
	  , Base              = $RegExp
	  , proto             = $RegExp.prototype
	  , re1               = /a/g
	  , re2               = /a/g
	  // "new" creates a new object, old webkit buggy here
	  , CORRECT_NEW       = new $RegExp(re1) !== re1;
	
	if(__webpack_require__(/*! ./_descriptors */ 6) && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ 7)(function(){
	  re2[__webpack_require__(/*! ./_wks */ 25)('match')] = false;
	  // RegExp constructor can alter flags and IsRegExp works correct with @@match
	  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
	}))){
	  $RegExp = function RegExp(p, f){
	    var tiRE = this instanceof $RegExp
	      , piRE = isRegExp(p)
	      , fiU  = f === undefined;
	    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
	      : inheritIfRequired(CORRECT_NEW
	        ? new Base(piRE && !fiU ? p.source : p, f)
	        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
	      , tiRE ? this : proto, $RegExp);
	  };
	  var proxy = function(key){
	    key in $RegExp || dP($RegExp, key, {
	      configurable: true,
	      get: function(){ return Base[key]; },
	      set: function(it){ Base[key] = it; }
	    });
	  };
	  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
	  proto.constructor = $RegExp;
	  $RegExp.prototype = proto;
	  __webpack_require__(/*! ./_redefine */ 18)(global, 'RegExp', $RegExp);
	}
	
	__webpack_require__(/*! ./_set-species */ 192)('RegExp');

/***/ },
/* 196 */
/*!*************************************!*\
  !*** ./~/core-js/modules/_flags.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 21.2.5.3 get RegExp.prototype.flags
	var anObject = __webpack_require__(/*! ./_an-object */ 12);
	module.exports = function(){
	  var that   = anObject(this)
	    , result = '';
	  if(that.global)     result += 'g';
	  if(that.ignoreCase) result += 'i';
	  if(that.multiline)  result += 'm';
	  if(that.unicode)    result += 'u';
	  if(that.sticky)     result += 'y';
	  return result;
	};

/***/ },
/* 197 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.regexp.to-string.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	__webpack_require__(/*! ./es6.regexp.flags */ 198);
	var anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , $flags      = __webpack_require__(/*! ./_flags */ 196)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 6)
	  , TO_STRING   = 'toString'
	  , $toString   = /./[TO_STRING];
	
	var define = function(fn){
	  __webpack_require__(/*! ./_redefine */ 18)(RegExp.prototype, TO_STRING, fn, true);
	};
	
	// 21.2.5.14 RegExp.prototype.toString()
	if(__webpack_require__(/*! ./_fails */ 7)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
	  define(function toString(){
	    var R = anObject(this);
	    return '/'.concat(R.source, '/',
	      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
	  });
	// FF44- RegExp#toString has a wrong name
	} else if($toString.name != TO_STRING){
	  define(function toString(){
	    return $toString.call(this);
	  });
	}

/***/ },
/* 198 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.regexp.flags.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 21.2.5.3 get RegExp.prototype.flags()
	if(__webpack_require__(/*! ./_descriptors */ 6) && /./g.flags != 'g')__webpack_require__(/*! ./_object-dp */ 11).f(RegExp.prototype, 'flags', {
	  configurable: true,
	  get: __webpack_require__(/*! ./_flags */ 196)
	});

/***/ },
/* 199 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.regexp.match.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@match logic
	__webpack_require__(/*! ./_fix-re-wks */ 200)('match', 1, function(defined, MATCH, $match){
	  // 21.1.3.11 String.prototype.match(regexp)
	  return [function match(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[MATCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
	  }, $match];
	});

/***/ },
/* 200 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_fix-re-wks.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var hide     = __webpack_require__(/*! ./_hide */ 10)
	  , redefine = __webpack_require__(/*! ./_redefine */ 18)
	  , fails    = __webpack_require__(/*! ./_fails */ 7)
	  , defined  = __webpack_require__(/*! ./_defined */ 35)
	  , wks      = __webpack_require__(/*! ./_wks */ 25);
	
	module.exports = function(KEY, length, exec){
	  var SYMBOL   = wks(KEY)
	    , fns      = exec(defined, SYMBOL, ''[KEY])
	    , strfn    = fns[0]
	    , rxfn     = fns[1];
	  if(fails(function(){
	    var O = {};
	    O[SYMBOL] = function(){ return 7; };
	    return ''[KEY](O) != 7;
	  })){
	    redefine(String.prototype, KEY, strfn);
	    hide(RegExp.prototype, SYMBOL, length == 2
	      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
	      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
	      ? function(string, arg){ return rxfn.call(string, this, arg); }
	      // 21.2.5.6 RegExp.prototype[@@match](string)
	      // 21.2.5.9 RegExp.prototype[@@search](string)
	      : function(string){ return rxfn.call(string, this); }
	    );
	  }
	};

/***/ },
/* 201 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es6.regexp.replace.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@replace logic
	__webpack_require__(/*! ./_fix-re-wks */ 200)('replace', 2, function(defined, REPLACE, $replace){
	  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
	  return [function replace(searchValue, replaceValue){
	    'use strict';
	    var O  = defined(this)
	      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
	    return fn !== undefined
	      ? fn.call(searchValue, O, replaceValue)
	      : $replace.call(String(O), searchValue, replaceValue);
	  }, $replace];
	});

/***/ },
/* 202 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.regexp.search.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@search logic
	__webpack_require__(/*! ./_fix-re-wks */ 200)('search', 1, function(defined, SEARCH, $search){
	  // 21.1.3.15 String.prototype.search(regexp)
	  return [function search(regexp){
	    'use strict';
	    var O  = defined(this)
	      , fn = regexp == undefined ? undefined : regexp[SEARCH];
	    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
	  }, $search];
	});

/***/ },
/* 203 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/es6.regexp.split.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	// @@split logic
	__webpack_require__(/*! ./_fix-re-wks */ 200)('split', 2, function(defined, SPLIT, $split){
	  'use strict';
	  var isRegExp   = __webpack_require__(/*! ./_is-regexp */ 134)
	    , _split     = $split
	    , $push      = [].push
	    , $SPLIT     = 'split'
	    , LENGTH     = 'length'
	    , LAST_INDEX = 'lastIndex';
	  if(
	    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
	    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
	    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
	    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
	    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
	    ''[$SPLIT](/.?/)[LENGTH]
	  ){
	    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
	    // based on es5-shim implementation, need to rework it
	    $split = function(separator, limit){
	      var string = String(this);
	      if(separator === undefined && limit === 0)return [];
	      // If `separator` is not a regex, use native split
	      if(!isRegExp(separator))return _split.call(string, separator, limit);
	      var output = [];
	      var flags = (separator.ignoreCase ? 'i' : '') +
	                  (separator.multiline ? 'm' : '') +
	                  (separator.unicode ? 'u' : '') +
	                  (separator.sticky ? 'y' : '');
	      var lastLastIndex = 0;
	      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
	      // Make `global` and avoid `lastIndex` issues by working with a copy
	      var separatorCopy = new RegExp(separator.source, flags + 'g');
	      var separator2, match, lastIndex, lastLength, i;
	      // Doesn't need flags gy, but they don't hurt
	      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
	      while(match = separatorCopy.exec(string)){
	        // `separatorCopy.lastIndex` is not reliable cross-browser
	        lastIndex = match.index + match[0][LENGTH];
	        if(lastIndex > lastLastIndex){
	          output.push(string.slice(lastLastIndex, match.index));
	          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
	          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
	            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
	          });
	          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
	          lastLength = match[0][LENGTH];
	          lastLastIndex = lastIndex;
	          if(output[LENGTH] >= splitLimit)break;
	        }
	        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
	      }
	      if(lastLastIndex === string[LENGTH]){
	        if(lastLength || !separatorCopy.test(''))output.push('');
	      } else output.push(string.slice(lastLastIndex));
	      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
	    };
	  // Chakra, V8
	  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
	    $split = function(separator, limit){
	      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
	    };
	  }
	  // 21.1.3.17 String.prototype.split(separator, limit)
	  return [function split(separator, limit){
	    var O  = defined(this)
	      , fn = separator == undefined ? undefined : separator[SPLIT];
	    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
	  }, $split];
	});

/***/ },
/* 204 */
/*!******************************************!*\
  !*** ./~/core-js/modules/es6.promise.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(/*! ./_library */ 28)
	  , global             = __webpack_require__(/*! ./_global */ 4)
	  , ctx                = __webpack_require__(/*! ./_ctx */ 20)
	  , classof            = __webpack_require__(/*! ./_classof */ 75)
	  , $export            = __webpack_require__(/*! ./_export */ 8)
	  , isObject           = __webpack_require__(/*! ./_is-object */ 13)
	  , aFunction          = __webpack_require__(/*! ./_a-function */ 21)
	  , anInstance         = __webpack_require__(/*! ./_an-instance */ 205)
	  , forOf              = __webpack_require__(/*! ./_for-of */ 206)
	  , speciesConstructor = __webpack_require__(/*! ./_species-constructor */ 207)
	  , task               = __webpack_require__(/*! ./_task */ 208).set
	  , microtask          = __webpack_require__(/*! ./_microtask */ 209)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ 25)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ 210)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(/*! ./_set-to-string-tag */ 24)($Promise, PROMISE);
	__webpack_require__(/*! ./_set-species */ 192)(PROMISE);
	Wrapper = __webpack_require__(/*! ./_core */ 9)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ 165)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 205 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_an-instance.js ***!
  \*******************************************/
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 206 */
/*!**************************************!*\
  !*** ./~/core-js/modules/_for-of.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(/*! ./_ctx */ 20)
	  , call        = __webpack_require__(/*! ./_iter-call */ 161)
	  , isArrayIter = __webpack_require__(/*! ./_is-array-iter */ 162)
	  , anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , toLength    = __webpack_require__(/*! ./_to-length */ 37)
	  , getIterFn   = __webpack_require__(/*! ./core.get-iterator-method */ 164)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 207 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/_species-constructor.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(/*! ./_an-object */ 12)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 21)
	  , SPECIES   = __webpack_require__(/*! ./_wks */ 25)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 208 */
/*!************************************!*\
  !*** ./~/core-js/modules/_task.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(/*! ./_ctx */ 20)
	  , invoke             = __webpack_require__(/*! ./_invoke */ 78)
	  , html               = __webpack_require__(/*! ./_html */ 48)
	  , cel                = __webpack_require__(/*! ./_dom-create */ 15)
	  , global             = __webpack_require__(/*! ./_global */ 4)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(/*! ./_cof */ 34)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 209 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/_microtask.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(/*! ./_global */ 4)
	  , macrotask = __webpack_require__(/*! ./_task */ 208).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(/*! ./_cof */ 34)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 210 */
/*!********************************************!*\
  !*** ./~/core-js/modules/_redefine-all.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var redefine = __webpack_require__(/*! ./_redefine */ 18);
	module.exports = function(target, src, safe){
	  for(var key in src)redefine(target, key, src[key], safe);
	  return target;
	};

/***/ },
/* 211 */
/*!**************************************!*\
  !*** ./~/core-js/modules/es6.map.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./_collection-strong */ 212);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(/*! ./_collection */ 213)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 212 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/_collection-strong.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(/*! ./_object-dp */ 11).f
	  , create      = __webpack_require__(/*! ./_object-create */ 46)
	  , redefineAll = __webpack_require__(/*! ./_redefine-all */ 210)
	  , ctx         = __webpack_require__(/*! ./_ctx */ 20)
	  , anInstance  = __webpack_require__(/*! ./_an-instance */ 205)
	  , defined     = __webpack_require__(/*! ./_defined */ 35)
	  , forOf       = __webpack_require__(/*! ./_for-of */ 206)
	  , $iterDefine = __webpack_require__(/*! ./_iter-define */ 128)
	  , step        = __webpack_require__(/*! ./_iter-step */ 194)
	  , setSpecies  = __webpack_require__(/*! ./_set-species */ 192)
	  , DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ 6)
	  , fastKey     = __webpack_require__(/*! ./_meta */ 22).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 213 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_collection.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global            = __webpack_require__(/*! ./_global */ 4)
	  , $export           = __webpack_require__(/*! ./_export */ 8)
	  , redefine          = __webpack_require__(/*! ./_redefine */ 18)
	  , redefineAll       = __webpack_require__(/*! ./_redefine-all */ 210)
	  , meta              = __webpack_require__(/*! ./_meta */ 22)
	  , forOf             = __webpack_require__(/*! ./_for-of */ 206)
	  , anInstance        = __webpack_require__(/*! ./_an-instance */ 205)
	  , isObject          = __webpack_require__(/*! ./_is-object */ 13)
	  , fails             = __webpack_require__(/*! ./_fails */ 7)
	  , $iterDetect       = __webpack_require__(/*! ./_iter-detect */ 165)
	  , setToStringTag    = __webpack_require__(/*! ./_set-to-string-tag */ 24)
	  , inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ 88);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  var fixMethod = function(KEY){
	    var fn = proto[KEY];
	    redefine(proto, KEY,
	      KEY == 'delete' ? function(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'has' ? function has(a){
	        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'get' ? function get(a){
	        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
	      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
	        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
	    );
	  };
	  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    var instance             = new C
	      // early implementations not supports chaining
	      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
	      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
	      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
	      // most early implementations doesn't supports iterables, most modern - not close it correctly
	      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
	      // for early implementations -0 and +0 not the same
	      , BUGGY_ZERO = !IS_WEAK && fails(function(){
	        // V8 ~ Chromium 42- fails only with 5+ elements
	        var $instance = new C()
	          , index     = 5;
	        while(index--)$instance[ADDER](index, index);
	        return !$instance.has(-0);
	      });
	    if(!ACCEPT_ITERABLES){ 
	      C = wrapper(function(target, iterable){
	        anInstance(target, C, NAME);
	        var that = inheritIfRequired(new Base, target, C);
	        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	        return that;
	      });
	      C.prototype = proto;
	      proto.constructor = C;
	    }
	    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
	      fixMethod('delete');
	      fixMethod('has');
	      IS_MAP && fixMethod('get');
	    }
	    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
	    // weak collections should not contains .clear method
	    if(IS_WEAK && proto.clear)delete proto.clear;
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F * (C != Base), O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 214 */
/*!**************************************!*\
  !*** ./~/core-js/modules/es6.set.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(/*! ./_collection-strong */ 212);
	
	// 23.2 Set Objects
	module.exports = __webpack_require__(/*! ./_collection */ 213)('Set', function(get){
	  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.2.3.1 Set.prototype.add(value)
	  add: function add(value){
	    return strong.def(this, value = value === 0 ? 0 : value, value);
	  }
	}, strong);

/***/ },
/* 215 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/es6.weak-map.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var each         = __webpack_require__(/*! ./_array-methods */ 172)(0)
	  , redefine     = __webpack_require__(/*! ./_redefine */ 18)
	  , meta         = __webpack_require__(/*! ./_meta */ 22)
	  , assign       = __webpack_require__(/*! ./_object-assign */ 69)
	  , weak         = __webpack_require__(/*! ./_collection-weak */ 216)
	  , isObject     = __webpack_require__(/*! ./_is-object */ 13)
	  , getWeak      = meta.getWeak
	  , isExtensible = Object.isExtensible
	  , uncaughtFrozenStore = weak.ufstore
	  , tmp          = {}
	  , InternalMap;
	
	var wrapper = function(get){
	  return function WeakMap(){
	    return get(this, arguments.length > 0 ? arguments[0] : undefined);
	  };
	};
	
	var methods = {
	  // 23.3.3.3 WeakMap.prototype.get(key)
	  get: function get(key){
	    if(isObject(key)){
	      var data = getWeak(key);
	      if(data === true)return uncaughtFrozenStore(this).get(key);
	      return data ? data[this._i] : undefined;
	    }
	  },
	  // 23.3.3.5 WeakMap.prototype.set(key, value)
	  set: function set(key, value){
	    return weak.def(this, key, value);
	  }
	};
	
	// 23.3 WeakMap Objects
	var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ 213)('WeakMap', wrapper, methods, weak, true, true);
	
	// IE11 WeakMap frozen keys fix
	if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
	  InternalMap = weak.getConstructor(wrapper);
	  assign(InternalMap.prototype, methods);
	  meta.NEED = true;
	  each(['delete', 'has', 'get', 'set'], function(key){
	    var proto  = $WeakMap.prototype
	      , method = proto[key];
	    redefine(proto, key, function(a, b){
	      // store frozen objects on internal weakmap shim
	      if(isObject(a) && !isExtensible(a)){
	        if(!this._f)this._f = new InternalMap;
	        var result = this._f[key](a, b);
	        return key == 'set' ? this : result;
	      // store all the rest on native weakmap
	      } return method.call(this, a, b);
	    });
	  });
	}

/***/ },
/* 216 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/_collection-weak.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var redefineAll       = __webpack_require__(/*! ./_redefine-all */ 210)
	  , getWeak           = __webpack_require__(/*! ./_meta */ 22).getWeak
	  , anObject          = __webpack_require__(/*! ./_an-object */ 12)
	  , isObject          = __webpack_require__(/*! ./_is-object */ 13)
	  , anInstance        = __webpack_require__(/*! ./_an-instance */ 205)
	  , forOf             = __webpack_require__(/*! ./_for-of */ 206)
	  , createArrayMethod = __webpack_require__(/*! ./_array-methods */ 172)
	  , $has              = __webpack_require__(/*! ./_has */ 5)
	  , arrayFind         = createArrayMethod(5)
	  , arrayFindIndex    = createArrayMethod(6)
	  , id                = 0;
	
	// fallback for uncaught frozen keys
	var uncaughtFrozenStore = function(that){
	  return that._l || (that._l = new UncaughtFrozenStore);
	};
	var UncaughtFrozenStore = function(){
	  this.a = [];
	};
	var findUncaughtFrozen = function(store, key){
	  return arrayFind(store.a, function(it){
	    return it[0] === key;
	  });
	};
	UncaughtFrozenStore.prototype = {
	  get: function(key){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)return entry[1];
	  },
	  has: function(key){
	    return !!findUncaughtFrozen(this, key);
	  },
	  set: function(key, value){
	    var entry = findUncaughtFrozen(this, key);
	    if(entry)entry[1] = value;
	    else this.a.push([key, value]);
	  },
	  'delete': function(key){
	    var index = arrayFindIndex(this.a, function(it){
	      return it[0] === key;
	    });
	    if(~index)this.a.splice(index, 1);
	    return !!~index;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = id++;      // collection id
	      that._l = undefined; // leak store for uncaught frozen objects
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.3.3.2 WeakMap.prototype.delete(key)
	      // 23.4.3.3 WeakSet.prototype.delete(value)
	      'delete': function(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
	        return data && $has(data, this._i) && delete data[this._i];
	      },
	      // 23.3.3.4 WeakMap.prototype.has(key)
	      // 23.4.3.4 WeakSet.prototype.has(value)
	      has: function has(key){
	        if(!isObject(key))return false;
	        var data = getWeak(key);
	        if(data === true)return uncaughtFrozenStore(this).has(key);
	        return data && $has(data, this._i);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var data = getWeak(anObject(key), true);
	    if(data === true)uncaughtFrozenStore(that).set(key, value);
	    else data[that._i] = value;
	    return that;
	  },
	  ufstore: uncaughtFrozenStore
	};

/***/ },
/* 217 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/es6.weak-set.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var weak = __webpack_require__(/*! ./_collection-weak */ 216);
	
	// 23.4 WeakSet Objects
	__webpack_require__(/*! ./_collection */ 213)('WeakSet', function(get){
	  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.4.3.1 WeakSet.prototype.add(value)
	  add: function add(value){
	    return weak.def(this, value, true);
	  }
	}, weak, false, true);

/***/ },
/* 218 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.array-buffer.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export      = __webpack_require__(/*! ./_export */ 8)
	  , $typed       = __webpack_require__(/*! ./_typed */ 219)
	  , buffer       = __webpack_require__(/*! ./_typed-buffer */ 220)
	  , anObject     = __webpack_require__(/*! ./_an-object */ 12)
	  , toIndex      = __webpack_require__(/*! ./_to-index */ 39)
	  , toLength     = __webpack_require__(/*! ./_to-length */ 37)
	  , isObject     = __webpack_require__(/*! ./_is-object */ 13)
	  , ArrayBuffer  = __webpack_require__(/*! ./_global */ 4).ArrayBuffer
	  , speciesConstructor = __webpack_require__(/*! ./_species-constructor */ 207)
	  , $ArrayBuffer = buffer.ArrayBuffer
	  , $DataView    = buffer.DataView
	  , $isView      = $typed.ABV && ArrayBuffer.isView
	  , $slice       = $ArrayBuffer.prototype.slice
	  , VIEW         = $typed.VIEW
	  , ARRAY_BUFFER = 'ArrayBuffer';
	
	$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});
	
	$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
	  // 24.1.3.1 ArrayBuffer.isView(arg)
	  isView: function isView(it){
	    return $isView && $isView(it) || isObject(it) && VIEW in it;
	  }
	});
	
	$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
	}), ARRAY_BUFFER, {
	  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
	  slice: function slice(start, end){
	    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
	    var len    = anObject(this).byteLength
	      , first  = toIndex(start, len)
	      , final  = toIndex(end === undefined ? len : end, len)
	      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
	      , viewS  = new $DataView(this)
	      , viewT  = new $DataView(result)
	      , index  = 0;
	    while(first < final){
	      viewT.setUint8(index++, viewS.getUint8(first++));
	    } return result;
	  }
	});
	
	__webpack_require__(/*! ./_set-species */ 192)(ARRAY_BUFFER);

/***/ },
/* 219 */
/*!*************************************!*\
  !*** ./~/core-js/modules/_typed.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(/*! ./_global */ 4)
	  , hide   = __webpack_require__(/*! ./_hide */ 10)
	  , uid    = __webpack_require__(/*! ./_uid */ 19)
	  , TYPED  = uid('typed_array')
	  , VIEW   = uid('view')
	  , ABV    = !!(global.ArrayBuffer && global.DataView)
	  , CONSTR = ABV
	  , i = 0, l = 9, Typed;
	
	var TypedArrayConstructors = (
	  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
	).split(',');
	
	while(i < l){
	  if(Typed = global[TypedArrayConstructors[i++]]){
	    hide(Typed.prototype, TYPED, true);
	    hide(Typed.prototype, VIEW, true);
	  } else CONSTR = false;
	}
	
	module.exports = {
	  ABV:    ABV,
	  CONSTR: CONSTR,
	  TYPED:  TYPED,
	  VIEW:   VIEW
	};

/***/ },
/* 220 */
/*!********************************************!*\
  !*** ./~/core-js/modules/_typed-buffer.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(/*! ./_global */ 4)
	  , DESCRIPTORS    = __webpack_require__(/*! ./_descriptors */ 6)
	  , LIBRARY        = __webpack_require__(/*! ./_library */ 28)
	  , $typed         = __webpack_require__(/*! ./_typed */ 219)
	  , hide           = __webpack_require__(/*! ./_hide */ 10)
	  , redefineAll    = __webpack_require__(/*! ./_redefine-all */ 210)
	  , fails          = __webpack_require__(/*! ./_fails */ 7)
	  , anInstance     = __webpack_require__(/*! ./_an-instance */ 205)
	  , toInteger      = __webpack_require__(/*! ./_to-integer */ 38)
	  , toLength       = __webpack_require__(/*! ./_to-length */ 37)
	  , gOPN           = __webpack_require__(/*! ./_object-gopn */ 50).f
	  , dP             = __webpack_require__(/*! ./_object-dp */ 11).f
	  , arrayFill      = __webpack_require__(/*! ./_array-fill */ 188)
	  , setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ 24)
	  , ARRAY_BUFFER   = 'ArrayBuffer'
	  , DATA_VIEW      = 'DataView'
	  , PROTOTYPE      = 'prototype'
	  , WRONG_LENGTH   = 'Wrong length!'
	  , WRONG_INDEX    = 'Wrong index!'
	  , $ArrayBuffer   = global[ARRAY_BUFFER]
	  , $DataView      = global[DATA_VIEW]
	  , Math           = global.Math
	  , RangeError     = global.RangeError
	  , Infinity       = global.Infinity
	  , BaseBuffer     = $ArrayBuffer
	  , abs            = Math.abs
	  , pow            = Math.pow
	  , floor          = Math.floor
	  , log            = Math.log
	  , LN2            = Math.LN2
	  , BUFFER         = 'buffer'
	  , BYTE_LENGTH    = 'byteLength'
	  , BYTE_OFFSET    = 'byteOffset'
	  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
	  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
	  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;
	
	// IEEE754 conversions based on https://github.com/feross/ieee754
	var packIEEE754 = function(value, mLen, nBytes){
	  var buffer = Array(nBytes)
	    , eLen   = nBytes * 8 - mLen - 1
	    , eMax   = (1 << eLen) - 1
	    , eBias  = eMax >> 1
	    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
	    , i      = 0
	    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
	    , e, m, c;
	  value = abs(value)
	  if(value != value || value === Infinity){
	    m = value != value ? 1 : 0;
	    e = eMax;
	  } else {
	    e = floor(log(value) / LN2);
	    if(value * (c = pow(2, -e)) < 1){
	      e--;
	      c *= 2;
	    }
	    if(e + eBias >= 1){
	      value += rt / c;
	    } else {
	      value += rt * pow(2, 1 - eBias);
	    }
	    if(value * c >= 2){
	      e++;
	      c /= 2;
	    }
	    if(e + eBias >= eMax){
	      m = 0;
	      e = eMax;
	    } else if(e + eBias >= 1){
	      m = (value * c - 1) * pow(2, mLen);
	      e = e + eBias;
	    } else {
	      m = value * pow(2, eBias - 1) * pow(2, mLen);
	      e = 0;
	    }
	  }
	  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
	  e = e << mLen | m;
	  eLen += mLen;
	  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
	  buffer[--i] |= s * 128;
	  return buffer;
	};
	var unpackIEEE754 = function(buffer, mLen, nBytes){
	  var eLen  = nBytes * 8 - mLen - 1
	    , eMax  = (1 << eLen) - 1
	    , eBias = eMax >> 1
	    , nBits = eLen - 7
	    , i     = nBytes - 1
	    , s     = buffer[i--]
	    , e     = s & 127
	    , m;
	  s >>= 7;
	  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
	  m = e & (1 << -nBits) - 1;
	  e >>= -nBits;
	  nBits += mLen;
	  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
	  if(e === 0){
	    e = 1 - eBias;
	  } else if(e === eMax){
	    return m ? NaN : s ? -Infinity : Infinity;
	  } else {
	    m = m + pow(2, mLen);
	    e = e - eBias;
	  } return (s ? -1 : 1) * m * pow(2, e - mLen);
	};
	
	var unpackI32 = function(bytes){
	  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
	};
	var packI8 = function(it){
	  return [it & 0xff];
	};
	var packI16 = function(it){
	  return [it & 0xff, it >> 8 & 0xff];
	};
	var packI32 = function(it){
	  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
	};
	var packF64 = function(it){
	  return packIEEE754(it, 52, 8);
	};
	var packF32 = function(it){
	  return packIEEE754(it, 23, 4);
	};
	
	var addGetter = function(C, key, internal){
	  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
	};
	
	var get = function(view, bytes, index, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = store.slice(start, start + bytes);
	  return isLittleEndian ? pack : pack.reverse();
	};
	var set = function(view, bytes, index, conversion, value, isLittleEndian){
	  var numIndex = +index
	    , intIndex = toInteger(numIndex);
	  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
	  var store = view[$BUFFER]._b
	    , start = intIndex + view[$OFFSET]
	    , pack  = conversion(+value);
	  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
	};
	
	var validateArrayBufferArguments = function(that, length){
	  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
	  var numberLength = +length
	    , byteLength   = toLength(numberLength);
	  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
	  return byteLength;
	};
	
	if(!$typed.ABV){
	  $ArrayBuffer = function ArrayBuffer(length){
	    var byteLength = validateArrayBufferArguments(this, length);
	    this._b       = arrayFill.call(Array(byteLength), 0);
	    this[$LENGTH] = byteLength;
	  };
	
	  $DataView = function DataView(buffer, byteOffset, byteLength){
	    anInstance(this, $DataView, DATA_VIEW);
	    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
	    var bufferLength = buffer[$LENGTH]
	      , offset       = toInteger(byteOffset);
	    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
	    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
	    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
	    this[$BUFFER] = buffer;
	    this[$OFFSET] = offset;
	    this[$LENGTH] = byteLength;
	  };
	
	  if(DESCRIPTORS){
	    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
	    addGetter($DataView, BUFFER, '_b');
	    addGetter($DataView, BYTE_LENGTH, '_l');
	    addGetter($DataView, BYTE_OFFSET, '_o');
	  }
	
	  redefineAll($DataView[PROTOTYPE], {
	    getInt8: function getInt8(byteOffset){
	      return get(this, 1, byteOffset)[0] << 24 >> 24;
	    },
	    getUint8: function getUint8(byteOffset){
	      return get(this, 1, byteOffset)[0];
	    },
	    getInt16: function getInt16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
	    },
	    getUint16: function getUint16(byteOffset /*, littleEndian */){
	      var bytes = get(this, 2, byteOffset, arguments[1]);
	      return bytes[1] << 8 | bytes[0];
	    },
	    getInt32: function getInt32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1]));
	    },
	    getUint32: function getUint32(byteOffset /*, littleEndian */){
	      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
	    },
	    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
	    },
	    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
	      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
	    },
	    setInt8: function setInt8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      set(this, 1, byteOffset, packI8, value);
	    },
	    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
	      set(this, 2, byteOffset, packI16, value, arguments[2]);
	    },
	    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packI32, value, arguments[2]);
	    },
	    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
	      set(this, 4, byteOffset, packF32, value, arguments[2]);
	    },
	    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
	      set(this, 8, byteOffset, packF64, value, arguments[2]);
	    }
	  });
	} else {
	  if(!fails(function(){
	    new $ArrayBuffer;     // eslint-disable-line no-new
	  }) || !fails(function(){
	    new $ArrayBuffer(.5); // eslint-disable-line no-new
	  })){
	    $ArrayBuffer = function ArrayBuffer(length){
	      return new BaseBuffer(validateArrayBufferArguments(this, length));
	    };
	    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
	    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
	      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
	    };
	    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
	  }
	  // iOS Safari 7.x bug
	  var view = new $DataView(new $ArrayBuffer(2))
	    , $setInt8 = $DataView[PROTOTYPE].setInt8;
	  view.setInt8(0, 2147483648);
	  view.setInt8(1, 2147483649);
	  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
	    setInt8: function setInt8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    },
	    setUint8: function setUint8(byteOffset, value){
	      $setInt8.call(this, byteOffset, value << 24 >> 24);
	    }
	  }, true);
	}
	setToStringTag($ArrayBuffer, ARRAY_BUFFER);
	setToStringTag($DataView, DATA_VIEW);
	hide($DataView[PROTOTYPE], $typed.VIEW, true);
	exports[ARRAY_BUFFER] = $ArrayBuffer;
	exports[DATA_VIEW] = $DataView;

/***/ },
/* 221 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/es6.typed.data-view.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8);
	$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ 219).ABV, {
	  DataView: __webpack_require__(/*! ./_typed-buffer */ 220).DataView
	});

/***/ },
/* 222 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.typed.int8-array.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Int8', 1, function(init){
	  return function Int8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 223 */
/*!*******************************************!*\
  !*** ./~/core-js/modules/_typed-array.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	if(__webpack_require__(/*! ./_descriptors */ 6)){
	  var LIBRARY             = __webpack_require__(/*! ./_library */ 28)
	    , global              = __webpack_require__(/*! ./_global */ 4)
	    , fails               = __webpack_require__(/*! ./_fails */ 7)
	    , $export             = __webpack_require__(/*! ./_export */ 8)
	    , $typed              = __webpack_require__(/*! ./_typed */ 219)
	    , $buffer             = __webpack_require__(/*! ./_typed-buffer */ 220)
	    , ctx                 = __webpack_require__(/*! ./_ctx */ 20)
	    , anInstance          = __webpack_require__(/*! ./_an-instance */ 205)
	    , propertyDesc        = __webpack_require__(/*! ./_property-desc */ 17)
	    , hide                = __webpack_require__(/*! ./_hide */ 10)
	    , redefineAll         = __webpack_require__(/*! ./_redefine-all */ 210)
	    , toInteger           = __webpack_require__(/*! ./_to-integer */ 38)
	    , toLength            = __webpack_require__(/*! ./_to-length */ 37)
	    , toIndex             = __webpack_require__(/*! ./_to-index */ 39)
	    , toPrimitive         = __webpack_require__(/*! ./_to-primitive */ 16)
	    , has                 = __webpack_require__(/*! ./_has */ 5)
	    , same                = __webpack_require__(/*! ./_same-value */ 71)
	    , classof             = __webpack_require__(/*! ./_classof */ 75)
	    , isObject            = __webpack_require__(/*! ./_is-object */ 13)
	    , toObject            = __webpack_require__(/*! ./_to-object */ 58)
	    , isArrayIter         = __webpack_require__(/*! ./_is-array-iter */ 162)
	    , create              = __webpack_require__(/*! ./_object-create */ 46)
	    , getPrototypeOf      = __webpack_require__(/*! ./_object-gpo */ 59)
	    , gOPN                = __webpack_require__(/*! ./_object-gopn */ 50).f
	    , getIterFn           = __webpack_require__(/*! ./core.get-iterator-method */ 164)
	    , uid                 = __webpack_require__(/*! ./_uid */ 19)
	    , wks                 = __webpack_require__(/*! ./_wks */ 25)
	    , createArrayMethod   = __webpack_require__(/*! ./_array-methods */ 172)
	    , createArrayIncludes = __webpack_require__(/*! ./_array-includes */ 36)
	    , speciesConstructor  = __webpack_require__(/*! ./_species-constructor */ 207)
	    , ArrayIterators      = __webpack_require__(/*! ./es6.array.iterator */ 193)
	    , Iterators           = __webpack_require__(/*! ./_iterators */ 129)
	    , $iterDetect         = __webpack_require__(/*! ./_iter-detect */ 165)
	    , setSpecies          = __webpack_require__(/*! ./_set-species */ 192)
	    , arrayFill           = __webpack_require__(/*! ./_array-fill */ 188)
	    , arrayCopyWithin     = __webpack_require__(/*! ./_array-copy-within */ 185)
	    , $DP                 = __webpack_require__(/*! ./_object-dp */ 11)
	    , $GOPD               = __webpack_require__(/*! ./_object-gopd */ 51)
	    , dP                  = $DP.f
	    , gOPD                = $GOPD.f
	    , RangeError          = global.RangeError
	    , TypeError           = global.TypeError
	    , Uint8Array          = global.Uint8Array
	    , ARRAY_BUFFER        = 'ArrayBuffer'
	    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
	    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
	    , PROTOTYPE           = 'prototype'
	    , ArrayProto          = Array[PROTOTYPE]
	    , $ArrayBuffer        = $buffer.ArrayBuffer
	    , $DataView           = $buffer.DataView
	    , arrayForEach        = createArrayMethod(0)
	    , arrayFilter         = createArrayMethod(2)
	    , arraySome           = createArrayMethod(3)
	    , arrayEvery          = createArrayMethod(4)
	    , arrayFind           = createArrayMethod(5)
	    , arrayFindIndex      = createArrayMethod(6)
	    , arrayIncludes       = createArrayIncludes(true)
	    , arrayIndexOf        = createArrayIncludes(false)
	    , arrayValues         = ArrayIterators.values
	    , arrayKeys           = ArrayIterators.keys
	    , arrayEntries        = ArrayIterators.entries
	    , arrayLastIndexOf    = ArrayProto.lastIndexOf
	    , arrayReduce         = ArrayProto.reduce
	    , arrayReduceRight    = ArrayProto.reduceRight
	    , arrayJoin           = ArrayProto.join
	    , arraySort           = ArrayProto.sort
	    , arraySlice          = ArrayProto.slice
	    , arrayToString       = ArrayProto.toString
	    , arrayToLocaleString = ArrayProto.toLocaleString
	    , ITERATOR            = wks('iterator')
	    , TAG                 = wks('toStringTag')
	    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
	    , DEF_CONSTRUCTOR     = uid('def_constructor')
	    , ALL_CONSTRUCTORS    = $typed.CONSTR
	    , TYPED_ARRAY         = $typed.TYPED
	    , VIEW                = $typed.VIEW
	    , WRONG_LENGTH        = 'Wrong length!';
	
	  var $map = createArrayMethod(1, function(O, length){
	    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
	  });
	
	  var LITTLE_ENDIAN = fails(function(){
	    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
	  });
	
	  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
	    new Uint8Array(1).set({});
	  });
	
	  var strictToLength = function(it, SAME){
	    if(it === undefined)throw TypeError(WRONG_LENGTH);
	    var number = +it
	      , length = toLength(it);
	    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
	    return length;
	  };
	
	  var toOffset = function(it, BYTES){
	    var offset = toInteger(it);
	    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
	    return offset;
	  };
	
	  var validate = function(it){
	    if(isObject(it) && TYPED_ARRAY in it)return it;
	    throw TypeError(it + ' is not a typed array!');
	  };
	
	  var allocate = function(C, length){
	    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
	      throw TypeError('It is not a typed array constructor!');
	    } return new C(length);
	  };
	
	  var speciesFromList = function(O, list){
	    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
	  };
	
	  var fromList = function(C, list){
	    var index  = 0
	      , length = list.length
	      , result = allocate(C, length);
	    while(length > index)result[index] = list[index++];
	    return result;
	  };
	
	  var addGetter = function(it, key, internal){
	    dP(it, key, {get: function(){ return this._d[internal]; }});
	  };
	
	  var $from = function from(source /*, mapfn, thisArg */){
	    var O       = toObject(source)
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , iterFn  = getIterFn(O)
	      , i, length, values, result, step, iterator;
	    if(iterFn != undefined && !isArrayIter(iterFn)){
	      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
	        values.push(step.value);
	      } O = values;
	    }
	    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
	    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
	      result[i] = mapping ? mapfn(O[i], i) : O[i];
	    }
	    return result;
	  };
	
	  var $of = function of(/*...items*/){
	    var index  = 0
	      , length = arguments.length
	      , result = allocate(this, length);
	    while(length > index)result[index] = arguments[index++];
	    return result;
	  };
	
	  // iOS Safari 6.x fails here
	  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });
	
	  var $toLocaleString = function toLocaleString(){
	    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
	  };
	
	  var proto = {
	    copyWithin: function copyWithin(target, start /*, end */){
	      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
	    },
	    every: function every(callbackfn /*, thisArg */){
	      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
	      return arrayFill.apply(validate(this), arguments);
	    },
	    filter: function filter(callbackfn /*, thisArg */){
	      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
	        arguments.length > 1 ? arguments[1] : undefined));
	    },
	    find: function find(predicate /*, thisArg */){
	      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    findIndex: function findIndex(predicate /*, thisArg */){
	      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    forEach: function forEach(callbackfn /*, thisArg */){
	      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    indexOf: function indexOf(searchElement /*, fromIndex */){
	      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    includes: function includes(searchElement /*, fromIndex */){
	      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    join: function join(separator){ // eslint-disable-line no-unused-vars
	      return arrayJoin.apply(validate(this), arguments);
	    },
	    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
	      return arrayLastIndexOf.apply(validate(this), arguments);
	    },
	    map: function map(mapfn /*, thisArg */){
	      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduce.apply(validate(this), arguments);
	    },
	    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
	      return arrayReduceRight.apply(validate(this), arguments);
	    },
	    reverse: function reverse(){
	      var that   = this
	        , length = validate(that).length
	        , middle = Math.floor(length / 2)
	        , index  = 0
	        , value;
	      while(index < middle){
	        value         = that[index];
	        that[index++] = that[--length];
	        that[length]  = value;
	      } return that;
	    },
	    some: function some(callbackfn /*, thisArg */){
	      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    },
	    sort: function sort(comparefn){
	      return arraySort.call(validate(this), comparefn);
	    },
	    subarray: function subarray(begin, end){
	      var O      = validate(this)
	        , length = O.length
	        , $begin = toIndex(begin, length);
	      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
	        O.buffer,
	        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
	        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
	      );
	    }
	  };
	
	  var $slice = function slice(start, end){
	    return speciesFromList(this, arraySlice.call(validate(this), start, end));
	  };
	
	  var $set = function set(arrayLike /*, offset */){
	    validate(this);
	    var offset = toOffset(arguments[1], 1)
	      , length = this.length
	      , src    = toObject(arrayLike)
	      , len    = toLength(src.length)
	      , index  = 0;
	    if(len + offset > length)throw RangeError(WRONG_LENGTH);
	    while(index < len)this[offset + index] = src[index++];
	  };
	
	  var $iterators = {
	    entries: function entries(){
	      return arrayEntries.call(validate(this));
	    },
	    keys: function keys(){
	      return arrayKeys.call(validate(this));
	    },
	    values: function values(){
	      return arrayValues.call(validate(this));
	    }
	  };
	
	  var isTAIndex = function(target, key){
	    return isObject(target)
	      && target[TYPED_ARRAY]
	      && typeof key != 'symbol'
	      && key in target
	      && String(+key) == String(key);
	  };
	  var $getDesc = function getOwnPropertyDescriptor(target, key){
	    return isTAIndex(target, key = toPrimitive(key, true))
	      ? propertyDesc(2, target[key])
	      : gOPD(target, key);
	  };
	  var $setDesc = function defineProperty(target, key, desc){
	    if(isTAIndex(target, key = toPrimitive(key, true))
	      && isObject(desc)
	      && has(desc, 'value')
	      && !has(desc, 'get')
	      && !has(desc, 'set')
	      // TODO: add validation descriptor w/o calling accessors
	      && !desc.configurable
	      && (!has(desc, 'writable') || desc.writable)
	      && (!has(desc, 'enumerable') || desc.enumerable)
	    ){
	      target[key] = desc.value;
	      return target;
	    } else return dP(target, key, desc);
	  };
	
	  if(!ALL_CONSTRUCTORS){
	    $GOPD.f = $getDesc;
	    $DP.f   = $setDesc;
	  }
	
	  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
	    getOwnPropertyDescriptor: $getDesc,
	    defineProperty:           $setDesc
	  });
	
	  if(fails(function(){ arrayToString.call({}); })){
	    arrayToString = arrayToLocaleString = function toString(){
	      return arrayJoin.call(this);
	    }
	  }
	
	  var $TypedArrayPrototype$ = redefineAll({}, proto);
	  redefineAll($TypedArrayPrototype$, $iterators);
	  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
	  redefineAll($TypedArrayPrototype$, {
	    slice:          $slice,
	    set:            $set,
	    constructor:    function(){ /* noop */ },
	    toString:       arrayToString,
	    toLocaleString: $toLocaleString
	  });
	  addGetter($TypedArrayPrototype$, 'buffer', 'b');
	  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
	  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
	  addGetter($TypedArrayPrototype$, 'length', 'e');
	  dP($TypedArrayPrototype$, TAG, {
	    get: function(){ return this[TYPED_ARRAY]; }
	  });
	
	  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
	    CLAMPED = !!CLAMPED;
	    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
	      , ISNT_UINT8 = NAME != 'Uint8Array'
	      , GETTER     = 'get' + KEY
	      , SETTER     = 'set' + KEY
	      , TypedArray = global[NAME]
	      , Base       = TypedArray || {}
	      , TAC        = TypedArray && getPrototypeOf(TypedArray)
	      , FORCED     = !TypedArray || !$typed.ABV
	      , O          = {}
	      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
	    var getter = function(that, index){
	      var data = that._d;
	      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
	    };
	    var setter = function(that, index, value){
	      var data = that._d;
	      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
	      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
	    };
	    var addElement = function(that, index){
	      dP(that, index, {
	        get: function(){
	          return getter(this, index);
	        },
	        set: function(value){
	          return setter(this, index, value);
	        },
	        enumerable: true
	      });
	    };
	    if(FORCED){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME, '_d');
	        var index  = 0
	          , offset = 0
	          , buffer, byteLength, length, klass;
	        if(!isObject(data)){
	          length     = strictToLength(data, true)
	          byteLength = length * BYTES;
	          buffer     = new $ArrayBuffer(byteLength);
	        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          buffer = data;
	          offset = toOffset($offset, BYTES);
	          var $len = data.byteLength;
	          if($length === undefined){
	            if($len % BYTES)throw RangeError(WRONG_LENGTH);
	            byteLength = $len - offset;
	            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
	          } else {
	            byteLength = toLength($length) * BYTES;
	            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
	          }
	          length = byteLength / BYTES;
	        } else if(TYPED_ARRAY in data){
	          return fromList(TypedArray, data);
	        } else {
	          return $from.call(TypedArray, data);
	        }
	        hide(that, '_d', {
	          b: buffer,
	          o: offset,
	          l: byteLength,
	          e: length,
	          v: new $DataView(buffer)
	        });
	        while(index < length)addElement(that, index++);
	      });
	      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
	      hide(TypedArrayPrototype, 'constructor', TypedArray);
	    } else if(!$iterDetect(function(iter){
	      // V8 works with iterators, but fails in many other cases
	      // https://code.google.com/p/v8/issues/detail?id=4552
	      new TypedArray(null); // eslint-disable-line no-new
	      new TypedArray(iter); // eslint-disable-line no-new
	    }, true)){
	      TypedArray = wrapper(function(that, data, $offset, $length){
	        anInstance(that, TypedArray, NAME);
	        var klass;
	        // `ws` module bug, temporarily remove validation length for Uint8Array
	        // https://github.com/websockets/ws/pull/645
	        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
	        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
	          return $length !== undefined
	            ? new Base(data, toOffset($offset, BYTES), $length)
	            : $offset !== undefined
	              ? new Base(data, toOffset($offset, BYTES))
	              : new Base(data);
	        }
	        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
	        return $from.call(TypedArray, data);
	      });
	      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
	        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
	      });
	      TypedArray[PROTOTYPE] = TypedArrayPrototype;
	      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
	    }
	    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
	      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
	      , $iterator         = $iterators.values;
	    hide(TypedArray, TYPED_CONSTRUCTOR, true);
	    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
	    hide(TypedArrayPrototype, VIEW, true);
	    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);
	
	    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
	      dP(TypedArrayPrototype, TAG, {
	        get: function(){ return NAME; }
	      });
	    }
	
	    O[NAME] = TypedArray;
	
	    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
	
	    $export($export.S, NAME, {
	      BYTES_PER_ELEMENT: BYTES,
	      from: $from,
	      of: $of
	    });
	
	    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
	
	    $export($export.P, NAME, proto);
	
	    setSpecies(NAME);
	
	    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});
	
	    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
	
	    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});
	
	    $export($export.P + $export.F * fails(function(){
	      new TypedArray(1).slice();
	    }), NAME, {slice: $slice});
	
	    $export($export.P + $export.F * (fails(function(){
	      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
	    }) || !fails(function(){
	      TypedArrayPrototype.toLocaleString.call([1, 2]);
	    })), NAME, {toLocaleString: $toLocaleString});
	
	    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
	    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
	  };
	} else module.exports = function(){ /* empty */ };

/***/ },
/* 224 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.uint8-array.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Uint8', 1, function(init){
	  return function Uint8Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 225 */
/*!************************************************************!*\
  !*** ./~/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Uint8', 1, function(init){
	  return function Uint8ClampedArray(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	}, true);

/***/ },
/* 226 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.int16-array.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Int16', 2, function(init){
	  return function Int16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 227 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.uint16-array.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Uint16', 2, function(init){
	  return function Uint16Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 228 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.int32-array.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Int32', 4, function(init){
	  return function Int32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 229 */
/*!*****************************************************!*\
  !*** ./~/core-js/modules/es6.typed.uint32-array.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Uint32', 4, function(init){
	  return function Uint32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 230 */
/*!******************************************************!*\
  !*** ./~/core-js/modules/es6.typed.float32-array.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Float32', 4, function(init){
	  return function Float32Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 231 */
/*!******************************************************!*\
  !*** ./~/core-js/modules/es6.typed.float64-array.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_typed-array */ 223)('Float64', 8, function(init){
	  return function Float64Array(data, byteOffset, length){
	    return init(this, data, byteOffset, length);
	  };
	});

/***/ },
/* 232 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.apply.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 21)
	  , anObject  = __webpack_require__(/*! ./_an-object */ 12)
	  , rApply    = (__webpack_require__(/*! ./_global */ 4).Reflect || {}).apply
	  , fApply    = Function.apply;
	// MS Edge argumentsList argument is optional
	$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ 7)(function(){
	  rApply(function(){});
	}), 'Reflect', {
	  apply: function apply(target, thisArgument, argumentsList){
	    var T = aFunction(target)
	      , L = anObject(argumentsList);
	    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
	  }
	});

/***/ },
/* 233 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.construct.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
	var $export    = __webpack_require__(/*! ./_export */ 8)
	  , create     = __webpack_require__(/*! ./_object-create */ 46)
	  , aFunction  = __webpack_require__(/*! ./_a-function */ 21)
	  , anObject   = __webpack_require__(/*! ./_an-object */ 12)
	  , isObject   = __webpack_require__(/*! ./_is-object */ 13)
	  , fails      = __webpack_require__(/*! ./_fails */ 7)
	  , bind       = __webpack_require__(/*! ./_bind */ 77)
	  , rConstruct = (__webpack_require__(/*! ./_global */ 4).Reflect || {}).construct;
	
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function(){
	  function F(){}
	  return !(rConstruct(function(){}, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function(){
	  rConstruct(function(){});
	});
	
	$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
	  construct: function construct(Target, args /*, newTarget*/){
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
	    if(Target == newTarget){
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch(args.length){
	        case 0: return new Target;
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (bind.apply(Target, $args));
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto    = newTarget.prototype
	      , instance = create(isObject(proto) ? proto : Object.prototype)
	      , result   = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

/***/ },
/* 234 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.define-property.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
	var dP          = __webpack_require__(/*! ./_object-dp */ 11)
	  , $export     = __webpack_require__(/*! ./_export */ 8)
	  , anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , toPrimitive = __webpack_require__(/*! ./_to-primitive */ 16);
	
	// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
	$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ 7)(function(){
	  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
	}), 'Reflect', {
	  defineProperty: function defineProperty(target, propertyKey, attributes){
	    anObject(target);
	    propertyKey = toPrimitive(propertyKey, true);
	    anObject(attributes);
	    try {
	      dP.f(target, propertyKey, attributes);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 235 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.delete-property.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.4 Reflect.deleteProperty(target, propertyKey)
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , gOPD     = __webpack_require__(/*! ./_object-gopd */ 51).f
	  , anObject = __webpack_require__(/*! ./_an-object */ 12);
	
	$export($export.S, 'Reflect', {
	  deleteProperty: function deleteProperty(target, propertyKey){
	    var desc = gOPD(anObject(target), propertyKey);
	    return desc && !desc.configurable ? false : delete target[propertyKey];
	  }
	});

/***/ },
/* 236 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.enumerate.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// 26.1.5 Reflect.enumerate(target)
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12);
	var Enumerate = function(iterated){
	  this._t = anObject(iterated); // target
	  this._i = 0;                  // next index
	  var keys = this._k = []       // keys
	    , key;
	  for(key in iterated)keys.push(key);
	};
	__webpack_require__(/*! ./_iter-create */ 130)(Enumerate, 'Object', function(){
	  var that = this
	    , keys = that._k
	    , key;
	  do {
	    if(that._i >= keys.length)return {value: undefined, done: true};
	  } while(!((key = keys[that._i++]) in that._t));
	  return {value: key, done: false};
	});
	
	$export($export.S, 'Reflect', {
	  enumerate: function enumerate(target){
	    return new Enumerate(target);
	  }
	});

/***/ },
/* 237 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.reflect.get.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.6 Reflect.get(target, propertyKey [, receiver])
	var gOPD           = __webpack_require__(/*! ./_object-gopd */ 51)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 59)
	  , has            = __webpack_require__(/*! ./_has */ 5)
	  , $export        = __webpack_require__(/*! ./_export */ 8)
	  , isObject       = __webpack_require__(/*! ./_is-object */ 13)
	  , anObject       = __webpack_require__(/*! ./_an-object */ 12);
	
	function get(target, propertyKey/*, receiver*/){
	  var receiver = arguments.length < 3 ? target : arguments[2]
	    , desc, proto;
	  if(anObject(target) === receiver)return target[propertyKey];
	  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
	    ? desc.value
	    : desc.get !== undefined
	      ? desc.get.call(receiver)
	      : undefined;
	  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
	}
	
	$export($export.S, 'Reflect', {get: get});

/***/ },
/* 238 */
/*!**********************************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
	var gOPD     = __webpack_require__(/*! ./_object-gopd */ 51)
	  , $export  = __webpack_require__(/*! ./_export */ 8)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12);
	
	$export($export.S, 'Reflect', {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
	    return gOPD.f(anObject(target), propertyKey);
	  }
	});

/***/ },
/* 239 */
/*!***********************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.8 Reflect.getPrototypeOf(target)
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , getProto = __webpack_require__(/*! ./_object-gpo */ 59)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12);
	
	$export($export.S, 'Reflect', {
	  getPrototypeOf: function getPrototypeOf(target){
	    return getProto(anObject(target));
	  }
	});

/***/ },
/* 240 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.reflect.has.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.9 Reflect.has(target, propertyKey)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Reflect', {
	  has: function has(target, propertyKey){
	    return propertyKey in target;
	  }
	});

/***/ },
/* 241 */
/*!********************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.is-extensible.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.10 Reflect.isExtensible(target)
	var $export       = __webpack_require__(/*! ./_export */ 8)
	  , anObject      = __webpack_require__(/*! ./_an-object */ 12)
	  , $isExtensible = Object.isExtensible;
	
	$export($export.S, 'Reflect', {
	  isExtensible: function isExtensible(target){
	    anObject(target);
	    return $isExtensible ? $isExtensible(target) : true;
	  }
	});

/***/ },
/* 242 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.own-keys.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.11 Reflect.ownKeys(target)
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Reflect', {ownKeys: __webpack_require__(/*! ./_own-keys */ 243)});

/***/ },
/* 243 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_own-keys.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	// all object keys, includes non-enumerable and symbols
	var gOPN     = __webpack_require__(/*! ./_object-gopn */ 50)
	  , gOPS     = __webpack_require__(/*! ./_object-gops */ 43)
	  , anObject = __webpack_require__(/*! ./_an-object */ 12)
	  , Reflect  = __webpack_require__(/*! ./_global */ 4).Reflect;
	module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
	  var keys       = gOPN.f(anObject(it))
	    , getSymbols = gOPS.f;
	  return getSymbols ? keys.concat(getSymbols(it)) : keys;
	};

/***/ },
/* 244 */
/*!*************************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.12 Reflect.preventExtensions(target)
	var $export            = __webpack_require__(/*! ./_export */ 8)
	  , anObject           = __webpack_require__(/*! ./_an-object */ 12)
	  , $preventExtensions = Object.preventExtensions;
	
	$export($export.S, 'Reflect', {
	  preventExtensions: function preventExtensions(target){
	    anObject(target);
	    try {
	      if($preventExtensions)$preventExtensions(target);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 245 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es6.reflect.set.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
	var dP             = __webpack_require__(/*! ./_object-dp */ 11)
	  , gOPD           = __webpack_require__(/*! ./_object-gopd */ 51)
	  , getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ 59)
	  , has            = __webpack_require__(/*! ./_has */ 5)
	  , $export        = __webpack_require__(/*! ./_export */ 8)
	  , createDesc     = __webpack_require__(/*! ./_property-desc */ 17)
	  , anObject       = __webpack_require__(/*! ./_an-object */ 12)
	  , isObject       = __webpack_require__(/*! ./_is-object */ 13);
	
	function set(target, propertyKey, V/*, receiver*/){
	  var receiver = arguments.length < 4 ? target : arguments[3]
	    , ownDesc  = gOPD.f(anObject(target), propertyKey)
	    , existingDescriptor, proto;
	  if(!ownDesc){
	    if(isObject(proto = getPrototypeOf(target))){
	      return set(proto, propertyKey, V, receiver);
	    }
	    ownDesc = createDesc(0);
	  }
	  if(has(ownDesc, 'value')){
	    if(ownDesc.writable === false || !isObject(receiver))return false;
	    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
	    existingDescriptor.value = V;
	    dP.f(receiver, propertyKey, existingDescriptor);
	    return true;
	  }
	  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
	}
	
	$export($export.S, 'Reflect', {set: set});

/***/ },
/* 246 */
/*!***********************************************************!*\
  !*** ./~/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	// 26.1.14 Reflect.setPrototypeOf(target, proto)
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , setProto = __webpack_require__(/*! ./_set-proto */ 73);
	
	if(setProto)$export($export.S, 'Reflect', {
	  setPrototypeOf: function setPrototypeOf(target, proto){
	    setProto.check(target, proto);
	    try {
	      setProto.set(target, proto);
	      return true;
	    } catch(e){
	      return false;
	    }
	  }
	});

/***/ },
/* 247 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es7.array.includes.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/Array.prototype.includes
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , $includes = __webpack_require__(/*! ./_array-includes */ 36)(true);
	
	$export($export.P, 'Array', {
	  includes: function includes(el /*, fromIndex = 0 */){
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});
	
	__webpack_require__(/*! ./_add-to-unscopables */ 186)('includes');

/***/ },
/* 248 */
/*!********************************************!*\
  !*** ./~/core-js/modules/es7.string.at.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/mathiasbynens/String.prototype.at
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $at     = __webpack_require__(/*! ./_string-at */ 127)(true);
	
	$export($export.P, 'String', {
	  at: function at(pos){
	    return $at(this, pos);
	  }
	});

/***/ },
/* 249 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es7.string.pad-start.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $pad    = __webpack_require__(/*! ./_string-pad */ 250);
	
	$export($export.P, 'String', {
	  padStart: function padStart(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
	  }
	});

/***/ },
/* 250 */
/*!******************************************!*\
  !*** ./~/core-js/modules/_string-pad.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-string-pad-start-end
	var toLength = __webpack_require__(/*! ./_to-length */ 37)
	  , repeat   = __webpack_require__(/*! ./_string-repeat */ 91)
	  , defined  = __webpack_require__(/*! ./_defined */ 35);
	
	module.exports = function(that, maxLength, fillString, left){
	  var S            = String(defined(that))
	    , stringLength = S.length
	    , fillStr      = fillString === undefined ? ' ' : String(fillString)
	    , intMaxLength = toLength(maxLength);
	  if(intMaxLength <= stringLength || fillStr == '')return S;
	  var fillLen = intMaxLength - stringLength
	    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
	  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
	  return left ? stringFiller + S : S + stringFiller;
	};


/***/ },
/* 251 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es7.string.pad-end.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/tc39/proposal-string-pad-start-end
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $pad    = __webpack_require__(/*! ./_string-pad */ 250);
	
	$export($export.P, 'String', {
	  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
	    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
	  }
	});

/***/ },
/* 252 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es7.string.trim-left.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(/*! ./_string-trim */ 83)('trimLeft', function($trim){
	  return function trimLeft(){
	    return $trim(this, 1);
	  };
	}, 'trimStart');

/***/ },
/* 253 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es7.string.trim-right.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
	__webpack_require__(/*! ./_string-trim */ 83)('trimRight', function($trim){
	  return function trimRight(){
	    return $trim(this, 2);
	  };
	}, 'trimEnd');

/***/ },
/* 254 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es7.string.match-all.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://tc39.github.io/String.prototype.matchAll/
	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , defined     = __webpack_require__(/*! ./_defined */ 35)
	  , toLength    = __webpack_require__(/*! ./_to-length */ 37)
	  , isRegExp    = __webpack_require__(/*! ./_is-regexp */ 134)
	  , getFlags    = __webpack_require__(/*! ./_flags */ 196)
	  , RegExpProto = RegExp.prototype;
	
	var $RegExpStringIterator = function(regexp, string){
	  this._r = regexp;
	  this._s = string;
	};
	
	__webpack_require__(/*! ./_iter-create */ 130)($RegExpStringIterator, 'RegExp String', function next(){
	  var match = this._r.exec(this._s);
	  return {value: match, done: match === null};
	});
	
	$export($export.P, 'String', {
	  matchAll: function matchAll(regexp){
	    defined(this);
	    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
	    var S     = String(this)
	      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
	      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
	    rx.lastIndex = toLength(regexp.lastIndex);
	    return new $RegExpStringIterator(rx, S);
	  }
	});

/***/ },
/* 255 */
/*!********************************************************!*\
  !*** ./~/core-js/modules/es7.symbol.async-iterator.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_wks-define */ 27)('asyncIterator');

/***/ },
/* 256 */
/*!****************************************************!*\
  !*** ./~/core-js/modules/es7.symbol.observable.js ***!
  \****************************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ./_wks-define */ 27)('observable');

/***/ },
/* 257 */
/*!**********************************************************************!*\
  !*** ./~/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \**********************************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-getownpropertydescriptors
	var $export        = __webpack_require__(/*! ./_export */ 8)
	  , ownKeys        = __webpack_require__(/*! ./_own-keys */ 243)
	  , toIObject      = __webpack_require__(/*! ./_to-iobject */ 32)
	  , gOPD           = __webpack_require__(/*! ./_object-gopd */ 51)
	  , createProperty = __webpack_require__(/*! ./_create-property */ 163);
	
	$export($export.S, 'Object', {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
	    var O       = toIObject(object)
	      , getDesc = gOPD.f
	      , keys    = ownKeys(O)
	      , result  = {}
	      , i       = 0
	      , key;
	    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
	    return result;
	  }
	});

/***/ },
/* 258 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es7.object.values.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $values = __webpack_require__(/*! ./_object-to-array */ 259)(false);
	
	$export($export.S, 'Object', {
	  values: function values(it){
	    return $values(it);
	  }
	});

/***/ },
/* 259 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/_object-to-array.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(/*! ./_object-keys */ 30)
	  , toIObject = __webpack_require__(/*! ./_to-iobject */ 32)
	  , isEnum    = __webpack_require__(/*! ./_object-pie */ 44).f;
	module.exports = function(isEntries){
	  return function(it){
	    var O      = toIObject(it)
	      , keys   = getKeys(O)
	      , length = keys.length
	      , i      = 0
	      , result = []
	      , key;
	    while(length > i)if(isEnum.call(O, key = keys[i++])){
	      result.push(isEntries ? [key, O[key]] : O[key]);
	    } return result;
	  };
	};

/***/ },
/* 260 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es7.object.entries.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/tc39/proposal-object-values-entries
	var $export  = __webpack_require__(/*! ./_export */ 8)
	  , $entries = __webpack_require__(/*! ./_object-to-array */ 259)(true);
	
	$export($export.S, 'Object', {
	  entries: function entries(it){
	    return $entries(it);
	  }
	});

/***/ },
/* 261 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.object.define-getter.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(/*! ./_export */ 8)
	  , toObject        = __webpack_require__(/*! ./_to-object */ 58)
	  , aFunction       = __webpack_require__(/*! ./_a-function */ 21)
	  , $defineProperty = __webpack_require__(/*! ./_object-dp */ 11);
	
	// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
	__webpack_require__(/*! ./_descriptors */ 6) && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ 262), 'Object', {
	  __defineGetter__: function __defineGetter__(P, getter){
	    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 262 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/_object-forced-pam.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// Forced replacement prototype accessors methods
	module.exports = __webpack_require__(/*! ./_library */ 28)|| !__webpack_require__(/*! ./_fails */ 7)(function(){
	  var K = Math.random();
	  // In FF throws only define methods
	  __defineSetter__.call(null, K, function(){ /* empty */});
	  delete __webpack_require__(/*! ./_global */ 4)[K];
	});

/***/ },
/* 263 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.object.define-setter.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export         = __webpack_require__(/*! ./_export */ 8)
	  , toObject        = __webpack_require__(/*! ./_to-object */ 58)
	  , aFunction       = __webpack_require__(/*! ./_a-function */ 21)
	  , $defineProperty = __webpack_require__(/*! ./_object-dp */ 11);
	
	// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
	__webpack_require__(/*! ./_descriptors */ 6) && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ 262), 'Object', {
	  __defineSetter__: function __defineSetter__(P, setter){
	    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
	  }
	});

/***/ },
/* 264 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.object.lookup-getter.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(/*! ./_export */ 8)
	  , toObject                 = __webpack_require__(/*! ./_to-object */ 58)
	  , toPrimitive              = __webpack_require__(/*! ./_to-primitive */ 16)
	  , getPrototypeOf           = __webpack_require__(/*! ./_object-gpo */ 59)
	  , getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ 51).f;
	
	// B.2.2.4 Object.prototype.__lookupGetter__(P)
	__webpack_require__(/*! ./_descriptors */ 6) && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ 262), 'Object', {
	  __lookupGetter__: function __lookupGetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.get;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 265 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.object.lookup-setter.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $export                  = __webpack_require__(/*! ./_export */ 8)
	  , toObject                 = __webpack_require__(/*! ./_to-object */ 58)
	  , toPrimitive              = __webpack_require__(/*! ./_to-primitive */ 16)
	  , getPrototypeOf           = __webpack_require__(/*! ./_object-gpo */ 59)
	  , getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ 51).f;
	
	// B.2.2.5 Object.prototype.__lookupSetter__(P)
	__webpack_require__(/*! ./_descriptors */ 6) && $export($export.P + __webpack_require__(/*! ./_object-forced-pam */ 262), 'Object', {
	  __lookupSetter__: function __lookupSetter__(P){
	    var O = toObject(this)
	      , K = toPrimitive(P, true)
	      , D;
	    do {
	      if(D = getOwnPropertyDescriptor(O, K))return D.set;
	    } while(O = getPrototypeOf(O));
	  }
	});

/***/ },
/* 266 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es7.map.to-json.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(/*! ./_collection-to-json */ 267)('Map')});

/***/ },
/* 267 */
/*!**************************************************!*\
  !*** ./~/core-js/modules/_collection-to-json.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(/*! ./_classof */ 75)
	  , from    = __webpack_require__(/*! ./_array-from-iterable */ 268);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 268 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/_array-from-iterable.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(/*! ./_for-of */ 206);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 269 */
/*!**********************************************!*\
  !*** ./~/core-js/modules/es7.set.to-json.js ***!
  \**********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(/*! ./_collection-to-json */ 267)('Set')});

/***/ },
/* 270 */
/*!************************************************!*\
  !*** ./~/core-js/modules/es7.system.global.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-global
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'System', {global: __webpack_require__(/*! ./_global */ 4)});

/***/ },
/* 271 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/es7.error.is-error.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/ljharb/proposal-is-error
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , cof     = __webpack_require__(/*! ./_cof */ 34);
	
	$export($export.S, 'Error', {
	  isError: function isError(it){
	    return cof(it) === 'Error';
	  }
	});

/***/ },
/* 272 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es7.math.iaddh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  iaddh: function iaddh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
	  }
	});

/***/ },
/* 273 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es7.math.isubh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  isubh: function isubh(x0, x1, y0, y1){
	    var $x0 = x0 >>> 0
	      , $x1 = x1 >>> 0
	      , $y0 = y0 >>> 0;
	    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
	  }
	});

/***/ },
/* 274 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es7.math.imulh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  imulh: function imulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >> 16
	      , v1 = $v >> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
	  }
	});

/***/ },
/* 275 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es7.math.umulh.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
	var $export = __webpack_require__(/*! ./_export */ 8);
	
	$export($export.S, 'Math', {
	  umulh: function umulh(u, v){
	    var UINT16 = 0xffff
	      , $u = +u
	      , $v = +v
	      , u0 = $u & UINT16
	      , v0 = $v & UINT16
	      , u1 = $u >>> 16
	      , v1 = $v >>> 16
	      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
	    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
	  }
	});

/***/ },
/* 276 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.define-metadata.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject                  = __webpack_require__(/*! ./_an-object */ 12)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
	  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
	}});

/***/ },
/* 277 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_metadata.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	var Map     = __webpack_require__(/*! ./es6.map */ 211)
	  , $export = __webpack_require__(/*! ./_export */ 8)
	  , shared  = __webpack_require__(/*! ./_shared */ 23)('metadata')
	  , store   = shared.store || (shared.store = new (__webpack_require__(/*! ./es6.weak-map */ 215)));
	
	var getOrCreateMetadataMap = function(target, targetKey, create){
	  var targetMetadata = store.get(target);
	  if(!targetMetadata){
	    if(!create)return undefined;
	    store.set(target, targetMetadata = new Map);
	  }
	  var keyMetadata = targetMetadata.get(targetKey);
	  if(!keyMetadata){
	    if(!create)return undefined;
	    targetMetadata.set(targetKey, keyMetadata = new Map);
	  } return keyMetadata;
	};
	var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
	};
	var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
	  var metadataMap = getOrCreateMetadataMap(O, P, false);
	  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
	};
	var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
	  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
	};
	var ordinaryOwnMetadataKeys = function(target, targetKey){
	  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
	    , keys        = [];
	  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
	  return keys;
	};
	var toMetaKey = function(it){
	  return it === undefined || typeof it == 'symbol' ? it : String(it);
	};
	var exp = function(O){
	  $export($export.S, 'Reflect', O);
	};
	
	module.exports = {
	  store: store,
	  map: getOrCreateMetadataMap,
	  has: ordinaryHasOwnMetadata,
	  get: ordinaryGetOwnMetadata,
	  set: ordinaryDefineOwnMetadata,
	  keys: ordinaryOwnMetadataKeys,
	  key: toMetaKey,
	  exp: exp
	};

/***/ },
/* 278 */
/*!**********************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.delete-metadata.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject               = __webpack_require__(/*! ./_an-object */ 12)
	  , toMetaKey              = metadata.key
	  , getOrCreateMetadataMap = metadata.map
	  , store                  = metadata.store;
	
	metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
	  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
	    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
	  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
	  if(metadataMap.size)return true;
	  var targetMetadata = store.get(target);
	  targetMetadata['delete'](targetKey);
	  return !!targetMetadata.size || store['delete'](target);
	}});

/***/ },
/* 279 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.get-metadata.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject               = __webpack_require__(/*! ./_an-object */ 12)
	  , getPrototypeOf         = __webpack_require__(/*! ./_object-gpo */ 59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	var ordinaryGetMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
	};
	
	metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 280 */
/*!************************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.get-metadata-keys.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var Set                     = __webpack_require__(/*! ./es6.set */ 214)
	  , from                    = __webpack_require__(/*! ./_array-from-iterable */ 268)
	  , metadata                = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject                = __webpack_require__(/*! ./_an-object */ 12)
	  , getPrototypeOf          = __webpack_require__(/*! ./_object-gpo */ 59)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	var ordinaryMetadataKeys = function(O, P){
	  var oKeys  = ordinaryOwnMetadataKeys(O, P)
	    , parent = getPrototypeOf(O);
	  if(parent === null)return oKeys;
	  var pKeys  = ordinaryMetadataKeys(parent, P);
	  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
	};
	
	metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
	  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 281 */
/*!***********************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.get-own-metadata.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject               = __webpack_require__(/*! ./_an-object */ 12)
	  , ordinaryGetOwnMetadata = metadata.get
	  , toMetaKey              = metadata.key;
	
	metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 282 */
/*!****************************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.get-own-metadata-keys.js ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata                = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject                = __webpack_require__(/*! ./_an-object */ 12)
	  , ordinaryOwnMetadataKeys = metadata.keys
	  , toMetaKey               = metadata.key;
	
	metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
	  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
	}});

/***/ },
/* 283 */
/*!*******************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.has-metadata.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject               = __webpack_require__(/*! ./_an-object */ 12)
	  , getPrototypeOf         = __webpack_require__(/*! ./_object-gpo */ 59)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	var ordinaryHasMetadata = function(MetadataKey, O, P){
	  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
	  if(hasOwn)return true;
	  var parent = getPrototypeOf(O);
	  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
	};
	
	metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 284 */
/*!***********************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.has-own-metadata.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata               = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject               = __webpack_require__(/*! ./_an-object */ 12)
	  , ordinaryHasOwnMetadata = metadata.has
	  , toMetaKey              = metadata.key;
	
	metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
	  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
	    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
	}});

/***/ },
/* 285 */
/*!***************************************************!*\
  !*** ./~/core-js/modules/es7.reflect.metadata.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	var metadata                  = __webpack_require__(/*! ./_metadata */ 277)
	  , anObject                  = __webpack_require__(/*! ./_an-object */ 12)
	  , aFunction                 = __webpack_require__(/*! ./_a-function */ 21)
	  , toMetaKey                 = metadata.key
	  , ordinaryDefineOwnMetadata = metadata.set;
	
	metadata.exp({metadata: function metadata(metadataKey, metadataValue){
	  return function decorator(target, targetKey){
	    ordinaryDefineOwnMetadata(
	      metadataKey, metadataValue,
	      (targetKey !== undefined ? anObject : aFunction)(target),
	      toMetaKey(targetKey)
	    );
	  };
	}});

/***/ },
/* 286 */
/*!***************************************!*\
  !*** ./~/core-js/modules/es7.asap.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
	var $export   = __webpack_require__(/*! ./_export */ 8)
	  , microtask = __webpack_require__(/*! ./_microtask */ 209)()
	  , process   = __webpack_require__(/*! ./_global */ 4).process
	  , isNode    = __webpack_require__(/*! ./_cof */ 34)(process) == 'process';
	
	$export($export.G, {
	  asap: function asap(fn){
	    var domain = isNode && process.domain;
	    microtask(domain ? domain.bind(fn) : fn);
	  }
	});

/***/ },
/* 287 */
/*!*********************************************!*\
  !*** ./~/core-js/modules/es7.observable.js ***!
  \*********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// https://github.com/zenparsing/es-observable
	var $export     = __webpack_require__(/*! ./_export */ 8)
	  , global      = __webpack_require__(/*! ./_global */ 4)
	  , core        = __webpack_require__(/*! ./_core */ 9)
	  , microtask   = __webpack_require__(/*! ./_microtask */ 209)()
	  , OBSERVABLE  = __webpack_require__(/*! ./_wks */ 25)('observable')
	  , aFunction   = __webpack_require__(/*! ./_a-function */ 21)
	  , anObject    = __webpack_require__(/*! ./_an-object */ 12)
	  , anInstance  = __webpack_require__(/*! ./_an-instance */ 205)
	  , redefineAll = __webpack_require__(/*! ./_redefine-all */ 210)
	  , hide        = __webpack_require__(/*! ./_hide */ 10)
	  , forOf       = __webpack_require__(/*! ./_for-of */ 206)
	  , RETURN      = forOf.RETURN;
	
	var getMethod = function(fn){
	  return fn == null ? undefined : aFunction(fn);
	};
	
	var cleanupSubscription = function(subscription){
	  var cleanup = subscription._c;
	  if(cleanup){
	    subscription._c = undefined;
	    cleanup();
	  }
	};
	
	var subscriptionClosed = function(subscription){
	  return subscription._o === undefined;
	};
	
	var closeSubscription = function(subscription){
	  if(!subscriptionClosed(subscription)){
	    subscription._o = undefined;
	    cleanupSubscription(subscription);
	  }
	};
	
	var Subscription = function(observer, subscriber){
	  anObject(observer);
	  this._c = undefined;
	  this._o = observer;
	  observer = new SubscriptionObserver(this);
	  try {
	    var cleanup      = subscriber(observer)
	      , subscription = cleanup;
	    if(cleanup != null){
	      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
	      else aFunction(cleanup);
	      this._c = cleanup;
	    }
	  } catch(e){
	    observer.error(e);
	    return;
	  } if(subscriptionClosed(this))cleanupSubscription(this);
	};
	
	Subscription.prototype = redefineAll({}, {
	  unsubscribe: function unsubscribe(){ closeSubscription(this); }
	});
	
	var SubscriptionObserver = function(subscription){
	  this._s = subscription;
	};
	
	SubscriptionObserver.prototype = redefineAll({}, {
	  next: function next(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      try {
	        var m = getMethod(observer.next);
	        if(m)return m.call(observer, value);
	      } catch(e){
	        try {
	          closeSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      }
	    }
	  },
	  error: function error(value){
	    var subscription = this._s;
	    if(subscriptionClosed(subscription))throw value;
	    var observer = subscription._o;
	    subscription._o = undefined;
	    try {
	      var m = getMethod(observer.error);
	      if(!m)throw value;
	      value = m.call(observer, value);
	    } catch(e){
	      try {
	        cleanupSubscription(subscription);
	      } finally {
	        throw e;
	      }
	    } cleanupSubscription(subscription);
	    return value;
	  },
	  complete: function complete(value){
	    var subscription = this._s;
	    if(!subscriptionClosed(subscription)){
	      var observer = subscription._o;
	      subscription._o = undefined;
	      try {
	        var m = getMethod(observer.complete);
	        value = m ? m.call(observer, value) : undefined;
	      } catch(e){
	        try {
	          cleanupSubscription(subscription);
	        } finally {
	          throw e;
	        }
	      } cleanupSubscription(subscription);
	      return value;
	    }
	  }
	});
	
	var $Observable = function Observable(subscriber){
	  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
	};
	
	redefineAll($Observable.prototype, {
	  subscribe: function subscribe(observer){
	    return new Subscription(observer, this._f);
	  },
	  forEach: function forEach(fn){
	    var that = this;
	    return new (core.Promise || global.Promise)(function(resolve, reject){
	      aFunction(fn);
	      var subscription = that.subscribe({
	        next : function(value){
	          try {
	            return fn(value);
	          } catch(e){
	            reject(e);
	            subscription.unsubscribe();
	          }
	        },
	        error: reject,
	        complete: resolve
	      });
	    });
	  }
	});
	
	redefineAll($Observable, {
	  from: function from(x){
	    var C = typeof this === 'function' ? this : $Observable;
	    var method = getMethod(anObject(x)[OBSERVABLE]);
	    if(method){
	      var observable = anObject(method.call(x));
	      return observable.constructor === C ? observable : new C(function(observer){
	        return observable.subscribe(observer);
	      });
	    }
	    return new C(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          try {
	            if(forOf(x, false, function(it){
	              observer.next(it);
	              if(done)return RETURN;
	            }) === RETURN)return;
	          } catch(e){
	            if(done)throw e;
	            observer.error(e);
	            return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  },
	  of: function of(){
	    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
	    return new (typeof this === 'function' ? this : $Observable)(function(observer){
	      var done = false;
	      microtask(function(){
	        if(!done){
	          for(var i = 0; i < items.length; ++i){
	            observer.next(items[i]);
	            if(done)return;
	          } observer.complete();
	        }
	      });
	      return function(){ done = true; };
	    });
	  }
	});
	
	hide($Observable.prototype, OBSERVABLE, function(){ return this; });
	
	$export($export.G, {Observable: $Observable});
	
	__webpack_require__(/*! ./_set-species */ 192)('Observable');

/***/ },
/* 288 */
/*!*****************************************!*\
  !*** ./~/core-js/modules/web.timers.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	// ie9- setTimeout & setInterval additional parameters fix
	var global     = __webpack_require__(/*! ./_global */ 4)
	  , $export    = __webpack_require__(/*! ./_export */ 8)
	  , invoke     = __webpack_require__(/*! ./_invoke */ 78)
	  , partial    = __webpack_require__(/*! ./_partial */ 289)
	  , navigator  = global.navigator
	  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
	var wrap = function(set){
	  return MSIE ? function(fn, time /*, ...args */){
	    return set(invoke(
	      partial,
	      [].slice.call(arguments, 2),
	      typeof fn == 'function' ? fn : Function(fn)
	    ), time);
	  } : set;
	};
	$export($export.G + $export.B + $export.F * MSIE, {
	  setTimeout:  wrap(global.setTimeout),
	  setInterval: wrap(global.setInterval)
	});

/***/ },
/* 289 */
/*!***************************************!*\
  !*** ./~/core-js/modules/_partial.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var path      = __webpack_require__(/*! ./_path */ 290)
	  , invoke    = __webpack_require__(/*! ./_invoke */ 78)
	  , aFunction = __webpack_require__(/*! ./_a-function */ 21);
	module.exports = function(/* ...pargs */){
	  var fn     = aFunction(this)
	    , length = arguments.length
	    , pargs  = Array(length)
	    , i      = 0
	    , _      = path._
	    , holder = false;
	  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
	  return function(/* ...args */){
	    var that = this
	      , aLen = arguments.length
	      , j = 0, k = 0, args;
	    if(!holder && !aLen)return invoke(fn, pargs, that);
	    args = pargs.slice();
	    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
	    while(aLen > k)args.push(arguments[k++]);
	    return invoke(fn, args, that);
	  };
	};

/***/ },
/* 290 */
/*!************************************!*\
  !*** ./~/core-js/modules/_path.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(/*! ./_global */ 4);

/***/ },
/* 291 */
/*!********************************************!*\
  !*** ./~/core-js/modules/web.immediate.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $task   = __webpack_require__(/*! ./_task */ 208);
	$export($export.G + $export.B, {
	  setImmediate:   $task.set,
	  clearImmediate: $task.clear
	});

/***/ },
/* 292 */
/*!***********************************************!*\
  !*** ./~/core-js/modules/web.dom.iterable.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	var $iterators    = __webpack_require__(/*! ./es6.array.iterator */ 193)
	  , redefine      = __webpack_require__(/*! ./_redefine */ 18)
	  , global        = __webpack_require__(/*! ./_global */ 4)
	  , hide          = __webpack_require__(/*! ./_hide */ 10)
	  , Iterators     = __webpack_require__(/*! ./_iterators */ 129)
	  , wks           = __webpack_require__(/*! ./_wks */ 25)
	  , ITERATOR      = wks('iterator')
	  , TO_STRING_TAG = wks('toStringTag')
	  , ArrayValues   = Iterators.Array;
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype
	    , key;
	  if(proto){
	    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
	    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	    Iterators[NAME] = ArrayValues;
	    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
	  }
	}

/***/ },
/* 293 */
/*!******************************************!*\
  !*** ./~/regenerator-runtime/runtime.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */
	
	!(function(global) {
	  "use strict";
	
	  var hasOwn = Object.prototype.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
	
	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }
	
	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};
	
	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);
	
	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);
	
	    return generator;
	  }
	  runtime.wrap = wrap;
	
	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }
	
	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";
	
	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};
	
	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}
	
	  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
	
	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }
	
	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };
	
	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };
	
	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `value instanceof AwaitArgument` to determine if the yielded value is
	  // meant to be awaited. Some may consider the name of this method too
	  // cutesy, but they are curmudgeons.
	  runtime.awrap = function(arg) {
	    return new AwaitArgument(arg);
	  };
	
	  function AwaitArgument(arg) {
	    this.arg = arg;
	  }
	
	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value instanceof AwaitArgument) {
	          return Promise.resolve(value.arg).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }
	
	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }
	
	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }
	
	    var previousPromise;
	
	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }
	
	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }
	
	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }
	
	  defineIteratorMethods(AsyncIterator.prototype);
	
	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );
	
	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };
	
	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;
	
	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }
	
	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }
	
	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }
	
	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          if (method === "return" ||
	              (method === "throw" && delegate.iterator[method] === undefined)) {
	            // A return or throw (when the delegate iterator has no throw
	            // method) always terminates the yield* loop.
	            context.delegate = null;
	
	            // If the delegate iterator has a return method, give it a
	            // chance to clean up.
	            var returnMethod = delegate.iterator["return"];
	            if (returnMethod) {
	              var record = tryCatch(returnMethod, delegate.iterator, arg);
	              if (record.type === "throw") {
	                // If the return method threw an exception, let that
	                // exception prevail over the original return or throw.
	                method = "throw";
	                arg = record.arg;
	                continue;
	              }
	            }
	
	            if (method === "return") {
	              // Continue with the outer return, now that the delegate
	              // iterator has been terminated.
	              continue;
	            }
	          }
	
	          var record = tryCatch(
	            delegate.iterator[method],
	            delegate.iterator,
	            arg
	          );
	
	          if (record.type === "throw") {
	            context.delegate = null;
	
	            // Like returning generator.throw(uncaught), but without the
	            // overhead of an extra function call.
	            method = "throw";
	            arg = record.arg;
	            continue;
	          }
	
	          // Delegate generator ran and handled its own exceptions so
	          // regardless of what the method was, we continue as if it is
	          // "next" with an undefined arg.
	          method = "next";
	          arg = undefined;
	
	          var info = record.arg;
	          if (info.done) {
	            context[delegate.resultName] = info.value;
	            context.next = delegate.nextLoc;
	          } else {
	            state = GenStateSuspendedYield;
	            return info;
	          }
	
	          context.delegate = null;
	        }
	
	        if (method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = arg;
	
	        } else if (method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw arg;
	          }
	
	          if (context.dispatchException(arg)) {
	            // If the dispatched exception was caught by a catch block,
	            // then let that catch block handle the exception normally.
	            method = "next";
	            arg = undefined;
	          }
	
	        } else if (method === "return") {
	          context.abrupt("return", arg);
	        }
	
	        state = GenStateExecuting;
	
	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;
	
	          var info = {
	            value: record.arg,
	            done: context.done
	          };
	
	          if (record.arg === ContinueSentinel) {
	            if (context.delegate && method === "next") {
	              // Deliberately forget the last sent value so that we don't
	              // accidentally pass it on to the delegate.
	              arg = undefined;
	            }
	          } else {
	            return info;
	          }
	
	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(arg) call above.
	          method = "throw";
	          arg = record.arg;
	        }
	      }
	    };
	  }
	
	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);
	
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };
	
	  Gp[toStringTagSymbol] = "Generator";
	
	  Gp.toString = function() {
	    return "[object Generator]";
	  };
	
	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };
	
	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }
	
	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }
	
	    this.tryEntries.push(entry);
	  }
	
	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }
	
	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }
	
	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();
	
	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }
	
	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };
	
	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }
	
	      if (typeof iterable.next === "function") {
	        return iterable;
	      }
	
	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }
	
	          next.value = undefined;
	          next.done = true;
	
	          return next;
	        };
	
	        return next.next = next;
	      }
	    }
	
	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;
	
	  function doneResult() {
	    return { value: undefined, done: true };
	  }
	
	  Context.prototype = {
	    constructor: Context,
	
	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;
	
	      this.tryEntries.forEach(resetTryEntry);
	
	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },
	
	    stop: function() {
	      this.done = true;
	
	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }
	
	      return this.rval;
	    },
	
	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }
	
	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;
	        return !!caught;
	      }
	
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;
	
	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }
	
	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");
	
	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }
	
	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }
	
	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },
	
	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }
	
	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }
	
	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;
	
	      if (finallyEntry) {
	        this.next = finallyEntry.finallyLoc;
	      } else {
	        this.complete(record);
	      }
	
	      return ContinueSentinel;
	    },
	
	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }
	
	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = record.arg;
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }
	    },
	
	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },
	
	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }
	
	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },
	
	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };
	
	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/process/browser.js */ 294)))

/***/ },
/* 294 */
/*!******************************!*\
  !*** ./~/process/browser.js ***!
  \******************************/
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 295 */
/*!***************************************!*\
  !*** ./~/core-js/fn/regexp/escape.js ***!
  \***************************************/
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(/*! ../../modules/core.regexp.escape */ 296);
	module.exports = __webpack_require__(/*! ../../modules/_core */ 9).RegExp.escape;

/***/ },
/* 296 */
/*!*************************************************!*\
  !*** ./~/core-js/modules/core.regexp.escape.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/benjamingr/RexExp.escape
	var $export = __webpack_require__(/*! ./_export */ 8)
	  , $re     = __webpack_require__(/*! ./_replacer */ 297)(/[\\^$*+?.()|[\]{}]/g, '\\$&');
	
	$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ },
/* 297 */
/*!****************************************!*\
  !*** ./~/core-js/modules/_replacer.js ***!
  \****************************************/
/***/ function(module, exports) {

	module.exports = function(regExp, replace){
	  var replacer = replace === Object(replace) ? function(part){
	    return replace[part];
	  } : replace;
	  return function(it){
	    return String(it).replace(regExp, replacer);
	  };
	};

/***/ },
/* 298 */
/*!*************************!*\
  !*** ./beeline/main.js ***!
  \*************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _format = __webpack_require__(/*! ./shared/format */ 299);
	
	var _imageSources = __webpack_require__(/*! ./shared/imageSources */ 300);
	
	var _compareVersions = __webpack_require__(/*! compare-versions */ 302);
	
	var _compareVersions2 = _interopRequireDefault(_compareVersions);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _angularGoogleMaps = __webpack_require__(/*! angular-google-maps */ 307);
	
	var _angularGoogleMaps2 = _interopRequireDefault(_angularGoogleMaps);
	
	var _multipleDatePicker = __webpack_require__(/*! multiple-date-picker/dist/multipleDatePicker */ 308);
	
	var _multipleDatePicker2 = _interopRequireDefault(_multipleDatePicker);
	
	var _router = __webpack_require__(/*! ./router.js */ 310);
	
	var _router2 = _interopRequireDefault(_router);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	global.moment = __webpack_require__(/*! moment */ 311);
	
	// node imports
	
	
	// Angular imports
	
	
	// Configuration Imports
	
	
	__webpack_require__(/*! ./directives/extA */ 423);
	
	// //////////////////////////////////////////////////////////////////////////////
	// Angular configuration
	// //////////////////////////////////////////////////////////////////////////////
	angular.module('beeline').filter('formatDate', function () {
	  return _format.formatDate;
	}).filter('formatDateMMMdd', function () {
	  return _format.formatDateMMMdd;
	}).filter('formatUTCDate', function () {
	  return _format.formatUTCDate;
	}).filter('formatTime', function () {
	  return _format.formatTime;
	}).filter('formatTimeArray', function () {
	  return _format.formatTimeArray;
	}).filter('formatHHMM_ampm', function () {
	  return formatHHMM_ampm;
	}).filter('titleCase', function () {
	  return _format.titleCase;
	}).filter('routeStartTime', function () {
	  return function (route) {
	    return route && route.trips ? route.trips[0].tripStops[0].time : '';
	  };
	}).filter('routeEndTime', function () {
	  return function (route) {
	    return route && route.trips ? route.trips[0].tripStops[route.trips[0].tripStops.length - 1].time : '';
	  };
	}).filter('routeStartRoad', function () {
	  return function (route) {
	    return route && route.trips ? route.trips[0].tripStops[0].stop.road : '';
	  };
	}).filter('routeEndRoad', function () {
	  return function (route) {
	    return route && route.trips ? route.trips[0].tripStops[route.trips[0].tripStops.length - 1].stop.road : '';
	  };
	}).filter('companyLogo', function () {
	  return _imageSources.companyLogo;
	}).filter('monthNames', function () {
	  return function (i) {
	    monthNames = 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(',');
	    return monthNames[i];
	  };
	}).factory('TicketService', __webpack_require__(/*! ./services/TicketService.js */ 424).default).factory('LiteRouteSubscriptionService', __webpack_require__(/*! ./services/LiteRouteSubscriptionService.js */ 428).default).factory('UserService', __webpack_require__(/*! ./services/UserService.js */ 429).default).factory('TripService', __webpack_require__(/*! ./services/TripService.js */ 437).default).factory('CompanyService', __webpack_require__(/*! ./services/CompanyService.js */ 438).default).factory('SuggestionService', __webpack_require__(/*! ./services/SuggestionService.js */ 461).default).factory('RoutesService', __webpack_require__(/*! ./services/RoutesService.js */ 462).default).factory('CreditsService', __webpack_require__(/*! ./services/CreditsService.js */ 463).default).factory('LiteRoutesService', __webpack_require__(/*! ./services/LiteRoutesService.js */ 464).default).service('BookingService', __webpack_require__(/*! ./services/BookingService.js */ 465).default).factory('OneMapService', __webpack_require__(/*! ./services/OneMapService.js */ 467).default).factory('DateService', __webpack_require__(/*! ./services/DateService.js */ 468).default).factory('StripeService', __webpack_require__(/*! ./services/StripeService.js */ 469).default).factory('loadingSpinner', __webpack_require__(/*! ./services/LoadingSpinner.js */ 470).default).factory('GoogleAnalytics', __webpack_require__(/*! ./services/GoogleAnalytics.js */ 472).default).factory('SearchService', __webpack_require__(/*! ./services/SearchService.js */ 473).default).service('MapOptions', __webpack_require__(/*! ./services/MapOptions */ 474).default).service('busStopSelectorDialog', __webpack_require__(/*! ./services/busStopSelectorDialog.js */ 475).default).service('Legalese', __webpack_require__(/*! ./services/legalese.js */ 477).default).service('LoginDialog', __webpack_require__(/*! ./services/login.js */ 484).default).service('KickstarterService', __webpack_require__(/*! ./services/KickstarterService.js */ 486).default).controller('IntroSlidesController', __webpack_require__(/*! ./controllers/IntroSlidesController.js */ 488).default).controller('RoutesListController', __webpack_require__(/*! ./controllers/RoutesListController.js */ 489).default).controller('BookingStopsController', __webpack_require__(/*! ./controllers/BookingStopsController.js */ 491).default).controller('BookingDatesController', __webpack_require__(/*! ./controllers/BookingDatesController.js */ 492).default).controller('BookingSummaryController', __webpack_require__(/*! ./controllers/BookingSummaryController.js */ 493).default).controller('BookingConfirmationController', __webpack_require__(/*! ./controllers/BookingConfirmationController.js */ 495).default).controller('SuggestController', __webpack_require__(/*! ./controllers/SuggestController.js */ 496).default).controller('SettingsController', __webpack_require__(/*! ./controllers/SettingsController.js */ 498).default).controller('TicketsController', __webpack_require__(/*! ./controllers/TicketsController.js */ 501).default).controller('TicketDetailController', __webpack_require__(/*! ./controllers/TicketDetailController.js */ 502).default).controller('LiteRouteTrackerController', __webpack_require__(/*! ./controllers/LiteRouteTrackerController.js */ 503).default).controller('BookingHistoryController', __webpack_require__(/*! ./controllers/BookingHistoryController.js */ 504).default).controller('LiteSummaryController', __webpack_require__(/*! ./controllers/LiteSummaryController.js */ 505).default).controller('LiteMoreInfoController', __webpack_require__(/*! ./controllers/LiteMoreInfoController.js */ 506).default).controller('WelcomeController', __webpack_require__(/*! ./controllers/WelcomeController.js */ 507).default).controller('KickstarterController', __webpack_require__(/*! ./controllers/KickstarterController.js */ 508).default).controller('KickstarterDetailController', __webpack_require__(/*! ./controllers/KickstarterDetailController.js */ 510).default).controller('KickstarterSummaryController', __webpack_require__(/*! ./controllers/KickstarterSummaryController.js */ 512).default).controller('KickstarterCommitController', __webpack_require__(/*! ./controllers/KickstarterCommitController.js */ 513).default).controller('KickstarterRecapController', __webpack_require__(/*! ./controllers/KickstarterRecapController.js */ 514).default).controller('SearchController', __webpack_require__(/*! ./controllers/SearchController.js */ 515).default).controller('SearchResultsController', __webpack_require__(/*! ./controllers/SearchResultsController.js */ 516).default).directive('searchButton', __webpack_require__(/*! ./directives/searchButton.js */ 517).default).directive('suggestionViewer', __webpack_require__(/*! ./directives/suggestionViewer/suggestionViewer */ 518).default).directive('startEndPicker', __webpack_require__(/*! ./directives/startEndPicker/startEndPicker */ 521).default).directive('busStopSelector', __webpack_require__(/*! ./directives/busStopSelector/busStopSelector */ 523).default).directive('priceCalculator', __webpack_require__(/*! ./directives/priceCalculator/priceCalculator */ 525).default).directive('revGeocode', __webpack_require__(/*! ./directives/revGeocode/revGeocode */ 527).default).directive('fancyPrice', __webpack_require__(/*! ./directives/fancyPrice/fancyPrice */ 528).default).directive('bookingBreadcrumbs', __webpack_require__(/*! ./directives/bookingBreadcrumbs/bookingBreadcrumbs */ 529).default).directive('routeItem', __webpack_require__(/*! ./directives/routeItem/routeItem.js */ 530).default).directive('companyTnc', __webpack_require__(/*! ./directives/companyTnc/companyTnc.js */ 532).default).directive('tripCode', __webpack_require__(/*! ./directives/tripCode/tripCode.js */ 534).default).directive('myLocation', __webpack_require__(/*! ./directives/myLocation.js */ 535).default).directive('companyInfoBroker', __webpack_require__(/*! ./directives/companyInfoBroker.js */ 536).default).directive('moreInfo', __webpack_require__(/*! ./directives/moreInfo/moreInfo */ 537).default).directive('markdownRenderer', __webpack_require__(/*! ./directives/markdownRenderer */ 539).default).directive('mapPolyRoute', __webpack_require__(/*! ./directives/mapPolyRoute */ 540).default).directive('mapBusPolyRoute', __webpack_require__(/*! ./directives/mapBusPolyRoute */ 541).default).directive('mapBusStops', __webpack_require__(/*! ./directives/mapBusStops */ 543).default).directive('dynamicSignage', __webpack_require__(/*! ./directives/dynamicSignage.js */ 544).default).directive('beelineBindHtml', __webpack_require__(/*! ./directives/beelineBindHtml.js */ 545).default).directive('kickstartInfo', __webpack_require__(/*! ./directives/kickstartInfo/kickstartInfo.js */ 546).default).directive('progressBar', __webpack_require__(/*! ./directives/progressBar/progressBar.js */ 548).default).directive('dailyTripsBroker', __webpack_require__(/*! ./directives/dailyTripsBroker.js */ 550).default).directive('fakeProgressBar', __webpack_require__(/*! ./directives/fakeProgressBar.js */ 552).default).directive('inServiceWindow', __webpack_require__(/*! ./directives/inServiceWindow.js */ 553).default).directive('crowdstartShare', __webpack_require__(/*! ./directives/crowdstartShare.js */ 554).default).directive('poweredByBeeline', __webpack_require__(/*! ./directives/poweredByBeeline/poweredByBeeline.js */ 555).default).directive('gmapAutocomplete', __webpack_require__(/*! ./directives/autocomplete.js */ 557).default).directive('regularRoute', __webpack_require__(/*! ./directives/routeItem/regularRoute.js */ 558).default).directive('kickstartRoute', __webpack_require__(/*! ./directives/routeItem/kickstartRoute.js */ 560).default).directive('liteRoute', __webpack_require__(/*! ./directives/routeItem/liteRoute.js */ 562).default).config(_router2.default).config(function ($ionicConfigProvider) {
	  $ionicConfigProvider.tabs.position('bottom');
	  $ionicConfigProvider.tabs.style('standard');
	  $ionicConfigProvider.navBar.alignTitle('center');
	  $ionicConfigProvider.scrolling.jsScrolling(false);
	  //kickstart-summary use default history stack
	  $ionicConfigProvider.backButton.previousTitleText(false).text(' ');
	}).config(function ($httpProvider) {
	  $httpProvider.useApplyAsync(true);
	}).config(function (uiGmapGoogleMapApiProvider) {
	  uiGmapGoogleMapApiProvider.configure({
	    client: 'gme-infocommunications',
	    //        v: ', //defaults to latest 3.X anyhow
	    libraries: 'places,geometry'
	  });
	}).run(function ($ionicPlatform) {
	  $ionicPlatform.ready(function () {
	    // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
	    // for form inputs)
	    if (window.cordova && window.cordova.plugins && window.cordova.plugins.Keyboard) {
	      cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
	      cordova.plugins.Keyboard.disableScroll(false);
	    }
	    if (window.StatusBar) {
	      // org.apache.cordova.statusbar required
	      StatusBar.styleLightContent();
	    }
	  });
	}).run(function ($ionicPopup) {
	  // Check that external dependencies have loaded
	  if (typeof StripeCheckout === 'undefined' || typeof Stripe === 'undefined') {
	
	    document.addEventListener('online', function () {
	      window.location.reload(true);
	    });
	
	    $ionicPopup.alert({
	      title: 'Unable to connect to the Internet',
	      template: 'Please check your Internet connection'
	    }).then(function () {
	      window.location.reload(true);
	    });
	  }
	}).run(function ($rootScope, $ionicTabsDelegate) {
	  // hide/show tabs bar depending on how the route is configured
	  $rootScope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
	    if (toState.data && toState.data.hideTabs) {
	      $ionicTabsDelegate.showBar(false);
	    } else {
	      $ionicTabsDelegate.showBar(true);
	    }
	  });
	}).run(function (RoutesService, KickstarterService) {
	  // Pre-fetch the routes
	  RoutesService.fetchRoutes();
	  RoutesService.fetchRecentRoutes();
	  KickstarterService.fetchLelong();
	  KickstarterService.fetchBids();
	}).run(function ($templateCache) {
	  $templateCache.put('templates/intro-slides.html', __webpack_require__(/*! ../www/templates/intro-slides.html */ 564));
	  $templateCache.put('templates/settings.html', __webpack_require__(/*! ../www/templates/settings.html */ 565));
	  $templateCache.put('templates/routes-list.html', __webpack_require__(/*! ../www/templates/routes-list.html */ 566));
	  $templateCache.put('templates/tickets.html', __webpack_require__(/*! ../www/templates/tickets.html */ 567));
	  $templateCache.put('templates/ticket-detail.html', __webpack_require__(/*! ../www/templates/ticket-detail.html */ 568));
	  $templateCache.put('templates/tab-booking-stops.html', __webpack_require__(/*! ../www/templates/tab-booking-stops.html */ 569));
	  $templateCache.put('templates/tab-booking-dates.html', __webpack_require__(/*! ../www/templates/tab-booking-dates.html */ 570));
	  $templateCache.put('templates/tab-booking-summary.html', __webpack_require__(/*! ../www/templates/tab-booking-summary.html */ 571));
	  $templateCache.put('templates/tab-booking-confirmation.html', __webpack_require__(/*! ../www/templates/tab-booking-confirmation.html */ 572));
	});
	
	var devicePromise = new Promise(function (resolve, reject) {
	  if (window.cordova) {
	    document.addEventListener('deviceready', resolve, false);
	  } else {
	    console.log('No cordova detected');
	    resolve();
	  }
	});
	
	app.service('DevicePromise', function () {
	  return devicePromise;
	});
	
	app.run(['UserService', '$ionicPopup', function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(UserService, $ionicPopup) {
	    var versionNumberPromise, versionRequirementsPromise, _ref2, _ref3, versionNumber, versionRequirementsResponse, appRequirements;
	
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if (window.cordova) {
	              _context.next = 2;
	              break;
	            }
	
	            return _context.abrupt('return');
	
	          case 2:
	            _context.next = 4;
	            return devicePromise;
	
	          case 4:
	
	            (0, _assert2.default)(window.cordova.InAppBrowser);
	            (0, _assert2.default)(window.cordova.getAppVersion);
	            (0, _assert2.default)(window.device);
	
	            versionNumberPromise = cordova.getAppVersion.getVersionNumber();
	            versionRequirementsPromise = UserService.beeline({
	              method: 'GET',
	              url: '/versionRequirements'
	            });
	            _context.next = 11;
	            return Promise.all([versionNumberPromise, versionRequirementsPromise]);
	
	          case 11:
	            _ref2 = _context.sent;
	            _ref3 = _slicedToArray(_ref2, 2);
	            versionNumber = _ref3[0];
	            versionRequirementsResponse = _ref3[1];
	            appRequirements = versionRequirementsResponse.data.commuterApp;
	
	            (0, _assert2.default)(appRequirements);
	
	            if (!((0, _compareVersions2.default)(versionNumber, appRequirements.minVersion) < 0)) {
	              _context.next = 24;
	              break;
	            }
	
	          case 18:
	            if (false) {
	              _context.next = 24;
	              break;
	            }
	
	            _context.next = 21;
	            return $ionicPopup.alert({
	              title: 'Update required',
	              template: 'Your version of the app is too old. Please visit the app\n        store to upgrade your app.'
	            });
	
	          case 21:
	
	            if (appRequirements.upgradeUrl) {
	              cordova.InAppBrowser.open(appRequirements.upgradeUrl[device.platform], '_system');
	            }
	            _context.next = 18;
	            break;
	
	          case 24:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	
	  return function (_x, _x2) {
	    return _ref.apply(this, arguments);
	  };
	}()]);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 299 */
/*!**********************************!*\
  !*** ./beeline/shared/format.js ***!
  \**********************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.twoPad = twoPad;
	exports.timeSinceMidnight = timeSinceMidnight;
	exports.formatDate = formatDate;
	exports.formatDateMMMdd = formatDateMMMdd;
	exports.formatUTCDate = formatUTCDate;
	exports.formatTime = formatTime;
	exports.formatTimeArray = formatTimeArray;
	exports.formatHHMM_ampm = formatHHMM_ampm;
	exports.titleCase = titleCase;
	function twoPad(s, len, ch) {
	  len = len || 2;
	  ch = ch || '0';
	
	  s = s + '';
	  while (s.length < len) {
	    s = ch + s;
	  }
	  return s;
	}
	
	function timeSinceMidnight(date) {
	  if (!date) return '';
	  if (typeof date == 'string' || typeof date == 'number') {
	    date = new Date(date);
	  }
	
	  return date.getHours() * 3600000 + date.getMinutes() * 60000 + date.getSeconds() * 1000 + date.getMilliseconds();
	}
	
	function formatDate(date) {
	  if (!date) return '';
	  if (typeof date == 'string' || typeof date == 'number') {
	    date = new Date(date);
	  }
	  return twoPad(date.getDate()) + '-' + twoPad(date.getMonth() + 1) + '-' + twoPad(date.getFullYear());
	}
	
	function formatDateMMMdd(date) {
	  var monthNames = 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(',');
	
	  if (!date) return '';
	  if (typeof date == 'string' || typeof date == 'number') {
	    date = new Date(date);
	  }
	  return monthNames[date.getMonth()] + ' ' + twoPad(date.getDate());
	}
	
	function formatUTCDate(date) {
	  if (!date) return '';
	  if (typeof date == 'string') {
	    date = new Date(date);
	  }
	  return twoPad(date.getUTCDate()) + '-' + twoPad(date.getUTCMonth() + 1) + '-' + twoPad(date.getUTCFullYear());
	}
	
	function formatTime(date, prePadding) {
	  if (!date) return '';
	  if (typeof date == 'string' || typeof date == 'number') {
	    date = new Date(date);
	  }
	
	  // Fix time zone to +0800
	  date = new Date(date.getTime() + 8 * 60 * 60 * 1000);
	
	  var hours = date.getUTCHours();
	
	  var hourPart = 12 - (24 - hours) % 12;
	  hourPart = prePadding ? twoPad(hourPart, 2, '\u2007') : hourPart;
	
	  /* \u2007 is a figure space */
	  return hourPart + ':' + twoPad(date.getUTCMinutes()) + '\xA0' /* non-breaking space */
	  + (hours >= 12 ? 'pm' : 'am') /* + ':' +
	                                twoPad(date.getSeconds()) */;
	}
	
	function formatTimeArray(timeArray) {
	  if (timeArray.length == 0) return;else {
	    return timeArray.map(function (x) {
	      return formatTime(x, true);
	    }).join(', ');
	  }
	}
	
	// func to generate something like '14:15 pm' from JS date obj
	function formatHHMM_ampm(t) {
	  var h = t.getHours(),
	      m = t.getMinutes(),
	      term = 'am';
	
	  if (h >= 12) {
	    term = 'pm';
	    if (h > 12) {
	      h = h - 12;
	    }
	    h = h.toString();
	  }
	
	  if (h.toString().length == 1) {
	    h = '0' + h.toString();
	  }
	  if (m.toString().length == 1) {
	    m = '0' + m.toString();
	  }
	
	  return h + ':' + m + ' ' + term;
	}
	
	function titleCase(s) {
	  if (!s) return '';
	
	  return s.replace(/\w\S*/g, function (txt) {
	    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
	  });
	}

/***/ },
/* 300 */
/*!****************************************!*\
  !*** ./beeline/shared/imageSources.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.companyLogo = companyLogo;
	var env = __webpack_require__(/*! ../env.json */ 301);
	
	function companyLogo(i) {
	  if (!i) return '';
	  return env.BACKEND_URL + '/companies/' + i + '/logo';
	}

/***/ },
/* 301 */
/*!**************************!*\
  !*** ./beeline/env.json ***!
  \**************************/
/***/ function(module, exports) {

	module.exports = {
		"BACKEND_URL": "https://api.beeline.sg"
	};

/***/ },
/* 302 */
/*!*************************************!*\
  !*** ./~/compare-versions/index.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define */
	(function (root, factory) {
	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        module.exports = factory();
	    } else {
	        root.compareVersions = factory();
	    }
	}(this, function () {
	
	    var semver = /^v?(?:0|[1-9]\d*)(\.(?:[x*]|0|[1-9]\d*)(\.(?:[x*]|0|[1-9]\d*)(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i;
	    var patch = /-([0-9A-Za-z-.]+)/;
	
	    function split(v) {
	        var temp = v.split('.');
	        var arr = temp.splice(0, 2);
	        arr.push(temp.join('.'));
	        return arr;
	    }
	
	    function tryParse(v) {
	        return isNaN(Number(v)) ? v : Number(v);
	    }
	
	    function validate(version) {
	        if (typeof version !== 'string') {
	            throw new TypeError('Invalid argument expected string');
	        }
	        if (!semver.test(version)) {
	            throw new Error('Invalid argument not valid semver');
	        }
	    }
	
	    return function compareVersions(v1, v2) {
	        [v1, v2].forEach(validate);
	
	        var s1 = split(v1);
	        var s2 = split(v2);
	
	        for (var i = 0; i < 3; i++) {
	            var n1 = parseInt(s1[i] || 0, 10);
	            var n2 = parseInt(s2[i] || 0, 10);
	
	            if (n1 > n2) return 1;
	            if (n2 > n1) return -1;
	        }
	
	        if ([s1[2], s2[2]].every(patch.test.bind(patch))) {
	            var p1 = patch.exec(s1[2])[1].split('.').map(tryParse);
	            var p2 = patch.exec(s2[2])[1].split('.').map(tryParse);
	
	            for (i = 0; i < Math.max(p1.length, p2.length); i++) {
	                if (p1[i] === undefined || typeof p2[i] === 'string' && typeof p1[i] === 'number') return -1;
	                if (p2[i] === undefined || typeof p1[i] === 'string' && typeof p2[i] === 'number') return 1;
	
	                if (p1[i] > p2[i]) return 1;
	                if (p2[i] > p1[i]) return -1;
	            }
	        } else if ([s1[2], s2[2]].some(patch.test.bind(patch))) {
	            return patch.test(s1[2]) ? -1 : 1;
	        }
	
	        return 0;
	    };
	
	}));


/***/ },
/* 303 */
/*!****************************!*\
  !*** ./~/assert/assert.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(/*! util/ */ 304);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 304 */
/*!************************!*\
  !*** ./~/util/util.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ 305);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(/*! inherits */ 306);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(/*! ./~/process/browser.js */ 294)))

/***/ },
/* 305 */
/*!*******************************************!*\
  !*** ./~/util/support/isBufferBrowser.js ***!
  \*******************************************/
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 306 */
/*!***********************************************!*\
  !*** ./~/util/~/inherits/inherits_browser.js ***!
  \***********************************************/
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 307 */
/*!***********************************************************!*\
  !*** ./~/angular-google-maps/dist/angular-google-maps.js ***!
  \***********************************************************/
/***/ function(module, exports) {

	/*! angular-google-maps 2.4.0 2016-09-19
	 *  AngularJS directives for Google Maps
	 *  git: https://github.com/angular-ui/angular-google-maps.git
	 */
	;
	(function( window, angular, _, undefined ){
	  'use strict';
	/*
	!
	The MIT License
	
	Copyright (c) 2010-2013 Google, Inc. http://angularjs.org
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the 'Software'), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	
	angular-google-maps
	https://github.com/angular-ui/angular-google-maps
	
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.providers', ['nemLogging']);
	
	  angular.module('uiGmapgoogle-maps.wrapped', []);
	
	  angular.module('uiGmapgoogle-maps.extensions', ['uiGmapgoogle-maps.wrapped', 'uiGmapgoogle-maps.providers']);
	
	  angular.module('uiGmapgoogle-maps.directives.api.utils', ['uiGmapgoogle-maps.extensions']);
	
	  angular.module('uiGmapgoogle-maps.directives.api.managers', []);
	
	  angular.module('uiGmapgoogle-maps.directives.api.options', ['uiGmapgoogle-maps.directives.api.utils']);
	
	  angular.module('uiGmapgoogle-maps.directives.api.options.builders', []);
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.child', ['uiGmapgoogle-maps.directives.api.utils', 'uiGmapgoogle-maps.directives.api.options', 'uiGmapgoogle-maps.directives.api.options.builders']);
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent', ['uiGmapgoogle-maps.directives.api.managers', 'uiGmapgoogle-maps.directives.api.models.child', 'uiGmapgoogle-maps.providers']);
	
	  angular.module('uiGmapgoogle-maps.directives.api', ['uiGmapgoogle-maps.directives.api.models.parent']);
	
	  angular.module('uiGmapgoogle-maps', ['uiGmapgoogle-maps.directives.api', 'uiGmapgoogle-maps.providers']);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.providers').factory('uiGmapMapScriptLoader', [
	    '$q', 'uiGmapuuid', function($q, uuid) {
	      var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId, usedConfiguration;
	      scriptId = void 0;
	      usedConfiguration = void 0;
	      getScriptUrl = function(options) {
	        if (options.china) {
	          return 'http://maps.google.cn/maps/api/js?';
	        } else {
	          if (options.transport === 'auto') {
	            return '//maps.googleapis.com/maps/api/js?';
	          } else {
	            return options.transport + '://maps.googleapis.com/maps/api/js?';
	          }
	        }
	      };
	      includeScript = function(options) {
	        var omitOptions, query, script, scriptElem;
	        omitOptions = ['transport', 'isGoogleMapsForWork', 'china', 'preventLoad'];
	        if (options.isGoogleMapsForWork) {
	          omitOptions.push('key');
	        }
	        query = _.map(_.omit(options, omitOptions), function(v, k) {
	          return k + '=' + v;
	        });
	        if (scriptId) {
	          scriptElem = document.getElementById(scriptId);
	          scriptElem.parentNode.removeChild(scriptElem);
	        }
	        query = query.join('&');
	        script = document.createElement('script');
	        script.id = scriptId = "ui_gmap_map_load_" + (uuid.generate());
	        script.type = 'text/javascript';
	        script.src = getScriptUrl(options) + query;
	        return document.head.appendChild(script);
	      };
	      isGoogleMapsLoaded = function() {
	        return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
	      };
	      return {
	        load: function(options) {
	          var deferred, randomizedFunctionName;
	          deferred = $q.defer();
	          if (isGoogleMapsLoaded()) {
	            deferred.resolve(window.google.maps);
	            return deferred.promise;
	          }
	          randomizedFunctionName = options.callback = 'onGoogleMapsReady' + Math.round(Math.random() * 1000);
	          window[randomizedFunctionName] = function() {
	            window[randomizedFunctionName] = null;
	            deferred.resolve(window.google.maps);
	          };
	          if (window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE && !options.preventLoad) {
	            document.addEventListener('online', function() {
	              if (!isGoogleMapsLoaded()) {
	                return includeScript(options);
	              }
	            });
	          } else if (!options.preventLoad) {
	            includeScript(options);
	          }
	          usedConfiguration = options;
	          usedConfiguration.randomizedFunctionName = randomizedFunctionName;
	          return deferred.promise;
	        },
	        manualLoad: function() {
	          var config;
	          config = usedConfiguration;
	          if (!isGoogleMapsLoaded()) {
	            return includeScript(config);
	          } else {
	            if (window[config.randomizedFunctionName]) {
	              return window[config.randomizedFunctionName]();
	            }
	          }
	        }
	      };
	    }
	  ]).provider('uiGmapGoogleMapApi', function() {
	    this.options = {
	      transport: 'https',
	      isGoogleMapsForWork: false,
	      china: false,
	      v: '3',
	      libraries: '',
	      language: 'en',
	      preventLoad: false
	    };
	    this.configure = function(options) {
	      angular.extend(this.options, options);
	    };
	    this.$get = [
	      'uiGmapMapScriptLoader', (function(_this) {
	        return function(loader) {
	          return loader.load(_this.options);
	        };
	      })(this)
	    ];
	    return this;
	  }).service('uiGmapGoogleMapApiManualLoader', [
	    'uiGmapMapScriptLoader', function(loader) {
	      return {
	        load: function() {
	          loader.manualLoad();
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.extensions').service('uiGmapExtendGWin', function() {
	    return {
	      init: _.once(function() {
	        var uiGmapInfoBox;
	        if (!(google || (typeof google !== "undefined" && google !== null ? google.maps : void 0) || (google.maps.InfoWindow != null))) {
	          return;
	        }
	        google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
	        google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
	        google.maps.InfoWindow.prototype._isOpen = false;
	        google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
	          if (recurse != null) {
	            return;
	          }
	          this._isOpen = true;
	          this._open(map, anchor, true);
	        };
	        google.maps.InfoWindow.prototype.close = function(recurse) {
	          if (recurse != null) {
	            return;
	          }
	          this._isOpen = false;
	          this._close(true);
	        };
	        google.maps.InfoWindow.prototype.isOpen = function(val) {
	          if (val == null) {
	            val = void 0;
	          }
	          if (val == null) {
	            return this._isOpen;
	          } else {
	            return this._isOpen = val;
	          }
	        };
	
	        /*
	        Do the same for InfoBox
	        TODO: Clean this up so the logic is defined once, wait until develop becomes master as this will be easier
	         */
	        if (window.InfoBox) {
	          window.InfoBox.prototype._open = window.InfoBox.prototype.open;
	          window.InfoBox.prototype._close = window.InfoBox.prototype.close;
	          window.InfoBox.prototype._isOpen = false;
	          window.InfoBox.prototype.open = function(map, anchor) {
	            this._isOpen = true;
	            this._open(map, anchor);
	          };
	          window.InfoBox.prototype.close = function() {
	            this._isOpen = false;
	            this._close();
	          };
	          window.InfoBox.prototype.isOpen = function(val) {
	            if (val == null) {
	              val = void 0;
	            }
	            if (val == null) {
	              return this._isOpen;
	            } else {
	              return this._isOpen = val;
	            }
	          };
	          uiGmapInfoBox = (function(superClass) {
	            extend(uiGmapInfoBox, superClass);
	
	            function uiGmapInfoBox(opts) {
	              this.getOrigCloseBoxImg_ = bind(this.getOrigCloseBoxImg_, this);
	              this.getCloseBoxDiv_ = bind(this.getCloseBoxDiv_, this);
	              var box;
	              box = new window.InfoBox(opts);
	              _.extend(this, box);
	              if (opts.closeBoxDiv != null) {
	                this.closeBoxDiv_ = opts.closeBoxDiv;
	              }
	            }
	
	            uiGmapInfoBox.prototype.getCloseBoxDiv_ = function() {
	              return this.closeBoxDiv_;
	            };
	
	            uiGmapInfoBox.prototype.getCloseBoxImg_ = function() {
	              var div, img;
	              div = this.getCloseBoxDiv_();
	              img = this.getOrigCloseBoxImg_();
	              return div || img;
	            };
	
	            uiGmapInfoBox.prototype.getOrigCloseBoxImg_ = function() {
	              var img;
	              img = "";
	              if (this.closeBoxURL_ !== "") {
	                img = "<img";
	                img += " src='" + this.closeBoxURL_ + "'";
	                img += " align=right";
	                img += " style='";
	                img += " position: relative;";
	                img += " cursor: pointer;";
	                img += " margin: " + this.closeBoxMargin_ + ";";
	                img += "'>";
	              }
	              return img;
	            };
	
	            return uiGmapInfoBox;
	
	          })(window.InfoBox);
	          window.uiGmapInfoBox = uiGmapInfoBox;
	        }
	        if (window.MarkerLabel_) {
	          return window.MarkerLabel_.prototype.setContent = function() {
	            var content;
	            content = this.marker_.get('labelContent');
	            if (!content || _.isEqual(this.oldContent, content)) {
	              return;
	            }
	            if (typeof (content != null ? content.nodeType : void 0) === 'undefined') {
	              this.labelDiv_.innerHTML = content;
	              this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
	              this.oldContent = content;
	            } else {
	              this.labelDiv_.innerHTML = '';
	              this.labelDiv_.appendChild(content);
	              content = content.cloneNode(true);
	              this.labelDiv_.innerHTML = '';
	              this.eventDiv_.appendChild(content);
	              this.oldContent = content;
	            }
	          };
	        }
	      })
	    };
	  });
	
	}).call(this);
	;
	/*global _:true, angular:true */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.extensions').service('uiGmapLodash', function() {
	    var baseGet, baseToString, fixLodash, get, reEscapeChar, rePropName, toObject, toPath;
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
	    reEscapeChar = /\\(\\)?/g;
	
	    /*
	        For Lodash 4 compatibility (some aliases are removed)
	     */
	    fixLodash = function(arg) {
	      var isProto, missingName, swapName;
	      missingName = arg.missingName, swapName = arg.swapName, isProto = arg.isProto;
	      if (_[missingName] == null) {
	        _[missingName] = _[swapName];
	        if (isProto) {
	          return _.prototype[missingName] = _[swapName];
	        }
	      }
	    };
	    [
	      {
	        missingName: 'contains',
	        swapName: 'includes',
	        isProto: true
	      }, {
	        missingName: 'includes',
	        swapName: 'contains',
	        isProto: true
	      }, {
	        missingName: 'object',
	        swapName: 'zipObject'
	      }, {
	        missingName: 'zipObject',
	        swapName: 'object'
	      }, {
	        missingName: 'all',
	        swapName: 'every'
	      }, {
	        missingName: 'every',
	        swapName: 'all'
	      }, {
	        missingName: 'any',
	        swapName: 'some'
	      }, {
	        missingName: 'some',
	        swapName: 'any'
	      }, {
	        missingName: 'first',
	        swapName: 'head'
	      }, {
	        missingName: 'head',
	        swapName: 'first'
	      }
	    ].forEach(function(toMonkeyPatch) {
	      return fixLodash(toMonkeyPatch);
	    });
	    if (_.get == null) {
	
	      /**
	       * Converts `value` to an object if it's not one.
	       *
	       * @private
	       * @param {*} value The value to process.
	       * @returns {Object} Returns the object.
	       */
	      toObject = function(value) {
	        if (_.isObject(value)) {
	          return value;
	        } else {
	          return Object(value);
	        }
	      };
	
	      /**
	       * Converts `value` to a string if it's not one. An empty string is returned
	       * for `null` or `undefined` values.
	       *
	       * @private
	       * @param {*} value The value to process.
	       * @returns {string} Returns the string.
	       */
	      baseToString = function(value) {
	        if (value === null) {
	          return '';
	        } else {
	          return value + '';
	        }
	      };
	
	      /**
	       * Converts `value` to property path array if it's not one.
	       *
	       * @private
	       * @param {*} value The value to process.
	       * @returns {Array} Returns the property path array.
	       */
	      toPath = function(value) {
	        var result;
	        if (_.isArray(value)) {
	          return value;
	        }
	        result = [];
	        baseToString(value).replace(rePropName, function(match, number, quote, string) {
	          result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
	        });
	        return result;
	      };
	
	      /**
	       * The base implementation of `get` without support for string paths
	       * and default values.
	       *
	       * @private
	       * @param {Object} object The object to query.
	       * @param {Array} path The path of the property to get.
	       * @param {string} [pathKey] The key representation of path.
	       * @returns {*} Returns the resolved value.
	       */
	      baseGet = function(object, path, pathKey) {
	        var index, length;
	        if (object === null) {
	          return;
	        }
	        if (pathKey !== void 0 && pathKey in toObject(object)) {
	          path = [pathKey];
	        }
	        index = 0;
	        length = path.length;
	        while (!_.isUndefined(object) && index < length) {
	          object = object[path[index++]];
	        }
	        if (index && index === length) {
	          return object;
	        } else {
	          return void 0;
	        }
	      };
	
	      /**
	       * Gets the property value at `path` of `object`. If the resolved value is
	       * `undefined` the `defaultValue` is used in its place.
	       *
	       * @static
	       * @memberOf _
	       * @category Object
	       * @param {Object} object The object to query.
	       * @param {Array|string} path The path of the property to get.
	       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
	       * @returns {*} Returns the resolved value.
	       * @example
	       *
	       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	       *
	       * _.get(object, 'a[0].b.c');
	       * // => 3
	       *
	       * _.get(object, ['a', '0', 'b', 'c']);
	       * // => 3
	       *
	       * _.get(object, 'a.b.c', 'default');
	       * // => 'default'
	       */
	      get = function(object, path, defaultValue) {
	        var result;
	        result = object === null ? void 0 : baseGet(object, toPath(path), path + '');
	        if (result === void 0) {
	          return defaultValue;
	        } else {
	          return result;
	        }
	      };
	      _.get = get;
	    }
	
	    /*
	        Author Nick McCready
	        Intersection of Objects if the arrays have something in common each intersecting object will be returned
	        in an new array.
	     */
	    this.intersectionObjects = function(array1, array2, comparison) {
	      var res;
	      if (comparison == null) {
	        comparison = void 0;
	      }
	      res = _.map(array1, function(obj1) {
	        return _.find(array2, function(obj2) {
	          if (comparison != null) {
	            return comparison(obj1, obj2);
	          } else {
	            return _.isEqual(obj1, obj2);
	          }
	        });
	      });
	      return _.filter(res, function(o) {
	        return o != null;
	      });
	    };
	    this.containsObject = _.includeObject = function(obj, target, comparison) {
	      if (comparison == null) {
	        comparison = void 0;
	      }
	      if (obj === null) {
	        return false;
	      }
	      return _.some(obj, function(value) {
	        if (comparison != null) {
	          return comparison(value, target);
	        } else {
	          return _.isEqual(value, target);
	        }
	      });
	    };
	    this.differenceObjects = function(array1, array2, comparison) {
	      if (comparison == null) {
	        comparison = void 0;
	      }
	      return _.filter(array1, (function(_this) {
	        return function(value) {
	          return !_this.containsObject(array2, value, comparison);
	        };
	      })(this));
	    };
	    this.withoutObjects = this.differenceObjects;
	    this.indexOfObject = function(array, item, comparison, isSorted) {
	      var i, length;
	      if (array == null) {
	        return -1;
	      }
	      i = 0;
	      length = array.length;
	      if (isSorted) {
	        if (typeof isSorted === "number") {
	          i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
	        } else {
	          i = _.sortedIndex(array, item);
	          return (array[i] === item ? i : -1);
	        }
	      }
	      while (i < length) {
	        if (comparison != null) {
	          if (comparison(array[i], item)) {
	            return i;
	          }
	        } else {
	          if (_.isEqual(array[i], item)) {
	            return i;
	          }
	        }
	        i++;
	      }
	      return -1;
	    };
	    this.isNullOrUndefined = function(thing) {
	      return _.isNull(thing || _.isUndefined(thing));
	    };
	    return this;
	  });
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.extensions').factory('uiGmapString', function() {
	    return function(str) {
	      this.contains = function(value, fromIndex) {
	        return str.indexOf(value, fromIndex) !== -1;
	      };
	      return this;
	    };
	  });
	
	}).call(this);
	;
	/*global _:true,angular:true, */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmap_sync', [
	    function() {
	      return {
	        fakePromise: function() {
	          var _cb;
	          _cb = void 0;
	          return {
	            then: function(cb) {
	              return _cb = cb;
	            },
	            resolve: function() {
	              return _cb.apply(void 0, arguments);
	            }
	          };
	        }
	      };
	    }
	  ]).service('uiGmap_async', [
	    '$timeout', 'uiGmapPromise', 'uiGmapLogger', '$q', 'uiGmapDataStructures', 'uiGmapGmapUtil', function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
	      var ExposedPromise, PromiseQueueManager, SniffedPromise, _getIterateeValue, _ignoreFields, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, getArrayAndKeys, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
	      promiseTypes = uiGmapPromise.promiseTypes;
	      isInProgress = uiGmapPromise.isInProgress;
	      promiseStatus = uiGmapPromise.promiseStatus;
	      ExposedPromise = uiGmapPromise.ExposedPromise;
	      SniffedPromise = uiGmapPromise.SniffedPromise;
	      kickPromise = function(sniffedPromise, cancelCb) {
	        var promise;
	        promise = sniffedPromise.promise();
	        promise.promiseType = sniffedPromise.promiseType;
	        if (promise.$$state) {
	          $log.debug("promiseType: " + promise.promiseType + ", state: " + (promiseStatus(promise.$$state.status)));
	        }
	        promise.cancelCb = cancelCb;
	        return promise;
	      };
	      doSkippPromise = function(sniffedPromise, lastPromise) {
	        if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
	          $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
	          return true;
	        }
	        return false;
	      };
	      maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
	        var first;
	        if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"]) {
	          if ((lastPromise.cancelCb != null) && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
	            $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
	            lastPromise.cancelCb('cancel safe');
	            first = queue.peek();
	            if ((first != null) && isInProgress(first)) {
	              if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
	                $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
	                return first.cancelCb('cancel safe');
	              } else {
	                return $log.warn('first promise was not cancelable');
	              }
	            }
	          }
	        }
	      };
	
	      /*
	      From a High Level:
	        This is a SniffedPromiseQueueManager (looking to rename) where the queue is existingPiecesObj.existingPieces.
	        This is a function and should not be considered a class.
	        So it is run to manage the state (cancel, skip, link) as needed.
	      Purpose:
	      The whole point is to check if there is existing async work going on. If so we wait on it.
	      
	      arguments:
	      - existingPiecesObj =  Queue<Promises>
	      - sniffedPromise = object wrapper holding a function to a pending (function) promise (promise: fnPromise)
	      with its intended type.
	      - cancelCb = callback which accepts a string, this string is intended to be returned at the end of _async.each iterator
	      
	        Where the cancelCb passed msg is 'cancel safe' _async.each will drop out and fall through. Thus canceling the promise
	        gracefully without messing up state.
	      
	      Synopsis:
	      
	       - Promises have been broken down to 4 states create, update,delete (3 main) and init. (Helps boil down problems in ordering)
	        where (init) is special to indicate that it is one of the first or to allow a create promise to work beyond being after a delete
	      
	       - Every Promise that comes in is enqueued and linked to the last promise in the queue.
	      
	       - A promise can be skipped or canceled to save cycles.
	      
	      Saved Cycles:
	        - Skipped - This will only happen if async work comes in out of order. Where a pending create promise (un-executed) comes in
	          after a delete promise.
	        - Canceled - Where an incoming promise (un-executed promise) is of type delete and the any lastPromise is not a delete type.
	      
	      
	      NOTE:
	      - You should not muck with existingPieces as its state is dependent on this functional loop.
	      - PromiseQueueManager should not be thought of as a class that has a life expectancy (it has none). It's sole
	      purpose is to link, skip, and kill promises. It also manages the promise queue existingPieces.
	       */
	      PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
	        var lastPromise, newPromise;
	        if (!existingPiecesObj.existingPieces) {
	          existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
	          return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
	        } else {
	          lastPromise = _.last(existingPiecesObj.existingPieces._content);
	          if (doSkippPromise(sniffedPromise, lastPromise)) {
	            return;
	          }
	          maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
	          newPromise = ExposedPromise(lastPromise["finally"](function() {
	            return kickPromise(sniffedPromise, cancelCb);
	          }));
	          newPromise.cancelCb = cancelCb;
	          newPromise.promiseType = sniffedPromise.promiseType;
	          existingPiecesObj.existingPieces.enqueue(newPromise);
	          return lastPromise["finally"](function() {
	            return existingPiecesObj.existingPieces.dequeue();
	          });
	        }
	      };
	      managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
	        var cancelLogger;
	        if (msg == null) {
	          msg = '';
	        }
	        cancelLogger = function(msg) {
	          $log.debug(msg + ": " + msg);
	          if ((cancelCb != null) && _.isFunction(cancelCb)) {
	            return cancelCb(msg);
	          }
	        };
	        return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
	      };
	      defaultChunkSize = 80;
	      errorObject = {
	        value: null
	      };
	      tryCatch = function(fn, ctx, args) {
	        var e, error1;
	        try {
	          return fn.apply(ctx, args);
	        } catch (error1) {
	          e = error1;
	          errorObject.value = e;
	          return errorObject;
	        }
	      };
	      logTryCatch = function(fn, ctx, deferred, args) {
	        var msg, result;
	        result = tryCatch(fn, ctx, args);
	        if (result === errorObject) {
	          msg = "error within chunking iterator: " + errorObject.value;
	          $log.error(msg);
	          deferred.reject(msg);
	        }
	        if (result === 'cancel safe') {
	          return false;
	        }
	        return true;
	      };
	      _getIterateeValue = function(collection, array, index) {
	        var _isArray, valOrKey;
	        _isArray = collection === array;
	        valOrKey = array[index];
	        if (_isArray) {
	          return valOrKey;
	        }
	        return collection[valOrKey];
	      };
	      _ignoreFields = ['length', 'forEach', 'map'];
	      getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
	        var array, propName, val;
	        if (angular.isArray(collection)) {
	          array = collection;
	        } else {
	          if (keys) {
	            array = keys;
	          } else {
	            array = [];
	            for (propName in collection) {
	              val = collection[propName];
	              if (collection.hasOwnProperty(propName) && !_.includes(_ignoreFields, propName)) {
	                array.push(propName);
	              }
	            }
	          }
	        }
	        if (cb == null) {
	          cb = bailOutCb;
	        }
	        if (angular.isArray(array) && !(array != null ? array.length : void 0)) {
	          if (cb !== bailOutCb) {
	            return bailOutCb();
	          }
	        }
	        return cb(array, keys);
	      };
	
	      /*
	        Author: Nicholas McCready & jfriend00
	        _async handles things asynchronous-like :), to allow the UI to be free'd to do other things
	        Code taken from http://stackoverflow.com/questions/10344498/best-way-to-iterate-over-an-array-without-blocking-the-ui
	      
	        The design of any functionality of _async is to be like lodash/underscore and replicate it but call things
	        asynchronously underneath. Each should be sufficient for most things to be derived from.
	      
	        Optional Asynchronous Chunking via promises.
	       */
	      doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
	        return getArrayAndKeys(collection, _keys, function(array, keys) {
	          var cnt, i, keepGoing, val;
	          if (chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length) {
	            cnt = chunkSizeOrDontChunk;
	          } else {
	            cnt = array.length;
	          }
	          i = index;
	          keepGoing = true;
	          while (keepGoing && cnt-- && i < (array ? array.length : i + 1)) {
	            val = _getIterateeValue(collection, array, i);
	            keepGoing = angular.isFunction(val) ? true : logTryCatch(chunkCb, void 0, overallD, [val, i]);
	            ++i;
	          }
	          if (array) {
	            if (keepGoing && i < array.length) {
	              index = i;
	              if (chunkSizeOrDontChunk) {
	                if ((pauseCb != null) && _.isFunction(pauseCb)) {
	                  logTryCatch(pauseCb, void 0, overallD, []);
	                }
	                return $timeout(function() {
	                  return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
	                }, pauseMilli, false);
	              }
	            } else {
	              return overallD.resolve();
	            }
	          }
	        });
	      };
	      each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
	        var error, overallD, ret;
	        if (chunkSizeOrDontChunk == null) {
	          chunkSizeOrDontChunk = defaultChunkSize;
	        }
	        if (index == null) {
	          index = 0;
	        }
	        if (pauseMilli == null) {
	          pauseMilli = 1;
	        }
	        ret = void 0;
	        overallD = uiGmapPromise.defer();
	        ret = overallD.promise;
	        if (!pauseMilli) {
	          error = 'pause (delay) must be set from _async!';
	          $log.error(error);
	          overallD.reject(error);
	          return ret;
	        }
	        return getArrayAndKeys(collection, _keys, function() {
	          overallD.resolve();
	          return ret;
	        }, function(array, keys) {
	          doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
	          return ret;
	        });
	      };
	      map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
	        var results;
	        results = [];
	        return getArrayAndKeys(collection, _keys, function() {
	          return uiGmapPromise.resolve(results);
	        }, function(array, keys) {
	          return each(collection, function(o) {
	            return results.push(iterator(o));
	          }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
	            return results;
	          });
	        });
	      };
	      return {
	        each: each,
	        map: map,
	        managePromiseQueue: managePromiseQueue,
	        promiseLock: managePromiseQueue,
	        defaultChunkSize: defaultChunkSize,
	        getArrayAndKeys: getArrayAndKeys,
	        chunkSizeFrom: function(fromSize, ret) {
	          if (ret == null) {
	            ret = void 0;
	          }
	          if (_.isNumber(fromSize)) {
	            ret = fromSize;
	          }
	          if (uiGmapGmapUtil.isFalse(fromSize) || fromSize === false) {
	            ret = false;
	          }
	          return ret;
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	  angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapBaseObject', function() {
	    var BaseObject, baseObjectKeywords;
	    baseObjectKeywords = ['extended', 'included'];
	    BaseObject = (function() {
	      function BaseObject() {}
	
	      BaseObject.extend = function(obj) {
	        var key, ref, value;
	        for (key in obj) {
	          value = obj[key];
	          if (indexOf.call(baseObjectKeywords, key) < 0) {
	            this[key] = value;
	          }
	        }
	        if ((ref = obj.extended) != null) {
	          ref.apply(this);
	        }
	        return this;
	      };
	
	      BaseObject.include = function(obj) {
	        var key, ref, value;
	        for (key in obj) {
	          value = obj[key];
	          if (indexOf.call(baseObjectKeywords, key) < 0) {
	            this.prototype[key] = value;
	          }
	        }
	        if ((ref = obj.included) != null) {
	          ref.apply(this);
	        }
	        return this;
	      };
	
	      return BaseObject;
	
	    })();
	    return BaseObject;
	  });
	
	}).call(this);
	;
	/*
	    Useful function callbacks that should be defined at later time.
	    Mainly to be used for specs to verify creation / linking.
	
	    This is to lead a common design in notifying child stuff.
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapChildEvents', function() {
	    return {
	      onChildCreation: function(child) {}
	    };
	  });
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapCtrlHandle', [
	    '$q', function($q) {
	      var CtrlHandle;
	      return CtrlHandle = {
	        handle: function($scope, $element) {
	          $scope.$on('$destroy', function() {
	            return CtrlHandle.handle($scope);
	          });
	          $scope.deferred = $q.defer();
	          return {
	            getScope: function() {
	              return $scope;
	            }
	          };
	        },
	        mapPromise: function(scope, ctrl) {
	          var mapScope;
	          mapScope = ctrl.getScope();
	          mapScope.deferred.promise.then(function(map) {
	            return scope.map = map;
	          });
	          return mapScope.deferred.promise;
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", [
	    "uiGmapLogger", function($log) {
	      var _getEventsObj, _hasEvents;
	      _hasEvents = function(obj) {
	        return angular.isDefined(obj.events) && (obj.events != null) && angular.isObject(obj.events);
	      };
	      _getEventsObj = function(scope, model) {
	        if (_hasEvents(scope)) {
	          return scope;
	        }
	        if (_hasEvents(model)) {
	          return model;
	        }
	      };
	      return {
	        setEvents: function(gObject, scope, model, ignores) {
	          var eventObj;
	          eventObj = _getEventsObj(scope, model);
	          if (eventObj != null) {
	            return _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
	              var doIgnore;
	              if (ignores) {
	                doIgnore = _(ignores).includes(eventName);
	              }
	              if (eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore) {
	                return google.maps.event.addListener(gObject, eventName, function() {
	                  if (!scope.$evalAsync) {
	                    scope.$evalAsync = function() {};
	                  }
	                  return scope.$evalAsync(eventHandler.apply(scope, [gObject, eventName, model, arguments]));
	                });
	              }
	            }));
	          }
	        },
	        removeEvents: function(listeners) {
	          var key, l;
	          if (!listeners) {
	            return;
	          }
	          for (key in listeners) {
	            l = listeners[key];
	            if (l && listeners.hasOwnProperty(key)) {
	              google.maps.event.removeListener(l);
	            }
	          }
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapFitHelper', [
	    'uiGmapLogger', '$timeout', function($log, $timeout) {
	      return {
	        fit: function(markersOrPoints, gMap) {
	          var bounds, everSet, key, markerOrPoint, point;
	          if (gMap && (markersOrPoints != null ? markersOrPoints.length : void 0)) {
	            bounds = new google.maps.LatLngBounds();
	            everSet = false;
	            for (key in markersOrPoints) {
	              markerOrPoint = markersOrPoints[key];
	              if (markerOrPoint) {
	                if (!everSet) {
	                  everSet = true;
	                }
	                point = _.isFunction(markerOrPoint.getPosition) ? markerOrPoint.getPosition() : markerOrPoint;
	              }
	              bounds.extend(point);
	            }
	            if (everSet) {
	              return $timeout(function() {
	                return gMap.fitBounds(bounds);
	              });
	            }
	          }
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true, angular:true, google:true */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapGmapUtil', [
	    'uiGmapLogger', '$compile', function(Logger, $compile) {
	      var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
	      _isTruthy = function(value, bool, optionsArray) {
	        return value === bool || optionsArray.indexOf(value) !== -1;
	      };
	      _isFalse = function(value) {
	        return _isTruthy(value, false, ['false', 'FALSE', 0, 'n', 'N', 'no', 'NO']);
	      };
	      getLatitude = function(value) {
	        if (Array.isArray(value) && value.length === 2) {
	          return value[1];
	        } else if (angular.isDefined(value.type) && value.type === 'Point') {
	          return value.coordinates[1];
	        } else {
	          return value.latitude;
	        }
	      };
	      getLongitude = function(value) {
	        if (Array.isArray(value) && value.length === 2) {
	          return value[0];
	        } else if (angular.isDefined(value.type) && value.type === 'Point') {
	          return value.coordinates[0];
	        } else {
	          return value.longitude;
	        }
	      };
	      getCoords = function(value) {
	        if (!value) {
	          return;
	        }
	        if (value instanceof google.maps.LatLng) {
	          return value;
	        } else if (Array.isArray(value) && value.length === 2) {
	          return new google.maps.LatLng(value[1], value[0]);
	        } else if (angular.isDefined(value.type) && value.type === 'Point') {
	          return new google.maps.LatLng(value.coordinates[1], value.coordinates[0]);
	        } else {
	          return new google.maps.LatLng(value.latitude, value.longitude);
	        }
	      };
	      validateCoords = function(coords) {
	        if (angular.isUndefined(coords)) {
	          return false;
	        }
	        if (_.isArray(coords)) {
	          if (coords.length === 2) {
	            return true;
	          }
	        } else if ((coords != null) && (coords != null ? coords.type : void 0)) {
	          if (coords.type === 'Point' && _.isArray(coords.coordinates) && coords.coordinates.length === 2) {
	            return true;
	          }
	        }
	        if (coords && angular.isDefined((coords != null ? coords.latitude : void 0) && angular.isDefined(coords != null ? coords.longitude : void 0))) {
	          return true;
	        }
	        return false;
	      };
	      return {
	        setCoordsFromEvent: function(prevValue, newLatLon) {
	          if (!prevValue) {
	            return;
	          }
	          if (Array.isArray(prevValue) && prevValue.length === 2) {
	            prevValue[1] = newLatLon.lat();
	            prevValue[0] = newLatLon.lng();
	          } else if (angular.isDefined(prevValue.type) && prevValue.type === 'Point') {
	            prevValue.coordinates[1] = newLatLon.lat();
	            prevValue.coordinates[0] = newLatLon.lng();
	          } else {
	            prevValue.latitude = newLatLon.lat();
	            prevValue.longitude = newLatLon.lng();
	          }
	          return prevValue;
	        },
	        getLabelPositionPoint: function(anchor) {
	          var xPos, yPos;
	          if (anchor === void 0) {
	            return void 0;
	          }
	          anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
	          xPos = parseFloat(anchor[1]);
	          yPos = parseFloat(anchor[2]);
	          if ((xPos != null) && (yPos != null)) {
	            return new google.maps.Point(xPos, yPos);
	          }
	        },
	        createWindowOptions: function(gMarker, scope, content, defaults) {
	          var options;
	          if ((content != null) && (defaults != null) && ($compile != null)) {
	            options = angular.extend({}, defaults, {
	              content: this.buildContent(scope, defaults, content),
	              position: defaults.position != null ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
	            });
	            if ((gMarker != null) && ((options != null ? options.pixelOffset : void 0) == null)) {
	              if (options.boxClass == null) {
	
	              } else {
	                options.pixelOffset = {
	                  height: 0,
	                  width: -2
	                };
	              }
	            }
	            return options;
	          } else {
	            if (!defaults) {
	              Logger.error('infoWindow defaults not defined');
	              if (!content) {
	                return Logger.error('infoWindow content not defined');
	              }
	            } else {
	              return defaults;
	            }
	          }
	        },
	        buildContent: function(scope, defaults, content) {
	          var parsed, ret;
	          if (defaults.content != null) {
	            ret = defaults.content;
	          } else {
	            if ($compile != null) {
	              content = content.replace(/^\s+|\s+$/g, '');
	              parsed = content === '' ? '' : $compile(content)(scope);
	              if (parsed.length > 0) {
	                ret = parsed[0];
	              }
	            } else {
	              ret = content;
	            }
	          }
	          return ret;
	        },
	        defaultDelay: 50,
	        isTrue: function(value) {
	          return _isTruthy(value, true, ['true', 'TRUE', 1, 'y', 'Y', 'yes', 'YES']);
	        },
	        isFalse: _isFalse,
	        isFalsy: function(value) {
	          return _isTruthy(value, false, [void 0, null]) || _isFalse(value);
	        },
	        getCoords: getCoords,
	        validateCoords: validateCoords,
	        equalCoords: function(coord1, coord2) {
	          return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
	        },
	        validatePath: function(path) {
	          var array, i, polygon, trackMaxVertices;
	          i = 0;
	          if (angular.isUndefined(path.type)) {
	            if (!Array.isArray(path) || path.length < 2) {
	              return false;
	            }
	            while (i < path.length) {
	              if (!((angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) || (typeof path[i].lat === 'function' && typeof path[i].lng === 'function'))) {
	                return false;
	              }
	              i++;
	            }
	            return true;
	          } else {
	            if (angular.isUndefined(path.coordinates)) {
	              return false;
	            }
	            if (path.type === 'Polygon') {
	              if (path.coordinates[0].length < 4) {
	                return false;
	              }
	              array = path.coordinates[0];
	            } else if (path.type === 'MultiPolygon') {
	              trackMaxVertices = {
	                max: 0,
	                index: 0
	              };
	              _.forEach(path.coordinates, function(polygon, index) {
	                if (polygon[0].length > this.max) {
	                  this.max = polygon[0].length;
	                  return this.index = index;
	                }
	              }, trackMaxVertices);
	              polygon = path.coordinates[trackMaxVertices.index];
	              array = polygon[0];
	              if (array.length < 4) {
	                return false;
	              }
	            } else if (path.type === 'LineString') {
	              if (path.coordinates.length < 2) {
	                return false;
	              }
	              array = path.coordinates;
	            } else {
	              return false;
	            }
	            while (i < array.length) {
	              if (array[i].length !== 2) {
	                return false;
	              }
	              i++;
	            }
	            return true;
	          }
	        },
	        convertPathPoints: function(path) {
	          var array, i, latlng, result, trackMaxVertices;
	          i = 0;
	          result = new google.maps.MVCArray();
	          if (angular.isUndefined(path.type)) {
	            while (i < path.length) {
	              latlng;
	              if (angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude)) {
	                latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude);
	              } else if (typeof path[i].lat === 'function' && typeof path[i].lng === 'function') {
	                latlng = path[i];
	              }
	              result.push(latlng);
	              i++;
	            }
	          } else {
	            array;
	            if (path.type === 'Polygon') {
	              array = path.coordinates[0];
	            } else if (path.type === 'MultiPolygon') {
	              trackMaxVertices = {
	                max: 0,
	                index: 0
	              };
	              _.forEach(path.coordinates, function(polygon, index) {
	                if (polygon[0].length > this.max) {
	                  this.max = polygon[0].length;
	                  return this.index = index;
	                }
	              }, trackMaxVertices);
	              array = path.coordinates[trackMaxVertices.index][0];
	            } else if (path.type === 'LineString') {
	              array = path.coordinates;
	            }
	            while (i < array.length) {
	              result.push(new google.maps.LatLng(array[i][1], array[i][0]));
	              i++;
	            }
	          }
	          return result;
	        },
	        getPath: function(object, key) {
	          var obj;
	          if ((key == null) || !_.isString(key)) {
	            return key;
	          }
	          obj = object;
	          _.each(key.split('.'), function(value) {
	            if (obj) {
	              return obj = obj[value];
	            }
	          });
	          return obj;
	        },
	        validateBoundPoints: function(bounds) {
	          if (angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude)) {
	            return false;
	          }
	          return true;
	        },
	        convertBoundPoints: function(bounds) {
	          var result;
	          result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
	          return result;
	        },
	        fitMapBounds: function(map, bounds) {
	          return map.fitBounds(bounds);
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapIsReady', [
	    '$q', '$timeout', function($q, $timeout) {
	      var _checkIfReady, _ctr, _promises, _proms;
	      _ctr = 0;
	      _proms = [];
	      _promises = function() {
	        return $q.all(_proms);
	      };
	      _checkIfReady = function(deferred, expectedInstances, retriesLeft) {
	        return $timeout(function() {
	          if (retriesLeft <= 0) {
	            deferred.reject('Your maps are not found we have checked the maximum amount of times. :)');
	            return;
	          }
	          if (_ctr !== expectedInstances) {
	            _checkIfReady(deferred, expectedInstances, retriesLeft - 1);
	          } else {
	            deferred.resolve(_promises());
	          }
	        }, 100);
	      };
	      return {
	        spawn: function() {
	          var d;
	          d = $q.defer();
	          _proms.push(d.promise);
	          _ctr += 1;
	          return {
	            instance: _ctr,
	            deferred: d
	          };
	        },
	        promises: _promises,
	        instances: function() {
	          return _ctr;
	        },
	        promise: function(expectedInstances, numRetries) {
	          var d;
	          if (expectedInstances == null) {
	            expectedInstances = 1;
	          }
	          if (numRetries == null) {
	            numRetries = 50;
	          }
	          d = $q.defer();
	          _checkIfReady(d, expectedInstances, numRetries);
	          return d.promise;
	        },
	        reset: function() {
	          _ctr = 0;
	          _proms.length = 0;
	        },
	        decrement: function() {
	          if (_ctr > 0) {
	            _ctr -= 1;
	          }
	          if (_proms.length) {
	            _proms.length -= 1;
	          }
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", [
	    "uiGmapBaseObject", function(BaseObject) {
	      var Linked;
	      Linked = (function(superClass) {
	        extend(Linked, superClass);
	
	        function Linked(scope, element, attrs, ctrls) {
	          this.scope = scope;
	          this.element = element;
	          this.attrs = attrs;
	          this.ctrls = ctrls;
	        }
	
	        return Linked;
	
	      })(BaseObject);
	      return Linked;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapLogger', [
	    'nemSimpleLogger', function(nemSimpleLogger) {
	      return nemSimpleLogger.spawn();
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true, angular:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelKey', [
	    'uiGmapBaseObject', 'uiGmapGmapUtil', function(BaseObject, GmapUtil) {
	      return (function(superClass) {
	        extend(_Class, superClass);
	
	        function _Class(scope1, _interface) {
	          this.scope = scope1;
	          this["interface"] = _interface != null ? _interface : {
	            scopeKeys: []
	          };
	          this.modelsLength = bind(this.modelsLength, this);
	          this.updateChild = bind(this.updateChild, this);
	          this.destroy = bind(this.destroy, this);
	          this.setChildScope = bind(this.setChildScope, this);
	          this.getChanges = bind(this.getChanges, this);
	          this.getProp = bind(this.getProp, this);
	          this.setIdKey = bind(this.setIdKey, this);
	          this.modelKeyComparison = bind(this.modelKeyComparison, this);
	          _Class.__super__.constructor.call(this);
	          this.defaultIdKey = 'id';
	          this.idKey = void 0;
	        }
	
	        _Class.prototype.evalModelHandle = function(model, modelKey) {
	          if ((model == null) || (modelKey == null)) {
	            return;
	          }
	          if (modelKey === 'self') {
	            return model;
	          } else {
	            if (_.isFunction(modelKey)) {
	              modelKey = modelKey();
	            }
	            return GmapUtil.getPath(model, modelKey);
	          }
	        };
	
	        _Class.prototype.modelKeyComparison = function(model1, model2) {
	          var coord1, coord2, hasCoords, isEqual, scope, without;
	          hasCoords = this["interface"].scopeKeys.indexOf('coords') >= 0;
	          if (hasCoords && (this.scope.coords != null) || !hasCoords) {
	            scope = this.scope;
	          }
	          if (scope == null) {
	            throw 'No scope set!';
	          }
	          if (hasCoords) {
	            coord1 = this.scopeOrModelVal('coords', scope, model1);
	            coord2 = this.scopeOrModelVal('coords', scope, model2);
	            isEqual = GmapUtil.equalCoords(coord1, coord2);
	            if (!isEqual) {
	              return isEqual;
	            }
	          }
	          without = _.without(this["interface"].scopeKeys, 'coords');
	          isEqual = _.every(without, (function(_this) {
	            return function(k) {
	              var m1, m2;
	              m1 = _this.scopeOrModelVal(scope[k], scope, model1);
	              m2 = _this.scopeOrModelVal(scope[k], scope, model2);
	              if (scope.deepComparison) {
	                return _.isEqual(m1, m2);
	              } else {
	                return m1 === m2;
	              }
	            };
	          })(this));
	          return isEqual;
	        };
	
	        _Class.prototype.setIdKey = function(scope) {
	          return this.idKey = scope.idKey != null ? scope.idKey : this.defaultIdKey;
	        };
	
	        _Class.prototype.setVal = function(model, key, newValue) {
	          this.modelOrKey(model, key = newValue);
	          return model;
	        };
	
	        _Class.prototype.modelOrKey = function(model, key) {
	          if (key == null) {
	            return;
	          }
	          if (key !== 'self') {
	            return GmapUtil.getPath(model, key);
	          }
	          return model;
	        };
	
	        _Class.prototype.getProp = function(propName, scope, model) {
	          return this.scopeOrModelVal(propName, scope, model);
	        };
	
	
	        /*
	        For the cases were watching a large object we only want to know the list of props
	        that actually changed.
	        Also we want to limit the amount of props we analyze to whitelisted props that are
	        actually tracked by scope. (should make things faster with whitelisted)
	         */
	
	        _Class.prototype.getChanges = function(now, prev, whitelistedProps) {
	          var c, changes, prop;
	          if (whitelistedProps) {
	            prev = _.pick(prev, whitelistedProps);
	            now = _.pick(now, whitelistedProps);
	          }
	          changes = {};
	          prop = {};
	          c = {};
	          for (prop in now) {
	            if (!prev || prev[prop] !== now[prop]) {
	              if (_.isArray(now[prop])) {
	                changes[prop] = now[prop];
	              } else if (_.isObject(now[prop])) {
	                c = this.getChanges(now[prop], (prev ? prev[prop] : null));
	                if (!_.isEmpty(c)) {
	                  changes[prop] = c;
	                }
	              } else {
	                changes[prop] = now[prop];
	              }
	            }
	          }
	          return changes;
	        };
	
	        _Class.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
	          var maybeWrap, modelKey, modelProp, scopeProp;
	          if (doWrap == null) {
	            doWrap = false;
	          }
	          maybeWrap = function(isScope, ret, doWrap) {
	            if (doWrap == null) {
	              doWrap = false;
	            }
	            if (doWrap) {
	              return {
	                isScope: isScope,
	                value: ret
	              };
	            }
	            return ret;
	          };
	          scopeProp = _.get(scope, key);
	          if (_.isFunction(scopeProp)) {
	            return maybeWrap(true, scopeProp(model), doWrap);
	          }
	          if (_.isObject(scopeProp)) {
	            return maybeWrap(true, scopeProp, doWrap);
	          }
	          if (!_.isString(scopeProp)) {
	            return maybeWrap(true, scopeProp, doWrap);
	          }
	          modelKey = scopeProp;
	          if (!modelKey) {
	            modelProp = _.get(model, key);
	          } else {
	            modelProp = modelKey === 'self' ? model : _.get(model, modelKey);
	          }
	          if (_.isFunction(modelProp)) {
	            return maybeWrap(false, modelProp(), doWrap);
	          }
	          return maybeWrap(false, modelProp, doWrap);
	        };
	
	        _Class.prototype.setChildScope = function(keys, childScope, model) {
	          var isScopeObj, key, name, newValue;
	          for (key in keys) {
	            name = keys[key];
	            isScopeObj = this.scopeOrModelVal(name, childScope, model, true);
	            if ((isScopeObj != null ? isScopeObj.value : void 0) != null) {
	              newValue = isScopeObj.value;
	              if (newValue !== childScope[name]) {
	                childScope[name] = newValue;
	              }
	            }
	          }
	          return childScope.model = model;
	        };
	
	        _Class.prototype.onDestroy = function(scope) {};
	
	        _Class.prototype.destroy = function(manualOverride) {
	          var ref;
	          if (manualOverride == null) {
	            manualOverride = false;
	          }
	          if ((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) {
	            return this.scope.$destroy();
	          } else {
	            return this.clean();
	          }
	        };
	
	        _Class.prototype.updateChild = function(child, model) {
	          if (model[this.idKey] == null) {
	            this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
	            return;
	          }
	          return child.updateModel(model);
	        };
	
	        _Class.prototype.modelsLength = function(arrayOrObjModels) {
	          var len, toCheck;
	          if (arrayOrObjModels == null) {
	            arrayOrObjModels = void 0;
	          }
	          len = 0;
	          toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
	          if (toCheck == null) {
	            return len;
	          }
	          if (angular.isArray(toCheck) || (toCheck.length != null)) {
	            len = toCheck.length;
	          } else {
	            len = Object.keys(toCheck).length;
	          }
	          return len;
	        };
	
	        return _Class;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').factory('uiGmapModelsWatcher', [
	    'uiGmapLogger', 'uiGmap_async', '$q', 'uiGmapPromise', function(Logger, _async, $q, uiGmapPromise) {
	      return {
	        didQueueInitPromise: function(existingPiecesObj, scope) {
	          if (scope.models.length === 0) {
	            _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, (function() {
	              return uiGmapPromise.resolve();
	            }));
	            return true;
	          }
	          return false;
	        },
	        figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
	          var adds, children, mappedScopeModelIds, removals, updates;
	          adds = [];
	          mappedScopeModelIds = {};
	          removals = [];
	          updates = [];
	          scope.models.forEach(function(m) {
	            var child;
	            if (m[idKey] != null) {
	              mappedScopeModelIds[m[idKey]] = {};
	              if (childObjects.get(m[idKey]) == null) {
	                return adds.push(m);
	              } else {
	                child = childObjects.get(m[idKey]);
	                if (!comparison(m, child.clonedModel, scope)) {
	                  return updates.push({
	                    model: m,
	                    child: child
	                  });
	                }
	              }
	            } else {
	              return Logger.error(' id missing for model #{m.toString()},\ncan not use do comparison/insertion');
	            }
	          });
	          children = childObjects.values();
	          children.forEach(function(c) {
	            var id;
	            if (c == null) {
	              Logger.error('child undefined in ModelsWatcher.');
	              return;
	            }
	            if (c.model == null) {
	              Logger.error('child.model undefined in ModelsWatcher.');
	              return;
	            }
	            id = c.model[idKey];
	            if (mappedScopeModelIds[id] == null) {
	              return removals.push(c);
	            }
	          });
	          return {
	            adds: adds,
	            removals: removals,
	            updates: updates
	          };
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.utils').service('uiGmapPromise', [
	    '$q', '$timeout', 'uiGmapLogger', function($q, $timeout, $log) {
	      var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
	      promiseTypes = {
	        create: 'create',
	        update: 'update',
	        "delete": 'delete',
	        init: 'init'
	      };
	      promiseStatuses = {
	        IN_PROGRESS: 0,
	        RESOLVED: 1,
	        REJECTED: 2
	      };
	      strPromiseStatuses = (function() {
	        var obj;
	        obj = {};
	        obj["" + promiseStatuses.IN_PROGRESS] = 'in-progress';
	        obj["" + promiseStatuses.RESOLVED] = 'resolved';
	        obj["" + promiseStatuses.REJECTED] = 'rejected';
	        return obj;
	      })();
	      isInProgress = function(promise) {
	        if (promise.$$state) {
	          return promise.$$state.status === promiseStatuses.IN_PROGRESS;
	        }
	        if (!promise.hasOwnProperty("$$v")) {
	          return true;
	        }
	      };
	      isResolved = function(promise) {
	        if (promise.$$state) {
	          return promise.$$state.status === promiseStatuses.RESOLVED;
	        }
	        if (promise.hasOwnProperty("$$v")) {
	          return true;
	        }
	      };
	      promiseStatus = function(status) {
	        return strPromiseStatuses[status] || 'done w error';
	      };
	      ExposedPromise = function(promise) {
	        var cancelDeferred, combined, wrapped;
	        cancelDeferred = $q.defer();
	        combined = $q.all([promise, cancelDeferred.promise]);
	        wrapped = $q.defer();
	        promise.then(cancelDeferred.resolve, (function() {}), function(notify) {
	          cancelDeferred.notify(notify);
	          return wrapped.notify(notify);
	        });
	        combined.then(function(successes) {
	          return wrapped.resolve(successes[0] || successes[1]);
	        }, function(error) {
	          return wrapped.reject(error);
	        });
	        wrapped.promise.cancel = function(reason) {
	          if (reason == null) {
	            reason = 'canceled';
	          }
	          return cancelDeferred.reject(reason);
	        };
	        wrapped.promise.notify = function(msg) {
	          if (msg == null) {
	            msg = 'cancel safe';
	          }
	          wrapped.notify(msg);
	          if (promise.hasOwnProperty('notify')) {
	            return promise.notify(msg);
	          }
	        };
	        if (promise.promiseType != null) {
	          wrapped.promise.promiseType = promise.promiseType;
	        }
	        return wrapped.promise;
	      };
	      SniffedPromise = function(fnPromise, promiseType) {
	        return {
	          promise: fnPromise,
	          promiseType: promiseType
	        };
	      };
	      defer = function() {
	        return $q.defer();
	      };
	      resolve = function() {
	        var d;
	        d = $q.defer();
	        d.resolve.apply(void 0, arguments);
	        return d.promise;
	      };
	      promise = function(fnToWrap) {
	        var d;
	        if (!_.isFunction(fnToWrap)) {
	          $log.error("uiGmapPromise.promise() only accepts functions");
	          return;
	        }
	        d = $q.defer();
	        $timeout(function() {
	          var result;
	          result = fnToWrap();
	          return d.resolve(result);
	        });
	        return d.promise;
	      };
	      return {
	        defer: defer,
	        promise: promise,
	        resolve: resolve,
	        promiseTypes: promiseTypes,
	        isInProgress: isInProgress,
	        isResolved: isResolved,
	        promiseStatus: promiseStatus,
	        ExposedPromise: ExposedPromise,
	        SniffedPromise: SniffedPromise
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
	
	    /*
	      Simple Object Map with a length property to make it easy to track length/size
	     */
	    var PropMap;
	    return PropMap = (function() {
	      function PropMap() {
	        this.removeAll = bind(this.removeAll, this);
	        this.slice = bind(this.slice, this);
	        this.push = bind(this.push, this);
	        this.keys = bind(this.keys, this);
	        this.values = bind(this.values, this);
	        this.remove = bind(this.remove, this);
	        this.put = bind(this.put, this);
	        this.stateChanged = bind(this.stateChanged, this);
	        this.get = bind(this.get, this);
	        this.length = 0;
	        this.dict = {};
	        this.didValsStateChange = false;
	        this.didKeysStateChange = false;
	        this.allVals = [];
	        this.allKeys = [];
	      }
	
	      PropMap.prototype.get = function(key) {
	        return this.dict[key];
	      };
	
	      PropMap.prototype.stateChanged = function() {
	        this.didValsStateChange = true;
	        return this.didKeysStateChange = true;
	      };
	
	      PropMap.prototype.put = function(key, value) {
	        if (this.get(key) == null) {
	          this.length++;
	        }
	        this.stateChanged();
	        return this.dict[key] = value;
	      };
	
	      PropMap.prototype.remove = function(key, isSafe) {
	        var value;
	        if (isSafe == null) {
	          isSafe = false;
	        }
	        if (isSafe && !this.get(key)) {
	          return void 0;
	        }
	        value = this.dict[key];
	        delete this.dict[key];
	        this.length--;
	        this.stateChanged();
	        return value;
	      };
	
	      PropMap.prototype.valuesOrKeys = function(str) {
	        var keys, vals;
	        if (str == null) {
	          str = 'Keys';
	        }
	        if (!this["did" + str + "StateChange"]) {
	          return this['all' + str];
	        }
	        vals = [];
	        keys = [];
	        _.each(this.dict, function(v, k) {
	          vals.push(v);
	          return keys.push(k);
	        });
	        this.didKeysStateChange = false;
	        this.didValsStateChange = false;
	        this.allVals = vals;
	        this.allKeys = keys;
	        return this['all' + str];
	      };
	
	      PropMap.prototype.values = function() {
	        return this.valuesOrKeys('Vals');
	      };
	
	      PropMap.prototype.keys = function() {
	        return this.valuesOrKeys();
	      };
	
	      PropMap.prototype.push = function(obj, key) {
	        if (key == null) {
	          key = "key";
	        }
	        return this.put(obj[key], obj);
	      };
	
	      PropMap.prototype.slice = function() {
	        return this.keys().map((function(_this) {
	          return function(k) {
	            return _this.remove(k);
	          };
	        })(this));
	      };
	
	      PropMap.prototype.removeAll = function() {
	        return this.slice();
	      };
	
	      PropMap.prototype.each = function(cb) {
	        return _.each(this.dict, function(v, k) {
	          return cb(v);
	        });
	      };
	
	      PropMap.prototype.map = function(cb) {
	        return _.map(this.dict, function(v, k) {
	          return cb(v);
	        });
	      };
	
	      return PropMap;
	
	    })();
	  });
	
	}).call(this);
	;
	/*globals angular,_ */
	
	(function() {
	  angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", [
	    "uiGmapLogger", function(Logger) {
	      var PropertyAction;
	      PropertyAction = function(setterFn) {
	        this.setIfChange = function(callingKey) {
	          return function(newVal, oldVal) {
	            if (!_.isEqual(oldVal, newVal)) {
	              return setterFn(callingKey, newVal);
	            }
	          };
	        };
	        this.sic = this.setIfChange;
	        return this;
	      };
	      return PropertyAction;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapClustererMarkerManager', [
	    'uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapEventsHelper', function($log, FitHelper, PropMap, EventsHelper) {
	      var ClustererMarkerManager;
	      ClustererMarkerManager = (function() {
	        ClustererMarkerManager.type = 'ClustererMarkerManager';
	
	        function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
	          if (opt_markers == null) {
	            opt_markers = {};
	          }
	          this.opt_options = opt_options != null ? opt_options : {};
	          this.opt_events = opt_events;
	          this.checkSync = bind(this.checkSync, this);
	          this.getGMarkers = bind(this.getGMarkers, this);
	          this.fit = bind(this.fit, this);
	          this.destroy = bind(this.destroy, this);
	          this.attachEvents = bind(this.attachEvents, this);
	          this.clear = bind(this.clear, this);
	          this.draw = bind(this.draw, this);
	          this.removeMany = bind(this.removeMany, this);
	          this.remove = bind(this.remove, this);
	          this.addMany = bind(this.addMany, this);
	          this.update = bind(this.update, this);
	          this.add = bind(this.add, this);
	          this.type = ClustererMarkerManager.type;
	          this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
	          this.propMapGMarkers = new PropMap();
	          this.attachEvents(this.opt_events, 'opt_events');
	          this.clusterer.setIgnoreHidden(true);
	          this.noDrawOnSingleAddRemoves = true;
	          $log.info(this);
	        }
	
	        ClustererMarkerManager.prototype.checkKey = function(gMarker) {
	          var msg;
	          if (gMarker.key == null) {
	            msg = 'gMarker.key undefined and it is REQUIRED!!';
	            return $log.error(msg);
	          }
	        };
	
	        ClustererMarkerManager.prototype.add = function(gMarker) {
	          this.checkKey(gMarker);
	          this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
	          this.propMapGMarkers.put(gMarker.key, gMarker);
	          return this.checkSync();
	        };
	
	        ClustererMarkerManager.prototype.update = function(gMarker) {
	          this.remove(gMarker);
	          return this.add(gMarker);
	        };
	
	        ClustererMarkerManager.prototype.addMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(gMarker) {
	              return _this.add(gMarker);
	            };
	          })(this));
	        };
	
	        ClustererMarkerManager.prototype.remove = function(gMarker) {
	          var exists;
	          this.checkKey(gMarker);
	          exists = this.propMapGMarkers.get(gMarker.key);
	          if (exists) {
	            this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
	            this.propMapGMarkers.remove(gMarker.key);
	          }
	          return this.checkSync();
	        };
	
	        ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(gMarker) {
	              return _this.remove(gMarker);
	            };
	          })(this));
	        };
	
	        ClustererMarkerManager.prototype.draw = function() {
	          return this.clusterer.repaint();
	        };
	
	        ClustererMarkerManager.prototype.clear = function() {
	          this.removeMany(this.getGMarkers());
	          return this.clusterer.repaint();
	        };
	
	        ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
	          var eventHandler, eventName, results;
	          this.listeners = [];
	          if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
	            results = [];
	            for (eventName in options) {
	              eventHandler = options[eventName];
	              if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
	                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
	                results.push(this.listeners.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName])));
	              } else {
	                results.push(void 0);
	              }
	            }
	            return results;
	          }
	        };
	
	        ClustererMarkerManager.prototype.clearEvents = function() {
	          EventsHelper.removeEvents(this.listeners);
	          return this.listeners = [];
	        };
	
	        ClustererMarkerManager.prototype.destroy = function() {
	          this.clearEvents();
	          return this.clear();
	        };
	
	        ClustererMarkerManager.prototype.fit = function() {
	          return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
	        };
	
	        ClustererMarkerManager.prototype.getGMarkers = function() {
	          return this.clusterer.getMarkers().values();
	        };
	
	        ClustererMarkerManager.prototype.checkSync = function() {};
	
	        return ClustererMarkerManager;
	
	      })();
	      return ClustererMarkerManager;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.managers').service('uiGmapGoogleMapObjectManager', [
	    function() {
	      var _availableInstances, _usedInstances;
	      _availableInstances = [];
	      _usedInstances = [];
	      return {
	        createMapInstance: function(parentElement, options) {
	          var instance;
	          instance = null;
	          if (_availableInstances.length === 0) {
	            instance = new google.maps.Map(parentElement, options);
	            _usedInstances.push(instance);
	          } else {
	            instance = _availableInstances.pop();
	            angular.element(parentElement).append(instance.getDiv());
	            instance.setOptions(options);
	            _usedInstances.push(instance);
	          }
	          return instance;
	        },
	        recycleMapInstance: function(instance) {
	          var index;
	          index = _usedInstances.indexOf(instance);
	          if (index < 0) {
	            throw new Error('Expected map instance to be a previously used instance');
	          }
	          _usedInstances.splice(index, 1);
	          return _availableInstances.push(instance);
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", [
	    "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
	      var MarkerManager;
	      MarkerManager = (function() {
	        MarkerManager.type = 'MarkerManager';
	
	        function MarkerManager(gMap, opt_markers, opt_options) {
	          this.getGMarkers = bind(this.getGMarkers, this);
	          this.fit = bind(this.fit, this);
	          this.handleOptDraw = bind(this.handleOptDraw, this);
	          this.clear = bind(this.clear, this);
	          this.destroy = bind(this.destroy, this);
	          this.draw = bind(this.draw, this);
	          this.removeMany = bind(this.removeMany, this);
	          this.remove = bind(this.remove, this);
	          this.addMany = bind(this.addMany, this);
	          this.update = bind(this.update, this);
	          this.add = bind(this.add, this);
	          this.type = MarkerManager.type;
	          this.gMap = gMap;
	          this.gMarkers = new PropMap();
	          this.$log = Logger;
	          this.$log.info(this);
	        }
	
	        MarkerManager.prototype.add = function(gMarker, optDraw) {
	          var exists, msg;
	          if (optDraw == null) {
	            optDraw = true;
	          }
	          if (gMarker.key == null) {
	            msg = "gMarker.key undefined and it is REQUIRED!!";
	            Logger.error(msg);
	            throw msg;
	          }
	          exists = this.gMarkers.get(gMarker.key);
	          if (!exists) {
	            this.handleOptDraw(gMarker, optDraw, true);
	            return this.gMarkers.put(gMarker.key, gMarker);
	          }
	        };
	
	        MarkerManager.prototype.update = function(gMarker, optDraw) {
	          if (optDraw == null) {
	            optDraw = true;
	          }
	          this.remove(gMarker, optDraw);
	          return this.add(gMarker, optDraw);
	        };
	
	        MarkerManager.prototype.addMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(gMarker) {
	              return _this.add(gMarker);
	            };
	          })(this));
	        };
	
	        MarkerManager.prototype.remove = function(gMarker, optDraw) {
	          if (optDraw == null) {
	            optDraw = true;
	          }
	          this.handleOptDraw(gMarker, optDraw, false);
	          if (this.gMarkers.get(gMarker.key)) {
	            return this.gMarkers.remove(gMarker.key);
	          }
	        };
	
	        MarkerManager.prototype.removeMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(marker) {
	              return _this.remove(marker);
	            };
	          })(this));
	        };
	
	        MarkerManager.prototype.draw = function() {
	          var deletes;
	          deletes = [];
	          this.gMarkers.each((function(_this) {
	            return function(gMarker) {
	              if (!gMarker.isDrawn) {
	                if (gMarker.doAdd) {
	                  gMarker.setMap(_this.gMap);
	                  return gMarker.isDrawn = true;
	                } else {
	                  return deletes.push(gMarker);
	                }
	              }
	            };
	          })(this));
	          return deletes.forEach((function(_this) {
	            return function(gMarker) {
	              gMarker.isDrawn = false;
	              return _this.remove(gMarker, true);
	            };
	          })(this));
	        };
	
	        MarkerManager.prototype.destroy = function() {
	          return this.clear();
	        };
	
	        MarkerManager.prototype.clear = function() {
	          this.gMarkers.each(function(gMarker) {
	            return gMarker.setMap(null);
	          });
	          delete this.gMarkers;
	          return this.gMarkers = new PropMap();
	        };
	
	        MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
	          if (optDraw === true) {
	            if (doAdd) {
	              gMarker.setMap(this.gMap);
	            } else {
	              gMarker.setMap(null);
	            }
	            return gMarker.isDrawn = true;
	          } else {
	            gMarker.isDrawn = false;
	            return gMarker.doAdd = doAdd;
	          }
	        };
	
	        MarkerManager.prototype.fit = function() {
	          return FitHelper.fit(this.getGMarkers(), this.gMap);
	        };
	
	        MarkerManager.prototype.getGMarkers = function() {
	          return this.gMarkers.values();
	        };
	
	        return MarkerManager;
	
	      })();
	      return MarkerManager;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module('uiGmapgoogle-maps.directives.api.managers').factory('uiGmapSpiderfierMarkerManager', [
	    'uiGmapLogger', 'uiGmapFitHelper', 'uiGmapPropMap', 'uiGmapMarkerSpiderfier', function($log, FitHelper, PropMap, MarkerSpiderfier) {
	      var SpiderfierMarkerManager;
	      return SpiderfierMarkerManager = (function() {
	        SpiderfierMarkerManager.type = 'SpiderfierMarkerManager';
	
	        function SpiderfierMarkerManager(gMap, opt_markers, opt_options, opt_events, scope) {
	          if (opt_markers == null) {
	            opt_markers = {};
	          }
	          this.opt_options = opt_options != null ? opt_options : {};
	          this.opt_events = opt_events;
	          this.scope = scope;
	          this.checkSync = bind(this.checkSync, this);
	          this.isSpiderfied = bind(this.isSpiderfied, this);
	          this.getGMarkers = bind(this.getGMarkers, this);
	          this.fit = bind(this.fit, this);
	          this.destroy = bind(this.destroy, this);
	          this.attachEvents = bind(this.attachEvents, this);
	          this.clear = bind(this.clear, this);
	          this.draw = bind(this.draw, this);
	          this.removeMany = bind(this.removeMany, this);
	          this.remove = bind(this.remove, this);
	          this.addMany = bind(this.addMany, this);
	          this.update = bind(this.update, this);
	          this.add = bind(this.add, this);
	          this.type = SpiderfierMarkerManager.type;
	          this.markerSpiderfier = new MarkerSpiderfier(gMap, this.opt_options);
	          this.propMapGMarkers = new PropMap();
	          this.attachEvents(this.opt_events, 'opt_events');
	          this.noDrawOnSingleAddRemoves = true;
	          $log.info(this);
	        }
	
	        SpiderfierMarkerManager.prototype.checkKey = function(gMarker) {
	          var msg;
	          if (gMarker.key == null) {
	            msg = 'gMarker.key undefined and it is REQUIRED!!';
	            return $log.error(msg);
	          }
	        };
	
	        SpiderfierMarkerManager.prototype.add = function(gMarker) {
	          gMarker.setMap(this.markerSpiderfier.map);
	          this.checkKey(gMarker);
	          this.markerSpiderfier.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
	          this.propMapGMarkers.put(gMarker.key, gMarker);
	          return this.checkSync();
	        };
	
	        SpiderfierMarkerManager.prototype.update = function(gMarker) {
	          this.remove(gMarker);
	          return this.add(gMarker);
	        };
	
	        SpiderfierMarkerManager.prototype.addMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(gMarker) {
	              return _this.add(gMarker);
	            };
	          })(this));
	        };
	
	        SpiderfierMarkerManager.prototype.remove = function(gMarker) {
	          var exists;
	          this.checkKey(gMarker);
	          exists = this.propMapGMarkers.get(gMarker.key);
	          if (exists) {
	            gMarker.setMap(null);
	            this.markerSpiderfier.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
	            this.propMapGMarkers.remove(gMarker.key);
	          }
	          return this.checkSync();
	        };
	
	        SpiderfierMarkerManager.prototype.removeMany = function(gMarkers) {
	          return gMarkers.forEach((function(_this) {
	            return function(gMarker) {
	              return _this.remove(gMarker);
	            };
	          })(this));
	        };
	
	        SpiderfierMarkerManager.prototype.draw = function() {};
	
	        SpiderfierMarkerManager.prototype.clear = function() {
	          return this.removeMany(this.getGMarkers());
	        };
	
	        SpiderfierMarkerManager.prototype.attachEvents = function(options, optionsName) {
	          if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
	            return _.each(options, (function(_this) {
	              return function(eventHandler, eventName) {
	                if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
	                  $log.info(optionsName + ": Attaching event: " + eventName + " to markerSpiderfier");
	                  return _this.markerSpiderfier.addListener(eventName, function() {
	                    if (eventName === 'spiderfy' || eventName === 'unspiderfy') {
	                      return _this.scope.$evalAsync(options[eventName].apply(options, arguments));
	                    } else {
	                      return _this.scope.$evalAsync(options[eventName].apply(options, [arguments[0], eventName, arguments[0].model, arguments]));
	                    }
	                  });
	                }
	              };
	            })(this));
	          }
	        };
	
	        SpiderfierMarkerManager.prototype.clearEvents = function(options, optionsName) {
	          var eventHandler, eventName;
	          if (angular.isDefined(options) && (options != null) && angular.isObject(options)) {
	            for (eventName in options) {
	              eventHandler = options[eventName];
	              if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
	                $log.info(optionsName + ": Clearing event: " + eventName + " to markerSpiderfier");
	                this.markerSpiderfier.clearListeners(eventName);
	              }
	            }
	          }
	        };
	
	        SpiderfierMarkerManager.prototype.destroy = function() {
	          this.clearEvents(this.opt_events, 'opt_events');
	          return this.clear();
	        };
	
	        SpiderfierMarkerManager.prototype.fit = function() {
	          return FitHelper.fit(this.getGMarkers(), this.markerSpiderfier.map);
	        };
	
	        SpiderfierMarkerManager.prototype.getGMarkers = function() {
	          return this.markerSpiderfier.getMarkers();
	        };
	
	        SpiderfierMarkerManager.prototype.isSpiderfied = function() {
	          return _.find(this.getGMarkers(), function(gMarker) {
	            return (gMarker != null ? gMarker._omsData : void 0) != null;
	          });
	        };
	
	        SpiderfierMarkerManager.prototype.checkSync = function() {};
	
	        return SpiderfierMarkerManager;
	
	      })();
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps').factory('uiGmapadd-events', [
	    '$timeout', function($timeout) {
	      var addEvent, addEvents;
	      addEvent = function(target, eventName, handler) {
	        return google.maps.event.addListener(target, eventName, function() {
	          handler.apply(this, arguments);
	          return $timeout((function() {}), true);
	        });
	      };
	      addEvents = function(target, eventName, handler) {
	        var remove;
	        if (handler) {
	          return addEvent(target, eventName, handler);
	        }
	        remove = [];
	        angular.forEach(eventName, function(_handler, key) {
	          return remove.push(addEvent(target, key, _handler));
	        });
	        return function() {
	          angular.forEach(remove, function(listener) {
	            return google.maps.event.removeListener(listener);
	          });
	          return remove = null;
	        };
	      };
	      return addEvents;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps').factory('uiGmaparray-sync', [
	    'uiGmapadd-events', function(mapEvents) {
	      return function(mapArray, scope, pathEval, pathChangedFn) {
	        var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
	        isSetFromScope = false;
	        scopePath = scope.$eval(pathEval);
	        if (!scope["static"]) {
	          legacyHandlers = {
	            set_at: function(index) {
	              var value;
	              if (isSetFromScope) {
	                return;
	              }
	              value = mapArray.getAt(index);
	              if (!value) {
	                return;
	              }
	              if (!value.lng || !value.lat) {
	                return scopePath[index] = value;
	              } else {
	                scopePath[index].latitude = value.lat();
	                return scopePath[index].longitude = value.lng();
	              }
	            },
	            insert_at: function(index) {
	              var value;
	              if (isSetFromScope) {
	                return;
	              }
	              value = mapArray.getAt(index);
	              if (!value) {
	                return;
	              }
	              if (!value.lng || !value.lat) {
	                return scopePath.splice(index, 0, value);
	              } else {
	                return scopePath.splice(index, 0, {
	                  latitude: value.lat(),
	                  longitude: value.lng()
	                });
	              }
	            },
	            remove_at: function(index) {
	              if (isSetFromScope) {
	                return;
	              }
	              return scopePath.splice(index, 1);
	            }
	          };
	          geojsonArray;
	          if (scopePath.type === 'Polygon') {
	            geojsonArray = scopePath.coordinates[0];
	          } else if (scopePath.type === 'LineString') {
	            geojsonArray = scopePath.coordinates;
	          }
	          geojsonHandlers = {
	            set_at: function(index) {
	              var value;
	              if (isSetFromScope) {
	                return;
	              }
	              value = mapArray.getAt(index);
	              if (!(value && value.lng && value.lat)) {
	                return;
	              }
	              geojsonArray[index][1] = value.lat();
	              return geojsonArray[index][0] = value.lng();
	            },
	            insert_at: function(index) {
	              var value;
	              if (isSetFromScope) {
	                return;
	              }
	              value = mapArray.getAt(index);
	              if (!value) {
	                return;
	              }
	              if (!value.lng || !value.lat) {
	                return;
	              }
	              return geojsonArray.splice(index, 0, [value.lng(), value.lat()]);
	            },
	            remove_at: function(index) {
	              if (isSetFromScope) {
	                return;
	              }
	              return geojsonArray.splice(index, 1);
	            }
	          };
	          mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
	        }
	        legacyWatcher = function(newPath) {
	          var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
	          isSetFromScope = true;
	          oldArray = mapArray;
	          changed = false;
	          if (newPath) {
	            i = 0;
	            oldLength = oldArray.getLength();
	            newLength = newPath.length;
	            l = Math.min(oldLength, newLength);
	            newValue = void 0;
	            while (i < l) {
	              oldValue = oldArray.getAt(i);
	              newValue = newPath[i];
	              if (typeof newValue.equals === 'function') {
	                if (!newValue.equals(oldValue)) {
	                  oldArray.setAt(i, newValue);
	                  changed = true;
	                }
	              } else {
	                if ((oldValue.lat() !== newValue.latitude) || (oldValue.lng() !== newValue.longitude)) {
	                  oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
	                  changed = true;
	                }
	              }
	              i++;
	            }
	            while (i < newLength) {
	              newValue = newPath[i];
	              if (typeof newValue.lat === 'function' && typeof newValue.lng === 'function') {
	                oldArray.push(newValue);
	              } else {
	                oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
	              }
	              changed = true;
	              i++;
	            }
	            while (i < oldLength) {
	              oldArray.pop();
	              changed = true;
	              i++;
	            }
	          }
	          isSetFromScope = false;
	          if (changed) {
	            return pathChangedFn(oldArray);
	          }
	        };
	        geojsonWatcher = function(newPath) {
	          var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
	          isSetFromScope = true;
	          oldArray = mapArray;
	          changed = false;
	          if (newPath) {
	            array;
	            if (scopePath.type === 'Polygon') {
	              array = newPath.coordinates[0];
	            } else if (scopePath.type === 'LineString') {
	              array = newPath.coordinates;
	            }
	            i = 0;
	            oldLength = oldArray.getLength();
	            newLength = array.length;
	            l = Math.min(oldLength, newLength);
	            newValue = void 0;
	            while (i < l) {
	              oldValue = oldArray.getAt(i);
	              newValue = array[i];
	              if ((oldValue.lat() !== newValue[1]) || (oldValue.lng() !== newValue[0])) {
	                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
	                changed = true;
	              }
	              i++;
	            }
	            while (i < newLength) {
	              newValue = array[i];
	              oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
	              changed = true;
	              i++;
	            }
	            while (i < oldLength) {
	              oldArray.pop();
	              changed = true;
	              i++;
	            }
	          }
	          isSetFromScope = false;
	          if (changed) {
	            return pathChangedFn(oldArray);
	          }
	        };
	        watchListener;
	        if (!scope["static"]) {
	          if (angular.isUndefined(scopePath.type)) {
	            watchListener = scope.$watchCollection(pathEval, legacyWatcher);
	          } else {
	            watchListener = scope.$watch(pathEval, geojsonWatcher, true);
	          }
	        }
	        return function() {
	          if (mapArrayListener) {
	            mapArrayListener();
	            mapArrayListener = null;
	          }
	          if (watchListener) {
	            watchListener();
	            return watchListener = null;
	          }
	        };
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", [
	    '$timeout', function($timeout) {
	      return {
	        maybeRepaint: function(el) {
	          if (el) {
	            el.style.opacity = 0.9;
	            return $timeout(function() {
	              return el.style.opacity = 1;
	            });
	          }
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps').service('uiGmapObjectIterators', function() {
	    var _ignores, _iterators, _slapForEach, _slapMap;
	    _ignores = ['length', 'forEach', 'map'];
	    _iterators = [];
	    _slapForEach = function(object) {
	      object.forEach = function(cb) {
	        return _.each(_.omit(object, _ignores), function(val) {
	          if (!_.isFunction(val)) {
	            return cb(val);
	          }
	        });
	      };
	      return object;
	    };
	    _iterators.push(_slapForEach);
	    _slapMap = function(object) {
	      object.map = function(cb) {
	        return _.map(_.omit(object, _ignores), function(val) {
	          if (!_.isFunction(val)) {
	            return cb(val);
	          }
	        });
	      };
	      return object;
	    };
	    _iterators.push(_slapMap);
	    return {
	      slapMap: _slapMap,
	      slapForEach: _slapForEach,
	      slapAll: function(object) {
	        _iterators.forEach(function(it) {
	          return it(object);
	        });
	        return object;
	      }
	    };
	  });
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.options.builders').service('uiGmapCommonOptionsBuilder', [
	    'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapModelKey', function(BaseObject, $log, ModelKey) {
	      var CommonOptionsBuilder;
	      return CommonOptionsBuilder = (function(superClass) {
	        extend(CommonOptionsBuilder, superClass);
	
	        function CommonOptionsBuilder() {
	          this.watchProps = bind(this.watchProps, this);
	          this.buildOpts = bind(this.buildOpts, this);
	          return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        CommonOptionsBuilder.prototype.props = [
	          'clickable', 'draggable', 'editable', 'visible', {
	            prop: 'stroke',
	            isColl: true
	          }
	        ];
	
	        CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
	          if (angular.isDefined(scope != null ? scope.model : void 0)) {
	            return scope.model;
	          } else {
	            return scope;
	          }
	        };
	
	        CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
	          var model, opts, stroke;
	          if (customOpts == null) {
	            customOpts = {};
	          }
	          if (forEachOpts == null) {
	            forEachOpts = {};
	          }
	          if (!this.scope) {
	            $log.error('this.scope not defined in CommonOptionsBuilder can not buildOpts');
	            return;
	          }
	          if (!this.gMap) {
	            $log.error('this.map not defined in CommonOptionsBuilder can not buildOpts');
	            return;
	          }
	          model = this.getCorrectModel(this.scope);
	          stroke = this.scopeOrModelVal('stroke', this.scope, model);
	          opts = angular.extend(customOpts, this.DEFAULTS, {
	            map: this.gMap,
	            strokeColor: stroke != null ? stroke.color : void 0,
	            strokeOpacity: stroke != null ? stroke.opacity : void 0,
	            strokeWeight: stroke != null ? stroke.weight : void 0
	          });
	          angular.forEach(angular.extend(forEachOpts, {
	            clickable: true,
	            draggable: false,
	            editable: false,
	            "static": false,
	            fit: false,
	            visible: true,
	            zIndex: 0,
	            icons: []
	          }), (function(_this) {
	            return function(defaultValue, key) {
	              var val;
	              val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
	              if (angular.isUndefined(val)) {
	                return opts[key] = defaultValue;
	              } else {
	                return opts[key] = model[key];
	              }
	            };
	          })(this));
	          if (opts["static"]) {
	            opts.editable = false;
	          }
	          return opts;
	        };
	
	        CommonOptionsBuilder.prototype.watchProps = function(props) {
	          if (props == null) {
	            props = this.props;
	          }
	          return props.forEach((function(_this) {
	            return function(prop) {
	              if ((_this.attrs[prop] != null) || (_this.attrs[prop != null ? prop.prop : void 0] != null)) {
	                if (prop != null ? prop.isColl : void 0) {
	                  return _this.scope.$watchCollection(prop.prop, _this.setMyOptions);
	                } else {
	                  return _this.scope.$watch(prop, _this.setMyOptions);
	                }
	              }
	            };
	          })(this));
	        };
	
	        return CommonOptionsBuilder;
	
	      })(ModelKey);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.options.builders').factory('uiGmapPolylineOptionsBuilder', [
	    'uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
	      var PolylineOptionsBuilder;
	      return PolylineOptionsBuilder = (function(superClass) {
	        extend(PolylineOptionsBuilder, superClass);
	
	        function PolylineOptionsBuilder() {
	          return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
	          return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
	            path: pathPoints
	          }, cachedEval, {
	            geodesic: false
	          });
	        };
	
	        return PolylineOptionsBuilder;
	
	      })(CommonOptionsBuilder);
	    }
	  ]).factory('uiGmapShapeOptionsBuilder', [
	    'uiGmapCommonOptionsBuilder', function(CommonOptionsBuilder) {
	      var ShapeOptionsBuilder;
	      return ShapeOptionsBuilder = (function(superClass) {
	        extend(ShapeOptionsBuilder, superClass);
	
	        function ShapeOptionsBuilder() {
	          return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
	          var fill, model;
	          model = this.getCorrectModel(this.scope);
	          fill = cachedEval ? cachedEval['fill'] : this.scopeOrModelVal('fill', this.scope, model);
	          customOpts = angular.extend(customOpts, {
	            fillColor: fill != null ? fill.color : void 0,
	            fillOpacity: fill != null ? fill.opacity : void 0
	          });
	          return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
	        };
	
	        return ShapeOptionsBuilder;
	
	      })(CommonOptionsBuilder);
	    }
	  ]).factory('uiGmapPolygonOptionsBuilder', [
	    'uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
	      var PolygonOptionsBuilder;
	      return PolygonOptionsBuilder = (function(superClass) {
	        extend(PolygonOptionsBuilder, superClass);
	
	        function PolygonOptionsBuilder() {
	          return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
	          return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
	            path: pathPoints
	          }, cachedEval, {
	            geodesic: false
	          });
	        };
	
	        return PolygonOptionsBuilder;
	
	      })(ShapeOptionsBuilder);
	    }
	  ]).factory('uiGmapRectangleOptionsBuilder', [
	    'uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
	      var RectangleOptionsBuilder;
	      return RectangleOptionsBuilder = (function(superClass) {
	        extend(RectangleOptionsBuilder, superClass);
	
	        function RectangleOptionsBuilder() {
	          return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
	          return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
	            bounds: bounds
	          }, cachedEval);
	        };
	
	        return RectangleOptionsBuilder;
	
	      })(ShapeOptionsBuilder);
	    }
	  ]).factory('uiGmapCircleOptionsBuilder', [
	    'uiGmapShapeOptionsBuilder', function(ShapeOptionsBuilder) {
	      var CircleOptionsBuilder;
	      return CircleOptionsBuilder = (function(superClass) {
	        extend(CircleOptionsBuilder, superClass);
	
	        function CircleOptionsBuilder() {
	          return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
	        }
	
	        CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
	          return CircleOptionsBuilder.__super__.buildOpts.call(this, {
	            center: center,
	            radius: radius
	          }, cachedEval);
	        };
	
	        return CircleOptionsBuilder;
	
	      })(ShapeOptionsBuilder);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.options').service('uiGmapMarkerOptions', [
	    'uiGmapLogger', 'uiGmapGmapUtil', function($log, GmapUtil) {
	      return _.extend(GmapUtil, {
	        createOptions: function(coords, icon, defaults, map) {
	          var opts;
	          if (defaults == null) {
	            defaults = {};
	          }
	          opts = angular.extend({}, defaults, {
	            position: defaults.position != null ? defaults.position : GmapUtil.getCoords(coords),
	            visible: defaults.visible != null ? defaults.visible : GmapUtil.validateCoords(coords)
	          });
	          if ((defaults.icon != null) || (icon != null)) {
	            opts = angular.extend(opts, {
	              icon: defaults.icon != null ? defaults.icon : icon
	            });
	          }
	          if (map != null) {
	            opts.map = map;
	          }
	          return opts;
	        },
	        isLabel: function(options) {
	          if (options == null) {
	            return false;
	          }
	          return (options.labelContent != null) || (options.labelAnchor != null) || (options.labelClass != null) || (options.labelStyle != null) || (options.labelVisible != null);
	        }
	      });
	    }
	  ]);
	
	}).call(this);
	;
	/*global _,angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapBasePolyChildModel', [
	    'uiGmapLogger', '$timeout', 'uiGmaparray-sync', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
	      return function(Builder, gFactory) {
	        var BasePolyChildModel;
	        return BasePolyChildModel = (function(superClass) {
	          extend(BasePolyChildModel, superClass);
	
	          BasePolyChildModel.include(GmapUtil);
	
	          function BasePolyChildModel(arg) {
	            var create, gObjectChangeCb, ref;
	            this.scope = arg.scope, this.attrs = arg.attrs, this.gMap = arg.gMap, this.defaults = arg.defaults, this.model = arg.model, gObjectChangeCb = arg.gObjectChangeCb, this.isScopeModel = (ref = arg.isScopeModel) != null ? ref : false;
	            this.clean = bind(this.clean, this);
	            if (this.isScopeModel) {
	              this.clonedModel = _.clone(this.model, true);
	            }
	            this.isDragging = false;
	            this.internalEvents = {
	              dragend: (function(_this) {
	                return function() {
	                  return _.defer(function() {
	                    return _this.isDragging = false;
	                  });
	                };
	              })(this),
	              dragstart: (function(_this) {
	                return function() {
	                  return _this.isDragging = true;
	                };
	              })(this)
	            };
	            create = (function(_this) {
	              return function() {
	                var maybeCachedEval;
	                if (_this.isDragging) {
	                  return;
	                }
	                _this.pathPoints = _this.convertPathPoints(_this.scope.path);
	                if (_this.gObject != null) {
	                  _this.clean();
	                }
	                if (_this.scope.model != null) {
	                  maybeCachedEval = _this.scope;
	                }
	                if (_this.pathPoints.length > 0) {
	                  _this.gObject = gFactory(_this.buildOpts(_this.pathPoints, maybeCachedEval));
	                }
	                if (_this.gObject) {
	                  arraySync(_this.gObject.getPath(), _this.scope, 'path', function(pathPoints) {
	                    _this.pathPoints = pathPoints;
	                    if (gObjectChangeCb != null) {
	                      return gObjectChangeCb();
	                    }
	                  });
	                  if (angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events)) {
	                    _this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope);
	                  }
	                  return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
	                    events: _this.internalEvents
	                  }, _this.model) : EventsHelper.setEvents(_this.gObject, {
	                    events: _this.internalEvents
	                  }, _this.scope);
	                }
	              };
	            })(this);
	            create();
	            this.scope.$watch('path', (function(_this) {
	              return function(newValue, oldValue) {
	                if (!_.isEqual(newValue, oldValue) || !_this.gObject) {
	                  return create();
	                }
	              };
	            })(this), true);
	            if (!this.scope["static"] && angular.isDefined(this.scope.editable)) {
	              this.scope.$watch('editable', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    newValue = !_this.isFalse(newValue);
	                    return (ref1 = _this.gObject) != null ? ref1.setEditable(newValue) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.draggable)) {
	              this.scope.$watch('draggable', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    newValue = !_this.isFalse(newValue);
	                    return (ref1 = _this.gObject) != null ? ref1.setDraggable(newValue) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.visible)) {
	              this.scope.$watch('visible', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    newValue = !_this.isFalse(newValue);
	                  }
	                  return (ref1 = _this.gObject) != null ? ref1.setVisible(newValue) : void 0;
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.geodesic)) {
	              this.scope.$watch('geodesic', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    newValue = !_this.isFalse(newValue);
	                    return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight)) {
	              this.scope.$watch('stroke.weight', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color)) {
	              this.scope.$watch('stroke.color', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity)) {
	              this.scope.$watch('stroke.opacity', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            if (angular.isDefined(this.scope.icons)) {
	              this.scope.$watch('icons', (function(_this) {
	                return function(newValue, oldValue) {
	                  var ref1;
	                  if (newValue !== oldValue) {
	                    return (ref1 = _this.gObject) != null ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
	                  }
	                };
	              })(this), true);
	            }
	            this.scope.$on('$destroy', (function(_this) {
	              return function() {
	                _this.clean();
	                return _this.scope = null;
	              };
	            })(this));
	            if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color)) {
	              this.scope.$watch('fill.color', (function(_this) {
	                return function(newValue, oldValue) {
	                  if (newValue !== oldValue) {
	                    return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
	                  }
	                };
	              })(this));
	            }
	            if (angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity)) {
	              this.scope.$watch('fill.opacity', (function(_this) {
	                return function(newValue, oldValue) {
	                  if (newValue !== oldValue) {
	                    return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
	                  }
	                };
	              })(this));
	            }
	            if (angular.isDefined(this.scope.zIndex)) {
	              this.scope.$watch('zIndex', (function(_this) {
	                return function(newValue, oldValue) {
	                  if (newValue !== oldValue) {
	                    return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
	                  }
	                };
	              })(this));
	            }
	          }
	
	          BasePolyChildModel.prototype.clean = function() {
	            var ref;
	            EventsHelper.removeEvents(this.listeners);
	            EventsHelper.removeEvents(this.internalListeners);
	            if ((ref = this.gObject) != null) {
	              ref.setMap(null);
	            }
	            return this.gObject = null;
	          };
	
	          return BasePolyChildModel;
	
	        })(Builder);
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicholas McCready - https://twitter.com/nmccready
	Original idea from: http://stackoverflow.com/questions/22758950/google-map-drawing-freehand  , &
	  http://jsfiddle.net/YsQdh/88/
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapDrawFreeHandChildModel', [
	    'uiGmapLogger', '$q', function($log, $q) {
	      var drawFreeHand, freeHandMgr;
	      drawFreeHand = function(map, polys, done) {
	        var move, poly;
	        poly = new google.maps.Polyline({
	          map: map,
	          clickable: false
	        });
	        move = google.maps.event.addListener(map, 'mousemove', function(e) {
	          return poly.getPath().push(e.latLng);
	        });
	        google.maps.event.addListenerOnce(map, 'mouseup', function(e) {
	          var path;
	          google.maps.event.removeListener(move);
	          path = poly.getPath();
	          poly.setMap(null);
	          polys.push(new google.maps.Polygon({
	            map: map,
	            path: path
	          }));
	          poly = null;
	          google.maps.event.clearListeners(map.getDiv(), 'mousedown');
	          return done();
	        });
	        return void 0;
	      };
	      freeHandMgr = function(map1, scope) {
	        var disableMap, enableMap;
	        this.map = map1;
	        disableMap = (function(_this) {
	          return function() {
	            var mapOptions;
	            mapOptions = {
	              draggable: false,
	              disableDefaultUI: true,
	              scrollwheel: false,
	              disableDoubleClickZoom: false
	            };
	            $log.info('disabling map move');
	            return _this.map.setOptions(mapOptions);
	          };
	        })(this);
	        enableMap = (function(_this) {
	          return function() {
	            var mapOptions, ref;
	            mapOptions = {
	              draggable: true,
	              disableDefaultUI: false,
	              scrollwheel: true,
	              disableDoubleClickZoom: true
	            };
	            if ((ref = _this.deferred) != null) {
	              ref.resolve();
	            }
	            return _.defer(function() {
	              return _this.map.setOptions(_.extend(mapOptions, scope.options));
	            });
	          };
	        })(this);
	        this.engage = (function(_this) {
	          return function(polys1) {
	            _this.polys = polys1;
	            _this.deferred = $q.defer();
	            disableMap();
	            $log.info('DrawFreeHandChildModel is engaged (drawing).');
	            google.maps.event.addDomListener(_this.map.getDiv(), 'mousedown', function(e) {
	              return drawFreeHand(_this.map, _this.polys, enableMap);
	            });
	            return _this.deferred.promise;
	          };
	        })(this);
	        return this;
	      };
	      return freeHandMgr;
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true,angular:true,google:true, RichMarker:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapMarkerChildModel', [
	    'uiGmapModelKey', 'uiGmapGmapUtil', 'uiGmapLogger', 'uiGmapEventsHelper', 'uiGmapPropertyAction', 'uiGmapMarkerOptions', 'uiGmapIMarker', 'uiGmapMarkerManager', 'uiGmapPromise', function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
	      var MarkerChildModel;
	      MarkerChildModel = (function(superClass) {
	        var destroy;
	
	        extend(MarkerChildModel, superClass);
	
	        MarkerChildModel.include(GmapUtil);
	
	        MarkerChildModel.include(EventsHelper);
	
	        MarkerChildModel.include(MarkerOptions);
	
	        destroy = function(child) {
	          if ((child != null ? child.gObject : void 0) != null) {
	            child.removeEvents(child.externalListeners);
	            child.removeEvents(child.internalListeners);
	            if (child != null ? child.gObject : void 0) {
	              if (child.removeFromManager) {
	                child.gManager.remove(child.gObject);
	              }
	              child.gObject.setMap(null);
	              return child.gObject = null;
	            }
	          }
	        };
	
	        function MarkerChildModel(opts) {
	          this.internalEvents = bind(this.internalEvents, this);
	          this.setLabelOptions = bind(this.setLabelOptions, this);
	          this.setOptions = bind(this.setOptions, this);
	          this.setIcon = bind(this.setIcon, this);
	          this.setCoords = bind(this.setCoords, this);
	          this.isNotValid = bind(this.isNotValid, this);
	          this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
	          this.createMarker = bind(this.createMarker, this);
	          this.setMyScope = bind(this.setMyScope, this);
	          this.updateModel = bind(this.updateModel, this);
	          this.handleModelChanges = bind(this.handleModelChanges, this);
	          this.destroy = bind(this.destroy, this);
	          var action, ref, ref1, ref2, ref3, ref4, scope;
	          scope = opts.scope, this.model = opts.model, this.keys = opts.keys, this.gMap = opts.gMap, this.defaults = (ref = opts.defaults) != null ? ref : {}, this.doClick = opts.doClick, this.gManager = opts.gManager, this.doDrawSelf = (ref1 = opts.doDrawSelf) != null ? ref1 : true, this.trackModel = (ref2 = opts.trackModel) != null ? ref2 : true, this.needRedraw = (ref3 = opts.needRedraw) != null ? ref3 : false, this.isScopeModel = (ref4 = opts.isScopeModel) != null ? ref4 : false;
	          if (this.isScopeModel) {
	            this.clonedModel = _.clone(this.model, true);
	          }
	          this.deferred = uiGmapPromise.defer();
	          _.each(this.keys, (function(_this) {
	            return function(v, k) {
	              var keyValue;
	              keyValue = _this.keys[k];
	              if ((keyValue != null) && !_.isFunction(keyValue) && _.isString(keyValue)) {
	                return _this[k + 'Key'] = keyValue;
	              }
	            };
	          })(this));
	          this.idKey = this.idKeyKey || 'id';
	          if (this.model[this.idKey] != null) {
	            this.id = this.model[this.idKey];
	          }
	          MarkerChildModel.__super__.constructor.call(this, scope);
	          this.scope.getGMarker = (function(_this) {
	            return function() {
	              return _this.gObject;
	            };
	          })(this);
	          this.firstTime = true;
	          if (this.trackModel) {
	            this.scope.model = this.model;
	            this.scope.$watch('model', (function(_this) {
	              return function(newValue, oldValue) {
	                if (newValue !== oldValue) {
	                  return _this.handleModelChanges(newValue, oldValue);
	                }
	              };
	            })(this), true);
	          } else {
	            action = new PropertyAction((function(_this) {
	              return function(calledKey) {
	                if (_.isFunction(calledKey)) {
	                  calledKey = 'all';
	                }
	                if (!_this.firstTime) {
	                  return _this.setMyScope(calledKey, scope);
	                }
	              };
	            })(this), false);
	            _.each(this.keys, function(v, k) {
	              return scope.$watch(k, action.sic(k), true);
	            });
	          }
	          this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              return destroy(_this);
	            };
	          })(this));
	          this.createMarker(this.model);
	          $log.info(this);
	        }
	
	        MarkerChildModel.prototype.destroy = function(removeFromManager) {
	          if (removeFromManager == null) {
	            removeFromManager = true;
	          }
	          this.removeFromManager = removeFromManager;
	          return this.scope.$destroy();
	        };
	
	        MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
	          var changes, ctr, len;
	          changes = this.getChanges(newValue, oldValue, IMarker.keys);
	          if (!this.firstTime) {
	            ctr = 0;
	            len = _.keys(changes).length;
	            return _.each(changes, (function(_this) {
	              return function(v, k) {
	                var doDraw;
	                ctr += 1;
	                doDraw = len === ctr;
	                _this.setMyScope(k, newValue, oldValue, false, true, doDraw);
	                return _this.needRedraw = true;
	              };
	            })(this));
	          }
	        };
	
	        MarkerChildModel.prototype.updateModel = function(model) {
	          if (this.isScopeModel) {
	            this.clonedModel = _.clone(model, true);
	          }
	          return this.setMyScope('all', model, this.model);
	        };
	
	        MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
	          var coords, isSpiderfied, ref;
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          coords = this.getProp('coords', this.scope, this.model);
	          if (((ref = this.gManager) != null ? ref.isSpiderfied : void 0) != null) {
	            isSpiderfied = this.gManager.isSpiderfied();
	          }
	          if (coords != null) {
	            if (!this.validateCoords(coords)) {
	              $log.debug('MarkerChild does not have coords yet. They may be defined later.');
	              return;
	            }
	            if (validCb != null) {
	              validCb();
	            }
	            if (doDraw && this.gObject) {
	              this.gManager.add(this.gObject);
	            }
	            if (isSpiderfied) {
	              return this.gManager.markerSpiderfier.spiderListener(this.gObject, window.event);
	            }
	          } else {
	            if (doDraw && this.gObject) {
	              return this.gManager.remove(this.gObject);
	            }
	          }
	        };
	
	        MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
	          var justCreated;
	          if (oldModel == null) {
	            oldModel = void 0;
	          }
	          if (isInit == null) {
	            isInit = false;
	          }
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          if (model == null) {
	            model = this.model;
	          } else {
	            this.model = model;
	          }
	          if (!this.gObject) {
	            this.setOptions(this.scope, doDraw);
	            justCreated = true;
	          }
	          switch (thingThatChanged) {
	            case 'all':
	              return _.each(this.keys, (function(_this) {
	                return function(v, k) {
	                  return _this.setMyScope(k, model, oldModel, isInit, doDraw);
	                };
	              })(this));
	            case 'icon':
	              return this.maybeSetScopeValue({
	                gSetter: this.setIcon,
	                doDraw: doDraw
	              });
	            case 'coords':
	              return this.maybeSetScopeValue({
	                gSetter: this.setCoords,
	                doDraw: doDraw
	              });
	            case 'options':
	              if (!justCreated) {
	                return this.createMarker(model, oldModel, isInit, doDraw);
	              }
	          }
	        };
	
	        MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
	          if (oldModel == null) {
	            oldModel = void 0;
	          }
	          if (isInit == null) {
	            isInit = false;
	          }
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          this.maybeSetScopeValue({
	            gSetter: this.setOptions,
	            doDraw: doDraw
	          });
	          return this.firstTime = false;
	        };
	
	        MarkerChildModel.prototype.maybeSetScopeValue = function(arg) {
	          var doDraw, gSetter, ref;
	          gSetter = arg.gSetter, doDraw = (ref = arg.doDraw) != null ? ref : true;
	          if (gSetter != null) {
	            gSetter(this.scope, doDraw);
	          }
	          if (this.doDrawSelf && doDraw) {
	            return this.gManager.draw();
	          }
	        };
	
	        MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
	          var hasIdenticalScopes, hasNoGmarker;
	          if (doCheckGmarker == null) {
	            doCheckGmarker = true;
	          }
	          hasNoGmarker = !doCheckGmarker ? false : this.gObject === void 0;
	          hasIdenticalScopes = !this.trackModel ? scope.$id !== this.scope.$id : false;
	          return hasIdenticalScopes || hasNoGmarker;
	        };
	
	        MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          if (this.isNotValid(scope) || (this.gObject == null)) {
	            return;
	          }
	          return this.renderGMarker(doDraw, (function(_this) {
	            return function() {
	              var newGValue, newModelVal, oldGValue;
	              newModelVal = _this.getProp('coords', scope, _this.model);
	              newGValue = _this.getCoords(newModelVal);
	              oldGValue = _this.gObject.getPosition();
	              if ((oldGValue != null) && (newGValue != null)) {
	                if (newGValue.lng() === oldGValue.lng() && newGValue.lat() === oldGValue.lat()) {
	                  return;
	                }
	              }
	              _this.gObject.setPosition(newGValue);
	              return _this.gObject.setVisible(_this.validateCoords(newModelVal));
	            };
	          })(this));
	        };
	
	        MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          if (this.isNotValid(scope) || (this.gObject == null)) {
	            return;
	          }
	          return this.renderGMarker(doDraw, (function(_this) {
	            return function() {
	              var coords, newValue, oldValue;
	              oldValue = _this.gObject.getIcon();
	              newValue = _this.getProp('icon', scope, _this.model);
	              if (oldValue === newValue) {
	                return;
	              }
	              _this.gObject.setIcon(newValue);
	              coords = _this.getProp('coords', scope, _this.model);
	              _this.gObject.setPosition(_this.getCoords(coords));
	              return _this.gObject.setVisible(_this.validateCoords(coords));
	            };
	          })(this));
	        };
	
	        MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
	          var ref;
	          if (doDraw == null) {
	            doDraw = true;
	          }
	          if (this.isNotValid(scope, false)) {
	            return;
	          }
	          this.renderGMarker(doDraw, (function(_this) {
	            return function() {
	              var _options, coords, icon;
	              coords = _this.getProp('coords', scope, _this.model);
	              icon = _this.getProp('icon', scope, _this.model);
	              _options = _this.getProp('options', scope, _this.model);
	              _this.opts = _this.createOptions(coords, icon, _options);
	              if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && (_this.gObject != null)) {
	                _this.gManager.remove(_this.gObject);
	                _this.gObject = void 0;
	              }
	              if (_this.gObject != null) {
	                _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
	              }
	              if (!_this.gObject) {
	                if (_this.isLabel(_this.opts)) {
	                  _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts));
	                } else if (_this.opts.content) {
	                  _this.gObject = new RichMarker(_this.opts);
	                  _this.gObject.getIcon = _this.gObject.getContent;
	                  _this.gObject.setIcon = _this.gObject.setContent;
	                } else {
	                  _this.gObject = new google.maps.Marker(_this.opts);
	                }
	                _.extend(_this.gObject, {
	                  model: _this.model
	                });
	              }
	              if (_this.externalListeners) {
	                _this.removeEvents(_this.externalListeners);
	              }
	              if (_this.internalListeners) {
	                _this.removeEvents(_this.internalListeners);
	              }
	              _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, ['dragend']);
	              _this.internalListeners = _this.setEvents(_this.gObject, {
	                events: _this.internalEvents(),
	                $evalAsync: function() {}
	              }, _this.model);
	              if (_this.id != null) {
	                return _this.gObject.key = _this.id;
	              }
	            };
	          })(this));
	          if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) {
	            this.deferred.resolve(this.gObject);
	          } else {
	            if (!this.gObject) {
	              return this.deferred.reject('gObject is null');
	            }
	            if (!(((ref = this.gObject) != null ? ref.getMap() : void 0) && this.gManager.type === MarkerManager.type)) {
	              $log.debug('gObject has no map yet');
	              this.deferred.resolve(this.gObject);
	            }
	          }
	          if (this.model[this.fitKey]) {
	            return this.gManager.fit();
	          }
	        };
	
	        MarkerChildModel.prototype.setLabelOptions = function(opts) {
	          if (opts.labelAnchor) {
	            opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
	          }
	          return opts;
	        };
	
	        MarkerChildModel.prototype.internalEvents = function() {
	          return {
	            dragend: (function(_this) {
	              return function(marker, eventName, model, mousearg) {
	                var events, modelToSet, newCoords;
	                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
	                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
	                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
	                events = _this.scope.events;
	                if ((events != null ? events.dragend : void 0) != null) {
	                  events.dragend(marker, eventName, modelToSet, mousearg);
	                }
	                return _this.scope.$apply();
	              };
	            })(this),
	            click: (function(_this) {
	              return function(marker, eventName, model, mousearg) {
	                var click;
	                click = _this.getProp('click', _this.scope, _this.model);
	                if (_this.doClick && angular.isFunction(click)) {
	                  return _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg));
	                }
	              };
	            })(this)
	          };
	        };
	
	        return MarkerChildModel;
	
	      })(ModelKey);
	      return MarkerChildModel;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygonChildModel', [
	    'uiGmapBasePolyChildModel', 'uiGmapPolygonOptionsBuilder', function(BaseGen, Builder) {
	      var PolygonChildModel, base, gFactory;
	      gFactory = function(opts) {
	        return new google.maps.Polygon(opts);
	      };
	      base = new BaseGen(Builder, gFactory);
	      return PolygonChildModel = (function(superClass) {
	        extend(PolygonChildModel, superClass);
	
	        function PolygonChildModel() {
	          return PolygonChildModel.__super__.constructor.apply(this, arguments);
	        }
	
	        return PolygonChildModel;
	
	      })(base);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylineChildModel', [
	    'uiGmapBasePolyChildModel', 'uiGmapPolylineOptionsBuilder', function(BaseGen, Builder) {
	      var PolylineChildModel, base, gFactory;
	      gFactory = function(opts) {
	        return new google.maps.Polyline(opts);
	      };
	      base = BaseGen(Builder, gFactory);
	      return PolylineChildModel = (function(superClass) {
	        extend(PolylineChildModel, superClass);
	
	        function PolylineChildModel() {
	          return PolylineChildModel.__super__.constructor.apply(this, arguments);
	        }
	
	        return PolylineChildModel;
	
	      })(base);
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true,angular:true,google:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.child').factory('uiGmapWindowChildModel', [
	    'uiGmapBaseObject', 'uiGmapGmapUtil', 'uiGmapLogger', '$compile', '$http', '$templateCache', 'uiGmapChromeFixes', 'uiGmapEventsHelper', function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
	      var WindowChildModel;
	      WindowChildModel = (function(superClass) {
	        extend(WindowChildModel, superClass);
	
	        WindowChildModel.include(GmapUtil);
	
	        WindowChildModel.include(EventsHelper);
	
	        function WindowChildModel(opts) {
	          this.updateModel = bind(this.updateModel, this);
	          this.destroy = bind(this.destroy, this);
	          this.remove = bind(this.remove, this);
	          this.getLatestPosition = bind(this.getLatestPosition, this);
	          this.hideWindow = bind(this.hideWindow, this);
	          this.showWindow = bind(this.showWindow, this);
	          this.handleClick = bind(this.handleClick, this);
	          this.watchOptions = bind(this.watchOptions, this);
	          this.watchCoords = bind(this.watchCoords, this);
	          this.createGWin = bind(this.createGWin, this);
	          this.watchElement = bind(this.watchElement, this);
	          this.watchAndDoShow = bind(this.watchAndDoShow, this);
	          this.doShow = bind(this.doShow, this);
	          var maybeMarker, ref, ref1, ref2, ref3;
	          this.model = (ref = opts.model) != null ? ref : {}, this.scope = opts.scope, this.opts = opts.opts, this.isIconVisibleOnClick = opts.isIconVisibleOnClick, this.gMap = opts.gMap, this.markerScope = opts.markerScope, this.element = opts.element, this.needToManualDestroy = (ref1 = opts.needToManualDestroy) != null ? ref1 : false, this.markerIsVisibleAfterWindowClose = (ref2 = opts.markerIsVisibleAfterWindowClose) != null ? ref2 : true, this.isScopeModel = (ref3 = opts.isScopeModel) != null ? ref3 : false;
	          if (this.isScopeModel) {
	            this.clonedModel = _.clone(this.model, true);
	          }
	          this.getGmarker = function() {
	            var ref4, ref5;
	            if (((ref4 = this.markerScope) != null ? ref4['getGMarker'] : void 0) != null) {
	              return (ref5 = this.markerScope) != null ? ref5.getGMarker() : void 0;
	            }
	          };
	          this.listeners = [];
	          this.createGWin();
	          maybeMarker = this.getGmarker();
	          if (maybeMarker != null) {
	            maybeMarker.setClickable(true);
	          }
	          this.watchElement();
	          this.watchOptions();
	          this.watchCoords();
	          this.watchAndDoShow();
	          this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              return _this.destroy();
	            };
	          })(this));
	          $log.info(this);
	        }
	
	        WindowChildModel.prototype.doShow = function(wasOpen) {
	          if (this.scope.show === true || wasOpen) {
	            return this.showWindow();
	          } else {
	            return this.hideWindow();
	          }
	        };
	
	        WindowChildModel.prototype.watchAndDoShow = function() {
	          if (this.model.show != null) {
	            this.scope.show = this.model.show;
	          }
	          this.scope.$watch('show', this.doShow, true);
	          return this.doShow();
	        };
	
	        WindowChildModel.prototype.watchElement = function() {
	          return this.scope.$watch((function(_this) {
	            return function() {
	              var ref, wasOpen;
	              if (!(_this.element || _this.html)) {
	                return;
	              }
	              if (_this.html !== _this.element.html() && _this.gObject) {
	                if ((ref = _this.opts) != null) {
	                  ref.content = void 0;
	                }
	                wasOpen = _this.gObject.isOpen();
	                _this.remove();
	                return _this.createGWin(wasOpen);
	              }
	            };
	          })(this));
	        };
	
	        WindowChildModel.prototype.createGWin = function(isOpen) {
	          var _opts, defaults, maybeMarker, ref, ref1;
	          if (isOpen == null) {
	            isOpen = false;
	          }
	          maybeMarker = this.getGmarker();
	          defaults = {};
	          if (this.opts != null) {
	            if (this.scope.coords) {
	              this.opts.position = this.getCoords(this.scope.coords);
	            }
	            defaults = this.opts;
	          }
	          if (this.element) {
	            this.html = _.isObject(this.element) ? this.element.html() : this.element;
	          }
	          _opts = this.scope.options ? this.scope.options : defaults;
	          this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
	          if (this.opts != null) {
	            if (!this.gObject) {
	              if (this.opts.boxClass && (window.InfoBox && typeof window.InfoBox === 'function')) {
	                this.gObject = new window.InfoBox(this.opts);
	              } else {
	                this.gObject = new google.maps.InfoWindow(this.opts);
	              }
	              this.listeners.push(google.maps.event.addListener(this.gObject, 'domready', function() {
	                return ChromeFixes.maybeRepaint(this.content);
	              }));
	              this.listeners.push(google.maps.event.addListener(this.gObject, 'closeclick', (function(_this) {
	                return function() {
	                  if (maybeMarker) {
	                    maybeMarker.setAnimation(_this.oldMarkerAnimation);
	                    if (_this.markerIsVisibleAfterWindowClose) {
	                      _.delay(function() {
	                        maybeMarker.setVisible(false);
	                        return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
	                      }, 250);
	                    }
	                  }
	                  _this.gObject.close();
	                  _this.model.show = false;
	                  if (_this.scope.closeClick != null) {
	                    return _this.scope.$evalAsync(_this.scope.closeClick());
	                  } else {
	                    return _this.scope.$evalAsync();
	                  }
	                };
	              })(this)));
	            }
	            this.gObject.setContent(this.opts.content);
	            this.handleClick(((ref = this.scope) != null ? (ref1 = ref.options) != null ? ref1.forceClick : void 0 : void 0) || isOpen);
	            return this.doShow(this.gObject.isOpen());
	          }
	        };
	
	        WindowChildModel.prototype.watchCoords = function() {
	          var scope;
	          scope = this.markerScope != null ? this.markerScope : this.scope;
	          return scope.$watch('coords', (function(_this) {
	            return function(newValue, oldValue) {
	              var pos;
	              if (newValue !== oldValue) {
	                if (newValue == null) {
	                  _this.hideWindow();
	                } else if (!_this.validateCoords(newValue)) {
	                  $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + (JSON.stringify(_this.model)));
	                  return;
	                }
	                pos = _this.getCoords(newValue);
	                _this.doShow();
	                _this.gObject.setPosition(pos);
	                if (_this.opts) {
	                  return _this.opts.position = pos;
	                }
	              }
	            };
	          })(this), true);
	        };
	
	        WindowChildModel.prototype.watchOptions = function() {
	          return this.scope.$watch('options', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                _this.opts = newValue;
	                if (_this.gObject != null) {
	                  _this.gObject.setOptions(_this.opts);
	                  if ((_this.opts.visible != null) && _this.opts.visible) {
	                    return _this.showWindow();
	                  } else if (_this.opts.visible != null) {
	                    return _this.hideWindow();
	                  }
	                }
	              }
	            };
	          })(this), true);
	        };
	
	        WindowChildModel.prototype.handleClick = function(forceClick) {
	          var click, maybeMarker;
	          if (this.gObject == null) {
	            return;
	          }
	          maybeMarker = this.getGmarker();
	          click = (function(_this) {
	            return function() {
	              if (_this.gObject == null) {
	                _this.createGWin();
	              }
	              _this.showWindow();
	              if (maybeMarker != null) {
	                _this.initialMarkerVisibility = maybeMarker.getVisible();
	                _this.oldMarkerAnimation = maybeMarker.getAnimation();
	                return maybeMarker.setVisible(_this.isIconVisibleOnClick);
	              }
	            };
	          })(this);
	          if (forceClick) {
	            click();
	          }
	          if (maybeMarker) {
	            return this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
	              events: {
	                click: click
	              }
	            }, this.model));
	          }
	        };
	
	        WindowChildModel.prototype.showWindow = function() {
	          var compiled, show, templateScope;
	          if (this.gObject == null) {
	            return;
	          }
	          templateScope = null;
	          show = (function(_this) {
	            return function() {
	              var isOpen, maybeMarker, pos;
	              if (!_this.gObject.isOpen()) {
	                maybeMarker = _this.getGmarker();
	                if ((_this.gObject != null) && (_this.gObject.getPosition != null)) {
	                  pos = _this.gObject.getPosition();
	                }
	                if (maybeMarker) {
	                  pos = maybeMarker.getPosition();
	                }
	                if (!pos) {
	                  return;
	                }
	                _this.gObject.open(_this.gMap, maybeMarker);
	                isOpen = _this.gObject.isOpen();
	                if (_this.model.show !== isOpen) {
	                  return _this.model.show = isOpen;
	                }
	              }
	            };
	          })(this);
	          if (this.scope.templateUrl) {
	            $http.get(this.scope.templateUrl, {
	              cache: $templateCache
	            }).then((function(_this) {
	              return function(content) {
	                var compiled;
	                templateScope = _this.scope.$new();
	                if (angular.isDefined(_this.scope.templateParameter)) {
	                  templateScope.parameter = _this.scope.templateParameter;
	                }
	                compiled = $compile(content.data)(templateScope);
	                _this.gObject.setContent(compiled[0]);
	                return show();
	              };
	            })(this));
	          } else if (this.scope.template) {
	            templateScope = this.scope.$new();
	            if (angular.isDefined(this.scope.templateParameter)) {
	              templateScope.parameter = this.scope.templateParameter;
	            }
	            compiled = $compile(this.scope.template)(templateScope);
	            this.gObject.setContent(compiled[0]);
	            show();
	          } else {
	            show();
	          }
	          return this.scope.$on('destroy', function() {
	            return templateScope.$destroy();
	          });
	        };
	
	        WindowChildModel.prototype.hideWindow = function() {
	          if ((this.gObject != null) && this.gObject.isOpen()) {
	            return this.gObject.close();
	          }
	        };
	
	        WindowChildModel.prototype.getLatestPosition = function(overridePos) {
	          var maybeMarker;
	          maybeMarker = this.getGmarker();
	          if ((this.gObject != null) && (maybeMarker != null) && !overridePos) {
	            return this.gObject.setPosition(maybeMarker.getPosition());
	          } else {
	            if (overridePos) {
	              return this.gObject.setPosition(overridePos);
	            }
	          }
	        };
	
	        WindowChildModel.prototype.remove = function() {
	          this.hideWindow();
	          this.removeEvents(this.listeners);
	          this.listeners.length = 0;
	          delete this.gObject;
	          return delete this.opts;
	        };
	
	        WindowChildModel.prototype.destroy = function(manualOverride) {
	          var ref;
	          if (manualOverride == null) {
	            manualOverride = false;
	          }
	          this.remove();
	          if (((this.scope != null) && !((ref = this.scope) != null ? ref.$$destroyed : void 0)) && (this.needToManualDestroy || manualOverride)) {
	            return this.scope.$destroy();
	          }
	        };
	
	        WindowChildModel.prototype.updateModel = function(model) {
	          if (this.isScopeModel) {
	            this.clonedModel = _.clone(model, true);
	          }
	          return _.extend(this.model, this.clonedModel || model);
	        };
	
	        return WindowChildModel;
	
	      })(BaseObject);
	      return WindowChildModel;
	    }
	  ]);
	
	}).call(this);
	;
	/*global _, angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapBasePolysParentModel', [
	    '$timeout', 'uiGmapLogger', 'uiGmapModelKey', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmap_async', 'uiGmapPromise', 'uiGmapFitHelper', function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise, FitHelper) {
	      return function(IPoly, PolyChildModel, gObjectName) {
	        var BasePolysParentModel;
	        return BasePolysParentModel = (function(superClass) {
	          extend(BasePolysParentModel, superClass);
	
	          BasePolysParentModel.include(ModelsWatcher);
	
	          function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
	            this.element = element;
	            this.attrs = attrs;
	            this.gMap = gMap1;
	            this.defaults = defaults;
	            this.maybeFit = bind(this.maybeFit, this);
	            this.createChild = bind(this.createChild, this);
	            this.pieceMeal = bind(this.pieceMeal, this);
	            this.createAllNew = bind(this.createAllNew, this);
	            this.watchIdKey = bind(this.watchIdKey, this);
	            this.createChildScopes = bind(this.createChildScopes, this);
	            this.watchDestroy = bind(this.watchDestroy, this);
	            this.onDestroy = bind(this.onDestroy, this);
	            this.rebuildAll = bind(this.rebuildAll, this);
	            this.doINeedToWipe = bind(this.doINeedToWipe, this);
	            this.watchModels = bind(this.watchModels, this);
	            BasePolysParentModel.__super__.constructor.call(this, scope);
	            this["interface"] = IPoly;
	            this.$log = $log;
	            this.plurals = new PropMap();
	            _.each(IPoly.scopeKeys, (function(_this) {
	              return function(name) {
	                return _this[name + 'Key'] = void 0;
	              };
	            })(this));
	            this.models = void 0;
	            this.firstTime = true;
	            this.$log.info(this);
	            this.createChildScopes();
	          }
	
	          BasePolysParentModel.prototype.watchModels = function(scope) {
	
	            /*
	              This was watchCollection but not all model changes were being caught.
	              TODO: Make the directive flexible in overriding whether we watch models (and depth) via watch or watchColleciton.
	             */
	            return scope.$watch('models', (function(_this) {
	              return function(newValue, oldValue) {
	                if (newValue !== oldValue) {
	                  if (_this.doINeedToWipe(newValue) || scope.doRebuildAll) {
	                    return _this.rebuildAll(scope, true, true);
	                  } else {
	                    return _this.createChildScopes(false);
	                  }
	                }
	              };
	            })(this), true);
	          };
	
	          BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
	            var newValueIsEmpty;
	            newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
	            return this.plurals.length > 0 && newValueIsEmpty;
	          };
	
	          BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
	            return this.onDestroy(doDelete).then((function(_this) {
	              return function() {
	                if (doCreate) {
	                  return _this.createChildScopes();
	                }
	              };
	            })(this));
	          };
	
	          BasePolysParentModel.prototype.onDestroy = function() {
	            BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
	            return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
	              return function() {
	                return _async.each(_this.plurals.values(), function(child) {
	                  return child.destroy(true);
	                }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
	                  var ref;
	                  return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
	                });
	              };
	            })(this));
	          };
	
	          BasePolysParentModel.prototype.watchDestroy = function(scope) {
	            return scope.$on('$destroy', (function(_this) {
	              return function() {
	                return _this.rebuildAll(scope, false, true);
	              };
	            })(this));
	          };
	
	          BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
	            if (isCreatingFromScratch == null) {
	              isCreatingFromScratch = true;
	            }
	            if (angular.isUndefined(this.scope.models)) {
	              this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!");
	              return;
	            }
	            if ((this.gMap == null) || (this.scope.models == null)) {
	              return;
	            }
	            this.watchIdKey(this.scope);
	            if (isCreatingFromScratch) {
	              return this.createAllNew(this.scope, false);
	            } else {
	              return this.pieceMeal(this.scope, false);
	            }
	          };
	
	          BasePolysParentModel.prototype.watchIdKey = function(scope) {
	            this.setIdKey(scope);
	            return scope.$watch('idKey', (function(_this) {
	              return function(newValue, oldValue) {
	                if (newValue !== oldValue && (newValue == null)) {
	                  _this.idKey = newValue;
	                  return _this.rebuildAll(scope, true, true);
	                }
	              };
	            })(this));
	          };
	
	          BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
	            var maybeCanceled;
	            if (isArray == null) {
	              isArray = false;
	            }
	            this.models = scope.models;
	            if (this.firstTime) {
	              this.watchModels(scope);
	              this.watchDestroy(scope);
	            }
	            if (this.didQueueInitPromise(this, scope)) {
	              return;
	            }
	            maybeCanceled = null;
	            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
	              return maybeCanceled = canceledMsg;
	            }), (function(_this) {
	              return function() {
	                return _async.map(scope.models, function(model) {
	                  var child;
	                  child = _this.createChild(model, _this.gMap);
	                  if (maybeCanceled) {
	                    $log.debug('createNew should fall through safely');
	                    child.isEnabled = false;
	                  }
	                  maybeCanceled;
	                  return child.pathPoints.getArray();
	                }, _async.chunkSizeFrom(scope.chunk)).then(function(pathPoints) {
	                  _this.maybeFit(pathPoints);
	                  return _this.firstTime = false;
	                });
	              };
	            })(this));
	          };
	
	          BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
	            var maybeCanceled, payload;
	            if (isArray == null) {
	              isArray = true;
	            }
	            if (scope.$$destroyed) {
	              return;
	            }
	            maybeCanceled = null;
	            payload = null;
	            this.models = scope.models;
	            if ((scope != null) && this.modelsLength() && this.plurals.length) {
	              return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
	                return maybeCanceled = canceledMsg;
	              }), (function(_this) {
	                return function() {
	                  return uiGmapPromise.promise(function() {
	                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
	                  }).then(function(state) {
	                    payload = state;
	                    if (payload.updates.length) {
	                      _async.each(payload.updates, function(obj) {
	                        _.extend(obj.child.scope, obj.model);
	                        return obj.child.model = obj.model;
	                      });
	                    }
	                    return _async.each(payload.removals, function(child) {
	                      if (child != null) {
	                        child.destroy();
	                        _this.plurals.remove(child.model[_this.idKey]);
	                        return maybeCanceled;
	                      }
	                    }, _async.chunkSizeFrom(scope.chunk));
	                  }).then(function() {
	                    return _async.each(payload.adds, function(modelToAdd) {
	                      if (maybeCanceled) {
	                        $log.debug('pieceMeal should fall through safely');
	                      }
	                      _this.createChild(modelToAdd, _this.gMap);
	                      return maybeCanceled;
	                    }, _async.chunkSizeFrom(scope.chunk)).then(function() {
	                      return _this.maybeFit();
	                    });
	                  });
	                };
	              })(this));
	            } else {
	              this.inProgress = false;
	              return this.rebuildAll(this.scope, true, true);
	            }
	          };
	
	          BasePolysParentModel.prototype.createChild = function(model, gMap) {
	            var child, childScope;
	            childScope = this.scope.$new(false);
	            this.setChildScope(IPoly.scopeKeys, childScope, model);
	            childScope.$watch('model', (function(_this) {
	              return function(newValue, oldValue) {
	                if (newValue !== oldValue) {
	                  return _this.setChildScope(IPoly.scopeKeys, childScope, newValue);
	                }
	              };
	            })(this), true);
	            childScope["static"] = this.scope["static"];
	            child = new PolyChildModel({
	              isScopeModel: true,
	              scope: childScope,
	              attrs: this.attrs,
	              gMap: gMap,
	              defaults: this.defaults,
	              model: model,
	              gObjectChangeCb: (function(_this) {
	                return function() {
	                  return _this.maybeFit();
	                };
	              })(this)
	            });
	            if (model[this.idKey] == null) {
	              this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
	              return;
	            }
	            this.plurals.put(model[this.idKey], child);
	            return child;
	          };
	
	          BasePolysParentModel.prototype.maybeFit = function(pathPoints) {
	            if (pathPoints == null) {
	              pathPoints = this.plurals.map(function(p) {
	                return p.pathPoints;
	              });
	            }
	            if (this.scope.fit) {
	              pathPoints = _.flatten(pathPoints);
	              return FitHelper.fit(pathPoints, this.gMap);
	            }
	          };
	
	          return BasePolysParentModel;
	
	        })(ModelKey);
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*globals angular, _, google */
	
	(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapCircleParentModel', [
	    'uiGmapLogger', '$timeout', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapCircleOptionsBuilder', function($log, $timeout, GmapUtil, EventsHelper, Builder) {
	      var CircleParentModel, _settingFromDirective;
	      _settingFromDirective = function(scope, fn) {
	        scope.settingFromDirective = true;
	        fn();
	        return $timeout(function() {
	          return scope.settingFromDirective = false;
	        });
	      };
	      return CircleParentModel = (function(superClass) {
	        extend(CircleParentModel, superClass);
	
	        CircleParentModel.include(GmapUtil);
	
	        CircleParentModel.include(EventsHelper);
	
	        function CircleParentModel(scope, element, attrs, gMap, DEFAULTS) {
	          var clean, gObject, lastRadius;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.DEFAULTS = DEFAULTS;
	          this.scope = scope;
	          lastRadius = null;
	          clean = (function(_this) {
	            return function() {
	              lastRadius = null;
	              if (_this.listeners != null) {
	                _this.removeEvents(_this.listeners);
	                return _this.listeners = void 0;
	              }
	            };
	          })(this);
	          gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
	          this.setMyOptions = (function(_this) {
	            return function(newVals, oldVals) {
	              if (scope.settingFromDirective) {
	                return;
	              }
	              if (!(_.isEqual(newVals, oldVals) && newVals === oldVals && ((newVals != null) && (oldVals != null) ? newVals.coordinates === oldVals.coordinates : true))) {
	                return gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
	              }
	            };
	          })(this);
	          this.props = this.props.concat([
	            {
	              prop: 'center',
	              isColl: true
	            }, {
	              prop: 'fill',
	              isColl: true
	            }, 'radius', 'zIndex'
	          ]);
	          this.watchProps();
	          if (this.scope.control != null) {
	            this.scope.control.getCircle = function() {
	              return gObject;
	            };
	          }
	          clean();
	          this.listeners = this.setEvents(gObject, scope, scope, ['radius_changed']) || [];
	          this.listeners.push(google.maps.event.addListener(gObject, 'radius_changed', function() {
	
	            /*
	              possible google bug, and or because a circle has two radii
	              radius_changed appears to fire twice (original and new) which is not too helpful
	              therefore we will check for radius changes manually and bail out if nothing has changed
	             */
	            var newRadius, work;
	            newRadius = gObject.getRadius();
	            if (newRadius === lastRadius) {
	              return;
	            }
	            lastRadius = newRadius;
	            work = function() {
	              return _settingFromDirective(scope, function() {
	                var ref, ref1;
	                if (newRadius !== scope.radius) {
	                  scope.radius = newRadius;
	                }
	                if (((ref = scope.events) != null ? ref.radius_changed : void 0) && _.isFunction((ref1 = scope.events) != null ? ref1.radius_changed : void 0)) {
	                  return scope.events.radius_changed(gObject, 'radius_changed', scope, arguments);
	                }
	              });
	            };
	            if (!angular.mock) {
	              return scope.$evalAsync(function() {
	                return work();
	              });
	            } else {
	              return work();
	            }
	          }));
	          this.listeners.push(google.maps.event.addListener(gObject, 'center_changed', function() {
	            return scope.$evalAsync(function() {
	              return _settingFromDirective(scope, function() {
	                if (angular.isDefined(scope.center.type)) {
	                  scope.center.coordinates[1] = gObject.getCenter().lat();
	                  return scope.center.coordinates[0] = gObject.getCenter().lng();
	                } else {
	                  scope.center.latitude = gObject.getCenter().lat();
	                  return scope.center.longitude = gObject.getCenter().lng();
	                }
	              });
	            });
	          }));
	          scope.$on('$destroy', function() {
	            clean();
	            return gObject.setMap(null);
	          });
	          $log.info(this);
	        }
	
	        return CircleParentModel;
	
	      })(Builder);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapDrawingManagerParentModel', [
	    'uiGmapLogger', '$timeout', 'uiGmapBaseObject', 'uiGmapEventsHelper', function($log, $timeout, BaseObject, EventsHelper) {
	      var DrawingManagerParentModel;
	      return DrawingManagerParentModel = (function(superClass) {
	        extend(DrawingManagerParentModel, superClass);
	
	        DrawingManagerParentModel.include(EventsHelper);
	
	        function DrawingManagerParentModel(scope, element, attrs, map) {
	          var gObject, listeners;
	          this.scope = scope;
	          this.attrs = attrs;
	          this.map = map;
	          gObject = new google.maps.drawing.DrawingManager(this.scope.options);
	          gObject.setMap(this.map);
	          listeners = void 0;
	          if (this.scope.control != null) {
	            this.scope.control.getDrawingManager = function() {
	              return gObject;
	            };
	          }
	          if (!this.scope["static"] && this.scope.options) {
	            this.scope.$watch('options', function(newValue) {
	              return gObject != null ? gObject.setOptions(newValue) : void 0;
	            }, true);
	          }
	          if (this.scope.events != null) {
	            listeners = this.setEvents(gObject, this.scope, this.scope);
	            this.scope.$watch('events', (function(_this) {
	              return function(newValue, oldValue) {
	                if (!_.isEqual(newValue, oldValue)) {
	                  if (listeners != null) {
	                    _this.removeEvents(listeners);
	                  }
	                  return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
	                }
	              };
	            })(this));
	          }
	          this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              if (listeners != null) {
	                _this.removeEvents(listeners);
	              }
	              gObject.setMap(null);
	              return gObject = null;
	            };
	          })(this));
	        }
	
	        return DrawingManagerParentModel;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;
	/*
		- interface for all markers to derrive from
	 	- to enforce a minimum set of requirements
	 		- attributes
	 			- coords
	 			- icon
			- implementation needed on watches
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", [
	    "uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
	      var IMarkerParentModel;
	      IMarkerParentModel = (function(superClass) {
	        extend(IMarkerParentModel, superClass);
	
	        IMarkerParentModel.prototype.DEFAULTS = {};
	
	        function IMarkerParentModel(scope1, element, attrs, map) {
	          this.scope = scope1;
	          this.element = element;
	          this.attrs = attrs;
	          this.map = map;
	          this.onWatch = bind(this.onWatch, this);
	          this.watch = bind(this.watch, this);
	          this.validateScope = bind(this.validateScope, this);
	          IMarkerParentModel.__super__.constructor.call(this, this.scope);
	          this.$log = Logger;
	          if (!this.validateScope(this.scope)) {
	            throw new String("Unable to construct IMarkerParentModel due to invalid scope");
	          }
	          this.doClick = angular.isDefined(this.attrs.click);
	          if (this.scope.options != null) {
	            this.DEFAULTS = this.scope.options;
	          }
	          this.watch('coords', this.scope);
	          this.watch('icon', this.scope);
	          this.watch('options', this.scope);
	          this.scope.$on("$destroy", (function(_this) {
	            return function() {
	              return _this.onDestroy(_this.scope);
	            };
	          })(this));
	        }
	
	        IMarkerParentModel.prototype.validateScope = function(scope) {
	          var ret;
	          if (scope == null) {
	            this.$log.error(this.constructor.name + ": invalid scope used");
	            return false;
	          }
	          ret = scope.coords != null;
	          if (!ret) {
	            this.$log.error(this.constructor.name + ": no valid coords attribute found");
	            return false;
	          }
	          return ret;
	        };
	
	        IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
	          if (equalityCheck == null) {
	            equalityCheck = true;
	          }
	          return scope.$watch(propNameToWatch, (function(_this) {
	            return function(newValue, oldValue) {
	              if (!_.isEqual(newValue, oldValue)) {
	                return _this.onWatch(propNameToWatch, scope, newValue, oldValue);
	              }
	            };
	          })(this), equalityCheck);
	        };
	
	        IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
	
	        return IMarkerParentModel;
	
	      })(ModelKey);
	      return IMarkerParentModel;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", [
	    "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
	      var IWindowParentModel;
	      return IWindowParentModel = (function(superClass) {
	        extend(IWindowParentModel, superClass);
	
	        IWindowParentModel.include(GmapUtil);
	
	        function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
	          IWindowParentModel.__super__.constructor.call(this, scope);
	          this.$log = Logger;
	          this.$timeout = $timeout;
	          this.$compile = $compile;
	          this.$http = $http;
	          this.$templateCache = $templateCache;
	          this.DEFAULTS = {};
	          if (scope.options != null) {
	            this.DEFAULTS = scope.options;
	          }
	        }
	
	        IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
	          if (modelsPropToIterate === 'models') {
	            return scope[modelsPropToIterate][index];
	          }
	          return scope[modelsPropToIterate].get(index);
	        };
	
	        return IWindowParentModel;
	
	      })(ModelKey);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapLayerParentModel', [
	    'uiGmapBaseObject', 'uiGmapLogger', '$timeout', function(BaseObject, Logger, $timeout) {
	      var LayerParentModel;
	      LayerParentModel = (function(superClass) {
	        extend(LayerParentModel, superClass);
	
	        function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
	          this.scope = scope;
	          this.element = element;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.onLayerCreated = onLayerCreated != null ? onLayerCreated : void 0;
	          this.$log = $log != null ? $log : Logger;
	          this.createGoogleLayer = bind(this.createGoogleLayer, this);
	          if (this.attrs.type == null) {
	            this.$log.info('type attribute for the layer directive is mandatory. Layer creation aborted!!');
	            return;
	          }
	          this.createGoogleLayer();
	          this.doShow = true;
	          if (angular.isDefined(this.attrs.show)) {
	            this.doShow = this.scope.show;
	          }
	          if (this.doShow && (this.gMap != null)) {
	            this.gObject.setMap(this.gMap);
	          }
	          this.scope.$watch('show', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                _this.doShow = newValue;
	                if (newValue) {
	                  return _this.gObject.setMap(_this.gMap);
	                } else {
	                  return _this.gObject.setMap(null);
	                }
	              }
	            };
	          })(this), true);
	          this.scope.$watch('options', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue && _this.doShow) {
	                return _this.gObject.setOptions(newValue);
	              }
	            };
	          })(this), true);
	          this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              return _this.gObject.setMap(null);
	            };
	          })(this));
	        }
	
	        LayerParentModel.prototype.createGoogleLayer = function() {
	          var base;
	          if (this.attrs.options == null) {
	            this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]();
	          } else {
	            this.gObject = this.attrs.namespace === void 0 ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
	          }
	          if ((this.gObject != null) && this.doShow) {
	            this.gObject.setMap(this.gMap);
	          }
	          if ((this.gObject != null) && (this.onLayerCreated != null)) {
	            return typeof (base = this.onLayerCreated(this.scope, this.gObject)) === "function" ? base(this.gObject) : void 0;
	          }
	        };
	
	        return LayerParentModel;
	
	      })(BaseObject);
	      return LayerParentModel;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapMapTypeParentModel', [
	    'uiGmapBaseObject', 'uiGmapLogger', function(BaseObject, Logger) {
	      var MapTypeParentModel;
	      MapTypeParentModel = (function(superClass) {
	        extend(MapTypeParentModel, superClass);
	
	        function MapTypeParentModel(scope, element, attrs, gMap, $log, childModel, propMap) {
	          var watchChildModelOptions, watchChildModelShow, watchOptions, watchShow;
	          this.scope = scope;
	          this.element = element;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.$log = $log != null ? $log : Logger;
	          this.childModel = childModel;
	          this.propMap = propMap;
	          this.refreshShown = bind(this.refreshShown, this);
	          this.hideOverlay = bind(this.hideOverlay, this);
	          this.showOverlay = bind(this.showOverlay, this);
	          this.refreshMapType = bind(this.refreshMapType, this);
	          this.createMapType = bind(this.createMapType, this);
	          if (this.scope.options == null) {
	            this.$log.info('options attribute for the map-type directive is mandatory. Map type creation aborted!!');
	            return;
	          }
	          this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
	          this.doShow = true;
	          this.createMapType();
	          this.refreshShown();
	          if (this.doShow && (this.gMap != null)) {
	            this.showOverlay();
	          }
	          watchChildModelShow = (function(_this) {
	            return function() {
	              return _this.childModel[_this.attrs.show];
	            };
	          })(this);
	          watchShow = this.childModel ? watchChildModelShow : 'show';
	          this.scope.$watch(watchShow, (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                _this.doShow = newValue;
	                if (newValue) {
	                  return _this.showOverlay();
	                } else {
	                  return _this.hideOverlay();
	                }
	              }
	            };
	          })(this));
	          watchChildModelOptions = (function(_this) {
	            return function() {
	              return _this.childModel[_this.attrs.options];
	            };
	          })(this);
	          watchOptions = this.childModel ? watchChildModelOptions : 'options';
	          this.scope.$watchCollection(watchOptions, (function(_this) {
	            return function(newValue, oldValue) {
	              var different, mapTypeProps;
	              if (!_.isEqual(newValue, oldValue)) {
	                mapTypeProps = ['tileSize', 'maxZoom', 'minZoom', 'name', 'alt'];
	                different = _.some(mapTypeProps, function(prop) {
	                  return !oldValue || !newValue || !_.isEqual(newValue[prop], oldValue[prop]);
	                });
	                if (different) {
	                  return _this.refreshMapType();
	                }
	              }
	            };
	          })(this));
	          if (angular.isDefined(this.attrs.refresh)) {
	            this.scope.$watch('refresh', (function(_this) {
	              return function(newValue, oldValue) {
	                if (!_.isEqual(newValue, oldValue)) {
	                  return _this.refreshMapType();
	                }
	              };
	            })(this), true);
	          }
	          this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              _this.hideOverlay();
	              return _this.mapType = null;
	            };
	          })(this));
	        }
	
	        MapTypeParentModel.prototype.createMapType = function() {
	          var id, idAttr, mapType;
	          mapType = this.childModel ? (this.attrs.options ? this.childModel[this.attrs.options] : this.childModel) : this.scope.options;
	          if (mapType.getTile != null) {
	            this.mapType = mapType;
	          } else if (mapType.getTileUrl != null) {
	            this.mapType = new google.maps.ImageMapType(mapType);
	          } else {
	            this.$log.info('options should provide either getTile or getTileUrl methods. Map type creation aborted!!');
	            return;
	          }
	          idAttr = this.attrs.id ? (this.childModel ? this.attrs.id : 'id') : void 0;
	          id = idAttr ? (this.childModel ? this.childModel[idAttr] : this.scope[idAttr]) : void 0;
	          if (id) {
	            this.gMap.mapTypes.set(id, this.mapType);
	            if (!angular.isDefined(this.attrs.show)) {
	              this.doShow = false;
	            }
	          }
	          this.mapType.layerId = this.id;
	          if (this.childModel && angular.isDefined(this.scope.index)) {
	            return this.propMap.put(this.mapType.layerId, this.scope.index);
	          }
	        };
	
	        MapTypeParentModel.prototype.refreshMapType = function() {
	          this.hideOverlay();
	          this.mapType = null;
	          this.createMapType();
	          if (this.doShow && (this.gMap != null)) {
	            return this.showOverlay();
	          }
	        };
	
	        MapTypeParentModel.prototype.showOverlay = function() {
	          var found;
	          if (angular.isDefined(this.scope.index)) {
	            found = false;
	            if (this.gMap.overlayMapTypes.getLength()) {
	              this.gMap.overlayMapTypes.forEach((function(_this) {
	                return function(mapType, index) {
	                  var layerIndex;
	                  if (!found) {
	                    layerIndex = _this.propMap.get(mapType.layerId.toString());
	                    if (layerIndex > _this.scope.index || !angular.isDefined(layerIndex)) {
	                      found = true;
	                      _this.gMap.overlayMapTypes.insertAt(index, _this.mapType);
	                    }
	                  }
	                };
	              })(this));
	              if (!found) {
	                return this.gMap.overlayMapTypes.push(this.mapType);
	              }
	            } else {
	              return this.gMap.overlayMapTypes.push(this.mapType);
	            }
	          } else {
	            return this.gMap.overlayMapTypes.push(this.mapType);
	          }
	        };
	
	        MapTypeParentModel.prototype.hideOverlay = function() {
	          var found;
	          found = false;
	          return this.gMap.overlayMapTypes.forEach((function(_this) {
	            return function(mapType, index) {
	              if (!found && mapType.layerId === _this.id) {
	                found = true;
	                _this.gMap.overlayMapTypes.removeAt(index);
	              }
	            };
	          })(this));
	        };
	
	        MapTypeParentModel.prototype.refreshShown = function() {
	          return this.doShow = angular.isDefined(this.attrs.show) ? (this.childModel ? this.childModel[this.attrs.show] : this.scope.show) : true;
	        };
	
	        return MapTypeParentModel;
	
	      })(BaseObject);
	      return MapTypeParentModel;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapMapTypesParentModel', [
	    'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapMapTypeParentModel', 'uiGmapPropMap', function(BaseObject, Logger, MapTypeParentModel, PropMap) {
	      var MapTypesParentModel;
	      MapTypesParentModel = (function(superClass) {
	        extend(MapTypesParentModel, superClass);
	
	        function MapTypesParentModel(scope, element, attrs, gMap, $log) {
	          var pMap;
	          this.scope = scope;
	          this.element = element;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.$log = $log != null ? $log : Logger;
	          if (this.attrs.mapTypes == null) {
	            this.$log.info('layers attribute for the map-types directive is mandatory. Map types creation aborted!!');
	            return;
	          }
	          pMap = new PropMap;
	          this.scope.mapTypes.forEach((function(_this) {
	            return function(l, i) {
	              var childScope, mockAttr;
	              mockAttr = {
	                options: _this.scope.options,
	                show: _this.scope.show,
	                refresh: _this.scope.refresh
	              };
	              childScope = _this.scope.$new();
	              childScope.index = i;
	              new MapTypeParentModel(childScope, null, mockAttr, _this.gMap, _this.$log, l, pMap);
	            };
	          })(this));
	        }
	
	        return MapTypesParentModel;
	
	      })(BaseObject);
	      return MapTypesParentModel;
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true,angular:true, */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", [
	    "uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapSpiderfierMarkerManager", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log, SpiderfierMarkerManager) {
	      var MarkersParentModel, _setPlurals;
	      _setPlurals = function(val, objToSet) {
	        objToSet.plurals = new PropMap();
	        objToSet.scope.plurals = objToSet.plurals;
	        return objToSet;
	      };
	      MarkersParentModel = (function(superClass) {
	        extend(MarkersParentModel, superClass);
	
	        MarkersParentModel.include(GmapUtil);
	
	        MarkersParentModel.include(ModelsWatcher);
	
	        function MarkersParentModel(scope, element, attrs, map) {
	          this.maybeExecMappedEvent = bind(this.maybeExecMappedEvent, this);
	          this.onDestroy = bind(this.onDestroy, this);
	          this.newChildMarker = bind(this.newChildMarker, this);
	          this.pieceMeal = bind(this.pieceMeal, this);
	          this.rebuildAll = bind(this.rebuildAll, this);
	          this.createAllNew = bind(this.createAllNew, this);
	          this.bindToTypeEvents = bind(this.bindToTypeEvents, this);
	          this.createChildScopes = bind(this.createChildScopes, this);
	          this.validateScope = bind(this.validateScope, this);
	          this.onWatch = bind(this.onWatch, this);
	          MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
	          this["interface"] = IMarker;
	          _setPlurals(new PropMap(), this);
	          this.scope.pluralsUpdate = {
	            updateCtr: 0
	          };
	          this.$log.info(this);
	          this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
	          this.setIdKey(this.scope);
	          this.scope.$watch('doRebuildAll', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                return _this.doRebuildAll = newValue;
	              }
	            };
	          })(this));
	          if (!this.modelsLength()) {
	            this.modelsRendered = false;
	          }
	          this.scope.$watch('models', (function(_this) {
	            return function(newValue, oldValue) {
	              if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
	                if (newValue.length === 0 && oldValue.length === 0) {
	                  return;
	                }
	                _this.modelsRendered = true;
	                return _this.onWatch('models', _this.scope, newValue, oldValue);
	              }
	            };
	          })(this), !this.isTrue(attrs.modelsbyref));
	          this.watch('doCluster', this.scope);
	          this.watch('type', this.scope);
	          this.watch('clusterOptions', this.scope);
	          this.watch('clusterEvents', this.scope);
	          this.watch('typeOptions', this.scope);
	          this.watch('typeEvents', this.scope);
	          this.watch('fit', this.scope);
	          this.watch('idKey', this.scope);
	          this.gManager = void 0;
	          this.createAllNew(this.scope);
	        }
	
	        MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
	          if (propNameToWatch === "idKey" && newValue !== oldValue) {
	            this.idKey = newValue;
	          }
	          if (this.doRebuildAll || (propNameToWatch === 'doCluster' || propNameToWatch === 'type')) {
	            return this.rebuildAll(scope);
	          } else {
	            return this.pieceMeal(scope);
	          }
	        };
	
	        MarkersParentModel.prototype.validateScope = function(scope) {
	          var modelsNotDefined;
	          modelsNotDefined = angular.isUndefined(scope.models) || scope.models === void 0;
	          if (modelsNotDefined) {
	            this.$log.error(this.constructor.name + ": no valid models attribute found");
	          }
	          return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
	        };
	
	
	        /*
	        Not used internally by this parent
	        created for consistency for external control in the API
	         */
	
	        MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
	          if ((this.gMap == null) || (this.scope.models == null)) {
	            return;
	          }
	          if (isCreatingFromScratch) {
	            return this.createAllNew(this.scope, false);
	          } else {
	            return this.pieceMeal(this.scope, false);
	          }
	        };
	
	        MarkersParentModel.prototype.bindToTypeEvents = function(typeEvents, events) {
	          var internalHandles, self;
	          if (events == null) {
	            events = ['click', 'mouseout', 'mouseover'];
	          }
	
	          /*
	            You should only be binding to events that produce groups/clusters of somthing.
	            Otherwise use the orginal event handle.
	            For Example: Click on a cluster pushes a cluster/group obj through which has getMarkers
	            However Spiderfy's click is for a single marker so this is not ideal for that.
	           */
	          self = this;
	          if (!this.origTypeEvents) {
	            this.origTypeEvents = {};
	            _.each(events, (function(_this) {
	              return function(eventName) {
	                return _this.origTypeEvents[eventName] = typeEvents != null ? typeEvents[eventName] : void 0;
	              };
	            })(this));
	          } else {
	            angular.extend(typeEvents, this.origTypeEvents);
	          }
	          internalHandles = {};
	          _.each(events, function(eventName) {
	            return internalHandles[eventName] = function(group) {
	              return self.maybeExecMappedEvent(group, eventName);
	            };
	          });
	          return angular.extend(typeEvents, internalHandles);
	        };
	
	        MarkersParentModel.prototype.createAllNew = function(scope) {
	          var isSpiderfied, maybeCanceled, typeEvents, typeOptions;
	          if (this.gManager != null) {
	            if (this.gManager instanceof SpiderfierMarkerManager) {
	              isSpiderfied = this.gManager.isSpiderfied();
	            }
	            this.gManager.clear();
	            delete this.gManager;
	          }
	          typeEvents = scope.typeEvents || scope.clusterEvents;
	          typeOptions = scope.typeOptions || scope.clusterOptions;
	          if (scope.doCluster || scope.type === 'cluster') {
	            if (typeEvents != null) {
	              this.bindToTypeEvents(typeEvents);
	            }
	            this.gManager = new ClustererMarkerManager(this.map, void 0, typeOptions, typeEvents);
	          } else if (scope.type === 'spider') {
	            if (typeEvents != null) {
	              this.bindToTypeEvents(typeEvents, ['spiderfy', 'unspiderfy']);
	            }
	            this.gManager = new SpiderfierMarkerManager(this.map, void 0, typeOptions, typeEvents, this.scope);
	            if (isSpiderfied) {
	              this.gManager.spiderfy();
	            }
	          } else {
	            this.gManager = new MarkerManager(this.map);
	          }
	          if (this.didQueueInitPromise(this, scope)) {
	            return;
	          }
	          maybeCanceled = null;
	          return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
	            return maybeCanceled = canceledMsg;
	          }), (function(_this) {
	            return function() {
	              return _async.each(scope.models, function(model) {
	                _this.newChildMarker(model, scope);
	                return maybeCanceled;
	              }, _async.chunkSizeFrom(scope.chunk)).then(function() {
	                _this.modelsRendered = true;
	                if (scope.fit) {
	                  _this.gManager.fit();
	                }
	                _this.gManager.draw();
	                return _this.scope.pluralsUpdate.updateCtr += 1;
	              }, _async.chunkSizeFrom(scope.chunk));
	            };
	          })(this));
	        };
	
	        MarkersParentModel.prototype.rebuildAll = function(scope) {
	          var ref;
	          if (!scope.doRebuild && scope.doRebuild !== void 0) {
	            return;
	          }
	          if ((ref = this.scope.plurals) != null ? ref.length : void 0) {
	            return this.onDestroy(scope).then((function(_this) {
	              return function() {
	                return _this.createAllNew(scope);
	              };
	            })(this));
	          } else {
	            return this.createAllNew(scope);
	          }
	        };
	
	        MarkersParentModel.prototype.pieceMeal = function(scope) {
	          var maybeCanceled, payload;
	          if (scope.$$destroyed) {
	            return;
	          }
	          maybeCanceled = null;
	          payload = null;
	          if (this.modelsLength() && this.scope.plurals.length) {
	            return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
	              return maybeCanceled = canceledMsg;
	            }), (function(_this) {
	              return function() {
	                return uiGmapPromise.promise((function() {
	                  return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
	                })).then(function(state) {
	                  payload = state;
	                  return _async.each(payload.removals, function(child) {
	                    if (child != null) {
	                      if (child.destroy != null) {
	                        child.destroy();
	                      }
	                      _this.scope.plurals.remove(child.id);
	                      return maybeCanceled;
	                    }
	                  }, _async.chunkSizeFrom(scope.chunk));
	                }).then(function() {
	                  return _async.each(payload.adds, function(modelToAdd) {
	                    _this.newChildMarker(modelToAdd, scope);
	                    return maybeCanceled;
	                  }, _async.chunkSizeFrom(scope.chunk));
	                }).then(function() {
	                  return _async.each(payload.updates, function(update) {
	                    _this.updateChild(update.child, update.model);
	                    return maybeCanceled;
	                  }, _async.chunkSizeFrom(scope.chunk));
	                }).then(function() {
	                  if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
	                    scope.plurals = _this.scope.plurals;
	                    if (scope.fit) {
	                      _this.gManager.fit();
	                    }
	                    _this.gManager.draw();
	                  }
	                  return _this.scope.pluralsUpdate.updateCtr += 1;
	                });
	              };
	            })(this));
	          } else {
	            this.inProgress = false;
	            return this.rebuildAll(scope);
	          }
	        };
	
	        MarkersParentModel.prototype.newChildMarker = function(model, scope) {
	          var child, childScope, keys;
	          if (!model) {
	            throw 'model undefined';
	          }
	          if (model[this.idKey] == null) {
	            this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
	            return;
	          }
	          this.$log.info('child', child, 'markers', this.scope.markerModels);
	          childScope = scope.$new(false);
	          childScope.events = scope.events;
	          keys = {};
	          IMarker.scopeKeys.forEach(function(k) {
	            return keys[k] = scope[k];
	          });
	          child = new MarkerChildModel({
	            scope: childScope,
	            model: model,
	            keys: keys,
	            gMap: this.map,
	            defaults: this.DEFAULTS,
	            doClick: this.doClick,
	            gManager: this.gManager,
	            doDrawSelf: false,
	            isScopeModel: true
	          });
	          this.scope.plurals.put(model[this.idKey], child);
	          return child;
	        };
	
	        MarkersParentModel.prototype.onDestroy = function(scope) {
	          MarkersParentModel.__super__.onDestroy.call(this, scope);
	          return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
	            return function() {
	              return _async.each(_this.scope.plurals.values(), function(model) {
	                if (model != null) {
	                  return model.destroy(false);
	                }
	              }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
	                if (_this.gManager != null) {
	                  _this.gManager.destroy();
	                }
	                _this.plurals.removeAll();
	                if (_this.plurals !== _this.scope.plurals) {
	                  console.error('plurals out of sync for MarkersParentModel');
	                }
	                return _this.scope.pluralsUpdate.updateCtr += 1;
	              });
	            };
	          })(this));
	        };
	
	        MarkersParentModel.prototype.maybeExecMappedEvent = function(group, fnName) {
	          var pair, typeEvents;
	          if (this.scope.$$destroyed) {
	            return;
	          }
	          typeEvents = this.scope.typeEvents || this.scope.clusterEvents;
	          if (_.isFunction(typeEvents != null ? typeEvents[fnName] : void 0)) {
	            pair = this.mapTypeToPlurals(group);
	            if (this.origTypeEvents[fnName]) {
	              return this.origTypeEvents[fnName](pair.group, pair.mapped);
	            }
	          }
	        };
	
	        MarkersParentModel.prototype.mapTypeToPlurals = function(group) {
	          var arrayToMap, mapped, ref;
	          if (_.isArray(group)) {
	            arrayToMap = group;
	          } else if (_.isFunction(group.getMarkers)) {
	            arrayToMap = group.getMarkers();
	          }
	          if (arrayToMap == null) {
	            $log.error("Unable to map event as we cannot find the array group to map");
	            return;
	          }
	          if ((ref = this.scope.plurals.values()) != null ? ref.length : void 0) {
	            mapped = arrayToMap.map((function(_this) {
	              return function(g) {
	                return _this.scope.plurals.get(g.key).model;
	              };
	            })(this));
	          } else {
	            mapped = [];
	          }
	          return {
	            cluster: group,
	            mapped: mapped,
	            group: group
	          };
	        };
	
	        MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
	          if (modelsPropToIterate === 'models') {
	            return scope[modelsPropToIterate][index];
	          }
	          return scope[modelsPropToIterate].get(index);
	        };
	
	        return MarkersParentModel;
	
	      })(IMarkerParentModel);
	      return MarkersParentModel;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  ['Polygon', 'Polyline'].forEach(function(name) {
	    return angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory("uiGmap" + name + "sParentModel", [
	      'uiGmapBasePolysParentModel', "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
	        return BasePolysParentModel(IPoly, ChildModel, name);
	      }
	    ]);
	  });
	
	}).call(this);
	;
	/*globals angular, _, google */
	
	(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapRectangleParentModel', [
	    'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', 'uiGmapRectangleOptionsBuilder', function($log, GmapUtil, EventsHelper, Builder) {
	      var RectangleParentModel;
	      return RectangleParentModel = (function(superClass) {
	        extend(RectangleParentModel, superClass);
	
	        RectangleParentModel.include(GmapUtil);
	
	        RectangleParentModel.include(EventsHelper);
	
	        function RectangleParentModel(scope, element, attrs, gMap, DEFAULTS) {
	          var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
	          this.scope = scope;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.DEFAULTS = DEFAULTS;
	          bounds = void 0;
	          dragging = false;
	          myListeners = [];
	          listeners = void 0;
	          fit = (function(_this) {
	            return function() {
	              if (_this.isTrue(_this.attrs.fit)) {
	                return _this.fitMapBounds(_this.gMap, bounds);
	              }
	            };
	          })(this);
	          createBounds = (function(_this) {
	            return function() {
	              var ref, ref1, ref2;
	              if ((_this.scope.bounds != null) && (((ref = _this.scope.bounds) != null ? ref.sw : void 0) != null) && (((ref1 = _this.scope.bounds) != null ? ref1.ne : void 0) != null) && _this.validateBoundPoints(_this.scope.bounds)) {
	                bounds = _this.convertBoundPoints(_this.scope.bounds);
	                return $log.info("new new bounds created: " + (JSON.stringify(bounds)));
	              } else if ((_this.scope.bounds.getNorthEast != null) && (_this.scope.bounds.getSouthWest != null)) {
	                return bounds = _this.scope.bounds;
	              } else {
	                if (_this.scope.bounds != null) {
	                  return $log.error("Invalid bounds for newValue: " + (JSON.stringify((ref2 = _this.scope) != null ? ref2.bounds : void 0)));
	                }
	              }
	            };
	          })(this);
	          createBounds();
	          gObject = new google.maps.Rectangle(this.buildOpts(bounds));
	          $log.info("gObject (rectangle) created: " + gObject);
	          settingBoundsFromScope = false;
	          updateBounds = (function(_this) {
	            return function() {
	              var b, ne, sw;
	              b = gObject.getBounds();
	              ne = b.getNorthEast();
	              sw = b.getSouthWest();
	              if (settingBoundsFromScope) {
	                return;
	              }
	              return _this.scope.$evalAsync(function(s) {
	                if ((s.bounds != null) && (s.bounds.sw != null) && (s.bounds.ne != null)) {
	                  s.bounds.ne = {
	                    latitude: ne.lat(),
	                    longitude: ne.lng()
	                  };
	                  s.bounds.sw = {
	                    latitude: sw.lat(),
	                    longitude: sw.lng()
	                  };
	                }
	                if ((s.bounds.getNorthEast != null) && (s.bounds.getSouthWest != null)) {
	                  return s.bounds = b;
	                }
	              });
	            };
	          })(this);
	          init = (function(_this) {
	            return function() {
	              fit();
	              _this.removeEvents(myListeners);
	              myListeners.push(google.maps.event.addListener(gObject, 'dragstart', function() {
	                return dragging = true;
	              }));
	              myListeners.push(google.maps.event.addListener(gObject, 'dragend', function() {
	                dragging = false;
	                return updateBounds();
	              }));
	              return myListeners.push(google.maps.event.addListener(gObject, 'bounds_changed', function() {
	                if (dragging) {
	                  return;
	                }
	                return updateBounds();
	              }));
	            };
	          })(this);
	          clear = (function(_this) {
	            return function() {
	              _this.removeEvents(myListeners);
	              if (listeners != null) {
	                _this.removeEvents(listeners);
	              }
	              return gObject.setMap(null);
	            };
	          })(this);
	          if (bounds != null) {
	            init();
	          }
	          this.scope.$watch('bounds', (function(newValue, oldValue) {
	            var isNew;
	            if (_.isEqual(newValue, oldValue) && (bounds != null) || dragging) {
	              return;
	            }
	            settingBoundsFromScope = true;
	            if (newValue == null) {
	              clear();
	              return;
	            }
	            if (bounds == null) {
	              isNew = true;
	            } else {
	              fit();
	            }
	            createBounds();
	            gObject.setBounds(bounds);
	            settingBoundsFromScope = false;
	            if (isNew && (bounds != null)) {
	              return init();
	            }
	          }), true);
	          this.setMyOptions = (function(_this) {
	            return function(newVals, oldVals) {
	              if (!_.isEqual(newVals, oldVals)) {
	                if ((bounds != null) && (newVals != null)) {
	                  return gObject.setOptions(_this.buildOpts(bounds));
	                }
	              }
	            };
	          })(this);
	          this.props.push('bounds');
	          this.watchProps(this.props);
	          if (this.attrs.events != null) {
	            listeners = this.setEvents(gObject, this.scope, this.scope);
	            this.scope.$watch('events', (function(_this) {
	              return function(newValue, oldValue) {
	                if (!_.isEqual(newValue, oldValue)) {
	                  if (listeners != null) {
	                    _this.removeEvents(listeners);
	                  }
	                  return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
	                }
	              };
	            })(this));
	          }
	          this.scope.$on('$destroy', function() {
	            return clear();
	          });
	          $log.info(this);
	        }
	
	        return RectangleParentModel;
	
	      })(Builder);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular:true, google:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapSearchBoxParentModel', [
	    'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapEventsHelper', function(BaseObject, Logger, EventsHelper) {
	      var SearchBoxParentModel;
	      SearchBoxParentModel = (function(superClass) {
	        extend(SearchBoxParentModel, superClass);
	
	        SearchBoxParentModel.include(EventsHelper);
	
	        function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
	          var controlDiv;
	          this.scope = scope;
	          this.element = element;
	          this.attrs = attrs;
	          this.gMap = gMap;
	          this.ctrlPosition = ctrlPosition;
	          this.template = template;
	          this.$log = $log != null ? $log : Logger;
	          this.setVisibility = bind(this.setVisibility, this);
	          this.getBounds = bind(this.getBounds, this);
	          this.setBounds = bind(this.setBounds, this);
	          this.createSearchBox = bind(this.createSearchBox, this);
	          this.addToParentDiv = bind(this.addToParentDiv, this);
	          this.addAsMapControl = bind(this.addAsMapControl, this);
	          this.init = bind(this.init, this);
	          if (this.attrs.template == null) {
	            this.$log.error('template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!');
	            return;
	          }
	          if (angular.isUndefined(this.scope.options)) {
	            this.scope.options = {};
	            this.scope.options.visible = true;
	          }
	          if (angular.isUndefined(this.scope.options.visible)) {
	            this.scope.options.visible = true;
	          }
	          if (angular.isUndefined(this.scope.options.autocomplete)) {
	            this.scope.options.autocomplete = false;
	          }
	          this.visible = this.scope.options.visible;
	          this.autocomplete = this.scope.options.autocomplete;
	          controlDiv = angular.element('<div></div>');
	          controlDiv.append(this.template);
	          this.input = controlDiv.find('input')[0];
	          this.init();
	        }
	
	        SearchBoxParentModel.prototype.init = function() {
	          this.createSearchBox();
	          this.scope.$watch('options', (function(_this) {
	            return function(newValue, oldValue) {
	              if (angular.isObject(newValue)) {
	                if (newValue.bounds != null) {
	                  _this.setBounds(newValue.bounds);
	                }
	                if (newValue.visible != null) {
	                  if (_this.visible !== newValue.visible) {
	                    return _this.setVisibility(newValue.visible);
	                  }
	                }
	              }
	            };
	          })(this), true);
	          if (this.attrs.parentdiv != null) {
	            this.addToParentDiv();
	          } else {
	            this.addAsMapControl();
	          }
	          if (!this.visible) {
	            this.setVisibility(this.visible);
	          }
	          if (this.autocomplete) {
	            this.listener = google.maps.event.addListener(this.gObject, 'place_changed', (function(_this) {
	              return function() {
	                return _this.places = _this.gObject.getPlace();
	              };
	            })(this));
	          } else {
	            this.listener = google.maps.event.addListener(this.gObject, 'places_changed', (function(_this) {
	              return function() {
	                return _this.places = _this.gObject.getPlaces();
	              };
	            })(this));
	          }
	          this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
	          this.$log.info(this);
	          this.scope.$on('$stateChangeSuccess', (function(_this) {
	            return function() {
	              if (_this.attrs.parentdiv != null) {
	                return _this.addToParentDiv();
	              }
	            };
	          })(this));
	          return this.scope.$on('$destroy', (function(_this) {
	            return function() {
	              return _this.gObject = null;
	            };
	          })(this));
	        };
	
	        SearchBoxParentModel.prototype.addAsMapControl = function() {
	          return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
	        };
	
	        SearchBoxParentModel.prototype.addToParentDiv = function() {
	          var ref;
	          this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
	          if ((ref = this.parentDiv) != null ? ref.length : void 0) {
	            return this.parentDiv.append(this.input);
	          }
	        };
	
	        SearchBoxParentModel.prototype.createSearchBox = function() {
	          if (this.autocomplete) {
	            return this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options);
	          } else {
	            return this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
	          }
	        };
	
	        SearchBoxParentModel.prototype.setBounds = function(bounds) {
	          if (angular.isUndefined(bounds.isEmpty)) {
	            this.$log.error('Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds.');
	          } else {
	            if (bounds.isEmpty() === false) {
	              if (this.gObject != null) {
	                return this.gObject.setBounds(bounds);
	              }
	            }
	          }
	        };
	
	        SearchBoxParentModel.prototype.getBounds = function() {
	          return this.gObject.getBounds();
	        };
	
	        SearchBoxParentModel.prototype.setVisibility = function(val) {
	          if (this.attrs.parentdiv != null) {
	            if (val === false) {
	              this.parentDiv.addClass("ng-hide");
	            } else {
	              this.parentDiv.removeClass("ng-hide");
	            }
	          } else {
	            if (val === false) {
	              this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear();
	            } else {
	              this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
	            }
	          }
	          return this.visible = val;
	        };
	
	        return SearchBoxParentModel;
	
	      })(BaseObject);
	      return SearchBoxParentModel;
	    }
	  ]);
	
	}).call(this);
	;
	/*global _,angular */
	
	
	/*
		WindowsChildModel generator where there are many ChildModels to a parent.
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api.models.parent').factory('uiGmapWindowsParentModel', [
	    'uiGmapIWindowParentModel', 'uiGmapModelsWatcher', 'uiGmapPropMap', 'uiGmapWindowChildModel', 'uiGmapLinked', 'uiGmap_async', 'uiGmapLogger', '$timeout', '$compile', '$http', '$templateCache', '$interpolate', 'uiGmapPromise', 'uiGmapIWindow', 'uiGmapGmapUtil', function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
	      var WindowsParentModel;
	      WindowsParentModel = (function(superClass) {
	        extend(WindowsParentModel, superClass);
	
	        WindowsParentModel.include(ModelsWatcher);
	
	        function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
	          this.gMap = gMap1;
	          this.markersScope = markersScope;
	          this.modelKeyComparison = bind(this.modelKeyComparison, this);
	          this.interpolateContent = bind(this.interpolateContent, this);
	          this.setChildScope = bind(this.setChildScope, this);
	          this.createWindow = bind(this.createWindow, this);
	          this.setContentKeys = bind(this.setContentKeys, this);
	          this.pieceMeal = bind(this.pieceMeal, this);
	          this.createAllNew = bind(this.createAllNew, this);
	          this.watchIdKey = bind(this.watchIdKey, this);
	          this.createChildScopes = bind(this.createChildScopes, this);
	          this.watchOurScope = bind(this.watchOurScope, this);
	          this.watchDestroy = bind(this.watchDestroy, this);
	          this.onDestroy = bind(this.onDestroy, this);
	          this.rebuildAll = bind(this.rebuildAll, this);
	          this.doINeedToWipe = bind(this.doINeedToWipe, this);
	          this.watchModels = bind(this.watchModels, this);
	          this.go = bind(this.go, this);
	          WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
	          this["interface"] = IWindow;
	          this.plurals = new PropMap();
	          _.each(IWindow.scopeKeys, (function(_this) {
	            return function(name) {
	              return _this[name + 'Key'] = void 0;
	            };
	          })(this));
	          this.linked = new Linked(scope, element, attrs, ctrls);
	          this.contentKeys = void 0;
	          this.isIconVisibleOnClick = void 0;
	          this.firstTime = true;
	          this.firstWatchModels = true;
	          this.$log.info(self);
	          this.parentScope = void 0;
	          this.go(scope);
	        }
	
	        WindowsParentModel.prototype.go = function(scope) {
	          this.watchOurScope(scope);
	          this.doRebuildAll = this.scope.doRebuildAll != null ? this.scope.doRebuildAll : false;
	          scope.$watch('doRebuildAll', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                return _this.doRebuildAll = newValue;
	              }
	            };
	          })(this));
	          return this.createChildScopes();
	        };
	
	        WindowsParentModel.prototype.watchModels = function(scope) {
	          var itemToWatch;
	          itemToWatch = this.markersScope != null ? 'pluralsUpdate' : 'models';
	          return scope.$watch(itemToWatch, (function(_this) {
	            return function(newValue, oldValue) {
	              var doScratch;
	              if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
	                _this.firstWatchModels = false;
	                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) {
	                  return _this.rebuildAll(scope, true, true);
	                } else {
	                  doScratch = _this.plurals.length === 0;
	                  if (_this.existingPieces != null) {
	                    return _.last(_this.existingPieces._content).then(function() {
	                      return _this.createChildScopes(doScratch);
	                    });
	                  } else {
	                    return _this.createChildScopes(doScratch);
	                  }
	                }
	              }
	            };
	          })(this), true);
	        };
	
	        WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
	          var newValueIsEmpty;
	          newValueIsEmpty = newValue != null ? newValue.length === 0 : true;
	          return this.plurals.length > 0 && newValueIsEmpty;
	        };
	
	        WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
	          return this.onDestroy(doDelete).then((function(_this) {
	            return function() {
	              if (doCreate) {
	                return _this.createChildScopes();
	              }
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.onDestroy = function(scope) {
	          WindowsParentModel.__super__.onDestroy.call(this, this.scope);
	          return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, (function(_this) {
	            return function() {
	              return _async.each(_this.plurals.values(), function(child) {
	                return child.destroy(true);
	              }, _async.chunkSizeFrom(_this.scope.cleanchunk, false)).then(function() {
	                var ref;
	                return (ref = _this.plurals) != null ? ref.removeAll() : void 0;
	              });
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.watchDestroy = function(scope) {
	          return scope.$on('$destroy', (function(_this) {
	            return function() {
	              _this.firstWatchModels = true;
	              _this.firstTime = true;
	              return _this.rebuildAll(scope, false, true);
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.watchOurScope = function(scope) {
	          return _.each(IWindow.scopeKeys, (function(_this) {
	            return function(name) {
	              var nameKey;
	              nameKey = name + 'Key';
	              return _this[nameKey] = typeof scope[name] === 'function' ? scope[name]() : scope[name];
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
	          var modelsNotDefined, ref, ref1;
	          if (isCreatingFromScratch == null) {
	            isCreatingFromScratch = true;
	          }
	
	          /*
	          being that we cannot tell the difference in Key String vs. a normal value string (TemplateUrl)
	          we will assume that all scope values are string expressions either pointing to a key (propName) or using
	          'self' to point the model as container/object of interest.
	          
	          This may force redundant information into the model, but this appears to be the most flexible approach.
	           */
	          this.isIconVisibleOnClick = true;
	          if (angular.isDefined(this.linked.attrs.isiconvisibleonclick)) {
	            this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick;
	          }
	          modelsNotDefined = angular.isUndefined(this.linked.scope.models);
	          if (modelsNotDefined && (this.markersScope === void 0 || (((ref = this.markersScope) != null ? ref.plurals : void 0) === void 0 || ((ref1 = this.markersScope) != null ? ref1.models : void 0) === void 0))) {
	            this.$log.error('No models to create windows from! Need direct models or models derived from markers!');
	            return;
	          }
	          if (this.gMap != null) {
	            if (this.linked.scope.models != null) {
	              this.watchIdKey(this.linked.scope);
	              if (isCreatingFromScratch) {
	                return this.createAllNew(this.linked.scope, false);
	              } else {
	                return this.pieceMeal(this.linked.scope, false);
	              }
	            } else {
	              this.parentScope = this.markersScope;
	              this.watchIdKey(this.parentScope);
	              if (isCreatingFromScratch) {
	                return this.createAllNew(this.markersScope, true, 'plurals', false);
	              } else {
	                return this.pieceMeal(this.markersScope, true, 'plurals', false);
	              }
	            }
	          }
	        };
	
	        WindowsParentModel.prototype.watchIdKey = function(scope) {
	          this.setIdKey(scope);
	          return scope.$watch('idKey', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue && (newValue == null)) {
	                _this.idKey = newValue;
	                return _this.rebuildAll(scope, true, true);
	              }
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
	          var maybeCanceled;
	          if (modelsPropToIterate == null) {
	            modelsPropToIterate = 'models';
	          }
	          if (isArray == null) {
	            isArray = false;
	          }
	          if (this.firstTime) {
	            this.watchModels(scope);
	            this.watchDestroy(scope);
	          }
	          this.setContentKeys(scope.models);
	          if (this.didQueueInitPromise(this, scope)) {
	            return;
	          }
	          maybeCanceled = null;
	          return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, 'createAllNew', (function(canceledMsg) {
	            return maybeCanceled = canceledMsg;
	          }), (function(_this) {
	            return function() {
	              return _async.each(scope.models, function(model) {
	                var gMarker, ref;
	                gMarker = hasGMarker ? (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) != null ? ref.gObject : void 0 : void 0;
	                if (!maybeCanceled) {
	                  if (!gMarker && _this.markersScope) {
	                    $log.error('Unable to get gMarker from markersScope!');
	                  }
	                  _this.createWindow(model, gMarker, _this.gMap);
	                }
	                return maybeCanceled;
	              }, _async.chunkSizeFrom(scope.chunk)).then(function() {
	                return _this.firstTime = false;
	              });
	            };
	          })(this));
	        };
	
	        WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
	          var maybeCanceled, payload;
	          if (modelsPropToIterate == null) {
	            modelsPropToIterate = 'models';
	          }
	          if (isArray == null) {
	            isArray = true;
	          }
	          if (scope.$$destroyed) {
	            return;
	          }
	          maybeCanceled = null;
	          payload = null;
	          if ((scope != null) && this.modelsLength() && this.plurals.length) {
	            return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, 'pieceMeal', (function(canceledMsg) {
	              return maybeCanceled = canceledMsg;
	            }), (function(_this) {
	              return function() {
	                return uiGmapPromise.promise((function() {
	                  return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
	                })).then(function(state) {
	                  payload = state;
	                  return _async.each(payload.removals, function(child) {
	                    if (child != null) {
	                      _this.plurals.remove(child.id);
	                      if (child.destroy != null) {
	                        child.destroy(true);
	                      }
	                      return maybeCanceled;
	                    }
	                  }, _async.chunkSizeFrom(scope.chunk));
	                }).then(function() {
	                  return _async.each(payload.adds, function(modelToAdd) {
	                    var gMarker, ref;
	                    gMarker = (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) != null ? ref.gObject : void 0;
	                    if (!gMarker) {
	                      throw 'Gmarker undefined';
	                    }
	                    _this.createWindow(modelToAdd, gMarker, _this.gMap);
	                    return maybeCanceled;
	                  });
	                }).then(function() {
	                  return _async.each(payload.updates, function(update) {
	                    _this.updateChild(update.child, update.model);
	                    return maybeCanceled;
	                  }, _async.chunkSizeFrom(scope.chunk));
	                });
	              };
	            })(this));
	          } else {
	            $log.debug('pieceMeal: rebuildAll');
	            return this.rebuildAll(this.scope, true, true);
	          }
	        };
	
	        WindowsParentModel.prototype.setContentKeys = function(models) {
	          if (this.modelsLength(models)) {
	            return this.contentKeys = Object.keys(models[0]);
	          }
	        };
	
	        WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
	          var child, childScope, fakeElement, opts, ref, ref1;
	          childScope = this.linked.scope.$new(false);
	          this.setChildScope(childScope, model);
	          childScope.$watch('model', (function(_this) {
	            return function(newValue, oldValue) {
	              if (newValue !== oldValue) {
	                return _this.setChildScope(childScope, newValue);
	              }
	            };
	          })(this), true);
	          fakeElement = {
	            html: (function(_this) {
	              return function() {
	                return _this.interpolateContent(_this.linked.element.html(), model);
	              };
	            })(this)
	          };
	          this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
	          opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
	          child = new WindowChildModel({
	            model: model,
	            scope: childScope,
	            opts: opts,
	            isIconVisibleOnClick: this.isIconVisibleOnClick,
	            gMap: gMap,
	            markerScope: (ref = this.markersScope) != null ? (ref1 = ref.plurals.get(model[this.idKey])) != null ? ref1.scope : void 0 : void 0,
	            element: fakeElement,
	            needToManualDestroy: false,
	            markerIsVisibleAfterWindowClose: true,
	            isScopeModel: true
	          });
	          if (model[this.idKey] == null) {
	            this.$log.error('Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.');
	            return;
	          }
	          this.plurals.put(model[this.idKey], child);
	          return child;
	        };
	
	        WindowsParentModel.prototype.setChildScope = function(childScope, model) {
	          _.each(IWindow.scopeKeys, (function(_this) {
	            return function(name) {
	              var nameKey, newValue;
	              nameKey = name + 'Key';
	              newValue = _this[nameKey] === 'self' ? model : model[_this[nameKey]];
	              if (newValue !== childScope[name]) {
	                return childScope[name] = newValue;
	              }
	            };
	          })(this));
	          return childScope.model = model;
	        };
	
	        WindowsParentModel.prototype.interpolateContent = function(content, model) {
	          var exp, i, interpModel, key, len, ref;
	          if (this.contentKeys === void 0 || this.contentKeys.length === 0) {
	            return;
	          }
	          exp = $interpolate(content);
	          interpModel = {};
	          ref = this.contentKeys;
	          for (i = 0, len = ref.length; i < len; i++) {
	            key = ref[i];
	            interpModel[key] = model[key];
	          }
	          return exp(interpModel);
	        };
	
	        WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
	          var isEqual, scope;
	          scope = this.scope.coords != null ? this.scope : this.parentScope;
	          if (scope == null) {
	            throw 'No scope or parentScope set!';
	          }
	          isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
	          if (!isEqual) {
	            return isEqual;
	          }
	          isEqual = _.every(_.without(this["interface"].scopeKeys, 'coords'), (function(_this) {
	            return function(k) {
	              return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
	            };
	          })(this));
	          return isEqual;
	        };
	
	        return WindowsParentModel;
	
	      })(IWindowParentModel);
	      return WindowsParentModel;
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular, _ */
	
	(function() {
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", [
	    "uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
	      return _.extend(ICircle, {
	        link: function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then(function(gMap) {
	            return new CircleParentModel(scope, element, attrs, gMap);
	          });
	        }
	      });
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", [
	    "uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", 'uiGmapGoogleMapApi', function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
	      var Control;
	      return Control = (function(superClass) {
	        extend(Control, superClass);
	
	        function Control() {
	          this.link = bind(this.link, this);
	          Control.__super__.constructor.call(this);
	        }
	
	        Control.prototype.transclude = true;
	
	        Control.prototype.link = function(scope, element, attrs, ctrl, transclude) {
	          return GoogleMapApi.then((function(_this) {
	            return function(maps) {
	              var hasTranscludedContent, index, position, transcludedContent;
	              transcludedContent = transclude();
	              hasTranscludedContent = transclude().length > 0;
	              if (!hasTranscludedContent && angular.isUndefined(scope.template)) {
	                _this.$log.error('mapControl: could not find a valid template property or elements for transclusion');
	                return;
	              }
	              index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
	              position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_CENTER';
	              if (!maps.ControlPosition[position]) {
	                _this.$log.error('mapControl: invalid position property');
	                return;
	              }
	              return IControl.mapPromise(scope, ctrl).then(function(map) {
	                var control, controlDiv, pushControl;
	                control = void 0;
	                controlDiv = angular.element('<div></div>');
	                pushControl = function(map, control, index) {
	                  if (index) {
	                    control[0].index = index;
	                  }
	                  return map.controls[google.maps.ControlPosition[position]].push(control[0]);
	                };
	                if (hasTranscludedContent) {
	                  return transclude(function(transcludeEl) {
	                    controlDiv.append(transcludeEl);
	                    return pushControl(map, controlDiv, index);
	                  });
	                } else {
	                  return $http.get(scope.template, {
	                    cache: $templateCache
	                  }).success(function(template) {
	                    var templateCtrl, templateScope;
	                    templateScope = scope.$new();
	                    controlDiv.append(template);
	                    if (angular.isDefined(scope.controller)) {
	                      templateCtrl = $controller(scope.controller, {
	                        $scope: templateScope
	                      });
	                      controlDiv.children().data('$ngControllerController', templateCtrl);
	                    }
	                    return control = $compile(controlDiv.children())(templateScope);
	                  }).error(function(error) {
	                    return _this.$log.error('mapControl: template could not be found');
	                  }).then(function() {
	                    return pushControl(map, control, index);
	                  });
	                }
	              });
	            };
	          })(this));
	        };
	
	        return Control;
	
	      })(IControl);
	    }
	  ]);
	
	}).call(this);
	;
	/*globals angular, _ */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapDragZoom', [
	    'uiGmapCtrlHandle', 'uiGmapPropertyAction', function(CtrlHandle, PropertyAction) {
	      return {
	        restrict: 'EMA',
	        transclude: true,
	        template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
	        require: '^' + 'uiGmapGoogleMap',
	        scope: {
	          keyboardkey: '=',
	          options: '=',
	          spec: '='
	        },
	        controller: [
	          '$scope', '$element', function($scope, $element) {
	            $scope.ctrlType = 'uiGmapDragZoom';
	            return _.extend(this, CtrlHandle.handle($scope, $element));
	          }
	        ],
	        link: function(scope, element, attrs, ctrl) {
	          return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
	            var enableKeyDragZoom, setKeyAction, setOptionsAction;
	            enableKeyDragZoom = function(opts) {
	              return map.enableKeyDragZoom(opts);
	            };
	            setKeyAction = new PropertyAction(function(key, newVal) {
	              if (newVal) {
	                return enableKeyDragZoom({
	                  key: newVal
	                });
	              } else {
	                return enableKeyDragZoom();
	              }
	            });
	            setOptionsAction = new PropertyAction(function(key, newVal) {
	              if (newVal) {
	                return enableKeyDragZoom(newVal);
	              }
	            });
	            scope.$watch('keyboardkey', setKeyAction.sic('keyboardkey'));
	            setKeyAction.sic(scope.keyboardkey);
	            scope.$watch('options', setOptionsAction.sic('options'));
	            return setOptionsAction.sic(scope.options);
	          });
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", [
	    "uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
	      return _.extend(IDrawingManager, {
	        link: function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then(function(map) {
	            return new DrawingManagerParentModel(scope, element, attrs, map);
	          });
	        }
	      });
	    }
	  ]);
	
	}).call(this);
	;
	/*
	  - Link up Polygons to be sent back to a controller
	  - inject the draw function into a controllers scope so that controller can call the directive to draw on demand
	  - draw function creates the DrawFreeHandChildModel which manages itself
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapApiFreeDrawPolygons', [
	    'uiGmapLogger', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapDrawFreeHandChildModel', 'uiGmapLodash', function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
	      var FreeDrawPolygons;
	      return FreeDrawPolygons = (function(superClass) {
	        extend(FreeDrawPolygons, superClass);
	
	        function FreeDrawPolygons() {
	          this.link = bind(this.link, this);
	          return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
	        }
	
	        FreeDrawPolygons.include(CtrlHandle);
	
	        FreeDrawPolygons.prototype.restrict = 'EMA';
	
	        FreeDrawPolygons.prototype.replace = true;
	
	        FreeDrawPolygons.prototype.require = '^' + 'uiGmapGoogleMap';
	
	        FreeDrawPolygons.prototype.scope = {
	          polygons: '=',
	          draw: '='
	        };
	
	        FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
	          return this.mapPromise(scope, ctrl).then((function(_this) {
	            return function(map) {
	              var freeHand, listener;
	              if (!scope.polygons) {
	                return $log.error('No polygons to bind to!');
	              }
	              if (!_.isArray(scope.polygons)) {
	                return $log.error('Free Draw Polygons must be of type Array!');
	              }
	              freeHand = new DrawFreeHandChildModel(map, ctrl.getScope());
	              listener = void 0;
	              return scope.draw = function() {
	                if (typeof listener === "function") {
	                  listener();
	                }
	                return freeHand.engage(scope.polygons).then(function() {
	                  var firstTime;
	                  firstTime = true;
	                  return listener = scope.$watchCollection('polygons', function(newValue, oldValue) {
	                    var removals;
	                    if (firstTime || newValue === oldValue) {
	                      firstTime = false;
	                      return;
	                    }
	                    removals = uiGmapLodash.differenceObjects(oldValue, newValue);
	                    return removals.forEach(function(p) {
	                      return p.setMap(null);
	                    });
	                  });
	                });
	              };
	            };
	          })(this));
	        };
	
	        return FreeDrawPolygons;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [
	    function() {
	      var DEFAULTS;
	      DEFAULTS = {};
	      return {
	        restrict: "EA",
	        replace: true,
	        require: '^' + 'uiGmapGoogleMap',
	        scope: {
	          center: "=center",
	          radius: "=radius",
	          stroke: "=stroke",
	          fill: "=fill",
	          clickable: "=",
	          draggable: "=",
	          editable: "=",
	          geodesic: "=",
	          icons: "=icons",
	          visible: "=",
	          events: "=",
	          control: "=",
	          zIndex: "=zindex"
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*
	 - interface for all controls to derive from
	 - to enforce a minimum set of requirements
		- attributes
			- template
			- position
			- controller
			- index
	 */
	
	(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", [
	    "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
	      var IControl;
	      return IControl = (function(superClass) {
	        extend(IControl, superClass);
	
	        IControl.extend(CtrlHandle);
	
	        function IControl() {
	          this.restrict = 'EA';
	          this.replace = true;
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.scope = {
	            template: '@template',
	            position: '@position',
	            controller: '@controller',
	            index: '@index'
	          };
	          this.$log = Logger;
	        }
	
	        IControl.prototype.link = function(scope, element, attrs, ctrl) {
	          throw new Exception("Not implemented!!");
	        };
	
	        return IControl;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIDrawingManager', [
	    function() {
	      return {
	        restrict: 'EA',
	        replace: true,
	        require: '^' + 'uiGmapGoogleMap',
	        scope: {
	          "static": '@',
	          control: '=',
	          options: '=',
	          events: '='
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIMarker', [
	    'uiGmapBaseObject', 'uiGmapCtrlHandle', function(BaseObject, CtrlHandle) {
	      var IMarker;
	      return IMarker = (function(superClass) {
	        extend(IMarker, superClass);
	
	        IMarker.scope = {
	          coords: '=coords',
	          icon: '=icon',
	          click: '&click',
	          options: '=options',
	          events: '=events',
	          fit: '=fit',
	          idKey: '=idkey',
	          control: '=control'
	        };
	
	        IMarker.scopeKeys = _.keys(IMarker.scope);
	
	        IMarker.keys = IMarker.scopeKeys;
	
	        IMarker.extend(CtrlHandle);
	
	        function IMarker() {
	          this.restrict = 'EMA';
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.priority = -1;
	          this.transclude = true;
	          this.replace = true;
	          this.scope = _.extend(this.scope || {}, IMarker.scope);
	        }
	
	        return IMarker;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolygon', [
	    'uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
	      var IPolygon;
	      return IPolygon = (function(superClass) {
	        extend(IPolygon, superClass);
	
	        IPolygon.scope = {
	          path: '=path',
	          stroke: '=stroke',
	          clickable: '=',
	          draggable: '=',
	          editable: '=',
	          geodesic: '=',
	          fill: '=',
	          icons: '=icons',
	          visible: '=',
	          "static": '=',
	          events: '=',
	          zIndex: '=zindex',
	          fit: '=',
	          control: '=control'
	        };
	
	        IPolygon.scopeKeys = _.keys(IPolygon.scope);
	
	        IPolygon.include(GmapUtil);
	
	        IPolygon.extend(CtrlHandle);
	
	        function IPolygon() {}
	
	        IPolygon.prototype.restrict = 'EMA';
	
	        IPolygon.prototype.replace = true;
	
	        IPolygon.prototype.require = '^' + 'uiGmapGoogleMap';
	
	        IPolygon.prototype.scope = IPolygon.scope;
	
	        IPolygon.prototype.DEFAULTS = {};
	
	        IPolygon.prototype.$log = Logger;
	
	        return IPolygon;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIPolyline', [
	    'uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapLogger', 'uiGmapCtrlHandle', function(GmapUtil, BaseObject, Logger, CtrlHandle) {
	      var IPolyline;
	      return IPolyline = (function(superClass) {
	        extend(IPolyline, superClass);
	
	        IPolyline.scope = {
	          path: '=',
	          stroke: '=',
	          clickable: '=',
	          draggable: '=',
	          editable: '=',
	          geodesic: '=',
	          icons: '=',
	          visible: '=',
	          "static": '=',
	          fit: '=',
	          events: '=',
	          zIndex: '=zindex'
	        };
	
	        IPolyline.scopeKeys = _.keys(IPolyline.scope);
	
	        IPolyline.include(GmapUtil);
	
	        IPolyline.extend(CtrlHandle);
	
	        function IPolyline() {}
	
	        IPolyline.prototype.restrict = 'EMA';
	
	        IPolyline.prototype.replace = true;
	
	        IPolyline.prototype.require = '^' + 'uiGmapGoogleMap';
	
	        IPolyline.prototype.scope = IPolyline.scope;
	
	        IPolyline.prototype.DEFAULTS = {};
	
	        IPolyline.prototype.$log = Logger;
	
	        return IPolyline;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapIRectangle', [
	    function() {
	      'use strict';
	      var DEFAULTS;
	      DEFAULTS = {};
	      return {
	        restrict: 'EMA',
	        require: '^' + 'uiGmapGoogleMap',
	        replace: true,
	        scope: {
	          bounds: '=',
	          stroke: '=',
	          clickable: '=',
	          draggable: '=',
	          editable: '=',
	          fill: '=',
	          visible: '=',
	          events: '='
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapIWindow', [
	    'uiGmapBaseObject', 'uiGmapChildEvents', 'uiGmapCtrlHandle', function(BaseObject, ChildEvents, CtrlHandle) {
	      var IWindow;
	      return IWindow = (function(superClass) {
	        extend(IWindow, superClass);
	
	        IWindow.scope = {
	          coords: '=coords',
	          template: '=template',
	          templateUrl: '=templateurl',
	          templateParameter: '=templateparameter',
	          isIconVisibleOnClick: '=isiconvisibleonclick',
	          closeClick: '&closeclick',
	          options: '=options',
	          control: '=control',
	          show: '=show'
	        };
	
	        IWindow.scopeKeys = _.keys(IWindow.scope);
	
	        IWindow.include(ChildEvents);
	
	        IWindow.extend(CtrlHandle);
	
	        function IWindow() {
	          this.restrict = 'EMA';
	          this.template = void 0;
	          this.transclude = true;
	          this.priority = -100;
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.replace = true;
	          this.scope = _.extend(this.scope || {}, IWindow.scope);
	        }
	
	        return IWindow;
	
	      })(BaseObject);
	    }
	  ]);
	
	}).call(this);
	;
	/*globals angular,_,google */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapMap', ['$timeout', '$q', '$log', 'uiGmapGmapUtil', 'uiGmapBaseObject', 'uiGmapCtrlHandle', 'uiGmapIsReady', 'uiGmapuuid', 'uiGmapExtendGWin', 'uiGmapExtendMarkerClusterer', 'uiGmapGoogleMapsUtilV3', 'uiGmapGoogleMapApi', 'uiGmapEventsHelper', 'uiGmapGoogleMapObjectManager', function($timeout, $q, $log, uiGmapGmapUtil, uiGmapBaseObject, uiGmapCtrlHandle, uiGmapIsReady, uiGmapuuid, uiGmapExtendGWin, uiGmapExtendMarkerClusterer, uiGmapGoogleMapsUtilV3, uiGmapGoogleMapApi, uiGmapEventsHelper, uiGmapGoogleMapObjectManager) {
	    var DEFAULTS, Map, initializeItems;
	    DEFAULTS = void 0;
	    initializeItems = [uiGmapGoogleMapsUtilV3, uiGmapExtendGWin, uiGmapExtendMarkerClusterer];
	    return Map = (function(superClass) {
	      extend(Map, superClass);
	
	      Map.include(uiGmapGmapUtil);
	
	      function Map() {
	        this.link = bind(this.link, this);
	        var ctrlFn;
	        ctrlFn = function($scope) {
	          var ctrlObj, retCtrl;
	          retCtrl = void 0;
	          $scope.$on('$destroy', function() {
	            return uiGmapIsReady.decrement();
	          });
	          ctrlObj = uiGmapCtrlHandle.handle($scope);
	          $scope.ctrlType = 'Map';
	          $scope.deferred.promise.then(function() {
	            return initializeItems.forEach(function(i) {
	              return i.init();
	            });
	          });
	          ctrlObj.getMap = function() {
	            return $scope.map;
	          };
	          retCtrl = _.extend(this, ctrlObj);
	          return retCtrl;
	        };
	        this.controller = ['$scope', ctrlFn];
	      }
	
	      Map.prototype.restrict = 'EMA';
	
	      Map.prototype.transclude = true;
	
	      Map.prototype.replace = false;
	
	      Map.prototype.template = "<div class=\"angular-google-map\"><div class=\"angular-google-map-container\">\n</div><div ng-transclude style=\"display: none\"></div></div>";
	
	      Map.prototype.scope = {
	        center: '=',
	        zoom: '=',
	        dragging: '=',
	        control: '=',
	        options: '=',
	        events: '=',
	        eventOpts: '=',
	        styles: '=',
	        bounds: '=',
	        update: '='
	      };
	
	      Map.prototype.link = function(scope, element, attrs) {
	        var listeners;
	        listeners = [];
	        scope.$on('$destroy', function() {
	          uiGmapEventsHelper.removeEvents(listeners);
	          if (attrs.recycleMapInstance === 'true' && scope.map) {
	            uiGmapGoogleMapObjectManager.recycleMapInstance(scope.map);
	            return scope.map = null;
	          }
	        });
	        scope.idleAndZoomChanged = false;
	        return uiGmapGoogleMapApi.then((function(_this) {
	          return function(maps) {
	            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
	            DEFAULTS = {
	              mapTypeId: maps.MapTypeId.ROADMAP
	            };
	            spawned = uiGmapIsReady.spawn();
	            resolveSpawned = function() {
	              return spawned.deferred.resolve({
	                instance: spawned.instance,
	                map: _gMap
	              });
	            };
	            if (!angular.isDefined(scope.center) && !angular.isDefined(scope.bounds)) {
	              $log.error('angular-google-maps: a center or bounds property is required');
	              return;
	            }
	            if (!angular.isDefined(scope.center)) {
	              scope.center = new google.maps.LatLngBounds(_this.getCoords(scope.bounds.southwest), _this.getCoords(scope.bounds.northeast)).getCenter();
	            }
	            if (!angular.isDefined(scope.zoom)) {
	              scope.zoom = 10;
	            }
	            el = angular.element(element);
	            el.addClass('angular-google-map');
	            opts = {
	              options: {}
	            };
	            if (attrs.options) {
	              opts.options = scope.options;
	            }
	            if (attrs.styles) {
	              opts.styles = scope.styles;
	            }
	            if (attrs.type) {
	              type = attrs.type.toUpperCase();
	              if (google.maps.MapTypeId.hasOwnProperty(type)) {
	                opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()];
	              } else {
	                $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
	              }
	            }
	            mapOptions = angular.extend({}, DEFAULTS, opts, {
	              center: _this.getCoords(scope.center),
	              zoom: scope.zoom,
	              bounds: scope.bounds
	            });
	            if (attrs.recycleMapInstance === 'true') {
	              _gMap = uiGmapGoogleMapObjectManager.createMapInstance(el.find('div')[1], mapOptions);
	            } else {
	              _gMap = new google.maps.Map(el.find('div')[1], mapOptions);
	            }
	            _gMap['uiGmap_id'] = uiGmapuuid.generate();
	            dragging = false;
	            listeners.push(google.maps.event.addListenerOnce(_gMap, 'idle', function() {
	              scope.deferred.resolve(_gMap);
	              return resolveSpawned();
	            }));
	            disabledEvents = attrs.events && (((ref = scope.events) != null ? ref.blacklist : void 0) != null) ? scope.events.blacklist : [];
	            if (_.isString(disabledEvents)) {
	              disabledEvents = [disabledEvents];
	            }
	            maybeHookToEvent = function(eventName, fn, prefn) {
	              if (!_.includes(disabledEvents, eventName)) {
	                if (prefn) {
	                  prefn();
	                }
	                return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
	                  var ref1;
	                  if (!((ref1 = scope.update) != null ? ref1.lazy : void 0)) {
	                    return fn();
	                  }
	                }));
	              }
	            };
	            if (!_.includes(disabledEvents, 'all')) {
	              maybeHookToEvent('dragstart', function() {
	                dragging = true;
	                return scope.$evalAsync(function(s) {
	                  if (s.dragging != null) {
	                    return s.dragging = dragging;
	                  }
	                });
	              });
	              maybeHookToEvent('dragend', function() {
	                dragging = false;
	                return scope.$evalAsync(function(s) {
	                  if (s.dragging != null) {
	                    return s.dragging = dragging;
	                  }
	                });
	              });
	              updateCenter = function(c, s) {
	                if (c == null) {
	                  c = _gMap.center;
	                }
	                if (s == null) {
	                  s = scope;
	                }
	                if (!_.includes(disabledEvents, 'center')) {
	                  if (s.center.latitude !== c.lat()) {
	                    s.center.latitude = c.lat();
	                  }
	                  if (s.center.longitude !== c.lng()) {
	                    return s.center.longitude = c.lng();
	                  }
	                }
	              };
	              settingFromDirective = false;
	              maybeHookToEvent('idle', function() {
	                var b, ne, sw;
	                b = _gMap.getBounds();
	                ne = b.getNorthEast();
	                sw = b.getSouthWest();
	                settingFromDirective = true;
	                return scope.$evalAsync(function(s) {
	                  updateCenter();
	                  if (!_.isUndefined(s.bounds) && !_.includes(disabledEvents, 'bounds')) {
	                    s.bounds.northeast = {
	                      latitude: ne.lat(),
	                      longitude: ne.lng()
	                    };
	                    s.bounds.southwest = {
	                      latitude: sw.lat(),
	                      longitude: sw.lng()
	                    };
	                  }
	                  if (!_.includes(disabledEvents, 'zoom')) {
	                    s.zoom = _gMap.zoom;
	                    scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
	                  }
	                  return settingFromDirective = false;
	                });
	              });
	            }
	            if (angular.isDefined(scope.events) && scope.events !== null && angular.isObject(scope.events)) {
	              getEventHandler = function(eventName) {
	                return function() {
	                  return scope.events[eventName].apply(scope, [_gMap, eventName, arguments]);
	                };
	              };
	              customListeners = [];
	              for (eventName in scope.events) {
	                if (scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName])) {
	                  customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
	                }
	              }
	              listeners.concat(customListeners);
	            }
	            _gMap.getOptions = function() {
	              return mapOptions;
	            };
	            scope.map = _gMap;
	            if ((attrs.control != null) && (scope.control != null)) {
	              scope.control.refresh = function(maybeCoords) {
	                var coords, ref1, ref2;
	                if (_gMap == null) {
	                  return;
	                }
	                if (((typeof google !== "undefined" && google !== null ? (ref1 = google.maps) != null ? (ref2 = ref1.event) != null ? ref2.trigger : void 0 : void 0 : void 0) != null) && (_gMap != null)) {
	                  google.maps.event.trigger(_gMap, 'resize');
	                }
	                if (((maybeCoords != null ? maybeCoords.latitude : void 0) != null) && ((maybeCoords != null ? maybeCoords.longitude : void 0) != null)) {
	                  coords = _this.getCoords(maybeCoords);
	                  if (_this.isTrue(attrs.pan)) {
	                    return _gMap.panTo(coords);
	                  } else {
	                    return _gMap.setCenter(coords);
	                  }
	                }
	              };
	              scope.control.getGMap = function() {
	                return _gMap;
	              };
	              scope.control.getMapOptions = function() {
	                return mapOptions;
	              };
	              scope.control.getCustomEventListeners = function() {
	                return customListeners;
	              };
	              scope.control.removeEvents = function(yourListeners) {
	                return uiGmapEventsHelper.removeEvents(yourListeners);
	              };
	            }
	            scope.$watch('center', function(newValue, oldValue) {
	              var coords;
	              if (newValue === oldValue || settingFromDirective) {
	                return;
	              }
	              coords = _this.getCoords(scope.center);
	              if (coords.lat() === _gMap.center.lat() && coords.lng() === _gMap.center.lng()) {
	                return;
	              }
	              if (!dragging) {
	                if (!_this.validateCoords(newValue)) {
	                  $log.error("Invalid center for newValue: " + (JSON.stringify(newValue)));
	                }
	                if (_this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom) {
	                  return _gMap.panTo(coords);
	                } else {
	                  return _gMap.setCenter(coords);
	                }
	              }
	            }, true);
	            zoomPromise = null;
	            scope.$watch('zoom', function(newValue, oldValue) {
	              var ref1, ref2;
	              if (newValue == null) {
	                return;
	              }
	              if (_.isEqual(newValue, oldValue) || (_gMap != null ? _gMap.getZoom() : void 0) === (scope != null ? scope.zoom : void 0) || settingFromDirective) {
	                return;
	              }
	              if (zoomPromise != null) {
	                $timeout.cancel(zoomPromise);
	              }
	              return zoomPromise = $timeout(function() {
	                return _gMap.setZoom(newValue);
	              }, ((ref1 = scope.eventOpts) != null ? (ref2 = ref1.debounce) != null ? ref2.zoomMs : void 0 : void 0) + 20, false);
	            });
	            scope.$watch('bounds', function(newValue, oldValue) {
	              var bounds, ne, ref1, ref2, ref3, ref4, sw;
	              if (newValue === oldValue) {
	                return;
	              }
	              if (((newValue != null ? (ref1 = newValue.northeast) != null ? ref1.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref2 = newValue.northeast) != null ? ref2.longitude : void 0 : void 0) == null) || ((newValue != null ? (ref3 = newValue.southwest) != null ? ref3.latitude : void 0 : void 0) == null) || ((newValue != null ? (ref4 = newValue.southwest) != null ? ref4.longitude : void 0 : void 0) == null)) {
	                $log.error("Invalid map bounds for new value: " + (JSON.stringify(newValue)));
	                return;
	              }
	              ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
	              sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
	              bounds = new google.maps.LatLngBounds(sw, ne);
	              return _gMap.fitBounds(bounds);
	            });
	            return ['options', 'styles'].forEach(function(toWatch) {
	              return scope.$watch(toWatch, function(newValue, oldValue) {
	                if (_.isEqual(newValue, oldValue)) {
	                  return;
	                }
	                if (toWatch === 'options') {
	                  opts.options = newValue;
	                } else {
	                  opts.options[toWatch] = newValue;
	                }
	                if (_gMap != null) {
	                  return _gMap.setOptions(opts);
	                }
	              }, true);
	            });
	          };
	        })(this));
	      };
	
	      return Map;
	
	    })(uiGmapBaseObject);
	  }]);
	
	}).call(this);
	;
	/*global _:true,angular:true */
	
	(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", [
	    "uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
	      var Marker;
	      return Marker = (function(superClass) {
	        extend(Marker, superClass);
	
	        function Marker() {
	          Marker.__super__.constructor.call(this);
	          this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
	          $log.info(this);
	        }
	
	        Marker.prototype.controller = [
	          '$scope', '$element', function($scope, $element) {
	            $scope.ctrlType = 'Marker';
	            return _.extend(this, IMarker.handle($scope, $element));
	          }
	        ];
	
	        Marker.prototype.link = function(scope, element, attrs, ctrl) {
	          var mapPromise;
	          mapPromise = IMarker.mapPromise(scope, ctrl);
	          mapPromise.then(function(gMap) {
	            var gManager, keys, m;
	            gManager = new MarkerManager(gMap);
	            keys = _.object(IMarker.keys, IMarker.keys);
	            m = new MarkerChildModel({
	              scope: scope,
	              model: scope,
	              keys: keys,
	              gMap: gMap,
	              doClick: true,
	              gManager: gManager,
	              doDrawSelf: false,
	              trackModel: false
	            });
	            m.deferred.promise.then(function(gMarker) {
	              return scope.deferred.resolve(gMarker);
	            });
	            if (scope.control != null) {
	              return scope.control.getGMarkers = gManager.getGMarkers;
	            }
	          });
	          return scope.$on('$destroy', function() {
	            var gManager;
	            if (typeof gManager !== "undefined" && gManager !== null) {
	              gManager.clear();
	            }
	            return gManager = null;
	          });
	        };
	
	        return Marker;
	
	      })(IMarker);
	    }
	  ]);
	
	}).call(this);
	;
	/*global _:true,angular:true */
	
	(function() {
	  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", [
	    "uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
	      var Markers;
	      return Markers = (function(superClass) {
	        extend(Markers, superClass);
	
	        function Markers() {
	          Markers.__super__.constructor.call(this);
	          this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
	          Plural.extend(this, {
	            doCluster: '=?docluster',
	            clusterOptions: '=clusteroptions',
	            clusterEvents: '=clusterevents',
	            modelsByRef: '=modelsbyref',
	            type: '=?type',
	            typeOptions: '=?typeoptions',
	            typeEvents: '=?typeevents',
	            deepComparison: '=?deepcomparison'
	          });
	          $log.info(this);
	        }
	
	        Markers.prototype.controller = [
	          '$scope', '$element', function($scope, $element) {
	            $scope.ctrlType = 'Markers';
	            return _.extend(this, IMarker.handle($scope, $element));
	          }
	        ];
	
	        Markers.prototype.link = function(scope, element, attrs, ctrl) {
	          var parentModel, ready;
	          parentModel = void 0;
	          ready = function() {
	            return scope.deferred.resolve();
	          };
	          return IMarker.mapPromise(scope, ctrl).then(function(map) {
	            var mapScope;
	            mapScope = ctrl.getScope();
	            mapScope.$watch('idleAndZoomChanged', function() {
	              return _.defer(parentModel.gManager.draw);
	            });
	            parentModel = new MarkersParentModel(scope, element, attrs, map);
	            Plural.link(scope, parentModel);
	            if (scope.control != null) {
	              scope.control.getGMarkers = function() {
	                var ref;
	                return (ref = parentModel.gManager) != null ? ref.getGMarkers() : void 0;
	              };
	              scope.control.getChildMarkers = function() {
	                return parentModel.plurals;
	              };
	            }
	            return _.last(parentModel.existingPieces._content).then(function() {
	              return ready();
	            });
	          });
	        };
	
	        return Markers;
	
	      })(IMarker);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular */
	
	(function() {
	  angular.module('uiGmapgoogle-maps.directives.api').service('uiGmapPlural', [
	    function() {
	      var _initControl;
	      _initControl = function(scope, parent) {
	        if (scope.control == null) {
	          return;
	        }
	        scope.control.updateModels = function(models) {
	          scope.models = models;
	          return parent.createChildScopes(false);
	        };
	        scope.control.newModels = function(models) {
	          scope.models = models;
	          return parent.rebuildAll(scope, true, true);
	        };
	        scope.control.clean = function() {
	          return parent.rebuildAll(scope, false, true);
	        };
	        scope.control.getPlurals = function() {
	          return parent.plurals;
	        };
	        scope.control.getManager = function() {
	          return parent.gManager;
	        };
	        scope.control.hasManager = function() {
	          return (parent.gManager != null) === true;
	        };
	        return scope.control.managerDraw = function() {
	          var ref;
	          if (scope.control.hasManager()) {
	            return (ref = scope.control.getManager()) != null ? ref.draw() : void 0;
	          }
	        };
	      };
	      return {
	        extend: function(obj, obj2) {
	          return _.extend(obj.scope || {}, obj2 || {}, {
	            idKey: '=idkey',
	            doRebuildAll: '=dorebuildall',
	            models: '=models',
	            chunk: '=chunk',
	            cleanchunk: '=cleanchunk',
	            control: '=control',
	            deepComparison: '=deepcomparison'
	          });
	        },
	        link: function(scope, parent) {
	          return _initControl(scope, parent);
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygon', [
	    'uiGmapIPolygon', '$timeout', 'uiGmapPolygonChildModel', function(IPolygon, $timeout, PolygonChild) {
	      var Polygon;
	      return Polygon = (function(superClass) {
	        extend(Polygon, superClass);
	
	        function Polygon() {
	          this.link = bind(this.link, this);
	          return Polygon.__super__.constructor.apply(this, arguments);
	        }
	
	        Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
	          var children, promise;
	          children = [];
	          promise = IPolygon.mapPromise(scope, mapCtrl);
	          if (scope.control != null) {
	            scope.control.getInstance = this;
	            scope.control.polygons = children;
	            scope.control.promise = promise;
	          }
	          return promise.then((function(_this) {
	            return function(gMap) {
	              return children.push(new PolygonChild({
	                scope: scope,
	                attrs: attrs,
	                gMap: gMap,
	                defaults: _this.DEFAULTS
	              }));
	            };
	          })(this));
	        };
	
	        return Polygon;
	
	      })(IPolygon);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolygons', [
	    'uiGmapIPolygon', '$timeout', 'uiGmapPolygonsParentModel', 'uiGmapPlural', function(Interface, $timeout, ParentModel, Plural) {
	      var Polygons;
	      return Polygons = (function(superClass) {
	        extend(Polygons, superClass);
	
	        function Polygons() {
	          this.link = bind(this.link, this);
	          Polygons.__super__.constructor.call(this);
	          Plural.extend(this);
	          this.$log.info(this);
	        }
	
	        Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then((function(_this) {
	            return function(map) {
	              if (angular.isUndefined(scope.path) || scope.path === null) {
	                _this.$log.warn('polygons: no valid path attribute found');
	              }
	              if (!scope.models) {
	                _this.$log.warn('polygons: no models found to create from');
	              }
	              return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
	            };
	          })(this));
	        };
	
	        return Polygons;
	
	      })(Interface);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolyline', [
	    'uiGmapIPolyline', '$timeout', 'uiGmapPolylineChildModel', function(IPolyline, $timeout, PolylineChildModel) {
	      var Polyline;
	      return Polyline = (function(superClass) {
	        extend(Polyline, superClass);
	
	        function Polyline() {
	          this.link = bind(this.link, this);
	          return Polyline.__super__.constructor.apply(this, arguments);
	        }
	
	        Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return IPolyline.mapPromise(scope, mapCtrl).then((function(_this) {
	            return function(gMap) {
	              if (angular.isUndefined(scope.path) || scope.path === null || !_this.validatePath(scope.path)) {
	                _this.$log.warn('polyline: no valid path attribute found');
	              }
	              return new PolylineChildModel({
	                scope: scope,
	                attrs: attrs,
	                gMap: gMap,
	                defaults: _this.DEFAULTS
	              });
	            };
	          })(this));
	        };
	
	        return Polyline;
	
	      })(IPolyline);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapPolylines', [
	    'uiGmapIPolyline', '$timeout', 'uiGmapPolylinesParentModel', 'uiGmapPlural', function(IPolyline, $timeout, PolylinesParentModel, Plural) {
	      var Polylines;
	      return Polylines = (function(superClass) {
	        extend(Polylines, superClass);
	
	        function Polylines() {
	          this.link = bind(this.link, this);
	          Polylines.__super__.constructor.call(this);
	          Plural.extend(this);
	          this.$log.info(this);
	        }
	
	        Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then((function(_this) {
	            return function(gMap) {
	              if (angular.isUndefined(scope.path) || scope.path === null) {
	                _this.$log.warn('polylines: no valid path attribute found');
	              }
	              if (!scope.models) {
	                _this.$log.warn('polylines: no models found to create from');
	              }
	              return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, gMap, _this.DEFAULTS));
	            };
	          })(this));
	        };
	
	        return Polylines;
	
	      })(IPolyline);
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapRectangle', [
	    'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapIRectangle', 'uiGmapRectangleParentModel', function($log, GmapUtil, IRectangle, RectangleParentModel) {
	      return _.extend(IRectangle, {
	        link: function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then(function(gMap) {
	            return new RectangleParentModel(scope, element, attrs, gMap);
	          });
	        }
	      });
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular:true */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindow', [
	    'uiGmapIWindow', 'uiGmapGmapUtil', 'uiGmapWindowChildModel', 'uiGmapLodash', 'uiGmapLogger', function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
	      var Window;
	      return Window = (function(superClass) {
	        extend(Window, superClass);
	
	        Window.include(GmapUtil);
	
	        function Window() {
	          this.link = bind(this.link, this);
	          Window.__super__.constructor.call(this);
	          this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarker'];
	          this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
	          $log.debug(this);
	          this.childWindows = [];
	        }
	
	        Window.prototype.link = function(scope, element, attrs, ctrls) {
	          var markerCtrl, markerScope;
	          markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
	          markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
	          this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
	          return this.mapPromise.then((function(_this) {
	            return function(gMap) {
	              var isIconVisibleOnClick;
	              isIconVisibleOnClick = true;
	              if (angular.isDefined(attrs.isiconvisibleonclick)) {
	                isIconVisibleOnClick = scope.isIconVisibleOnClick;
	              }
	              if (!markerCtrl) {
	                _this.init(scope, element, isIconVisibleOnClick, gMap);
	                return;
	              }
	              return markerScope.deferred.promise.then(function(gMarker) {
	                return _this.init(scope, element, isIconVisibleOnClick, gMap, markerScope);
	              });
	            };
	          })(this));
	        };
	
	        Window.prototype.init = function(scope, element, isIconVisibleOnClick, gMap, markerScope) {
	          var childWindow, defaults, gMarker, hasScopeCoords, opts;
	          defaults = scope.options != null ? scope.options : {};
	          hasScopeCoords = (scope != null) && this.validateCoords(scope.coords);
	          if ((markerScope != null ? markerScope['getGMarker'] : void 0) != null) {
	            gMarker = markerScope.getGMarker();
	          }
	          opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
	          if (gMap != null) {
	            childWindow = new WindowChildModel({
	              scope: scope,
	              opts: opts,
	              isIconVisibleOnClick: isIconVisibleOnClick,
	              gMap: gMap,
	              markerScope: markerScope,
	              element: element
	            });
	            this.childWindows.push(childWindow);
	            scope.$on('$destroy', (function(_this) {
	              return function() {
	                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [childWindow], function(child1, child2) {
	                  return child1.scope.$id === child2.scope.$id;
	                });
	                return _this.childWindows.length = 0;
	              };
	            })(this));
	          }
	          if (scope.control != null) {
	            scope.control.getGWindows = (function(_this) {
	              return function() {
	                return _this.childWindows.map(function(child) {
	                  return child.gObject;
	                });
	              };
	            })(this);
	            scope.control.getChildWindows = (function(_this) {
	              return function() {
	                return _this.childWindows;
	              };
	            })(this);
	            scope.control.getPlurals = scope.control.getChildWindows;
	            scope.control.showWindow = (function(_this) {
	              return function() {
	                return _this.childWindows.map(function(child) {
	                  return child.showWindow();
	                });
	              };
	            })(this);
	            scope.control.hideWindow = (function(_this) {
	              return function() {
	                return _this.childWindows.map(function(child) {
	                  return child.hideWindow();
	                });
	              };
	            })(this);
	          }
	          if ((this.onChildCreation != null) && (childWindow != null)) {
	            return this.onChildCreation(childWindow);
	          }
	        };
	
	        return Window;
	
	      })(IWindow);
	    }
	  ]);
	
	}).call(this);
	;
	/*global angular */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
	    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	    hasProp = {}.hasOwnProperty;
	
	  angular.module('uiGmapgoogle-maps.directives.api').factory('uiGmapWindows', [
	    'uiGmapIWindow', 'uiGmapPlural', 'uiGmapWindowsParentModel', 'uiGmapPromise', 'uiGmapLogger', function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
	
	      /*
	      Windows directive where many windows map to the models property
	       */
	      var Windows;
	      return Windows = (function(superClass) {
	        extend(Windows, superClass);
	
	        function Windows() {
	          this.link = bind(this.link, this);
	          Windows.__super__.constructor.call(this);
	          this.require = ['^' + 'uiGmapGoogleMap', '^?' + 'uiGmapMarkers'];
	          this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
	          Plural.extend(this);
	          $log.debug(this);
	        }
	
	        Windows.prototype.link = function(scope, element, attrs, ctrls) {
	          var mapScope, markerCtrl, markerScope;
	          mapScope = ctrls[0].getScope();
	          markerCtrl = ctrls.length > 1 && (ctrls[1] != null) ? ctrls[1] : void 0;
	          markerScope = markerCtrl != null ? markerCtrl.getScope() : void 0;
	          return mapScope.deferred.promise.then((function(_this) {
	            return function(map) {
	              var promise, ref;
	              promise = (markerScope != null ? (ref = markerScope.deferred) != null ? ref.promise : void 0 : void 0) || uiGmapPromise.resolve();
	              return promise.then(function() {
	                var pieces, ref1;
	                pieces = (ref1 = _this.parentModel) != null ? ref1.existingPieces : void 0;
	                if (pieces) {
	                  return pieces.then(function() {
	                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
	                  });
	                } else {
	                  return _this.init(scope, element, attrs, ctrls, map, markerScope);
	                }
	              });
	            };
	          })(this));
	        };
	
	        Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
	          var parentModel;
	          parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
	          Plural.link(scope, parentModel);
	          if (scope.control != null) {
	            scope.control.getGWindows = function() {
	              return parentModel.plurals.map(function(child) {
	                return child.gObject;
	              });
	            };
	            return scope.control.getChildWindows = function() {
	              return parentModel.plurals;
	            };
	          }
	        };
	
	        return Windows;
	
	      })(IWindow);
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	Nick Baugh - https://github.com/niftylettuce
	 */
	
	
	/*globals angular */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", ['uiGmapMap', function(uiGmapMap) {
	    return new uiGmapMap();
	  }]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	Map marker directive
	
	This directive is used to create a marker on an existing map.
	This directive creates a new scope.
	
	{attribute coords required}  object containing latitude and longitude properties
	{attribute icon optional}    string url to image used for marker icon
	{attribute animate optional} if set to false, the marker won't be animated (on by default)
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapMarker', [
	    '$timeout', 'uiGmapMarker', function($timeout, Marker) {
	      return new Marker($timeout);
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	Map marker directive
	
	This directive is used to create a marker on an existing map.
	This directive creates a new scope.
	
	{attribute coords required}  object containing latitude and longitude properties
	{attribute icon optional}    string url to image used for marker icon
	{attribute animate optional} if set to false, the marker won't be animated (on by default)
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapMarkers', [
	    '$timeout', 'uiGmapMarkers', function($timeout, Markers) {
	      return new Markers($timeout);
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	Rick Huizinga - https://plus.google.com/+RickHuizinga
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapPolygon', [
	    'uiGmapPolygon', function(Polygon) {
	      return new Polygon();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Julian Popescu - https://github.com/jpopesculian
	Rick Huizinga - https://plus.google.com/+RickHuizinga
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive("uiGmapCircle", [
	    "uiGmapCircle", function(Circle) {
	      return Circle;
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", [
	    "uiGmapPolyline", function(Polyline) {
	      return new Polyline();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapPolylines', [
	    'uiGmapPolylines', function(Polylines) {
	      return new Polylines();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	Chentsu Lin - https://github.com/ChenTsuLin
	 */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", [
	    "uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
	      return Rectangle;
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	Map info window directive
	
	This directive is used to create an info window on an existing map.
	This directive creates a new scope.
	
	{attribute coords required}  object containing latitude and longitude properties
	{attribute show optional}    map will show when this expression returns true
	 */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", [
	    "$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
	      return new Window($timeout, $compile, $http, $templateCache);
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	Map info window directive
	
	This directive is used to create an info window on an existing map.
	This directive creates a new scope.
	
	{attribute coords required}  object containing latitude and longitude properties
	{attribute show optional}    map will show when this expression returns true
	 */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", [
	    "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
	      return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors:
	- Nicolas Laplante https://plus.google.com/108189012221374960701
	- Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	Map Layer directive
	
	This directive is used to create any type of Layer from the google maps sdk.
	This directive creates a new scope.
	
	{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module('uiGmapgoogle-maps').directive('uiGmapLayer', [
	    '$timeout', 'uiGmapLogger', 'uiGmapLayerParentModel', function($timeout, Logger, LayerParentModel) {
	      var Layer;
	      Layer = (function() {
	        function Layer() {
	          this.link = bind(this.link, this);
	          this.$log = Logger;
	          this.restrict = 'EMA';
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.priority = -1;
	          this.transclude = true;
	          this.template = '<span class=\'angular-google-map-layer\' ng-transclude></span>';
	          this.replace = true;
	          this.scope = {
	            show: '=show',
	            type: '=type',
	            namespace: '=namespace',
	            options: '=options',
	            onCreated: '&oncreated'
	          };
	        }
	
	        Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then((function(_this) {
	            return function(map) {
	              if (scope.onCreated != null) {
	                return new LayerParentModel(scope, element, attrs, map, scope.onCreated);
	              } else {
	                return new LayerParentModel(scope, element, attrs, map);
	              }
	            };
	          })(this));
	        };
	
	        return Layer;
	
	      })();
	      return new Layer();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Adam Kreitals, kreitals@hotmail.com
	 */
	
	
	/*
	mapControl directive
	
	This directive is used to create a custom control element on an existing map.
	This directive creates a new scope.
	
	{attribute template required}  	string url of the template to be used for the control
	{attribute position optional}  	string position of the control of the form top-left or TOP_LEFT defaults to TOP_CENTER
	{attribute controller optional}	string controller to be applied to the template
	{attribute index optional}		number index for controlling the order of similarly positioned mapControl elements
	 */
	
	(function() {
	  angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", [
	    "uiGmapControl", function(Control) {
	      return new Control();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicholas McCready - https://twitter.com/nmccready
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapDragZoom', [
	    'uiGmapDragZoom', function(DragZoom) {
	      return DragZoom;
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps').directive("uiGmapDrawingManager", [
	    "uiGmapDrawingManager", function(DrawingManager) {
	      return DrawingManager;
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicholas McCready - https://twitter.com/nmccready
	 * Brunt of the work is in DrawFreeHandChildModel
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapFreeDrawPolygons', [
	    'uiGmapApiFreeDrawPolygons', function(FreeDrawPolygons) {
	      return new FreeDrawPolygons();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	Map Layer directive
	
	This directive is used to create any type of Layer from the google maps sdk.
	This directive creates a new scope.
	
	{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", [
	    "$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
	      var MapType;
	      MapType = (function() {
	        function MapType() {
	          this.link = bind(this.link, this);
	          this.$log = Logger;
	          this.restrict = "EMA";
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.priority = -1;
	          this.transclude = true;
	          this.template = '<span class=\"angular-google-map-layer\" ng-transclude></span>';
	          this.replace = true;
	          this.scope = {
	            show: "=show",
	            options: '=options',
	            refresh: '=refresh',
	            id: '@'
	          };
	        }
	
	        MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then((function(_this) {
	            return function(map) {
	              return new MapTypeParentModel(scope, element, attrs, map);
	            };
	          })(this));
	        };
	
	        return MapType;
	
	      })();
	      return new MapType();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	Map Layers directive
	
	This directive is used to create any type of Layer from the google maps sdk.
	This directive creates a new scope.
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module('uiGmapgoogle-maps').directive("uiGmapMapTypes", [
	    "$timeout", "uiGmapLogger", "uiGmapMapTypesParentModel", function($timeout, Logger, MapTypesParentModel) {
	      var MapTypes;
	      MapTypes = (function() {
	        function MapTypes() {
	          this.link = bind(this.link, this);
	          this.$log = Logger;
	          this.restrict = "EMA";
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.priority = -1;
	          this.transclude = true;
	          this.template = '<span class=\"angular-google-map-layers\" ng-transclude></span>';
	          this.scope = {
	            mapTypes: "=mapTypes",
	            show: "=show",
	            options: "=options",
	            refresh: "=refresh",
	            id: "=idKey"
	          };
	        }
	
	        MapTypes.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return mapCtrl.getScope().deferred.promise.then((function(_this) {
	            return function(map) {
	              return new MapTypesParentModel(scope, element, attrs, map);
	            };
	          })(this));
	        };
	
	        return MapTypes;
	
	      })();
	      return new MapTypes();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors
	Nicolas Laplante - https://plus.google.com/108189012221374960701
	Nicholas McCready - https://twitter.com/nmccready
	Rick Huizinga - https://plus.google.com/+RickHuizinga
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapPolygons', [
	    'uiGmapPolygons', function(Polygons) {
	      return new Polygons();
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors:
	- Nicolas Laplante https://plus.google.com/108189012221374960701
	- Nicholas McCready - https://twitter.com/nmccready
	- Carrie Kengle - http://about.me/carrie
	 */
	
	
	/*
	Places Search Box directive
	
	This directive is used to create a Places Search Box.
	This directive creates a new scope.
	
	{attribute input required}  HTMLInputElement
	{attribute options optional} The options that can be set on a SearchBox object (google.maps.places.SearchBoxOptions object specification)
	 */
	
	(function() {
	  var bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
	
	  angular.module('uiGmapgoogle-maps').directive('uiGmapSearchBox', [
	    'uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapSearchBoxParentModel', '$http', '$templateCache', '$compile', function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
	      var SearchBox;
	      SearchBox = (function() {
	        SearchBox.prototype.require = 'ngModel';
	
	        function SearchBox() {
	          this.link = bind(this.link, this);
	          this.$log = Logger;
	          this.restrict = 'EMA';
	          this.require = '^' + 'uiGmapGoogleMap';
	          this.priority = -1;
	          this.transclude = true;
	          this.template = '<span class=\'angular-google-map-search\' ng-transclude></span>';
	          this.replace = true;
	          this.scope = {
	            template: '=template',
	            events: '=events',
	            position: '=?position',
	            options: '=?options',
	            parentdiv: '=?parentdiv',
	            ngModel: "=?"
	          };
	        }
	
	        SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
	          return GoogleMapApi.then((function(_this) {
	            return function(maps) {
	              if (scope.template == null) {
	                $templateCache.put('uigmap-searchbox-default.tpl.html', '<input type="text">');
	                scope.template = 'uigmap-searchbox-default.tpl.html';
	              }
	              return $http.get(scope.template, {
	                cache: $templateCache
	              }).success(function(template) {
	                if (angular.isUndefined(scope.events)) {
	                  _this.$log.error('searchBox: the events property is required');
	                  return;
	                }
	                return mapCtrl.getScope().deferred.promise.then(function(map) {
	                  var ctrlPosition;
	                  ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, '_') : 'TOP_LEFT';
	                  if (!maps.ControlPosition[ctrlPosition]) {
	                    _this.$log.error('searchBox: invalid position property');
	                    return;
	                  }
	                  return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
	                });
	              });
	            };
	          })(this));
	        };
	
	        return SearchBox;
	
	      })();
	      return new SearchBox();
	    }
	  ]);
	
	}).call(this);
	;(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapShow', [
	    '$animate', 'uiGmapLogger', function($animate, $log) {
	      return {
	        scope: {
	          'uiGmapShow': '=',
	          'uiGmapAfterShow': '&',
	          'uiGmapAfterHide': '&'
	        },
	        link: function(scope, element) {
	          var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
	          angular_post_1_3_handle = function(animateAction, cb) {
	            return $animate[animateAction](element, 'ng-hide').then(function() {
	              return cb();
	            });
	          };
	          angular_pre_1_3_handle = function(animateAction, cb) {
	            return $animate[animateAction](element, 'ng-hide', cb);
	          };
	          handle = function(animateAction, cb) {
	            if (angular.version.major > 1) {
	              return $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + "\"");
	            }
	            if (angular.version.major === 1 && angular.version.minor < 3) {
	              return angular_pre_1_3_handle(animateAction, cb);
	            }
	            return angular_post_1_3_handle(animateAction, cb);
	          };
	          return scope.$watch('uiGmapShow', function(show) {
	            if (show) {
	              handle('removeClass', scope.uiGmapAfterShow);
	            }
	            if (!show) {
	              return handle('addClass', scope.uiGmapAfterHide);
	            }
	          });
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;
	/*
	@authors:
	- Nicholas McCready - https://twitter.com/nmccready
	 */
	
	
	/*
	StreetViewPanorama Directive to care of basic initialization of StreetViewPanorama
	 */
	
	(function() {
	  angular.module('uiGmapgoogle-maps').directive('uiGmapStreetViewPanorama', [
	    'uiGmapGoogleMapApi', 'uiGmapLogger', 'uiGmapGmapUtil', 'uiGmapEventsHelper', function(GoogleMapApi, $log, GmapUtil, EventsHelper) {
	      var name;
	      name = 'uiGmapStreetViewPanorama';
	      return {
	        restrict: 'EMA',
	        template: '<div class="angular-google-map-street-view-panorama"></div>',
	        replace: true,
	        scope: {
	          focalcoord: '=',
	          radius: '=?',
	          events: '=?',
	          options: '=?',
	          control: '=?',
	          povoptions: '=?',
	          imagestatus: '='
	        },
	        link: function(scope, element, attrs) {
	          return GoogleMapApi.then((function(_this) {
	            return function(maps) {
	              var clean, create, didCreateOptionsFromDirective, firstTime, handleSettings, listeners, opts, pano, povOpts, sv;
	              pano = void 0;
	              sv = void 0;
	              didCreateOptionsFromDirective = false;
	              listeners = void 0;
	              opts = null;
	              povOpts = null;
	              clean = function() {
	                EventsHelper.removeEvents(listeners);
	                if (pano != null) {
	                  pano.unbind('position');
	                  pano.setVisible(false);
	                }
	                if (sv != null) {
	                  if ((sv != null ? sv.setVisible : void 0) != null) {
	                    sv.setVisible(false);
	                  }
	                  return sv = void 0;
	                }
	              };
	              handleSettings = function(perspectivePoint, focalPoint) {
	                var heading;
	                heading = google.maps.geometry.spherical.computeHeading(perspectivePoint, focalPoint);
	                didCreateOptionsFromDirective = true;
	                scope.radius = scope.radius || 50;
	                povOpts = angular.extend({
	                  heading: heading,
	                  zoom: 1,
	                  pitch: 0
	                }, scope.povoptions || {});
	                opts = opts = angular.extend({
	                  navigationControl: false,
	                  addressControl: false,
	                  linksControl: false,
	                  position: perspectivePoint,
	                  pov: povOpts,
	                  visible: true
	                }, scope.options || {});
	                return didCreateOptionsFromDirective = false;
	              };
	              create = function() {
	                var focalPoint;
	                if (!scope.focalcoord) {
	                  $log.error(name + ": focalCoord needs to be defined");
	                  return;
	                }
	                if (!scope.radius) {
	                  $log.error(name + ": needs a radius to set the camera view from its focal target.");
	                  return;
	                }
	                clean();
	                if (sv == null) {
	                  sv = new google.maps.StreetViewService();
	                }
	                if (scope.events) {
	                  listeners = EventsHelper.setEvents(sv, scope, scope);
	                }
	                focalPoint = GmapUtil.getCoords(scope.focalcoord);
	                return sv.getPanoramaByLocation(focalPoint, scope.radius, function(streetViewPanoramaData, status) {
	                  var ele, perspectivePoint, ref;
	                  if (scope.imagestatus != null) {
	                    scope.imagestatus = status;
	                  }
	                  if (((ref = scope.events) != null ? ref.image_status_changed : void 0) != null) {
	                    scope.events.image_status_changed(sv, 'image_status_changed', scope, status);
	                  }
	                  if (status === "OK") {
	                    perspectivePoint = streetViewPanoramaData.location.latLng;
	                    handleSettings(perspectivePoint, focalPoint);
	                    ele = element[0];
	                    return pano = new google.maps.StreetViewPanorama(ele, opts);
	                  }
	                });
	              };
	              if (scope.control != null) {
	                scope.control.getOptions = function() {
	                  return opts;
	                };
	                scope.control.getPovOptions = function() {
	                  return povOpts;
	                };
	                scope.control.getGObject = function() {
	                  return sv;
	                };
	                scope.control.getGPano = function() {
	                  return pano;
	                };
	              }
	              scope.$watch('options', function(newValue, oldValue) {
	                if (newValue === oldValue || newValue === opts || didCreateOptionsFromDirective) {
	                  return;
	                }
	                return create();
	              });
	              firstTime = true;
	              scope.$watch('focalcoord', function(newValue, oldValue) {
	                if (newValue === oldValue && !firstTime) {
	                  return;
	                }
	                if (newValue == null) {
	                  return;
	                }
	                firstTime = false;
	                return create();
	              });
	              return scope.$on('$destroy', function() {
	                return clean();
	              });
	            };
	          })(this));
	        }
	      };
	    }
	  ]);
	
	}).call(this);
	;angular.module('uiGmapgoogle-maps.wrapped')
	.service('uiGmapuuid', function() {
	  //BEGIN REPLACE
	  /* istanbul ignore next */
	  /*
	 Version: core-1.0
	 The MIT License: Copyright (c) 2012 LiosK.
	*/
	function UUID(){}UUID.generate=function(){var a=UUID._gri,b=UUID._ha;return b(a(32),8)+"-"+b(a(16),4)+"-"+b(16384|a(12),4)+"-"+b(32768|a(14),4)+"-"+b(a(48),12)};UUID._gri=function(a){return 0>a?NaN:30>=a?0|Math.random()*(1<<a):53>=a?(0|1073741824*Math.random())+1073741824*(0|Math.random()*(1<<a-30)):NaN};UUID._ha=function(a,b){for(var c=a.toString(16),d=b-c.length,e="0";0<d;d>>>=1,e+=e)d&1&&(c=e+c);return c};
	
	  //END REPLACE
	return UUID;
	});
	;// wrap the utility libraries needed in ./lib
	// http://google-maps-utility-library-v3.googlecode.com/svn/
	angular.module('uiGmapgoogle-maps.wrapped')
	.service('uiGmapGoogleMapsUtilV3', function () {
	  return {
	    init: _.once(function () {
	      //BEGIN REPLACE
	      /* istanbul ignore next */
	      +function(){
	      function ClusterIcon(cluster,styles){cluster.getMarkerClusterer().extend(ClusterIcon,google.maps.OverlayView),this.cluster_=cluster,this.className_=cluster.getMarkerClusterer().getClusterClass(),this.styles_=styles,this.center_=null,this.div_=null,this.sums_=null,this.visible_=!1,this.setMap(cluster.getMap())}function Cluster(mc){this.markerClusterer_=mc,this.map_=mc.getMap(),this.gridSize_=mc.getGridSize(),this.minClusterSize_=mc.getMinimumClusterSize(),this.averageCenter_=mc.getAverageCenter(),this.hideLabel_=mc.getHideLabel(),this.markers_=[],this.center_=null,this.bounds_=null,this.clusterIcon_=new ClusterIcon(this,mc.getStyles())}function MarkerClusterer(map,opt_markers,opt_options){this.extend(MarkerClusterer,google.maps.OverlayView),opt_markers=opt_markers||[],opt_options=opt_options||{},this.markers_=[],this.clusters_=[],this.listeners_=[],this.activeMap_=null,this.ready_=!1,this.gridSize_=opt_options.gridSize||60,this.minClusterSize_=opt_options.minimumClusterSize||2,this.maxZoom_=opt_options.maxZoom||null,this.styles_=opt_options.styles||[],this.title_=opt_options.title||"",this.zoomOnClick_=!0,void 0!==opt_options.zoomOnClick&&(this.zoomOnClick_=opt_options.zoomOnClick),this.averageCenter_=!1,void 0!==opt_options.averageCenter&&(this.averageCenter_=opt_options.averageCenter),this.ignoreHidden_=!1,void 0!==opt_options.ignoreHidden&&(this.ignoreHidden_=opt_options.ignoreHidden),this.enableRetinaIcons_=!1,void 0!==opt_options.enableRetinaIcons&&(this.enableRetinaIcons_=opt_options.enableRetinaIcons),this.hideLabel_=!1,void 0!==opt_options.hideLabel&&(this.hideLabel_=opt_options.hideLabel),this.imagePath_=opt_options.imagePath||MarkerClusterer.IMAGE_PATH,this.imageExtension_=opt_options.imageExtension||MarkerClusterer.IMAGE_EXTENSION,this.imageSizes_=opt_options.imageSizes||MarkerClusterer.IMAGE_SIZES,this.calculator_=opt_options.calculator||MarkerClusterer.CALCULATOR,this.batchSize_=opt_options.batchSize||MarkerClusterer.BATCH_SIZE,this.batchSizeIE_=opt_options.batchSizeIE||MarkerClusterer.BATCH_SIZE_IE,this.clusterClass_=opt_options.clusterClass||"cluster",-1!==navigator.userAgent.toLowerCase().indexOf("msie")&&(this.batchSize_=this.batchSizeIE_),this.setupStyles_(),this.addMarkers(opt_markers,!0),this.setMap(map)}ClusterIcon.prototype.onAdd=function(){var cMouseDownInCluster,cDraggingMapByCluster,cClusterIcon=this;this.div_=document.createElement("div"),this.div_.className=this.className_,this.visible_&&this.show(),this.getPanes().overlayMouseTarget.appendChild(this.div_),this.boundsChangedListener_=google.maps.event.addListener(this.getMap(),"bounds_changed",function(){cDraggingMapByCluster=cMouseDownInCluster}),google.maps.event.addDomListener(this.div_,"mousedown",function(){cMouseDownInCluster=!0,cDraggingMapByCluster=!1}),google.maps.event.addDomListener(this.div_,"click",function(e){if(cMouseDownInCluster=!1,!cDraggingMapByCluster){var theBounds,mz,mc=cClusterIcon.cluster_.getMarkerClusterer();google.maps.event.trigger(mc,"click",cClusterIcon.cluster_),google.maps.event.trigger(mc,"clusterclick",cClusterIcon.cluster_),mc.getZoomOnClick()&&(mz=mc.getMaxZoom(),theBounds=cClusterIcon.cluster_.getBounds(),mc.getMap().fitBounds(theBounds),setTimeout(function(){mc.getMap().fitBounds(theBounds),null!==mz&&mc.getMap().getZoom()>mz&&mc.getMap().setZoom(mz+1)},100)),e.cancelBubble=!0,e.stopPropagation&&e.stopPropagation()}}),google.maps.event.addDomListener(this.div_,"mouseover",function(){var mc=cClusterIcon.cluster_.getMarkerClusterer();google.maps.event.trigger(mc,"mouseover",cClusterIcon.cluster_)}),google.maps.event.addDomListener(this.div_,"mouseout",function(){var mc=cClusterIcon.cluster_.getMarkerClusterer();google.maps.event.trigger(mc,"mouseout",cClusterIcon.cluster_)})},ClusterIcon.prototype.onRemove=function(){this.div_&&this.div_.parentNode&&(this.hide(),google.maps.event.removeListener(this.boundsChangedListener_),google.maps.event.clearInstanceListeners(this.div_),this.div_.parentNode.removeChild(this.div_),this.div_=null)},ClusterIcon.prototype.draw=function(){if(this.visible_){var pos=this.getPosFromLatLng_(this.center_);this.div_.style.top=pos.y+"px",this.div_.style.left=pos.x+"px"}},ClusterIcon.prototype.hide=function(){this.div_&&(this.div_.style.display="none"),this.visible_=!1},ClusterIcon.prototype.show=function(){if(this.div_){var img="",bp=this.backgroundPosition_.split(" "),spriteH=parseInt(bp[0].trim(),10),spriteV=parseInt(bp[1].trim(),10),pos=this.getPosFromLatLng_(this.center_);this.div_.style.cssText=this.createCss(pos),img="<img src='"+this.url_+"' style='position: absolute; top: "+spriteV+"px; left: "+spriteH+"px; ",img+=this.cluster_.getMarkerClusterer().enableRetinaIcons_?"width: "+this.width_+"px;height: "+this.height_+"px;":"clip: rect("+-1*spriteV+"px, "+(-1*spriteH+this.width_)+"px, "+(-1*spriteV+this.height_)+"px, "+-1*spriteH+"px);",img+="'>",this.div_.innerHTML=img+"<div style='position: absolute;top: "+this.anchorText_[0]+"px;left: "+this.anchorText_[1]+"px;color: "+this.textColor_+";font-size: "+this.textSize_+"px;font-family: "+this.fontFamily_+";font-weight: "+this.fontWeight_+";font-style: "+this.fontStyle_+";text-decoration: "+this.textDecoration_+";text-align: center;width: "+this.width_+"px;line-height:"+this.height_+"px;'>"+(this.cluster_.hideLabel_?" ":this.sums_.text)+"</div>",this.div_.title="undefined"==typeof this.sums_.title||""===this.sums_.title?this.cluster_.getMarkerClusterer().getTitle():this.sums_.title,this.div_.style.display=""}this.visible_=!0},ClusterIcon.prototype.useStyle=function(sums){this.sums_=sums;var index=Math.max(0,sums.index-1);index=Math.min(this.styles_.length-1,index);var style=this.styles_[index];this.url_=style.url,this.height_=style.height,this.width_=style.width,this.anchorText_=style.anchorText||[0,0],this.anchorIcon_=style.anchorIcon||[parseInt(this.height_/2,10),parseInt(this.width_/2,10)],this.textColor_=style.textColor||"black",this.textSize_=style.textSize||11,this.textDecoration_=style.textDecoration||"none",this.fontWeight_=style.fontWeight||"bold",this.fontStyle_=style.fontStyle||"normal",this.fontFamily_=style.fontFamily||"Arial,sans-serif",this.backgroundPosition_=style.backgroundPosition||"0 0"},ClusterIcon.prototype.setCenter=function(center){this.center_=center},ClusterIcon.prototype.createCss=function(pos){var style=[];return style.push("cursor: pointer;"),style.push("position: absolute; top: "+pos.y+"px; left: "+pos.x+"px;"),style.push("width: "+this.width_+"px; height: "+this.height_+"px;"),style.join("")},ClusterIcon.prototype.getPosFromLatLng_=function(latlng){var pos=this.getProjection().fromLatLngToDivPixel(latlng);return pos.x-=this.anchorIcon_[1],pos.y-=this.anchorIcon_[0],pos.x=parseInt(pos.x,10),pos.y=parseInt(pos.y,10),pos},Cluster.prototype.getSize=function(){return this.markers_.length},Cluster.prototype.getMarkers=function(){return this.markers_},Cluster.prototype.getCenter=function(){return this.center_},Cluster.prototype.getMap=function(){return this.map_},Cluster.prototype.getMarkerClusterer=function(){return this.markerClusterer_},Cluster.prototype.getBounds=function(){var i,bounds=new google.maps.LatLngBounds(this.center_,this.center_),markers=this.getMarkers();for(i=0;i<markers.length;i++)bounds.extend(markers[i].getPosition());return bounds},Cluster.prototype.remove=function(){this.clusterIcon_.setMap(null),this.markers_=[],delete this.markers_},Cluster.prototype.addMarker=function(marker){var i,mCount,mz;if(this.isMarkerAlreadyAdded_(marker))return!1;if(this.center_){if(this.averageCenter_){var l=this.markers_.length+1,lat=(this.center_.lat()*(l-1)+marker.getPosition().lat())/l,lng=(this.center_.lng()*(l-1)+marker.getPosition().lng())/l;this.center_=new google.maps.LatLng(lat,lng),this.calculateBounds_()}}else this.center_=marker.getPosition(),this.calculateBounds_();if(marker.isAdded=!0,this.markers_.push(marker),mCount=this.markers_.length,mz=this.markerClusterer_.getMaxZoom(),null!==mz&&this.map_.getZoom()>mz)marker.getMap()!==this.map_&&marker.setMap(this.map_);else if(mCount<this.minClusterSize_)marker.getMap()!==this.map_&&marker.setMap(this.map_);else if(mCount===this.minClusterSize_)for(i=0;mCount>i;i++)this.markers_[i].setMap(null);else marker.setMap(null);return!0},Cluster.prototype.isMarkerInClusterBounds=function(marker){return this.bounds_.contains(marker.getPosition())},Cluster.prototype.calculateBounds_=function(){var bounds=new google.maps.LatLngBounds(this.center_,this.center_);this.bounds_=this.markerClusterer_.getExtendedBounds(bounds)},Cluster.prototype.updateIcon_=function(){var mCount=this.markers_.length,mz=this.markerClusterer_.getMaxZoom();if(null!==mz&&this.map_.getZoom()>mz)return void this.clusterIcon_.hide();if(mCount<this.minClusterSize_)return void this.clusterIcon_.hide();var numStyles=this.markerClusterer_.getStyles().length,sums=this.markerClusterer_.getCalculator()(this.markers_,numStyles);this.clusterIcon_.setCenter(this.center_),this.clusterIcon_.useStyle(sums),this.clusterIcon_.show()},Cluster.prototype.isMarkerAlreadyAdded_=function(marker){for(var i=0,n=this.markers_.length;n>i;i++)if(marker===this.markers_[i])return!0;return!1},MarkerClusterer.prototype.onAdd=function(){var cMarkerClusterer=this;this.activeMap_=this.getMap(),this.ready_=!0,this.repaint(),this.listeners_=[google.maps.event.addListener(this.getMap(),"zoom_changed",function(){cMarkerClusterer.resetViewport_(!1),(this.getZoom()===(this.get("minZoom")||0)||this.getZoom()===this.get("maxZoom"))&&google.maps.event.trigger(this,"idle")}),google.maps.event.addListener(this.getMap(),"idle",function(){cMarkerClusterer.redraw_()})]},MarkerClusterer.prototype.onRemove=function(){var i;for(i=0;i<this.markers_.length;i++)this.markers_[i].getMap()!==this.activeMap_&&this.markers_[i].setMap(this.activeMap_);for(i=0;i<this.clusters_.length;i++)this.clusters_[i].remove();for(this.clusters_=[],i=0;i<this.listeners_.length;i++)google.maps.event.removeListener(this.listeners_[i]);this.listeners_=[],this.activeMap_=null,this.ready_=!1},MarkerClusterer.prototype.draw=function(){},MarkerClusterer.prototype.setupStyles_=function(){var i,size;if(!(this.styles_.length>0))for(i=0;i<this.imageSizes_.length;i++)size=this.imageSizes_[i],this.styles_.push({url:this.imagePath_+(i+1)+"."+this.imageExtension_,height:size,width:size})},MarkerClusterer.prototype.fitMapToMarkers=function(){var i,markers=this.getMarkers(),bounds=new google.maps.LatLngBounds;for(i=0;i<markers.length;i++)bounds.extend(markers[i].getPosition());this.getMap().fitBounds(bounds)},MarkerClusterer.prototype.getGridSize=function(){return this.gridSize_},MarkerClusterer.prototype.setGridSize=function(gridSize){this.gridSize_=gridSize},MarkerClusterer.prototype.getMinimumClusterSize=function(){return this.minClusterSize_},MarkerClusterer.prototype.setMinimumClusterSize=function(minimumClusterSize){this.minClusterSize_=minimumClusterSize},MarkerClusterer.prototype.getMaxZoom=function(){return this.maxZoom_},MarkerClusterer.prototype.setMaxZoom=function(maxZoom){this.maxZoom_=maxZoom},MarkerClusterer.prototype.getStyles=function(){return this.styles_},MarkerClusterer.prototype.setStyles=function(styles){this.styles_=styles},MarkerClusterer.prototype.getTitle=function(){return this.title_},MarkerClusterer.prototype.setTitle=function(title){this.title_=title},MarkerClusterer.prototype.getZoomOnClick=function(){return this.zoomOnClick_},MarkerClusterer.prototype.setZoomOnClick=function(zoomOnClick){this.zoomOnClick_=zoomOnClick},MarkerClusterer.prototype.getAverageCenter=function(){return this.averageCenter_},MarkerClusterer.prototype.setAverageCenter=function(averageCenter){this.averageCenter_=averageCenter},MarkerClusterer.prototype.getIgnoreHidden=function(){return this.ignoreHidden_},MarkerClusterer.prototype.setIgnoreHidden=function(ignoreHidden){this.ignoreHidden_=ignoreHidden},MarkerClusterer.prototype.getEnableRetinaIcons=function(){return this.enableRetinaIcons_},MarkerClusterer.prototype.setEnableRetinaIcons=function(enableRetinaIcons){this.enableRetinaIcons_=enableRetinaIcons},MarkerClusterer.prototype.getImageExtension=function(){return this.imageExtension_},MarkerClusterer.prototype.setImageExtension=function(imageExtension){this.imageExtension_=imageExtension},MarkerClusterer.prototype.getImagePath=function(){return this.imagePath_},MarkerClusterer.prototype.setImagePath=function(imagePath){this.imagePath_=imagePath},MarkerClusterer.prototype.getImageSizes=function(){return this.imageSizes_},MarkerClusterer.prototype.setImageSizes=function(imageSizes){this.imageSizes_=imageSizes},MarkerClusterer.prototype.getCalculator=function(){return this.calculator_},MarkerClusterer.prototype.setCalculator=function(calculator){this.calculator_=calculator},MarkerClusterer.prototype.setHideLabel=function(hideLabel){this.hideLabel_=hideLabel},MarkerClusterer.prototype.getHideLabel=function(){return this.hideLabel_},MarkerClusterer.prototype.getBatchSizeIE=function(){return this.batchSizeIE_},MarkerClusterer.prototype.setBatchSizeIE=function(batchSizeIE){this.batchSizeIE_=batchSizeIE},MarkerClusterer.prototype.getClusterClass=function(){return this.clusterClass_},MarkerClusterer.prototype.setClusterClass=function(clusterClass){this.clusterClass_=clusterClass},MarkerClusterer.prototype.getMarkers=function(){return this.markers_},MarkerClusterer.prototype.getTotalMarkers=function(){return this.markers_.length},MarkerClusterer.prototype.getClusters=function(){return this.clusters_},MarkerClusterer.prototype.getTotalClusters=function(){return this.clusters_.length},MarkerClusterer.prototype.addMarker=function(marker,opt_nodraw){this.pushMarkerTo_(marker),opt_nodraw||this.redraw_()},MarkerClusterer.prototype.addMarkers=function(markers,opt_nodraw){var key;for(key in markers)markers.hasOwnProperty(key)&&this.pushMarkerTo_(markers[key]);opt_nodraw||this.redraw_()},MarkerClusterer.prototype.pushMarkerTo_=function(marker){if(marker.getDraggable()){var cMarkerClusterer=this;google.maps.event.addListener(marker,"dragend",function(){cMarkerClusterer.ready_&&(this.isAdded=!1,cMarkerClusterer.repaint())})}marker.isAdded=!1,this.markers_.push(marker)},MarkerClusterer.prototype.removeMarker=function(marker,opt_nodraw,opt_noMapRemove){var removeFromMap=!0&&!opt_noMapRemove,removed=this.removeMarker_(marker,removeFromMap);return!opt_nodraw&&removed&&this.repaint(),removed},MarkerClusterer.prototype.removeMarkers=function(markers,opt_nodraw,opt_noMapRemove){var i,r,removed=!1,removeFromMap=!0&&!opt_noMapRemove;for(i=0;i<markers.length;i++)r=this.removeMarker_(markers[i],removeFromMap),removed=removed||r;return!opt_nodraw&&removed&&this.repaint(),removed},MarkerClusterer.prototype.removeMarker_=function(marker,removeFromMap){var i,index=-1;if(this.markers_.indexOf)index=this.markers_.indexOf(marker);else for(i=0;i<this.markers_.length;i++)if(marker===this.markers_[i]){index=i;break}return-1===index?!1:(removeFromMap&&marker.setMap(null),this.markers_.splice(index,1),!0)},MarkerClusterer.prototype.clearMarkers=function(){this.resetViewport_(!0),this.markers_=[]},MarkerClusterer.prototype.repaint=function(){var oldClusters=this.clusters_.slice();this.clusters_=[],this.resetViewport_(!1),this.redraw_(),setTimeout(function(){var i;for(i=0;i<oldClusters.length;i++)oldClusters[i].remove()},0)},MarkerClusterer.prototype.getExtendedBounds=function(bounds){var projection=this.getProjection(),tr=new google.maps.LatLng(bounds.getNorthEast().lat(),bounds.getNorthEast().lng()),bl=new google.maps.LatLng(bounds.getSouthWest().lat(),bounds.getSouthWest().lng()),trPix=projection.fromLatLngToDivPixel(tr);trPix.x+=this.gridSize_,trPix.y-=this.gridSize_;var blPix=projection.fromLatLngToDivPixel(bl);blPix.x-=this.gridSize_,blPix.y+=this.gridSize_;var ne=projection.fromDivPixelToLatLng(trPix),sw=projection.fromDivPixelToLatLng(blPix);return bounds.extend(ne),bounds.extend(sw),bounds},MarkerClusterer.prototype.redraw_=function(){this.createClusters_(0)},MarkerClusterer.prototype.resetViewport_=function(opt_hide){var i,marker;for(i=0;i<this.clusters_.length;i++)this.clusters_[i].remove();for(this.clusters_=[],i=0;i<this.markers_.length;i++)marker=this.markers_[i],marker.isAdded=!1,opt_hide&&marker.setMap(null)},MarkerClusterer.prototype.distanceBetweenPoints_=function(p1,p2){var R=6371,dLat=(p2.lat()-p1.lat())*Math.PI/180,dLon=(p2.lng()-p1.lng())*Math.PI/180,a=Math.sin(dLat/2)*Math.sin(dLat/2)+Math.cos(p1.lat()*Math.PI/180)*Math.cos(p2.lat()*Math.PI/180)*Math.sin(dLon/2)*Math.sin(dLon/2),c=2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a)),d=R*c;return d},MarkerClusterer.prototype.isMarkerInBounds_=function(marker,bounds){return bounds.contains(marker.getPosition())},MarkerClusterer.prototype.addToClosestCluster_=function(marker){var i,d,cluster,center,distance=4e4,clusterToAddTo=null;for(i=0;i<this.clusters_.length;i++)cluster=this.clusters_[i],center=cluster.getCenter(),center&&(d=this.distanceBetweenPoints_(center,marker.getPosition()),distance>d&&(distance=d,clusterToAddTo=cluster));clusterToAddTo&&clusterToAddTo.isMarkerInClusterBounds(marker)?clusterToAddTo.addMarker(marker):(cluster=new Cluster(this),cluster.addMarker(marker),this.clusters_.push(cluster))},MarkerClusterer.prototype.createClusters_=function(iFirst){var i,marker,mapBounds,cMarkerClusterer=this;if(this.ready_){0===iFirst&&(google.maps.event.trigger(this,"clusteringbegin",this),"undefined"!=typeof this.timerRefStatic&&(clearTimeout(this.timerRefStatic),delete this.timerRefStatic)),mapBounds=this.getMap().getZoom()>3?new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),this.getMap().getBounds().getNorthEast()):new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472,-178.48388434375),new google.maps.LatLng(-85.08136444384544,178.00048865625));var bounds=this.getExtendedBounds(mapBounds),iLast=Math.min(iFirst+this.batchSize_,this.markers_.length);for(i=iFirst;iLast>i;i++)marker=this.markers_[i],!marker.isAdded&&this.isMarkerInBounds_(marker,bounds)&&(!this.ignoreHidden_||this.ignoreHidden_&&marker.getVisible())&&this.addToClosestCluster_(marker);if(iLast<this.markers_.length)this.timerRefStatic=setTimeout(function(){cMarkerClusterer.createClusters_(iLast)},0);else for(delete this.timerRefStatic,google.maps.event.trigger(this,"clusteringend",this),i=0;i<this.clusters_.length;i++)this.clusters_[i].updateIcon_()}},MarkerClusterer.prototype.extend=function(obj1,obj2){return function(object){var property;for(property in object.prototype)this.prototype[property]=object.prototype[property];return this}.apply(obj1,[obj2])},MarkerClusterer.CALCULATOR=function(markers,numStyles){for(var index=0,title="",count=markers.length.toString(),dv=count;0!==dv;)dv=parseInt(dv/10,10),index++;return index=Math.min(index,numStyles),{text:count,index:index,title:title}},MarkerClusterer.BATCH_SIZE=2e3,MarkerClusterer.BATCH_SIZE_IE=500,MarkerClusterer.IMAGE_PATH="//cdn.rawgit.com/mahnunchik/markerclustererplus/master/images/m",MarkerClusterer.IMAGE_EXTENSION="png",MarkerClusterer.IMAGE_SIZES=[53,56,66,78,90],"function"!=typeof String.prototype.trim&&(String.prototype.trim=function(){return this.replace(/^\s+|\s+$/g,"")});
	/**
	 *  google-maps-utility-library-v3-infobox
	 *
	 * @version: 1.1.14
	 * @author: Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
	 * @contributors: Nicholas McCready
	 * @date: Fri May 13 2016 16:35:27 GMT-0400 (EDT)
	 * @license: Apache License 2.0
	 */
	/**
	 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
	 *  <p>
	 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
	 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
	 *  <p>
	 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
	 */
	
	/*jslint browser:true */
	/*global google */
	
	/**
	 * @name InfoBoxOptions
	 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
	 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
	 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
	 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
	 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
	 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
	 *  to the map pixel corresponding to <tt>position</tt>.
	 * @property {LatLng} position The geographic location at which to display the InfoBox.
	 * @property {number} zIndex The CSS z-index style value for the InfoBox.
	 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
	 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
	 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
	 *  style values to be applied to the InfoBox. Style values defined here override those that may
	 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
	 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
	 *  are removed from the InfoBox before the new style values are applied.
	 * @property {string} closeBoxMargin The CSS margin style value for the close box.
	 *  The default is "2px" (a 2-pixel margin on all sides).
	 * @property {string} closeBoxURL The URL of the image representing the close box.
	 *  Note: The default is the URL for Google's standard close box.
	 *  Set this property to "" if no close box is required.
	 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
	 *  map edge after an auto-pan.
	 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
	 *  [Deprecated in favor of the <tt>visible</tt> property.]
	 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
	 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
	 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
	 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
	 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
	 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
	 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
	 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
	 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
	 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
	 */
	
	/**
	 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
	 *  Call <tt>InfoBox.open</tt> to add the box to the map.
	 * @constructor
	 * @param {InfoBoxOptions} [opt_opts]
	 */
	function InfoBox(opt_opts) {
	
	  opt_opts = opt_opts || {};
	
	  google.maps.OverlayView.apply(this, arguments);
	
	  // Standard options (in common with google.maps.InfoWindow):
	  //
	  this.content_ = opt_opts.content || "";
	  this.disableAutoPan_ = opt_opts.disableAutoPan || false;
	  this.maxWidth_ = opt_opts.maxWidth || 0;
	  this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
	  this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
	  this.zIndex_ = opt_opts.zIndex || null;
	
	  // Additional options (unique to InfoBox):
	  //
	  this.boxClass_ = opt_opts.boxClass || "infoBox";
	  this.boxStyle_ = opt_opts.boxStyle || {};
	  this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
	  this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
	  if (opt_opts.closeBoxURL === "") {
	    this.closeBoxURL_ = "";
	  }
	  this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
	
	  if (typeof opt_opts.visible === "undefined") {
	    if (typeof opt_opts.isHidden === "undefined") {
	      opt_opts.visible = true;
	    } else {
	      opt_opts.visible = !opt_opts.isHidden;
	    }
	  }
	  this.isHidden_ = !opt_opts.visible;
	
	  this.alignBottom_ = opt_opts.alignBottom || false;
	  this.pane_ = opt_opts.pane || "floatPane";
	  this.enableEventPropagation_ = opt_opts.enableEventPropagation || false;
	
	  this.div_ = null;
	  this.closeListener_ = null;
	  this.moveListener_ = null;
	  this.contextListener_ = null;
	  this.eventListeners_ = null;
	  this.fixedWidthSet_ = null;
	}
	
	/* InfoBox extends OverlayView in the Google Maps API v3.
	 */
	InfoBox.prototype = new google.maps.OverlayView();
	
	/**
	 * Creates the DIV representing the InfoBox.
	 * @private
	 */
	InfoBox.prototype.createInfoBoxDiv_ = function () {
	
	  var i;
	  var events;
	  var bw;
	  var me = this;
	
	  // This handler prevents an event in the InfoBox from being passed on to the map.
	  //
	  var cancelHandler = function (e) {
	    e.cancelBubble = true;
	    if (e.stopPropagation) {
	      e.stopPropagation();
	    }
	  };
	
	  // This handler ignores the current event in the InfoBox and conditionally prevents
	  // the event from being passed on to the map. It is used for the contextmenu event.
	  //
	  var ignoreHandler = function (e) {
	
	    e.returnValue = false;
	
	    if (e.preventDefault) {
	
	      e.preventDefault();
	    }
	
	    if (!me.enableEventPropagation_) {
	
	      cancelHandler(e);
	    }
	  };
	
	  if (!this.div_) {
	
	    this.div_ = document.createElement("div");
	
	    this.setBoxStyle_();
	
	    if (typeof this.content_.nodeType === "undefined") {
	      this.div_.innerHTML = this.getCloseBoxImg_() + this.content_;
	    } else {
	      this.div_.innerHTML = this.getCloseBoxImg_();
	      this.div_.appendChild(this.content_);
	    }
	
	    // Add the InfoBox DIV to the DOM
	    this.getPanes()[this.pane_].appendChild(this.div_);
	
	    this.addClickHandler_();
	
	    if (this.div_.style.width) {
	
	      this.fixedWidthSet_ = true;
	
	    } else {
	
	      if (this.maxWidth_ !== 0 && this.div_.offsetWidth > this.maxWidth_) {
	
	        this.div_.style.width = this.maxWidth_;
	        this.div_.style.overflow = "auto";
	        this.fixedWidthSet_ = true;
	
	      } else { // The following code is needed to overcome problems with MSIE
	
	        bw = this.getBoxWidths_();
	
	        this.div_.style.width = (this.div_.offsetWidth - bw.left - bw.right) + "px";
	        this.fixedWidthSet_ = false;
	      }
	    }
	
	    this.panBox_(this.disableAutoPan_);
	
	    if (!this.enableEventPropagation_) {
	
	      this.eventListeners_ = [];
	
	      // Cancel event propagation.
	      //
	      // Note: mousemove not included (to resolve Issue 152)
	      events = ["mousedown", "mouseover", "mouseout", "mouseup",
	      "click", "dblclick", "touchstart", "touchend", "touchmove"];
	
	      for (i = 0; i < events.length; i++) {
	
	        this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
	      }
	
	      // Workaround for Google bug that causes the cursor to change to a pointer
	      // when the mouse moves over a marker underneath InfoBox.
	      this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function (e) {
	        this.style.cursor = "default";
	      }));
	    }
	
	    this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
	
	    /**
	     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
	     * @name InfoBox#domready
	     * @event
	     */
	    google.maps.event.trigger(this, "domready");
	  }
	};
	
	/**
	 * Returns the HTML <IMG> tag for the close box.
	 * @private
	 */
	InfoBox.prototype.getCloseBoxImg_ = function () {
	
	  var img = "";
	
	  if (this.closeBoxURL_ !== "") {
	
	    img  = "<img";
	    img += " src='" + this.closeBoxURL_ + "'";
	    img += " align=right"; // Do this because Opera chokes on style='float: right;'
	    img += " style='";
	    img += " position: relative;"; // Required by MSIE
	    img += " cursor: pointer;";
	    img += " margin: " + this.closeBoxMargin_ + ";";
	    img += "'>";
	  }
	
	  return img;
	};
	
	/**
	 * Adds the click handler to the InfoBox close box.
	 * @private
	 */
	InfoBox.prototype.addClickHandler_ = function () {
	
	  var closeBox;
	
	  if (this.closeBoxURL_ !== "") {
	
	    closeBox = this.div_.firstChild;
	    this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
	
	  } else {
	
	    this.closeListener_ = null;
	  }
	};
	
	/**
	 * Returns the function to call when the user clicks the close box of an InfoBox.
	 * @private
	 */
	InfoBox.prototype.getCloseClickHandler_ = function () {
	
	  var me = this;
	
	  return function (e) {
	
	    // 1.0.3 fix: Always prevent propagation of a close box click to the map:
	    e.cancelBubble = true;
	
	    if (e.stopPropagation) {
	
	      e.stopPropagation();
	    }
	
	    /**
	     * This event is fired when the InfoBox's close box is clicked.
	     * @name InfoBox#closeclick
	     * @event
	     */
	    google.maps.event.trigger(me, "closeclick");
	
	    me.close();
	  };
	};
	
	/**
	 * Pans the map so that the InfoBox appears entirely within the map's visible area.
	 * @private
	 */
	InfoBox.prototype.panBox_ = function (disablePan) {
	
	  var map;
	  var bounds;
	  var xOffset = 0, yOffset = 0;
	
	  if (!disablePan) {
	
	    map = this.getMap();
	
	    if (map instanceof google.maps.Map) { // Only pan if attached to map, not panorama
	
	      if (!map.getBounds().contains(this.position_)) {
	      // Marker not in visible area of map, so set center
	      // of map to the marker position first.
	        map.setCenter(this.position_);
	      }
	
	      bounds = map.getBounds();
	
	      var mapDiv = map.getDiv();
	      var mapWidth = mapDiv.offsetWidth;
	      var mapHeight = mapDiv.offsetHeight;
	      var iwOffsetX = this.pixelOffset_.width;
	      var iwOffsetY = this.pixelOffset_.height;
	      var iwWidth = this.div_.offsetWidth;
	      var iwHeight = this.div_.offsetHeight;
	      var padX = this.infoBoxClearance_.width;
	      var padY = this.infoBoxClearance_.height;
	      var pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
	
	      if (pixPosition.x < (-iwOffsetX + padX)) {
	        xOffset = pixPosition.x + iwOffsetX - padX;
	      } else if ((pixPosition.x + iwWidth + iwOffsetX + padX) > mapWidth) {
	        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;
	      }
	      if (this.alignBottom_) {
	        if (pixPosition.y < (-iwOffsetY + padY + iwHeight)) {
	          yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;
	        } else if ((pixPosition.y + iwOffsetY + padY) > mapHeight) {
	          yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;
	        }
	      } else {
	        if (pixPosition.y < (-iwOffsetY + padY)) {
	          yOffset = pixPosition.y + iwOffsetY - padY;
	        } else if ((pixPosition.y + iwHeight + iwOffsetY + padY) > mapHeight) {
	          yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;
	        }
	      }
	
	      if (!(xOffset === 0 && yOffset === 0)) {
	
	        // Move the map to the shifted center.
	        //
	        var c = map.getCenter();
	        map.panBy(xOffset, yOffset);
	      }
	    }
	  }
	};
	
	/**
	 * Sets the style of the InfoBox by setting the style sheet and applying
	 * other specific styles requested.
	 * @private
	 */
	InfoBox.prototype.setBoxStyle_ = function () {
	
	  var i, boxStyle;
	
	  if (this.div_) {
	
	    // Apply style values from the style sheet defined in the boxClass parameter:
	    this.div_.className = this.boxClass_;
	
	    // Clear existing inline style values:
	    this.div_.style.cssText = "";
	
	    // Apply style values defined in the boxStyle parameter:
	    boxStyle = this.boxStyle_;
	    for (i in boxStyle) {
	
	      if (boxStyle.hasOwnProperty(i)) {
	
	        this.div_.style[i] = boxStyle[i];
	      }
	    }
	
	    // Fix for iOS disappearing InfoBox problem.
	    // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
	    this.div_.style.WebkitTransform = "translateZ(0)";
	
	    // Fix up opacity style for benefit of MSIE:
	    //
	    if (typeof this.div_.style.opacity !== "undefined" && this.div_.style.opacity !== "") {
	      // See http://www.quirksmode.org/css/opacity.html
	      this.div_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (this.div_.style.opacity * 100) + ")\"";
	      this.div_.style.filter = "alpha(opacity=" + (this.div_.style.opacity * 100) + ")";
	    }
	
	    // Apply required styles:
	    //
	    this.div_.style.position = "absolute";
	    this.div_.style.visibility = 'hidden';
	    if (this.zIndex_ !== null) {
	
	      this.div_.style.zIndex = this.zIndex_;
	    }
	  }
	};
	
	/**
	 * Get the widths of the borders of the InfoBox.
	 * @private
	 * @return {Object} widths object (top, bottom left, right)
	 */
	InfoBox.prototype.getBoxWidths_ = function () {
	
	  var computedStyle;
	  var bw = {top: 0, bottom: 0, left: 0, right: 0};
	  var box = this.div_;
	
	  if (document.defaultView && document.defaultView.getComputedStyle) {
	
	    computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
	
	    if (computedStyle) {
	
	      // The computed styles are always in pixel units (good!)
	      bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
	      bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
	      bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
	      bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
	    }
	
	  } else if (document.documentElement.currentStyle) { // MSIE
	
	    if (box.currentStyle) {
	
	      // The current styles may not be in pixel units, but assume they are (bad!)
	      bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
	      bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
	      bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
	      bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
	    }
	  }
	
	  return bw;
	};
	
	/**
	 * Invoked when <tt>close</tt> is called. Do not call it directly.
	 */
	InfoBox.prototype.onRemove = function () {
	
	  if (this.div_) {
	
	    this.div_.parentNode.removeChild(this.div_);
	    this.div_ = null;
	  }
	};
	
	/**
	 * Draws the InfoBox based on the current map projection and zoom level.
	 */
	InfoBox.prototype.draw = function () {
	
	  this.createInfoBoxDiv_();
	
	  var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
	
	  this.div_.style.left = (pixPosition.x + this.pixelOffset_.width) + "px";
	
	  if (this.alignBottom_) {
	    this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px";
	  } else {
	    this.div_.style.top = (pixPosition.y + this.pixelOffset_.height) + "px";
	  }
	
	  if (this.isHidden_) {
	
	    this.div_.style.visibility = "hidden";
	
	  } else {
	
	    this.div_.style.visibility = "visible";
	  }
	};
	
	/**
	 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
	 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
	 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
	 *  is <tt>open</tt>ed.
	 * @param {InfoBoxOptions} opt_opts
	 */
	InfoBox.prototype.setOptions = function (opt_opts) {
	  if (typeof opt_opts.boxClass !== "undefined") { // Must be first
	
	    this.boxClass_ = opt_opts.boxClass;
	    this.setBoxStyle_();
	  }
	  if (typeof opt_opts.boxStyle !== "undefined") { // Must be second
	
	    this.boxStyle_ = opt_opts.boxStyle;
	    this.setBoxStyle_();
	  }
	  if (typeof opt_opts.content !== "undefined") {
	
	    this.setContent(opt_opts.content);
	  }
	  if (typeof opt_opts.disableAutoPan !== "undefined") {
	
	    this.disableAutoPan_ = opt_opts.disableAutoPan;
	  }
	  if (typeof opt_opts.maxWidth !== "undefined") {
	
	    this.maxWidth_ = opt_opts.maxWidth;
	  }
	  if (typeof opt_opts.pixelOffset !== "undefined") {
	
	    this.pixelOffset_ = opt_opts.pixelOffset;
	  }
	  if (typeof opt_opts.alignBottom !== "undefined") {
	
	    this.alignBottom_ = opt_opts.alignBottom;
	  }
	  if (typeof opt_opts.position !== "undefined") {
	
	    this.setPosition(opt_opts.position);
	  }
	  if (typeof opt_opts.zIndex !== "undefined") {
	
	    this.setZIndex(opt_opts.zIndex);
	  }
	  if (typeof opt_opts.closeBoxMargin !== "undefined") {
	
	    this.closeBoxMargin_ = opt_opts.closeBoxMargin;
	  }
	  if (typeof opt_opts.closeBoxURL !== "undefined") {
	
	    this.closeBoxURL_ = opt_opts.closeBoxURL;
	  }
	  if (typeof opt_opts.infoBoxClearance !== "undefined") {
	
	    this.infoBoxClearance_ = opt_opts.infoBoxClearance;
	  }
	  if (typeof opt_opts.isHidden !== "undefined") {
	
	    this.isHidden_ = opt_opts.isHidden;
	  }
	  if (typeof opt_opts.visible !== "undefined") {
	
	    this.isHidden_ = !opt_opts.visible;
	  }
	  if (typeof opt_opts.enableEventPropagation !== "undefined") {
	
	    this.enableEventPropagation_ = opt_opts.enableEventPropagation;
	  }
	
	  if (this.div_) {
	
	    this.draw();
	  }
	};
	
	/**
	 * Sets the content of the InfoBox.
	 *  The content can be plain text or an HTML DOM node.
	 * @param {string|Node} content
	 */
	InfoBox.prototype.setContent = function (content) {
	  this.content_ = content;
	
	  if (this.div_) {
	
	    if (this.closeListener_) {
	
	      google.maps.event.removeListener(this.closeListener_);
	      this.closeListener_ = null;
	    }
	
	    // Odd code required to make things work with MSIE.
	    //
	    if (!this.fixedWidthSet_) {
	
	      this.div_.style.width = "";
	    }
	
	    if (typeof content.nodeType === "undefined") {
	      this.div_.innerHTML = this.getCloseBoxImg_() + content;
	    } else {
	      this.div_.innerHTML = this.getCloseBoxImg_();
	      this.div_.appendChild(content);
	    }
	
	    // Perverse code required to make things work with MSIE.
	    // (Ensures the close box does, in fact, float to the right.)
	    //
	    if (!this.fixedWidthSet_) {
	      this.div_.style.width = this.div_.offsetWidth + "px";
	      if (typeof content.nodeType === "undefined") {
	        this.div_.innerHTML = this.getCloseBoxImg_() + content;
	      } else {
	        this.div_.innerHTML = this.getCloseBoxImg_();
	        this.div_.appendChild(content);
	      }
	    }
	
	    this.addClickHandler_();
	  }
	
	  /**
	   * This event is fired when the content of the InfoBox changes.
	   * @name InfoBox#content_changed
	   * @event
	   */
	  google.maps.event.trigger(this, "content_changed");
	};
	
	/**
	 * Sets the geographic location of the InfoBox.
	 * @param {LatLng} latlng
	 */
	InfoBox.prototype.setPosition = function (latlng) {
	
	  this.position_ = latlng;
	
	  if (this.div_) {
	
	    this.draw();
	  }
	
	  /**
	   * This event is fired when the position of the InfoBox changes.
	   * @name InfoBox#position_changed
	   * @event
	   */
	  google.maps.event.trigger(this, "position_changed");
	};
	
	/**
	 * Sets the zIndex style for the InfoBox.
	 * @param {number} index
	 */
	InfoBox.prototype.setZIndex = function (index) {
	
	  this.zIndex_ = index;
	
	  if (this.div_) {
	
	    this.div_.style.zIndex = index;
	  }
	
	  /**
	   * This event is fired when the zIndex of the InfoBox changes.
	   * @name InfoBox#zindex_changed
	   * @event
	   */
	  google.maps.event.trigger(this, "zindex_changed");
	};
	
	/**
	 * Sets the visibility of the InfoBox.
	 * @param {boolean} isVisible
	 */
	InfoBox.prototype.setVisible = function (isVisible) {
	
	  this.isHidden_ = !isVisible;
	  if (this.div_) {
	    this.div_.style.visibility = (this.isHidden_ ? "hidden" : "visible");
	  }
	};
	
	/**
	 * Returns the content of the InfoBox.
	 * @returns {string}
	 */
	InfoBox.prototype.getContent = function () {
	
	  return this.content_;
	};
	
	/**
	 * Returns the geographic location of the InfoBox.
	 * @returns {LatLng}
	 */
	InfoBox.prototype.getPosition = function () {
	
	  return this.position_;
	};
	
	/**
	 * Returns the zIndex for the InfoBox.
	 * @returns {number}
	 */
	InfoBox.prototype.getZIndex = function () {
	
	  return this.zIndex_;
	};
	
	/**
	 * Returns a flag indicating whether the InfoBox is visible.
	 * @returns {boolean}
	 */
	InfoBox.prototype.getVisible = function () {
	
	  var isVisible;
	
	  if ((typeof this.getMap() === "undefined") || (this.getMap() === null)) {
	    isVisible = false;
	  } else {
	    isVisible = !this.isHidden_;
	  }
	  return isVisible;
	};
	
	/**
	 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
	 */
	InfoBox.prototype.show = function () {
	
	  this.isHidden_ = false;
	  if (this.div_) {
	    this.div_.style.visibility = "visible";
	  }
	};
	
	/**
	 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
	 */
	InfoBox.prototype.hide = function () {
	
	  this.isHidden_ = true;
	  if (this.div_) {
	    this.div_.style.visibility = "hidden";
	  }
	};
	
	/**
	 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
	 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
	 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
	 *  anchor is dragged to a new location, the InfoBox moves as well.
	 * @param {Map|StreetViewPanorama} map
	 * @param {MVCObject} [anchor]
	 */
	InfoBox.prototype.open = function (map, anchor) {
	
	  var me = this;
	
	  if (anchor) {
	
	    this.position_ = anchor.getPosition();
	    this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function () {
	      me.setPosition(this.getPosition());
	    });
	  }
	
	  this.setMap(map);
	
	  if (this.div_) {
	
	    this.panBox_();
	  }
	};
	
	/**
	 * Removes the InfoBox from the map.
	 */
	InfoBox.prototype.close = function () {
	
	  var i;
	
	  if (this.closeListener_) {
	
	    google.maps.event.removeListener(this.closeListener_);
	    this.closeListener_ = null;
	  }
	
	  if (this.eventListeners_) {
	
	    for (i = 0; i < this.eventListeners_.length; i++) {
	
	      google.maps.event.removeListener(this.eventListeners_[i]);
	    }
	    this.eventListeners_ = null;
	  }
	
	  if (this.moveListener_) {
	
	    google.maps.event.removeListener(this.moveListener_);
	    this.moveListener_ = null;
	  }
	
	  if (this.contextListener_) {
	
	    google.maps.event.removeListener(this.contextListener_);
	    this.contextListener_ = null;
	  }
	
	  this.setMap(null);
	};
	
	/**
	 *  google-maps-utility-library-v3-keydragzoom
	 *
	 * @version: 2.0.9
	 * @author: Nianwei Liu [nianwei at gmail dot com] & Gary Little [gary at luxcentral dot com]
	 * @contributors: undefined
	 * @date: Fri May 13 2016 13:45:18 GMT-0400 (EDT)
	 * @license: Apache License 2.0
	 */
	/**
	 * @fileoverview This library adds a drag zoom capability to a V3 Google map.
	 *  When drag zoom is enabled, holding down a designated hot key <code>(shift | ctrl | alt)</code>
	 *  while dragging a box around an area of interest will zoom the map in to that area when
	 *  the mouse button is released. Optionally, a visual control can also be supplied for turning
	 *  a drag zoom operation on and off.
	 *  Only one line of code is needed: <code>google.maps.Map.enableKeyDragZoom();</code>
	 *  <p>
	 *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
	 *  it causes a context menu to appear when running on the Macintosh.
	 *  <p>
	 *  Note that if the map's container has a border around it, the border widths must be specified
	 *  in pixel units (or as thin, medium, or thick). This is required because of an MSIE limitation.
	 *   <p>NL: 2009-05-28: initial port to core API V3.
	 *  <br>NL: 2009-11-02: added a temp fix for -moz-transform for FF3.5.x using code from Paul Kulchenko (http://notebook.kulchenko.com/maps/gridmove).
	 *  <br>NL: 2010-02-02: added a fix for IE flickering on divs onmousemove, caused by scroll value when get mouse position.
	 *  <br>GL: 2010-06-15: added a visual control option.
	 */
	(function () {
	  /*jslint browser:true */
	  /*global window,google */
	  /* Utility functions use "var funName=function()" syntax to allow use of the */
	  /* Dean Edwards Packer compression tool (with Shrink variables, without Base62 encode). */
	
	  /**
	   * Converts "thin", "medium", and "thick" to pixel widths
	   * in an MSIE environment. Not called for other browsers
	   * because getComputedStyle() returns pixel widths automatically.
	   * @param {string} widthValue The value of the border width parameter.
	   */
	  var toPixels = function (widthValue) {
	    var px;
	    switch (widthValue) {
	    case "thin":
	      px = "2px";
	      break;
	    case "medium":
	      px = "4px";
	      break;
	    case "thick":
	      px = "6px";
	      break;
	    default:
	      px = widthValue;
	    }
	    return px;
	  };
	 /**
	  * Get the widths of the borders of an HTML element.
	  *
	  * @param {Node} h  The HTML element.
	  * @return {Object} The width object {top, bottom left, right}.
	  */
	  var getBorderWidths = function (h) {
	    var computedStyle;
	    var bw = {};
	    if (document.defaultView && document.defaultView.getComputedStyle) {
	      computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
	      if (computedStyle) {
	        // The computed styles are always in pixel units (good!)
	        bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
	        bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
	        bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
	        bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
	        return bw;
	      }
	    } else if (document.documentElement.currentStyle) { // MSIE
	      if (h.currentStyle) {
	        // The current styles may not be in pixel units so try to convert (bad!)
	        bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
	        bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
	        bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
	        bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
	        return bw;
	      }
	    }
	    // Shouldn't get this far for any modern browser
	    bw.top = parseInt(h.style["border-top-width"], 10) || 0;
	    bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
	    bw.left = parseInt(h.style["border-left-width"], 10) || 0;
	    bw.right = parseInt(h.style["border-right-width"], 10) || 0;
	    return bw;
	  };
	
	  // Page scroll values for use by getMousePosition. To prevent flickering on MSIE
	  // they are calculated only when the document actually scrolls, not every time the
	  // mouse moves (as they would be if they were calculated inside getMousePosition).
	  var scroll = {
	    x: 0,
	    y: 0
	  };
	  var getScrollValue = function (e) {
	    scroll.x = (typeof document.documentElement.scrollLeft !== "undefined" ? document.documentElement.scrollLeft : document.body.scrollLeft);
	    scroll.y = (typeof document.documentElement.scrollTop !== "undefined" ? document.documentElement.scrollTop : document.body.scrollTop);
	  };
	  getScrollValue();
	
	  /**
	   * Get the position of the mouse relative to the document.
	   * @param {Event} e  The mouse event.
	   * @return {Object} The position object {left, top}.
	   */
	  var getMousePosition = function (e) {
	    var posX = 0, posY = 0;
	    e = e || window.event;
	    if (typeof e.pageX !== "undefined") {
	      posX = e.pageX;
	      posY = e.pageY;
	    } else if (typeof e.clientX !== "undefined") { // MSIE
	      posX = e.clientX + scroll.x;
	      posY = e.clientY + scroll.y;
	    }
	    return {
	      left: posX,
	      top: posY
	    };
	  };
	  /**
	   * Get the position of an HTML element relative to the document.
	   * @param {Node} h  The HTML element.
	   * @return {Object} The position object {left, top}.
	   */
	  var getElementPosition = function (h) {
	    var posX = h.offsetLeft;
	    var posY = h.offsetTop;
	    var parent = h.offsetParent;
	    // Add offsets for all ancestors in the hierarchy
	    while (parent !== null) {
	      // Adjust for scrolling elements which may affect the map position.
	      //
	      // See http://www.howtocreate.co.uk/tutorials/javascript/browserspecific
	      //
	      // "...make sure that every element [on a Web page] with an overflow
	      // of anything other than visible also has a position style set to
	      // something other than the default static..."
	      if (parent !== document.body && parent !== document.documentElement) {
	        posX -= parent.scrollLeft;
	        posY -= parent.scrollTop;
	      }
	      // See http://groups.google.com/group/google-maps-js-api-v3/browse_thread/thread/4cb86c0c1037a5e5
	      // Example: http://notebook.kulchenko.com/maps/gridmove
	      var m = parent;
	      // This is the "normal" way to get offset information:
	      var moffx = m.offsetLeft;
	      var moffy = m.offsetTop;
	      // This covers those cases where a transform is used:
	      if (!moffx && !moffy && window.getComputedStyle) {
	        var matrix = document.defaultView.getComputedStyle(m, null).MozTransform ||
	        document.defaultView.getComputedStyle(m, null).WebkitTransform;
	        if (matrix) {
	          if (typeof matrix === "string") {
	            var parms = matrix.split(",");
	            moffx += parseInt(parms[4], 10) || 0;
	            moffy += parseInt(parms[5], 10) || 0;
	          }
	        }
	      }
	      posX += moffx;
	      posY += moffy;
	      parent = parent.offsetParent;
	    }
	    return {
	      left: posX,
	      top: posY
	    };
	  };
	  /**
	   * Set the properties of an object to those from another object.
	   * @param {Object} obj The target object.
	   * @param {Object} vals The source object.
	   */
	  var setVals = function (obj, vals) {
	    if (obj && vals) {
	      for (var x in vals) {
	        if (vals.hasOwnProperty(x)) {
	          obj[x] = vals[x];
	        }
	      }
	    }
	    return obj;
	  };
	  /**
	   * Set the opacity. If op is not passed in, this function just performs an MSIE fix.
	   * @param {Node} h The HTML element.
	   * @param {number} op The opacity value (0-1).
	   */
	  var setOpacity = function (h, op) {
	    if (typeof op !== "undefined") {
	      h.style.opacity = op;
	    }
	    if (typeof h.style.opacity !== "undefined" && h.style.opacity !== "") {
	      h.style.filter = "alpha(opacity=" + (h.style.opacity * 100) + ")";
	    }
	  };
	  /**
	   * @name KeyDragZoomOptions
	   * @class This class represents the optional parameter passed into <code>google.maps.Map.enableKeyDragZoom</code>.
	   * @property {string} [key="shift"] The hot key to hold down to activate a drag zoom, <code>shift | ctrl | alt</code>.
	   *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
	   *  it causes a context menu to appear when running on the Macintosh. Also note that the
	   *  <code>alt</code> hot key refers to the Option key on a Macintosh.
	   * @property {Object} [boxStyle={border: "4px solid #736AFF"}]
	   *  An object literal defining the CSS styles of the zoom box.
	   *  Border widths must be specified in pixel units (or as thin, medium, or thick).
	   * @property {Object} [veilStyle={backgroundColor: "gray", opacity: 0.25, cursor: "crosshair"}]
	   *  An object literal defining the CSS styles of the veil pane which covers the map when a drag
	   *  zoom is activated. The previous name for this property was <code>paneStyle</code> but the use
	   *  of this name is now deprecated.
	   * @property {boolean} [noZoom=false] A flag indicating whether to disable zooming after an area is
	   *  selected. Set this to <code>true</code> to allow KeyDragZoom to be used as a simple area
	   *  selection tool.
	   * @property {boolean} [visualEnabled=false] A flag indicating whether a visual control is to be used.
	   * @property {string} [visualClass=""] The name of the CSS class defining the styles for the visual
	   *  control. To prevent the visual control from being printed, set this property to the name of
	   *  a class, defined inside a <code>@media print</code> rule, which sets the CSS
	   *  <code>display</code> style to <code>none</code>.
	   * @property {ControlPosition} [visualPosition=google.maps.ControlPosition.LEFT_TOP]
	   *  The position of the visual control.
	   * @property {Size} [visualPositionOffset=google.maps.Size(35, 0)] The width and height values
	   *  provided by this property are the offsets (in pixels) from the location at which the control
	   *  would normally be drawn to the desired drawing location.
	   * @property {number} [visualPositionIndex=null] The index of the visual control.
	   *  The index is for controlling the placement of the control relative to other controls at the
	   *  position given by <code>visualPosition</code>; controls with a lower index are placed first.
	   *  Use a negative value to place the control <i>before</i> any default controls. No index is
	   *  generally required.
	   * @property {String} [visualSprite="http://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png"]
	   *  The URL of the sprite image used for showing the visual control in the on, off, and hot
	   *  (i.e., when the mouse is over the control) states. The three images within the sprite must
	   *  be the same size and arranged in on-hot-off order in a single row with no spaces between images.
	   * @property {Size} [visualSize=google.maps.Size(20, 20)] The width and height values provided by
	   *  this property are the size (in pixels) of each of the images within <code>visualSprite</code>.
	   * @property {Object} [visualTips={off: "Turn on drag zoom mode", on: "Turn off drag zoom mode"}]
	   *  An object literal defining the help tips that appear when
	   *  the mouse moves over the visual control. The <code>off</code> property is the tip to be shown
	   *  when the control is off and the <code>on</code> property is the tip to be shown when the
	   *  control is on.
	   */
	  /**
	   * @name DragZoom
	   * @class This class represents a drag zoom object for a map. The object is activated by holding down the hot key
	   * or by turning on the visual control.
	   * This object is created when <code>google.maps.Map.enableKeyDragZoom</code> is called; it cannot be created directly.
	   * Use <code>google.maps.Map.getDragZoomObject</code> to gain access to this object in order to attach event listeners.
	   * @param {Map} map The map to which the DragZoom object is to be attached.
	   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
	   */
	  function DragZoom(map, opt_zoomOpts) {
	    var me = this;
	    var ov = new google.maps.OverlayView();
	    ov.onAdd = function () {
	      me.init_(map, opt_zoomOpts);
	    };
	    ov.draw = function () {
	    };
	    ov.onRemove = function () {
	    };
	    ov.setMap(map);
	    this.prjov_ = ov;
	  }
	  /**
	   * Initialize the tool.
	   * @param {Map} map The map to which the DragZoom object is to be attached.
	   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
	   */
	  DragZoom.prototype.init_ = function (map, opt_zoomOpts) {
	    var i;
	    var me = this;
	    this.map_ = map;
	    opt_zoomOpts = opt_zoomOpts || {};
	    this.key_ = opt_zoomOpts.key || "shift";
	    this.key_ = this.key_.toLowerCase();
	    this.borderWidths_ = getBorderWidths(this.map_.getDiv());
	    this.veilDiv_ = [];
	    for (i = 0; i < 4; i++) {
	      this.veilDiv_[i] = document.createElement("div");
	      // Prevents selection of other elements on the webpage
	      // when a drag zoom operation is in progress:
	      this.veilDiv_[i].onselectstart = function () {
	        return false;
	      };
	      // Apply default style values for the veil:
	      setVals(this.veilDiv_[i].style, {
	        backgroundColor: "gray",
	        opacity: 0.25,
	        cursor: "crosshair"
	      });
	      // Apply style values specified in veilStyle parameter:
	      setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle); // Old option name was "paneStyle"
	      setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle); // New name is "veilStyle"
	      // Apply mandatory style values:
	      setVals(this.veilDiv_[i].style, {
	        position: "absolute",
	        overflow: "hidden",
	        display: "none"
	      });
	      // Workaround for Firefox Shift-Click problem:
	      if (this.key_ === "shift") {
	        this.veilDiv_[i].style.MozUserSelect = "none";
	      }
	      setOpacity(this.veilDiv_[i]);
	      // An IE fix: If the background is transparent it cannot capture mousedown
	      // events, so if it is, change the background to white with 0 opacity.
	      if (this.veilDiv_[i].style.backgroundColor === "transparent") {
	        this.veilDiv_[i].style.backgroundColor = "white";
	        setOpacity(this.veilDiv_[i], 0);
	      }
	      this.map_.getDiv().appendChild(this.veilDiv_[i]);
	    }
	
	    this.noZoom_ = opt_zoomOpts.noZoom || false;
	    this.visualEnabled_ = opt_zoomOpts.visualEnabled || false;
	    this.visualClass_ = opt_zoomOpts.visualClass || "";
	    this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
	    this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
	    this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
	    this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
	    this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
	    this.visualTips_ = opt_zoomOpts.visualTips || {};
	    this.visualTips_.off =  this.visualTips_.off || "Turn on drag zoom mode";
	    this.visualTips_.on =  this.visualTips_.on || "Turn off drag zoom mode";
	
	    this.boxDiv_ = document.createElement("div");
	    // Apply default style values for the zoom box:
	    setVals(this.boxDiv_.style, {
	      border: "4px solid #736AFF"
	    });
	    // Apply style values specified in boxStyle parameter:
	    setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
	    // Apply mandatory style values:
	    setVals(this.boxDiv_.style, {
	      position: "absolute",
	      display: "none"
	    });
	    setOpacity(this.boxDiv_);
	    this.map_.getDiv().appendChild(this.boxDiv_);
	    this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
	
	    this.listeners_ = [
	      google.maps.event.addDomListener(document, "keydown", function (e) {
	        me.onKeyDown_(e);
	      }),
	      google.maps.event.addDomListener(document, "keyup", function (e) {
	        me.onKeyUp_(e);
	      }),
	      google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function (e) {
	        me.onMouseDown_(e);
	      }),
	      google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function (e) {
	        me.onMouseDown_(e);
	      }),
	      google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function (e) {
	        me.onMouseDown_(e);
	      }),
	      google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function (e) {
	        me.onMouseDown_(e);
	      }),
	      google.maps.event.addDomListener(document, "mousedown", function (e) {
	        me.onMouseDownDocument_(e);
	      }),
	      google.maps.event.addDomListener(document, "mousemove", function (e) {
	        me.onMouseMove_(e);
	      }),
	      google.maps.event.addDomListener(document, "mouseup", function (e) {
	        me.onMouseUp_(e);
	      }),
	      google.maps.event.addDomListener(window, "scroll", getScrollValue)
	    ];
	
	    this.hotKeyDown_ = false;
	    this.mouseDown_ = false;
	    this.dragging_ = false;
	    this.startPt_ = null;
	    this.endPt_ = null;
	    this.mapWidth_ = null;
	    this.mapHeight_ = null;
	    this.mousePosn_ = null;
	    this.mapPosn_ = null;
	
	    if (this.visualEnabled_) {
	      this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
	      if (this.visualPositionIndex_ !== null) {
	        this.buttonDiv_.index = this.visualPositionIndex_;
	      }
	      this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
	      this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
	    }
	  };
	  /**
	   * Initializes the visual control and returns its DOM element.
	   * @param {Size} offset The offset of the control from its normal position.
	   * @return {Node} The DOM element containing the visual control.
	   */
	  DragZoom.prototype.initControl_ = function (offset) {
	    var control;
	    var image;
	    var me = this;
	
	    control = document.createElement("div");
	    control.className = this.visualClass_;
	    control.style.position = "relative";
	    control.style.overflow = "hidden";
	    control.style.height = this.visualSize_.height + "px";
	    control.style.width = this.visualSize_.width + "px";
	    control.title = this.visualTips_.off;
	    image = document.createElement("img");
	    image.src = this.visualSprite_;
	    image.style.position = "absolute";
	    image.style.left = -(this.visualSize_.width * 2) + "px";
	    image.style.top = 0 + "px";
	    control.appendChild(image);
	    control.onclick = function (e) {
	      me.hotKeyDown_ = !me.hotKeyDown_;
	      if (me.hotKeyDown_) {
	        me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
	        me.buttonDiv_.title = me.visualTips_.on;
	        me.activatedByControl_ = true;
	        google.maps.event.trigger(me, "activate");
	      } else {
	        me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
	        me.buttonDiv_.title = me.visualTips_.off;
	        google.maps.event.trigger(me, "deactivate");
	      }
	      me.onMouseMove_(e); // Updates the veil
	    };
	    control.onmouseover = function () {
	      me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 1) + "px";
	    };
	    control.onmouseout = function () {
	      if (me.hotKeyDown_) {
	        me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 0) + "px";
	        me.buttonDiv_.title = me.visualTips_.on;
	      } else {
	        me.buttonDiv_.firstChild.style.left = -(me.visualSize_.width * 2) + "px";
	        me.buttonDiv_.title = me.visualTips_.off;
	      }
	    };
	    control.ondragstart = function () {
	      return false;
	    };
	    setVals(control.style, {
	      cursor: "pointer",
	      marginTop: offset.height + "px",
	      marginLeft: offset.width + "px"
	    });
	    return control;
	  };
	  /**
	   * Returns <code>true</code> if the hot key is being pressed when an event occurs.
	   * @param {Event} e The keyboard event.
	   * @return {boolean} Flag indicating whether the hot key is down.
	   */
	  DragZoom.prototype.isHotKeyDown_ = function (e) {
	    var isHot;
	    e = e || window.event;
	    isHot = (e.shiftKey && this.key_ === "shift") || (e.altKey && this.key_ === "alt") || (e.ctrlKey && this.key_ === "ctrl");
	    if (!isHot) {
	      // Need to look at keyCode for Opera because it
	      // doesn't set the shiftKey, altKey, ctrlKey properties
	      // unless a non-modifier event is being reported.
	      //
	      // See http://cross-browser.com/x/examples/shift_mode.php
	      // Also see http://unixpapa.com/js/key.html
	      switch (e.keyCode) {
	      case 16:
	        if (this.key_ === "shift") {
	          isHot = true;
	        }
	        break;
	      case 17:
	        if (this.key_ === "ctrl") {
	          isHot = true;
	        }
	        break;
	      case 18:
	        if (this.key_ === "alt") {
	          isHot = true;
	        }
	        break;
	      }
	    }
	    return isHot;
	  };
	  /**
	   * Returns <code>true</code> if the mouse is on top of the map div.
	   * The position is captured in onMouseMove_.
	   * @return {boolean}
	   */
	  DragZoom.prototype.isMouseOnMap_ = function () {
	    var mousePosn = this.mousePosn_;
	    if (mousePosn) {
	      var mapPosn = this.mapPosn_;
	      var mapDiv = this.map_.getDiv();
	      return mousePosn.left > mapPosn.left && mousePosn.left < (mapPosn.left + mapDiv.offsetWidth) &&
	      mousePosn.top > mapPosn.top && mousePosn.top < (mapPosn.top + mapDiv.offsetHeight);
	    } else {
	      // if user never moved mouse
	      return false;
	    }
	  };
	  /**
	   * Show the veil if the hot key is down and the mouse is over the map,
	   * otherwise hide the veil.
	   */
	  DragZoom.prototype.setVeilVisibility_ = function () {
	    var i;
	    if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
	      var mapDiv = this.map_.getDiv();
	      this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
	      this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
	      if (this.activatedByControl_) { // Veil covers entire map (except control)
	        var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width;
	        var top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height;
	        var width = this.visualSize_.width;
	        var height = this.visualSize_.height;
	        // Left veil rectangle:
	        this.veilDiv_[0].style.top = "0px";
	        this.veilDiv_[0].style.left = "0px";
	        this.veilDiv_[0].style.width = left + "px";
	        this.veilDiv_[0].style.height = this.mapHeight_ + "px";
	        // Right veil rectangle:
	        this.veilDiv_[1].style.top = "0px";
	        this.veilDiv_[1].style.left = (left + width) + "px";
	        this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
	        this.veilDiv_[1].style.height = this.mapHeight_ + "px";
	        // Top veil rectangle:
	        this.veilDiv_[2].style.top = "0px";
	        this.veilDiv_[2].style.left = left + "px";
	        this.veilDiv_[2].style.width = width + "px";
	        this.veilDiv_[2].style.height = top + "px";
	        // Bottom veil rectangle:
	        this.veilDiv_[3].style.top = (top + height) + "px";
	        this.veilDiv_[3].style.left = left + "px";
	        this.veilDiv_[3].style.width = width + "px";
	        this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
	        for (i = 0; i < this.veilDiv_.length; i++) {
	          this.veilDiv_[i].style.display = "block";
	        }
	      } else {
	        this.veilDiv_[0].style.left = "0px";
	        this.veilDiv_[0].style.top = "0px";
	        this.veilDiv_[0].style.width = this.mapWidth_ + "px";
	        this.veilDiv_[0].style.height = this.mapHeight_ + "px";
	        for (i = 1; i < this.veilDiv_.length; i++) {
	          this.veilDiv_[i].style.width = "0px";
	          this.veilDiv_[i].style.height = "0px";
	        }
	        for (i = 0; i < this.veilDiv_.length; i++) {
	          this.veilDiv_[i].style.display = "block";
	        }
	      }
	    } else {
	      for (i = 0; i < this.veilDiv_.length; i++) {
	        this.veilDiv_[i].style.display = "none";
	      }
	    }
	  };
	  /**
	   * Handle key down. Show the veil if the hot key has been pressed.
	   * @param {Event} e The keyboard event.
	   */
	  DragZoom.prototype.onKeyDown_ = function (e) {
	    if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
	      this.mapPosn_ = getElementPosition(this.map_.getDiv());
	      this.hotKeyDown_ = true;
	      this.activatedByControl_ = false;
	      this.setVeilVisibility_();
	     /**
	       * This event is fired when the hot key is pressed.
	       * @name DragZoom#activate
	       * @event
	       */
	      google.maps.event.trigger(this, "activate");
	    }
	  };
	  /**
	   * Get the <code>google.maps.Point</code> of the mouse position.
	   * @param {Event} e The mouse event.
	   * @return {Point} The mouse position.
	   */
	  DragZoom.prototype.getMousePoint_ = function (e) {
	    var mousePosn = getMousePosition(e);
	    var p = new google.maps.Point();
	    p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
	    p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
	    p.x = Math.min(p.x, this.mapWidth_);
	    p.y = Math.min(p.y, this.mapHeight_);
	    p.x = Math.max(p.x, 0);
	    p.y = Math.max(p.y, 0);
	    return p;
	  };
	  /**
	   * Handle mouse down.
	   * @param {Event} e The mouse event.
	   */
	  DragZoom.prototype.onMouseDown_ = function (e) {
	    if (this.map_ && this.hotKeyDown_) {
	      this.mapPosn_ = getElementPosition(this.map_.getDiv());
	      this.dragging_ = true;
	      this.startPt_ = this.endPt_ = this.getMousePoint_(e);
	      this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
	      var prj = this.prjov_.getProjection();
	      var latlng = prj.fromContainerPixelToLatLng(this.startPt_);
	      /**
	       * This event is fired when the drag operation begins.
	       * The parameter passed is the geographic position of the starting point.
	       * @name DragZoom#dragstart
	       * @param {LatLng} latlng The geographic position of the starting point.
	       * @event
	       */
	      google.maps.event.trigger(this, "dragstart", latlng);
	    }
	  };
	  /**
	   * Handle mouse down at the document level.
	   * @param {Event} e The mouse event.
	   */
	  DragZoom.prototype.onMouseDownDocument_ = function (e) {
	    this.mouseDown_ = true;
	  };
	  /**
	   * Handle mouse move.
	   * @param {Event} e The mouse event.
	   */
	  DragZoom.prototype.onMouseMove_ = function (e) {
	    this.mousePosn_ = getMousePosition(e);
	    if (this.dragging_) {
	      this.endPt_ = this.getMousePoint_(e);
	      var left = Math.min(this.startPt_.x, this.endPt_.x);
	      var top = Math.min(this.startPt_.y, this.endPt_.y);
	      var width = Math.abs(this.startPt_.x - this.endPt_.x);
	      var height = Math.abs(this.startPt_.y - this.endPt_.y);
	      // For benefit of MSIE 7/8 ensure following values are not negative:
	      var boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right));
	      var boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
	      // Left veil rectangle:
	      this.veilDiv_[0].style.top = "0px";
	      this.veilDiv_[0].style.left = "0px";
	      this.veilDiv_[0].style.width = left + "px";
	      this.veilDiv_[0].style.height = this.mapHeight_ + "px";
	      // Right veil rectangle:
	      this.veilDiv_[1].style.top = "0px";
	      this.veilDiv_[1].style.left = (left + width) + "px";
	      this.veilDiv_[1].style.width = (this.mapWidth_ - (left + width)) + "px";
	      this.veilDiv_[1].style.height = this.mapHeight_ + "px";
	      // Top veil rectangle:
	      this.veilDiv_[2].style.top = "0px";
	      this.veilDiv_[2].style.left = left + "px";
	      this.veilDiv_[2].style.width = width + "px";
	      this.veilDiv_[2].style.height = top + "px";
	      // Bottom veil rectangle:
	      this.veilDiv_[3].style.top = (top + height) + "px";
	      this.veilDiv_[3].style.left = left + "px";
	      this.veilDiv_[3].style.width = width + "px";
	      this.veilDiv_[3].style.height = (this.mapHeight_ - (top + height)) + "px";
	      // Selection rectangle:
	      this.boxDiv_.style.top = top + "px";
	      this.boxDiv_.style.left = left + "px";
	      this.boxDiv_.style.width = boxWidth + "px";
	      this.boxDiv_.style.height = boxHeight + "px";
	      this.boxDiv_.style.display = "block";
	      /**
	       * This event is fired repeatedly while the user drags a box across the area of interest.
	       * The southwest and northeast point are passed as parameters of type <code>google.maps.Point</code>
	       * (for performance reasons), relative to the map container. Also passed is the projection object
	       * so that the event listener, if necessary, can convert the pixel positions to geographic
	       * coordinates using <code>google.maps.MapCanvasProjection.fromContainerPixelToLatLng</code>.
	       * @name DragZoom#drag
	       * @param {Point} southwestPixel The southwest point of the selection area.
	       * @param {Point} northeastPixel The northeast point of the selection area.
	       * @param {MapCanvasProjection} prj The projection object.
	       * @event
	       */
	      google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
	    } else if (!this.mouseDown_) {
	      this.mapPosn_ = getElementPosition(this.map_.getDiv());
	      this.setVeilVisibility_();
	    }
	  };
	  /**
	   * Handle mouse up.
	   * @param {Event} e The mouse event.
	   */
	  DragZoom.prototype.onMouseUp_ = function (e) {
	    var z;
	    var me = this;
	    this.mouseDown_ = false;
	    if (this.dragging_) {
	      if ((this.getMousePoint_(e).x === this.startPt_.x) && (this.getMousePoint_(e).y === this.startPt_.y)) {
	        this.onKeyUp_(e); // Cancel event
	        return;
	      }
	      var left = Math.min(this.startPt_.x, this.endPt_.x);
	      var top = Math.min(this.startPt_.y, this.endPt_.y);
	      var width = Math.abs(this.startPt_.x - this.endPt_.x);
	      var height = Math.abs(this.startPt_.y - this.endPt_.y);
	      // Google Maps API bug: setCenter() doesn't work as expected if the map has a
	      // border on the left or top. The code here includes a workaround for this problem.
	      var kGoogleCenteringBug = true;
	      if (kGoogleCenteringBug) {
	        left += this.borderWidths_.left;
	        top += this.borderWidths_.top;
	      }
	
	      var prj = this.prjov_.getProjection();
	      var sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
	      var ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
	      var bnds = new google.maps.LatLngBounds(sw, ne);
	
	      if (this.noZoom_) {
	        this.boxDiv_.style.display = "none";
	      } else {
	        // Sometimes fitBounds causes a zoom OUT, so restore original zoom level if this happens.
	        z = this.map_.getZoom();
	        this.map_.fitBounds(bnds);
	        if (this.map_.getZoom() < z) {
	          this.map_.setZoom(z);
	        }
	
	        // Redraw box after zoom:
	        var swPt = prj.fromLatLngToContainerPixel(sw);
	        var nePt = prj.fromLatLngToContainerPixel(ne);
	        if (kGoogleCenteringBug) {
	          swPt.x -= this.borderWidths_.left;
	          swPt.y -= this.borderWidths_.top;
	          nePt.x -= this.borderWidths_.left;
	          nePt.y -= this.borderWidths_.top;
	        }
	        this.boxDiv_.style.left = swPt.x + "px";
	        this.boxDiv_.style.top = nePt.y + "px";
	        this.boxDiv_.style.width = (Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)) + "px";
	        this.boxDiv_.style.height = (Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom)) + "px";
	        // Hide box asynchronously after 1 second:
	        setTimeout(function () {
	          me.boxDiv_.style.display = "none";
	        }, 1000);
	      }
	      this.dragging_ = false;
	      this.onMouseMove_(e); // Updates the veil
	      /**
	       * This event is fired when the drag operation ends.
	       * The parameter passed is the geographic bounds of the selected area.
	       * Note that this event is <i>not</i> fired if the hot key is released before the drag operation ends.
	       * @name DragZoom#dragend
	       * @param {LatLngBounds} bnds The geographic bounds of the selected area.
	       * @event
	       */
	      google.maps.event.trigger(this, "dragend", bnds);
	      // if the hot key isn't down, the drag zoom must have been activated by turning
	      // on the visual control. In this case, finish up by simulating a key up event.
	      if (!this.isHotKeyDown_(e)) {
	        this.onKeyUp_(e);
	      }
	    }
	  };
	  /**
	   * Handle key up.
	   * @param {Event} e The keyboard event.
	   */
	  DragZoom.prototype.onKeyUp_ = function (e) {
	    var i;
	    var left, top, width, height, prj, sw, ne;
	    var bnds = null;
	    if (this.map_ && this.hotKeyDown_) {
	      this.hotKeyDown_ = false;
	      if (this.dragging_) {
	        this.boxDiv_.style.display = "none";
	        this.dragging_ = false;
	        // Calculate the bounds when drag zoom was cancelled
	        left = Math.min(this.startPt_.x, this.endPt_.x);
	        top = Math.min(this.startPt_.y, this.endPt_.y);
	        width = Math.abs(this.startPt_.x - this.endPt_.x);
	        height = Math.abs(this.startPt_.y - this.endPt_.y);
	        prj = this.prjov_.getProjection();
	        sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
	        ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
	        bnds = new google.maps.LatLngBounds(sw, ne);
	      }
	      for (i = 0; i < this.veilDiv_.length; i++) {
	        this.veilDiv_[i].style.display = "none";
	      }
	      if (this.visualEnabled_) {
	        this.buttonDiv_.firstChild.style.left = -(this.visualSize_.width * 2) + "px";
	        this.buttonDiv_.title = this.visualTips_.off;
	        this.buttonDiv_.style.display = "";
	      }
	      /**
	       * This event is fired when the hot key is released.
	       * The parameter passed is the geographic bounds of the selected area immediately
	       * before the hot key was released.
	       * @name DragZoom#deactivate
	       * @param {LatLngBounds} bnds The geographic bounds of the selected area immediately
	       *  before the hot key was released.
	       * @event
	       */
	      google.maps.event.trigger(this, "deactivate", bnds);
	    }
	  };
	  /**
	   * @name google.maps.Map
	   * @class These are new methods added to the Google Maps JavaScript API V3's
	   * <a href="http://code.google.com/apis/maps/documentation/javascript/reference.html#Map">Map</a>
	   * class.
	   */
	  /**
	   * Enables drag zoom. The user can zoom to an area of interest by holding down the hot key
	   * <code>(shift | ctrl | alt )</code> while dragging a box around the area or by turning
	   * on the visual control then dragging a box around the area.
	   * @param {KeyDragZoomOptions} opt_zoomOpts The optional parameters.
	   */
	  google.maps.Map.prototype.enableKeyDragZoom = function (opt_zoomOpts) {
	    this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
	  };
	  /**
	   * Disables drag zoom.
	   */
	  google.maps.Map.prototype.disableKeyDragZoom = function () {
	    var i;
	    var d = this.dragZoom_;
	    if (d) {
	      for (i = 0; i < d.listeners_.length; ++i) {
	        google.maps.event.removeListener(d.listeners_[i]);
	      }
	      this.getDiv().removeChild(d.boxDiv_);
	      for (i = 0; i < d.veilDiv_.length; i++) {
	        this.getDiv().removeChild(d.veilDiv_[i]);
	      }
	      if (d.visualEnabled_) {
	        // Remove the custom control:
	        this.controls[d.visualPosition_].removeAt(d.controlIndex_);
	      }
	      d.prjov_.setMap(null);
	      this.dragZoom_ = null;
	    }
	  };
	  /**
	   * Returns <code>true</code> if the drag zoom feature has been enabled.
	   * @return {boolean}
	   */
	  google.maps.Map.prototype.keyDragZoomEnabled = function () {
	    return this.dragZoom_ !== null;
	  };
	  /**
	   * Returns the DragZoom object which is created when <code>google.maps.Map.enableKeyDragZoom</code> is called.
	   * With this object you can use <code>google.maps.event.addListener</code> to attach event listeners
	   * for the "activate", "deactivate", "dragstart", "drag", and "dragend" events.
	   * @return {DragZoom}
	   */
	  google.maps.Map.prototype.getDragZoomObject = function () {
	    return this.dragZoom_;
	  };
	})();
	
	/**
	 *  google-maps-utility-library-v3-markerwithlabel
	 *
	 * @version: 1.1.10
	 * @author: Gary Little (inspired by code from Marc Ridey of Google).
	 * @contributors: Nicholas McCready
	 * @date: Fri May 13 2016 16:29:58 GMT-0400 (EDT)
	 * @license: Apache License 2.0
	 */
	/**
	 *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,
	 *  if the marker is draggable, so too will be the label. In addition, a marker with a label
	 *  responds to all mouse events in the same manner as a regular marker. It also fires mouse
	 *  events and "property changed" events just as a regular marker would. Version 1.1 adds
	 *  support for the raiseOnDrag feature introduced in API V3.3.
	 *  <p>
	 *  If you drag a marker by its label, you can cancel the drag and return the marker to its
	 *  original position by pressing the <code>Esc</code> key. This doesn't work if you drag the marker
	 *  itself because this feature is not (yet) supported in the <code>google.maps.Marker</code> class.
	 */
	
	/*jslint browser:true */
	/*global document,google */
	
	/**
	 * @param {Function} childCtor Child class.
	 * @param {Function} parentCtor Parent class.
	 * @private
	 */
	function inherits(childCtor, parentCtor) {
	  /* @constructor */
	  function tempCtor() {}
	  tempCtor.prototype = parentCtor.prototype;
	  childCtor.superClass_ = parentCtor.prototype;
	  childCtor.prototype = new tempCtor();
	  /* @override */
	  childCtor.prototype.constructor = childCtor;
	}
	
	/**
	 * This constructor creates a label and associates it with a marker.
	 * It is for the private use of the MarkerWithLabel class.
	 * @constructor
	 * @param {Marker} marker The marker with which the label is to be associated.
	 * @param {string} crossURL The URL of the cross image =.
	 * @param {string} handCursor The URL of the hand cursor.
	 * @private
	 */
	function MarkerLabel_(marker, crossURL, handCursorURL) {
	  this.marker_ = marker;
	  this.handCursorURL_ = marker.handCursorURL;
	
	  this.labelDiv_ = document.createElement("div");
	  this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
	
	  // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil
	  // in the "overlayMouseTarget" pane, a veil that covers just the label. This is done so that
	  // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.
	  // Code is included here to ensure the veil is always exactly the same size as the label.
	  this.eventDiv_ = document.createElement("div");
	  this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
	
	  // This is needed for proper behavior on MSIE:
	  this.eventDiv_.setAttribute("onselectstart", "return false;");
	  this.eventDiv_.setAttribute("ondragstart", "return false;");
	
	  // Get the DIV for the "X" to be displayed when the marker is raised.
	  this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
	}
	
	inherits(MarkerLabel_, google.maps.OverlayView);
	
	/**
	 * Returns the DIV for the cross used when dragging a marker when the
	 * raiseOnDrag parameter set to true. One cross is shared with all markers.
	 * @param {string} crossURL The URL of the cross image =.
	 * @private
	 */
	MarkerLabel_.getSharedCross = function (crossURL) {
	  var div;
	  if (typeof MarkerLabel_.getSharedCross.crossDiv === "undefined") {
	    div = document.createElement("img");
	    div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
	    // Hopefully Google never changes the standard "X" attributes:
	    div.style.marginLeft = "-8px";
	    div.style.marginTop = "-9px";
	    div.src = crossURL;
	    MarkerLabel_.getSharedCross.crossDiv = div;
	  }
	  return MarkerLabel_.getSharedCross.crossDiv;
	};
	
	/**
	 * Adds the DIV representing the label to the DOM. This method is called
	 * automatically when the marker's <code>setMap</code> method is called.
	 * @private
	 */
	MarkerLabel_.prototype.onAdd = function () {
	  var me = this;
	  var cMouseIsDown = false;
	  var cDraggingLabel = false;
	  var cSavedZIndex;
	  var cLatOffset, cLngOffset;
	  var cIgnoreClick;
	  var cRaiseEnabled;
	  var cStartPosition;
	  var cStartCenter;
	  // Constants:
	  var cRaiseOffset = 20;
	  var cDraggingCursor = "url(" + this.handCursorURL_ + ")";
	
	  // Stops all processing of an event.
	  //
	  var cAbortEvent = function (e) {
	    if (e.preventDefault) {
	      e.preventDefault();
	    }
	    e.cancelBubble = true;
	    if (e.stopPropagation) {
	      e.stopPropagation();
	    }
	  };
	
	  var cStopBounce = function () {
	    me.marker_.setAnimation(null);
	  };
	
	  this.getPanes().overlayImage.appendChild(this.labelDiv_);
	  this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
	  // One cross is shared with all markers, so only add it once:
	  if (typeof MarkerLabel_.getSharedCross.processed === "undefined") {
	    this.getPanes().overlayImage.appendChild(this.crossDiv_);
	    MarkerLabel_.getSharedCross.processed = true;
	  }
	
	  this.listeners_ = [
	    google.maps.event.addDomListener(this.eventDiv_, "mouseover", function (e) {
	      if (me.marker_.getDraggable() || me.marker_.getClickable()) {
	        this.style.cursor = "pointer";
	        google.maps.event.trigger(me.marker_, "mouseover", e);
	      }
	    }),
	    google.maps.event.addDomListener(this.eventDiv_, "mouseout", function (e) {
	      if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
	        this.style.cursor = me.marker_.getCursor();
	        google.maps.event.trigger(me.marker_, "mouseout", e);
	      }
	    }),
	    google.maps.event.addDomListener(this.eventDiv_, "mousedown", function (e) {
	      cDraggingLabel = false;
	      if (me.marker_.getDraggable()) {
	        cMouseIsDown = true;
	        this.style.cursor = cDraggingCursor;
	      }
	      if (me.marker_.getDraggable() || me.marker_.getClickable()) {
	        google.maps.event.trigger(me.marker_, "mousedown", e);
	        cAbortEvent(e); // Prevent map pan when starting a drag on a label
	      }
	    }),
	    google.maps.event.addDomListener(document, "mouseup", function (mEvent) {
	      var position;
	      if (cMouseIsDown) {
	        cMouseIsDown = false;
	        me.eventDiv_.style.cursor = "pointer";
	        google.maps.event.trigger(me.marker_, "mouseup", mEvent);
	      }
	      if (cDraggingLabel) {
	        if (cRaiseEnabled) { // Lower the marker & label
	          position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
	          position.y += cRaiseOffset;
	          me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
	          // This is not the same bouncing style as when the marker portion is dragged,
	          // but it will have to do:
	          try { // Will fail if running Google Maps API earlier than V3.3
	            me.marker_.setAnimation(google.maps.Animation.BOUNCE);
	            setTimeout(cStopBounce, 1406);
	          } catch (e) {}
	        }
	        me.crossDiv_.style.display = "none";
	        me.marker_.setZIndex(cSavedZIndex);
	        cIgnoreClick = true; // Set flag to ignore the click event reported after a label drag
	        cDraggingLabel = false;
	        mEvent.latLng = me.marker_.getPosition();
	        google.maps.event.trigger(me.marker_, "dragend", mEvent);
	      }
	    }),
	    google.maps.event.addListener(me.marker_.getMap(), "mousemove", function (mEvent) {
	      var position;
	      if (cMouseIsDown) {
	        if (cDraggingLabel) {
	          // Change the reported location from the mouse position to the marker position:
	          mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
	          position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
	          if (cRaiseEnabled) {
	            me.crossDiv_.style.left = position.x + "px";
	            me.crossDiv_.style.top = position.y + "px";
	            me.crossDiv_.style.display = "";
	            position.y -= cRaiseOffset;
	          }
	          me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
	          if (cRaiseEnabled) { // Don't raise the veil; this hack needed to make MSIE act properly
	            me.eventDiv_.style.top = (position.y + cRaiseOffset) + "px";
	          }
	          google.maps.event.trigger(me.marker_, "drag", mEvent);
	        } else {
	          // Calculate offsets from the click point to the marker position:
	          cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
	          cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
	          cSavedZIndex = me.marker_.getZIndex();
	          cStartPosition = me.marker_.getPosition();
	          cStartCenter = me.marker_.getMap().getCenter();
	          cRaiseEnabled = me.marker_.get("raiseOnDrag");
	          cDraggingLabel = true;
	          me.marker_.setZIndex(1000000); // Moves the marker & label to the foreground during a drag
	          mEvent.latLng = me.marker_.getPosition();
	          google.maps.event.trigger(me.marker_, "dragstart", mEvent);
	        }
	      }
	    }),
	    google.maps.event.addDomListener(document, "keydown", function (e) {
	      if (cDraggingLabel) {
	        if (e.keyCode === 27) { // Esc key
	          cRaiseEnabled = false;
	          me.marker_.setPosition(cStartPosition);
	          me.marker_.getMap().setCenter(cStartCenter);
	          google.maps.event.trigger(document, "mouseup", e);
	        }
	      }
	    }),
	    google.maps.event.addDomListener(this.eventDiv_, "click", function (e) {
	      if (me.marker_.getDraggable() || me.marker_.getClickable()) {
	        if (cIgnoreClick) { // Ignore the click reported when a label drag ends
	          cIgnoreClick = false;
	        } else {
	          google.maps.event.trigger(me.marker_, "click", e);
	          cAbortEvent(e); // Prevent click from being passed on to map
	        }
	      }
	    }),
	    google.maps.event.addDomListener(this.eventDiv_, "dblclick", function (e) {
	      if (me.marker_.getDraggable() || me.marker_.getClickable()) {
	        google.maps.event.trigger(me.marker_, "dblclick", e);
	        cAbortEvent(e); // Prevent map zoom when double-clicking on a label
	      }
	    }),
	    google.maps.event.addListener(this.marker_, "dragstart", function (mEvent) {
	      if (!cDraggingLabel) {
	        cRaiseEnabled = this.get("raiseOnDrag");
	      }
	    }),
	    google.maps.event.addListener(this.marker_, "drag", function (mEvent) {
	      if (!cDraggingLabel) {
	        if (cRaiseEnabled) {
	          me.setPosition(cRaiseOffset);
	          // During a drag, the marker's z-index is temporarily set to 1000000 to
	          // ensure it appears above all other markers. Also set the label's z-index
	          // to 1000000 (plus or minus 1 depending on whether the label is supposed
	          // to be above or below the marker).
	          me.labelDiv_.style.zIndex = 1000000 + (this.get("labelInBackground") ? -1 : +1);
	        }
	      }
	    }),
	    google.maps.event.addListener(this.marker_, "dragend", function (mEvent) {
	      if (!cDraggingLabel) {
	        if (cRaiseEnabled) {
	          me.setPosition(0); // Also restores z-index of label
	        }
	      }
	    }),
	    google.maps.event.addListener(this.marker_, "position_changed", function () {
	      me.setPosition();
	    }),
	    google.maps.event.addListener(this.marker_, "zindex_changed", function () {
	      me.setZIndex();
	    }),
	    google.maps.event.addListener(this.marker_, "visible_changed", function () {
	      me.setVisible();
	    }),
	    google.maps.event.addListener(this.marker_, "labelvisible_changed", function () {
	      me.setVisible();
	    }),
	    google.maps.event.addListener(this.marker_, "title_changed", function () {
	      me.setTitle();
	    }),
	    google.maps.event.addListener(this.marker_, "labelcontent_changed", function () {
	      me.setContent();
	    }),
	    google.maps.event.addListener(this.marker_, "labelanchor_changed", function () {
	      me.setAnchor();
	    }),
	    google.maps.event.addListener(this.marker_, "labelclass_changed", function () {
	      me.setStyles();
	    }),
	    google.maps.event.addListener(this.marker_, "labelstyle_changed", function () {
	      me.setStyles();
	    })
	  ];
	};
	
	/**
	 * Removes the DIV for the label from the DOM. It also removes all event handlers.
	 * This method is called automatically when the marker's <code>setMap(null)</code>
	 * method is called.
	 * @private
	 */
	MarkerLabel_.prototype.onRemove = function () {
	  var i;
	  this.labelDiv_.parentNode.removeChild(this.labelDiv_);
	  this.eventDiv_.parentNode.removeChild(this.eventDiv_);
	
	  // Remove event listeners:
	  for (i = 0; i < this.listeners_.length; i++) {
	    google.maps.event.removeListener(this.listeners_[i]);
	  }
	};
	
	/**
	 * Draws the label on the map.
	 * @private
	 */
	MarkerLabel_.prototype.draw = function () {
	  this.setContent();
	  this.setTitle();
	  this.setStyles();
	};
	
	/**
	 * Sets the content of the label.
	 * The content can be plain text or an HTML DOM node.
	 * @private
	 */
	MarkerLabel_.prototype.setContent = function () {
	  var content = this.marker_.get("labelContent");
	  if (typeof content.nodeType === "undefined") {
	    this.labelDiv_.innerHTML = content;
	    this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
	  } else {
	    this.labelDiv_.innerHTML = ""; // Remove current content
	    this.labelDiv_.appendChild(content);
	    content = content.cloneNode(true);
	    this.eventDiv_.innerHTML = ""; // Remove current content
	    this.eventDiv_.appendChild(content);
	  }
	};
	
	/**
	 * Sets the content of the tool tip for the label. It is
	 * always set to be the same as for the marker itself.
	 * @private
	 */
	MarkerLabel_.prototype.setTitle = function () {
	  this.eventDiv_.title = this.marker_.getTitle() || "";
	};
	
	/**
	 * Sets the style of the label by setting the style sheet and applying
	 * other specific styles requested.
	 * @private
	 */
	MarkerLabel_.prototype.setStyles = function () {
	  var i, labelStyle;
	
	  // Apply style values from the style sheet defined in the labelClass parameter:
	  this.labelDiv_.className = this.marker_.get("labelClass");
	  this.eventDiv_.className = this.labelDiv_.className;
	
	  // Clear existing inline style values:
	  this.labelDiv_.style.cssText = "";
	  this.eventDiv_.style.cssText = "";
	  // Apply style values defined in the labelStyle parameter:
	  labelStyle = this.marker_.get("labelStyle");
	  for (i in labelStyle) {
	    if (labelStyle.hasOwnProperty(i)) {
	      this.labelDiv_.style[i] = labelStyle[i];
	      this.eventDiv_.style[i] = labelStyle[i];
	    }
	  }
	  this.setMandatoryStyles();
	};
	
	/**
	 * Sets the mandatory styles to the DIV representing the label as well as to the
	 * associated event DIV. This includes setting the DIV position, z-index, and visibility.
	 * @private
	 */
	MarkerLabel_.prototype.setMandatoryStyles = function () {
	  this.labelDiv_.style.position = "absolute";
	  this.labelDiv_.style.overflow = "hidden";
	  // Make sure the opacity setting causes the desired effect on MSIE:
	  if (typeof this.labelDiv_.style.opacity !== "undefined" && this.labelDiv_.style.opacity !== "") {
	    this.labelDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")\"";
	    this.labelDiv_.style.filter = "alpha(opacity=" + (this.labelDiv_.style.opacity * 100) + ")";
	  }
	
	  this.eventDiv_.style.position = this.labelDiv_.style.position;
	  this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
	  this.eventDiv_.style.opacity = 0.01; // Don't use 0; DIV won't be clickable on MSIE
	  this.eventDiv_.style.MsFilter = "\"progid:DXImageTransform.Microsoft.Alpha(opacity=1)\"";
	  this.eventDiv_.style.filter = "alpha(opacity=1)"; // For MSIE
	
	  this.setAnchor();
	  this.setPosition(); // This also updates z-index, if necessary.
	  this.setVisible();
	};
	
	/**
	 * Sets the anchor point of the label.
	 * @private
	 */
	MarkerLabel_.prototype.setAnchor = function () {
	  var anchor = this.marker_.get("labelAnchor");
	  this.labelDiv_.style.marginLeft = -anchor.x + "px";
	  this.labelDiv_.style.marginTop = -anchor.y + "px";
	  this.eventDiv_.style.marginLeft = -anchor.x + "px";
	  this.eventDiv_.style.marginTop = -anchor.y + "px";
	};
	
	/**
	 * Sets the position of the label. The z-index is also updated, if necessary.
	 * @private
	 */
	MarkerLabel_.prototype.setPosition = function (yOffset) {
	  var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
	  if (typeof yOffset === "undefined") {
	    yOffset = 0;
	  }
	  this.labelDiv_.style.left = Math.round(position.x) + "px";
	  this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
	  this.eventDiv_.style.left = this.labelDiv_.style.left;
	  this.eventDiv_.style.top = this.labelDiv_.style.top;
	
	  this.setZIndex();
	};
	
	/**
	 * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index
	 * of the label is set to the vertical coordinate of the label. This is in keeping with the default
	 * stacking order for Google Maps: markers to the south are in front of markers to the north.
	 * @private
	 */
	MarkerLabel_.prototype.setZIndex = function () {
	  var zAdjust = (this.marker_.get("labelInBackground") ? -1 : +1);
	  if (typeof this.marker_.getZIndex() === "undefined") {
	    this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
	    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
	  } else {
	    this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
	    this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
	  }
	};
	
	/**
	 * Sets the visibility of the label. The label is visible only if the marker itself is
	 * visible (i.e., its visible property is true) and the labelVisible property is true.
	 * @private
	 */
	MarkerLabel_.prototype.setVisible = function () {
	  if (this.marker_.get("labelVisible")) {
	    this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none";
	  } else {
	    this.labelDiv_.style.display = "none";
	  }
	  this.eventDiv_.style.display = this.labelDiv_.style.display;
	};
	
	/**
	 * @name MarkerWithLabelOptions
	 * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.
	 *  The properties available are the same as for <code>google.maps.Marker</code> with the addition
	 *  of the properties listed below. To change any of these additional properties after the labeled
	 *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.
	 *  <p>
	 *  When any of these properties changes, a property changed event is fired. The names of these
	 *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.
	 *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event
	 *  is fired.
	 *  <p>
	 * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).
	 * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so
	 *  that its top left corner is positioned at the anchor point of the associated marker. Use this
	 *  property to change the anchor point of the label. For example, to center a 50px-wide label
	 *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.
	 *  (Note: x-values increase to the right and y-values increase to the top.)
	 * @property {string} [labelClass] The name of the CSS class defining the styles for the label.
	 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
	 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
	 *  <code>marginTop</code> are ignored; these styles are for internal use only.
	 * @property {Object} [labelStyle] An object literal whose properties define specific CSS
	 *  style values to be applied to the label. Style values defined here override those that may
	 *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the
	 *  label has been created, all previously set styles (except those defined in the style sheet)
	 *  are removed from the label before the new style values are applied.
	 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
	 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
	 *  <code>marginTop</code> are ignored; these styles are for internal use only.
	 * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its
	 *  associated marker should appear in the background (i.e., in a plane below the marker).
	 *  The default is <code>false</code>, which causes the label to appear in the foreground.
	 * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.
	 *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is
	 *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also
	 *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).
	 * @property {boolean} [raiseOnDrag] A flag indicating whether the label and marker are to be
	 *  raised when the marker is dragged. The default is <code>true</code>. If a draggable marker is
	 *  being created and a version of Google Maps API earlier than V3.3 is being used, this property
	 *  must be set to <code>false</code>.
	 * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized for the
	 *  marker. <b>Important: The optimized rendering technique is not supported by MarkerWithLabel,
	 *  so the value of this parameter is always forced to <code>false</code>.
	 * @property {string} [crossImage="http://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png"]
	 *  The URL of the cross image to be displayed while dragging a marker.
	 * @property {string} [handCursor="http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur"]
	 *  The URL of the cursor to be displayed while dragging a marker.
	 */
	/**
	 * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.
	 * @constructor
	 * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.
	 */
	function MarkerWithLabel(opt_options) {
	  opt_options = opt_options || {};
	  opt_options.labelContent = opt_options.labelContent || "";
	  opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
	  opt_options.labelClass = opt_options.labelClass || "markerLabels";
	  opt_options.labelStyle = opt_options.labelStyle || {};
	  opt_options.labelInBackground = opt_options.labelInBackground || false;
	  if (typeof opt_options.labelVisible === "undefined") {
	    opt_options.labelVisible = true;
	  }
	  if (typeof opt_options.raiseOnDrag === "undefined") {
	    opt_options.raiseOnDrag = true;
	  }
	  if (typeof opt_options.clickable === "undefined") {
	    opt_options.clickable = true;
	  }
	  if (typeof opt_options.draggable === "undefined") {
	    opt_options.draggable = false;
	  }
	  if (typeof opt_options.optimized === "undefined") {
	    opt_options.optimized = false;
	  }
	  opt_options.crossImage = opt_options.crossImage || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
	  opt_options.handCursor = opt_options.handCursor || "http" + (document.location.protocol === "https:" ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
	  opt_options.optimized = false; // Optimized rendering is not supported
	
	  this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor); // Bind the label to the marker
	
	  // Call the parent constructor. It calls Marker.setValues to initialize, so all
	  // the new parameters are conveniently saved and can be accessed with get/set.
	  // Marker.set triggers a property changed event (called "propertyname_changed")
	  // that the marker label listens for in order to react to state changes.
	  google.maps.Marker.apply(this, arguments);
	}
	
	inherits(MarkerWithLabel, google.maps.Marker);
	
	/**
	 * Overrides the standard Marker setMap function.
	 * @param {Map} theMap The map to which the marker is to be added.
	 * @private
	 */
	MarkerWithLabel.prototype.setMap = function (theMap) {
	
	  // Call the inherited function...
	  google.maps.Marker.prototype.setMap.apply(this, arguments);
	
	  // ... then deal with the label:
	  this.label.setMap(theMap);
	};
	
	// ==ClosureCompiler==
	// @compilation_level ADVANCED_OPTIMIZATIONS
	// @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js
	// @output_wrapper (function() {%output%})();
	// ==/ClosureCompiler==
	
	/**
	 * @license
	 * Copyright 2013 Google Inc. All Rights Reserved.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */
	
	/**
	 * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.
	 *
	 * @param {Object.<string, *>=} opt_options Optional properties to set.
	 * @extends {google.maps.OverlayView}
	 * @constructor
	 */
	function RichMarker(opt_options) {
	  var options = opt_options || {};
	
	  /**
	   * @type {boolean}
	   * @private
	   */
	  this.ready_ = false;
	
	  /**
	   * @type {boolean}
	   * @private
	   */
	  this.dragging_ = false;
	
	  if (opt_options['visible'] == undefined) {
	    opt_options['visible'] = true;
	  }
	
	  if (opt_options['shadow'] == undefined) {
	    opt_options['shadow'] = '7px -3px 5px rgba(88,88,88,0.7)';
	  }
	
	  if (opt_options['anchor'] == undefined) {
	    opt_options['anchor'] = RichMarkerPosition['BOTTOM'];
	  }
	
	  this.setValues(options);
	}
	RichMarker.prototype = new google.maps.OverlayView();
	window['RichMarker'] = RichMarker;
	
	
	/**
	 * Returns the current visibility state of the marker.
	 *
	 * @return {boolean} The visiblity of the marker.
	 */
	RichMarker.prototype.getVisible = function() {
	  return /** @type {boolean} */ (this.get('visible'));
	};
	RichMarker.prototype['getVisible'] = RichMarker.prototype.getVisible;
	
	
	/**
	 * Sets the visiblility state of the marker.
	 *
	 * @param {boolean} visible The visiblilty of the marker.
	 */
	RichMarker.prototype.setVisible = function(visible) {
	  this.set('visible', visible);
	};
	RichMarker.prototype['setVisible'] = RichMarker.prototype.setVisible;
	
	
	/**
	 *  The visible changed event.
	 */
	RichMarker.prototype.visible_changed = function() {
	  if (this.ready_) {
	    this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
	    this.draw();
	  }
	};
	RichMarker.prototype['visible_changed'] = RichMarker.prototype.visible_changed;
	
	
	/**
	 * Sets the marker to be flat.
	 *
	 * @param {boolean} flat If the marker is to be flat or not.
	 */
	RichMarker.prototype.setFlat = function(flat) {
	  this.set('flat', !!flat);
	};
	RichMarker.prototype['setFlat'] = RichMarker.prototype.setFlat;
	
	
	/**
	 * If the makrer is flat or not.
	 *
	 * @return {boolean} True the marker is flat.
	 */
	RichMarker.prototype.getFlat = function() {
	  return /** @type {boolean} */ (this.get('flat'));
	};
	RichMarker.prototype['getFlat'] = RichMarker.prototype.getFlat;
	
	
	/**
	 * Get the width of the marker.
	 *
	 * @return {Number} The width of the marker.
	 */
	RichMarker.prototype.getWidth = function() {
	  return /** @type {Number} */ (this.get('width'));
	};
	RichMarker.prototype['getWidth'] = RichMarker.prototype.getWidth;
	
	
	/**
	 * Get the height of the marker.
	 *
	 * @return {Number} The height of the marker.
	 */
	RichMarker.prototype.getHeight = function() {
	  return /** @type {Number} */ (this.get('height'));
	};
	RichMarker.prototype['getHeight'] = RichMarker.prototype.getHeight;
	
	
	/**
	 * Sets the marker's box shadow.
	 *
	 * @param {string} shadow The box shadow to set.
	 */
	RichMarker.prototype.setShadow = function(shadow) {
	  this.set('shadow', shadow);
	  this.flat_changed();
	};
	RichMarker.prototype['setShadow'] = RichMarker.prototype.setShadow;
	
	
	/**
	 * Gets the marker's box shadow.
	 *
	 * @return {string} The box shadow.
	 */
	RichMarker.prototype.getShadow = function() {
	  return /** @type {string} */ (this.get('shadow'));
	};
	RichMarker.prototype['getShadow'] = RichMarker.prototype.getShadow;
	
	
	/**
	 * Flat changed event.
	 */
	RichMarker.prototype.flat_changed = function() {
	  if (!this.ready_) {
	    return;
	  }
	
	  this.markerWrapper_.style['boxShadow'] =
	      this.markerWrapper_.style['webkitBoxShadow'] =
	      this.markerWrapper_.style['MozBoxShadow'] =
	      this.getFlat() ? '' : this.getShadow();
	};
	RichMarker.prototype['flat_changed'] = RichMarker.prototype.flat_changed;
	
	
	/**
	 * Sets the zIndex of the marker.
	 *
	 * @param {Number} index The index to set.
	 */
	RichMarker.prototype.setZIndex = function(index) {
	  this.set('zIndex', index);
	};
	RichMarker.prototype['setZIndex'] = RichMarker.prototype.setZIndex;
	
	
	/**
	 * Gets the zIndex of the marker.
	 *
	 * @return {Number} The zIndex of the marker.
	 */
	RichMarker.prototype.getZIndex = function() {
	  return /** @type {Number} */ (this.get('zIndex'));
	};
	RichMarker.prototype['getZIndex'] = RichMarker.prototype.getZIndex;
	
	
	/**
	 * zIndex changed event.
	 */
	RichMarker.prototype.zIndex_changed = function() {
	  if (this.getZIndex() && this.ready_) {
	    this.markerWrapper_.style.zIndex = this.getZIndex();
	  }
	};
	RichMarker.prototype['zIndex_changed'] = RichMarker.prototype.zIndex_changed;
	
	/**
	 * Whether the marker is draggable or not.
	 *
	 * @return {boolean} True if the marker is draggable.
	 */
	RichMarker.prototype.getDraggable = function() {
	  return /** @type {boolean} */ (this.get('draggable'));
	};
	RichMarker.prototype['getDraggable'] = RichMarker.prototype.getDraggable;
	
	
	/**
	 * Sets the marker to be draggable or not.
	 *
	 * @param {boolean} draggable If the marker is draggable or not.
	 */
	RichMarker.prototype.setDraggable = function(draggable) {
	  this.set('draggable', !!draggable);
	};
	RichMarker.prototype['setDraggable'] = RichMarker.prototype.setDraggable;
	
	
	/**
	 * Draggable property changed callback.
	 */
	RichMarker.prototype.draggable_changed = function() {
	  if (this.ready_) {
	    if (this.getDraggable()) {
	      this.addDragging_(this.markerWrapper_);
	    } else {
	      this.removeDragListeners_();
	    }
	  }
	};
	RichMarker.prototype['draggable_changed'] =
	    RichMarker.prototype.draggable_changed;
	
	
	/**
	 * Gets the postiton of the marker.
	 *
	 * @return {google.maps.LatLng} The position of the marker.
	 */
	RichMarker.prototype.getPosition = function() {
	  return /** @type {google.maps.LatLng} */ (this.get('position'));
	};
	RichMarker.prototype['getPosition'] = RichMarker.prototype.getPosition;
	
	
	/**
	 * Sets the position of the marker.
	 *
	 * @param {google.maps.LatLng} position The position to set.
	 */
	RichMarker.prototype.setPosition = function(position) {
	  this.set('position', position);
	};
	RichMarker.prototype['setPosition'] = RichMarker.prototype.setPosition;
	
	
	/**
	 * Position changed event.
	 */
	RichMarker.prototype.position_changed = function() {
	  this.draw();
	};
	RichMarker.prototype['position_changed'] =
	    RichMarker.prototype.position_changed;
	
	
	/**
	 * Gets the anchor.
	 *
	 * @return {google.maps.Size} The position of the anchor.
	 */
	RichMarker.prototype.getAnchor = function() {
	  return /** @type {google.maps.Size} */ (this.get('anchor'));
	};
	RichMarker.prototype['getAnchor'] = RichMarker.prototype.getAnchor;
	
	
	/**
	 * Sets the anchor.
	 *
	 * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.
	 */
	RichMarker.prototype.setAnchor = function(anchor) {
	  this.set('anchor', anchor);
	};
	RichMarker.prototype['setAnchor'] = RichMarker.prototype.setAnchor;
	
	
	/**
	 * Anchor changed event.
	 */
	RichMarker.prototype.anchor_changed = function() {
	  this.draw();
	};
	RichMarker.prototype['anchor_changed'] = RichMarker.prototype.anchor_changed;
	
	
	/**
	 * Converts a HTML string to a document fragment.
	 *
	 * @param {string} htmlString The HTML string to convert.
	 * @return {Node} A HTML document fragment.
	 * @private
	 */
	RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
	  var tempDiv = document.createElement('DIV');
	  tempDiv.innerHTML = htmlString;
	  if (tempDiv.childNodes.length == 1) {
	    return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
	  } else {
	    var fragment = document.createDocumentFragment();
	    while (tempDiv.firstChild) {
	      fragment.appendChild(tempDiv.firstChild);
	    }
	    return fragment;
	  }
	};
	
	
	/**
	 * Removes all children from the node.
	 *
	 * @param {Node} node The node to remove all children from.
	 * @private
	 */
	RichMarker.prototype.removeChildren_ = function(node) {
	  if (!node) {
	    return;
	  }
	
	  var child;
	  while (child = node.firstChild) {
	    node.removeChild(child);
	  }
	};
	
	
	/**
	 * Sets the content of the marker.
	 *
	 * @param {string|Node} content The content to set.
	 */
	RichMarker.prototype.setContent = function(content) {
	  this.set('content', content);
	};
	RichMarker.prototype['setContent'] = RichMarker.prototype.setContent;
	
	
	/**
	 * Get the content of the marker.
	 *
	 * @return {string|Node} The marker content.
	 */
	RichMarker.prototype.getContent = function() {
	  return /** @type {Node|string} */ (this.get('content'));
	};
	RichMarker.prototype['getContent'] = RichMarker.prototype.getContent;
	
	
	/**
	 * Sets the marker content and adds loading events to images
	 */
	RichMarker.prototype.content_changed = function() {
	  if (!this.markerContent_) {
	    // Marker content area doesnt exist.
	    return;
	  }
	
	  this.removeChildren_(this.markerContent_);
	  var content = this.getContent();
	  if (content) {
	    if (typeof content == 'string') {
	      content = content.replace(/^\s*([\S\s]*)\b\s*$/, '$1');
	      content = this.htmlToDocumentFragment_(content);
	    }
	    this.markerContent_.appendChild(content);
	
	    var that = this;
	    var images = this.markerContent_.getElementsByTagName('IMG');
	    for (var i = 0, image; image = images[i]; i++) {
	      // By default, a browser lets a image be dragged outside of the browser,
	      // so by calling preventDefault we stop this behaviour and allow the image
	      // to be dragged around the map and now out of the browser and onto the
	      // desktop.
	      google.maps.event.addDomListener(image, 'mousedown', function(e) {
	        if (that.getDraggable()) {
	          if (e.preventDefault) {
	            e.preventDefault();
	          }
	          e.returnValue = false;
	        }
	      });
	
	      // Because we don't know the size of an image till it loads, add a
	      // listener to the image load so the marker can resize and reposition
	      // itself to be the correct height.
	      google.maps.event.addDomListener(image, 'load', function() {
	        that.draw();
	      });
	    }
	
	    google.maps.event.trigger(this, 'domready');
	  }
	
	  if (this.ready_) {
	    this.draw();
	  }
	};
	RichMarker.prototype['content_changed'] = RichMarker.prototype.content_changed;
	
	/**
	 * Sets the cursor.
	 *
	 * @param {string} whichCursor What cursor to show.
	 * @private
	 */
	RichMarker.prototype.setCursor_ = function(whichCursor) {
	  if (!this.ready_) {
	    return;
	  }
	
	  var cursor = '';
	  if (navigator.userAgent.indexOf('Gecko/') !== -1) {
	    // Moz has some nice cursors :)
	    if (whichCursor == 'dragging') {
	      cursor = '-moz-grabbing';
	    }
	
	    if (whichCursor == 'dragready') {
	      cursor = '-moz-grab';
	    }
	
	    if (whichCursor == 'draggable') {
	      cursor = 'pointer';
	    }
	  } else {
	    if (whichCursor == 'dragging' || whichCursor == 'dragready') {
	      cursor = 'move';
	    }
	
	    if (whichCursor == 'draggable') {
	      cursor = 'pointer';
	    }
	  }
	
	  if (this.markerWrapper_.style.cursor != cursor) {
	    this.markerWrapper_.style.cursor = cursor;
	  }
	};
	
	/**
	 * Start dragging.
	 *
	 * @param {Event} e The event.
	 */
	RichMarker.prototype.startDrag = function(e) {
	  if (!this.getDraggable()) {
	    return;
	  }
	
	  if (!this.dragging_) {
	    this.dragging_ = true;
	    var map = this.getMap();
	    this.mapDraggable_ = map.get('draggable');
	    map.set('draggable', false);
	
	    // Store the current mouse position
	    this.mouseX_ = e.clientX;
	    this.mouseY_ = e.clientY;
	
	    this.setCursor_('dragready');
	
	    // Stop the text from being selectable while being dragged
	    this.markerWrapper_.style['MozUserSelect'] = 'none';
	    this.markerWrapper_.style['KhtmlUserSelect'] = 'none';
	    this.markerWrapper_.style['WebkitUserSelect'] = 'none';
	
	    this.markerWrapper_['unselectable'] = 'on';
	    this.markerWrapper_['onselectstart'] = function() {
	      return false;
	    };
	
	    this.addDraggingListeners_();
	
	    google.maps.event.trigger(this, 'dragstart');
	  }
	};
	
	
	/**
	 * Stop dragging.
	 */
	RichMarker.prototype.stopDrag = function() {
	  if (!this.getDraggable()) {
	    return;
	  }
	
	  if (this.dragging_) {
	    this.dragging_ = false;
	    this.getMap().set('draggable', this.mapDraggable_);
	    this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
	
	    // Allow the text to be selectable again
	    this.markerWrapper_.style['MozUserSelect'] = '';
	    this.markerWrapper_.style['KhtmlUserSelect'] = '';
	    this.markerWrapper_.style['WebkitUserSelect'] = '';
	    this.markerWrapper_['unselectable'] = 'off';
	    this.markerWrapper_['onselectstart'] = function() {};
	
	    this.removeDraggingListeners_();
	
	    this.setCursor_('draggable');
	    google.maps.event.trigger(this, 'dragend');
	
	    this.draw();
	  }
	};
	
	
	/**
	 * Handles the drag event.
	 *
	 * @param {Event} e The event.
	 */
	RichMarker.prototype.drag = function(e) {
	  if (!this.getDraggable() || !this.dragging_) {
	    // This object isn't draggable or we have stopped dragging
	    this.stopDrag();
	    return;
	  }
	
	  var dx = this.mouseX_ - e.clientX;
	  var dy = this.mouseY_ - e.clientY;
	
	  this.mouseX_ = e.clientX;
	  this.mouseY_ = e.clientY;
	
	  var left = parseInt(this.markerWrapper_.style['left'], 10) - dx;
	  var top = parseInt(this.markerWrapper_.style['top'], 10) - dy;
	
	  this.markerWrapper_.style['left'] = left + 'px';
	  this.markerWrapper_.style['top'] = top + 'px';
	
	  var offset = this.getOffset_();
	
	  // Set the position property and adjust for the anchor offset
	  var point = new google.maps.Point(left - offset.width, top - offset.height);
	  var projection = this.getProjection();
	  this.setPosition(projection.fromDivPixelToLatLng(point));
	
	  this.setCursor_('dragging');
	  google.maps.event.trigger(this, 'drag');
	};
	
	
	/**
	 * Removes the drag listeners associated with the marker.
	 *
	 * @private
	 */
	RichMarker.prototype.removeDragListeners_ = function() {
	  if (this.draggableListener_) {
	    google.maps.event.removeListener(this.draggableListener_);
	    delete this.draggableListener_;
	  }
	  this.setCursor_('');
	};
	
	
	/**
	 * Add dragability events to the marker.
	 *
	 * @param {Node} node The node to apply dragging to.
	 * @private
	 */
	RichMarker.prototype.addDragging_ = function(node) {
	  if (!node) {
	    return;
	  }
	
	  var that = this;
	  this.draggableListener_ =
	    google.maps.event.addDomListener(node, 'mousedown', function(e) {
	      that.startDrag(e);
	    });
	
	  this.setCursor_('draggable');
	};
	
	
	/**
	 * Add dragging listeners.
	 *
	 * @private
	 */
	RichMarker.prototype.addDraggingListeners_ = function() {
	  var that = this;
	  if (this.markerWrapper_.setCapture) {
	    this.markerWrapper_.setCapture(true);
	    this.draggingListeners_ = [
	      google.maps.event.addDomListener(this.markerWrapper_, 'mousemove', function(e) {
	        that.drag(e);
	      }, true),
	      google.maps.event.addDomListener(this.markerWrapper_, 'mouseup', function() {
	        that.stopDrag();
	        that.markerWrapper_.releaseCapture();
	      }, true)
	    ];
	  } else {
	    this.draggingListeners_ = [
	      google.maps.event.addDomListener(window, 'mousemove', function(e) {
	        that.drag(e);
	      }, true),
	      google.maps.event.addDomListener(window, 'mouseup', function() {
	        that.stopDrag();
	      }, true)
	    ];
	  }
	};
	
	
	/**
	 * Remove dragging listeners.
	 *
	 * @private
	 */
	RichMarker.prototype.removeDraggingListeners_ = function() {
	  if (this.draggingListeners_) {
	    for (var i = 0, listener; listener = this.draggingListeners_[i]; i++) {
	      google.maps.event.removeListener(listener);
	    }
	    this.draggingListeners_.length = 0;
	  }
	};
	
	
	/**
	 * Get the anchor offset.
	 *
	 * @return {google.maps.Size} The size offset.
	 * @private
	 */
	RichMarker.prototype.getOffset_ = function() {
	  var anchor = this.getAnchor();
	  if (typeof anchor == 'object') {
	    return /** @type {google.maps.Size} */ (anchor);
	  }
	
	  var offset = new google.maps.Size(0, 0);
	  if (!this.markerContent_) {
	    return offset;
	  }
	
	  var width = this.markerContent_.offsetWidth;
	  var height = this.markerContent_.offsetHeight;
	
	  switch (anchor) {
	   case RichMarkerPosition['TOP_LEFT']:
	     break;
	   case RichMarkerPosition['TOP']:
	     offset.width = -width / 2;
	     break;
	   case RichMarkerPosition['TOP_RIGHT']:
	     offset.width = -width;
	     break;
	   case RichMarkerPosition['LEFT']:
	     offset.height = -height / 2;
	     break;
	   case RichMarkerPosition['MIDDLE']:
	     offset.width = -width / 2;
	     offset.height = -height / 2;
	     break;
	   case RichMarkerPosition['RIGHT']:
	     offset.width = -width;
	     offset.height = -height / 2;
	     break;
	   case RichMarkerPosition['BOTTOM_LEFT']:
	     offset.height = -height;
	     break;
	   case RichMarkerPosition['BOTTOM']:
	     offset.width = -width / 2;
	     offset.height = -height;
	     break;
	   case RichMarkerPosition['BOTTOM_RIGHT']:
	     offset.width = -width;
	     offset.height = -height;
	     break;
	  }
	
	  return offset;
	};
	
	
	/**
	 * Adding the marker to a map.
	 * Implementing the interface.
	 */
	RichMarker.prototype.onAdd = function() {
	  if (!this.markerWrapper_) {
	    this.markerWrapper_ = document.createElement('DIV');
	    this.markerWrapper_.style['position'] = 'absolute';
	  }
	
	  if (this.getZIndex()) {
	    this.markerWrapper_.style['zIndex'] = this.getZIndex();
	  }
	
	  this.markerWrapper_.style['display'] = this.getVisible() ? '' : 'none';
	
	  if (!this.markerContent_) {
	    this.markerContent_ = document.createElement('DIV');
	    this.markerWrapper_.appendChild(this.markerContent_);
	
	    var that = this;
	    google.maps.event.addDomListener(this.markerContent_, 'click', function(e) {
	      google.maps.event.trigger(that, 'click');
	    });
	    google.maps.event.addDomListener(this.markerContent_, 'mouseover', function(e) {
	      google.maps.event.trigger(that, 'mouseover');
	    });
	    google.maps.event.addDomListener(this.markerContent_, 'mouseout', function(e) {
	      google.maps.event.trigger(that, 'mouseout');
	    });
	  }
	
	  this.ready_ = true;
	  this.content_changed();
	  this.flat_changed();
	  this.draggable_changed();
	
	  var panes = this.getPanes();
	  if (panes) {
	    panes.overlayMouseTarget.appendChild(this.markerWrapper_);
	  }
	
	  google.maps.event.trigger(this, 'ready');
	};
	RichMarker.prototype['onAdd'] = RichMarker.prototype.onAdd;
	
	
	/**
	 * Impelementing the interface.
	 */
	RichMarker.prototype.draw = function() {
	  if (!this.ready_ || this.dragging_) {
	    return;
	  }
	
	  var projection = this.getProjection();
	
	  if (!projection) {
	    // The map projection is not ready yet so do nothing
	    return;
	  }
	
	  var latLng = /** @type {google.maps.LatLng} */ (this.get('position'));
	  var pos = projection.fromLatLngToDivPixel(latLng);
	
	  var offset = this.getOffset_();
	  this.markerWrapper_.style['top'] = (pos.y + offset.height) + 'px';
	  this.markerWrapper_.style['left'] = (pos.x + offset.width) + 'px';
	
	  var height = this.markerContent_.offsetHeight;
	  var width = this.markerContent_.offsetWidth;
	
	  if (width != this.get('width')) {
	    this.set('width', width);
	  }
	
	  if (height != this.get('height')) {
	    this.set('height', height);
	  }
	};
	RichMarker.prototype['draw'] = RichMarker.prototype.draw;
	
	
	/**
	 * Removing a marker from the map.
	 * Implementing the interface.
	 */
	RichMarker.prototype.onRemove = function() {
	  if (this.markerWrapper_ && this.markerWrapper_.parentNode) {
	    this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
	  }
	  this.removeDragListeners_();
	};
	RichMarker.prototype['onRemove'] = RichMarker.prototype.onRemove;
	
	
	/**
	 * RichMarker Anchor positions
	 * @enum {number}
	 */
	var RichMarkerPosition = {
	  'TOP_LEFT': 1,
	  'TOP': 2,
	  'TOP_RIGHT': 3,
	  'LEFT': 4,
	  'MIDDLE': 5,
	  'RIGHT': 6,
	  'BOTTOM_LEFT': 7,
	  'BOTTOM': 8,
	  'BOTTOM_RIGHT': 9
	};
	window['RichMarkerPosition'] = RichMarkerPosition;
	
	
	        //TODO: export / passthese on in the service instead of window
	        window.InfoBox = InfoBox;
	        window.Cluster = Cluster;
	        window.ClusterIcon = ClusterIcon;
	        window.MarkerClusterer = MarkerClusterer;
	        window.MarkerLabel_ = MarkerLabel_;
	        window.MarkerWithLabel = MarkerWithLabel;
	        window.RichMarker = RichMarker;
	      }();
	      //END REPLACE
	    })
	  };
	});
	;/******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};
	
	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {
	
	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;
	
	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};
	
	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
	
	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;
	
	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}
	
	
	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;
	
	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;
	
	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";
	
	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {
	
		/* istanbul ignore next */
		angular.module('uiGmapgoogle-maps.wrapped')
		.service('uiGmapDataStructures', function() {
		return {
		  Graph: __webpack_require__(1).Graph,
		  Queue: __webpack_require__(1).Queue
		};
		});
	
	
	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {
	
		(function() {
		  module.exports = {
		    Graph: __webpack_require__(2),
		    Heap: __webpack_require__(3),
		    LinkedList: __webpack_require__(4),
		    Map: __webpack_require__(5),
		    Queue: __webpack_require__(6),
		    RedBlackTree: __webpack_require__(7),
		    Trie: __webpack_require__(8)
		  };
	
		}).call(this);
	
	
	/***/ },
	/* 2 */
	/***/ function(module, exports) {
	
		/*
		Graph implemented as a modified incidence list. O(1) for every typical
		operation except `removeNode()` at O(E) where E is the number of edges.
	
		## Overview example:
	
		```js
		var graph = new Graph;
		graph.addNode('A'); // => a node object. For more info, log the output or check
		                    // the documentation for addNode
		graph.addNode('B');
		graph.addNode('C');
		graph.addEdge('A', 'C'); // => an edge object
		graph.addEdge('A', 'B');
		graph.getEdge('B', 'A'); // => undefined. Directed edge!
		graph.getEdge('A', 'B'); // => the edge object previously added
		graph.getEdge('A', 'B').weight = 2 // weight is the only built-in handy property
		                                   // of an edge object. Feel free to attach
		                                   // other properties
		graph.getInEdgesOf('B'); // => array of edge objects, in this case only one;
		                         // connecting A to B
		graph.getOutEdgesOf('A'); // => array of edge objects, one to B and one to C
		graph.getAllEdgesOf('A'); // => all the in and out edges. Edge directed toward
		                          // the node itself are only counted once
		forEachNode(function(nodeObject) {
		  console.log(node);
		});
		forEachEdge(function(edgeObject) {
		  console.log(edgeObject);
		});
		graph.removeNode('C'); // => 'C'. The edge between A and C also removed
		graph.removeEdge('A', 'B'); // => the edge object removed
		```
	
		## Properties:
	
		- nodeSize: total number of nodes.
		- edgeSize: total number of edges.
		*/
	
	
		(function() {
		  var Graph,
		    __hasProp = {}.hasOwnProperty;
	
		  Graph = (function() {
		    function Graph() {
		      this._nodes = {};
		      this.nodeSize = 0;
		      this.edgeSize = 0;
		    }
	
		    Graph.prototype.addNode = function(id) {
		      /*
		      The `id` is a unique identifier for the node, and should **not** change
		      after it's added. It will be used for adding, retrieving and deleting
		      related edges too.
		      
		      **Note** that, internally, the ids are kept in an object. JavaScript's
		      object hashes the id `'2'` and `2` to the same key, so please stick to a
		      simple id data type such as number or string.
		      
		      _Returns:_ the node object. Feel free to attach additional custom properties
		      on it for graph algorithms' needs. **Undefined if node id already exists**,
		      as to avoid accidental overrides.
		      */
	
		      if (!this._nodes[id]) {
		        this.nodeSize++;
		        return this._nodes[id] = {
		          _outEdges: {},
		          _inEdges: {}
		        };
		      }
		    };
	
		    Graph.prototype.getNode = function(id) {
		      /*
		      _Returns:_ the node object. Feel free to attach additional custom properties
		      on it for graph algorithms' needs.
		      */
	
		      return this._nodes[id];
		    };
	
		    Graph.prototype.removeNode = function(id) {
		      /*
		      _Returns:_ the node object removed, or undefined if it didn't exist in the
		      first place.
		      */
	
		      var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
		      nodeToRemove = this._nodes[id];
		      if (!nodeToRemove) {
		        return;
		      } else {
		        _ref = nodeToRemove._outEdges;
		        for (outEdgeId in _ref) {
		          if (!__hasProp.call(_ref, outEdgeId)) continue;
		          this.removeEdge(id, outEdgeId);
		        }
		        _ref1 = nodeToRemove._inEdges;
		        for (inEdgeId in _ref1) {
		          if (!__hasProp.call(_ref1, inEdgeId)) continue;
		          this.removeEdge(inEdgeId, id);
		        }
		        this.nodeSize--;
		        delete this._nodes[id];
		      }
		      return nodeToRemove;
		    };
	
		    Graph.prototype.addEdge = function(fromId, toId, weight) {
		      var edgeToAdd, fromNode, toNode;
		      if (weight == null) {
		        weight = 1;
		      }
		      /*
		      `fromId` and `toId` are the node id specified when it was created using
		      `addNode()`. `weight` is optional and defaults to 1. Ignoring it effectively
		      makes this an unweighted graph. Under the hood, `weight` is just a normal
		      property of the edge object.
		      
		      _Returns:_ the edge object created. Feel free to attach additional custom
		      properties on it for graph algorithms' needs. **Or undefined** if the nodes
		      of id `fromId` or `toId` aren't found, or if an edge already exists between
		      the two nodes.
		      */
	
		      if (this.getEdge(fromId, toId)) {
		        return;
		      }
		      fromNode = this._nodes[fromId];
		      toNode = this._nodes[toId];
		      if (!fromNode || !toNode) {
		        return;
		      }
		      edgeToAdd = {
		        weight: weight
		      };
		      fromNode._outEdges[toId] = edgeToAdd;
		      toNode._inEdges[fromId] = edgeToAdd;
		      this.edgeSize++;
		      return edgeToAdd;
		    };
	
		    Graph.prototype.getEdge = function(fromId, toId) {
		      /*
		      _Returns:_ the edge object, or undefined if the nodes of id `fromId` or
		      `toId` aren't found.
		      */
	
		      var fromNode, toNode;
		      fromNode = this._nodes[fromId];
		      toNode = this._nodes[toId];
		      if (!fromNode || !toNode) {
	
		      } else {
		        return fromNode._outEdges[toId];
		      }
		    };
	
		    Graph.prototype.removeEdge = function(fromId, toId) {
		      /*
		      _Returns:_ the edge object removed, or undefined of edge wasn't found.
		      */
	
		      var edgeToDelete, fromNode, toNode;
		      fromNode = this._nodes[fromId];
		      toNode = this._nodes[toId];
		      edgeToDelete = this.getEdge(fromId, toId);
		      if (!edgeToDelete) {
		        return;
		      }
		      delete fromNode._outEdges[toId];
		      delete toNode._inEdges[fromId];
		      this.edgeSize--;
		      return edgeToDelete;
		    };
	
		    Graph.prototype.getInEdgesOf = function(nodeId) {
		      /*
		      _Returns:_ an array of edge objects that are directed toward the node, or
		      empty array if no such edge or node exists.
		      */
	
		      var fromId, inEdges, toNode, _ref;
		      toNode = this._nodes[nodeId];
		      inEdges = [];
		      _ref = toNode != null ? toNode._inEdges : void 0;
		      for (fromId in _ref) {
		        if (!__hasProp.call(_ref, fromId)) continue;
		        inEdges.push(this.getEdge(fromId, nodeId));
		      }
		      return inEdges;
		    };
	
		    Graph.prototype.getOutEdgesOf = function(nodeId) {
		      /*
		      _Returns:_ an array of edge objects that go out of the node, or empty array
		      if no such edge or node exists.
		      */
	
		      var fromNode, outEdges, toId, _ref;
		      fromNode = this._nodes[nodeId];
		      outEdges = [];
		      _ref = fromNode != null ? fromNode._outEdges : void 0;
		      for (toId in _ref) {
		        if (!__hasProp.call(_ref, toId)) continue;
		        outEdges.push(this.getEdge(nodeId, toId));
		      }
		      return outEdges;
		    };
	
		    Graph.prototype.getAllEdgesOf = function(nodeId) {
		      /*
		      **Note:** not the same as concatenating `getInEdgesOf()` and
		      `getOutEdgesOf()`. Some nodes might have an edge pointing toward itself.
		      This method solves that duplication.
		      
		      _Returns:_ an array of edge objects linked to the node, no matter if they're
		      outgoing or coming. Duplicate edge created by self-pointing nodes are
		      removed. Only one copy stays. Empty array if node has no edge.
		      */
	
		      var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
		      inEdges = this.getInEdgesOf(nodeId);
		      outEdges = this.getOutEdgesOf(nodeId);
		      if (inEdges.length === 0) {
		        return outEdges;
		      }
		      selfEdge = this.getEdge(nodeId, nodeId);
		      for (i = _i = 0, _ref = inEdges.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
		        if (inEdges[i] === selfEdge) {
		          _ref1 = [inEdges[inEdges.length - 1], inEdges[i]], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
		          inEdges.pop();
		          break;
		        }
		      }
		      return inEdges.concat(outEdges);
		    };
	
		    Graph.prototype.forEachNode = function(operation) {
		      /*
		      Traverse through the graph in an arbitrary manner, visiting each node once.
		      Pass a function of the form `fn(nodeObject, nodeId)`.
		      
		      _Returns:_ undefined.
		      */
	
		      var nodeId, nodeObject, _ref;
		      _ref = this._nodes;
		      for (nodeId in _ref) {
		        if (!__hasProp.call(_ref, nodeId)) continue;
		        nodeObject = _ref[nodeId];
		        operation(nodeObject, nodeId);
		      }
		    };
	
		    Graph.prototype.forEachEdge = function(operation) {
		      /*
		      Traverse through the graph in an arbitrary manner, visiting each edge once.
		      Pass a function of the form `fn(edgeObject)`.
		      
		      _Returns:_ undefined.
		      */
	
		      var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
		      _ref = this._nodes;
		      for (nodeId in _ref) {
		        if (!__hasProp.call(_ref, nodeId)) continue;
		        nodeObject = _ref[nodeId];
		        _ref1 = nodeObject._outEdges;
		        for (toId in _ref1) {
		          if (!__hasProp.call(_ref1, toId)) continue;
		          edgeObject = _ref1[toId];
		          operation(edgeObject);
		        }
		      }
		    };
	
		    return Graph;
	
		  })();
	
		  module.exports = Graph;
	
		}).call(this);
	
	
	/***/ },
	/* 3 */
	/***/ function(module, exports) {
	
		/*
		Minimum heap, i.e. smallest node at root.
	
		**Note:** does not accept null or undefined. This is by design. Those values
		cause comparison problems and might report false negative during extraction.
	
		## Overview example:
	
		```js
		var heap = new Heap([5, 6, 3, 4]);
		heap.add(10); // => 10
		heap.removeMin(); // => 3
		heap.peekMin(); // => 4
		```
	
		## Properties:
	
		- size: total number of items.
		*/
	
	
		(function() {
		  var Heap, _leftChild, _parent, _rightChild;
	
		  Heap = (function() {
		    function Heap(dataToHeapify) {
		      var i, item, _i, _j, _len, _ref;
		      if (dataToHeapify == null) {
		        dataToHeapify = [];
		      }
		      /*
		      Pass an optional array to be heapified. Takes only O(n) time.
		      */
	
		      this._data = [void 0];
		      for (_i = 0, _len = dataToHeapify.length; _i < _len; _i++) {
		        item = dataToHeapify[_i];
		        if (item != null) {
		          this._data.push(item);
		        }
		      }
		      if (this._data.length > 1) {
		        for (i = _j = 2, _ref = this._data.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) {
		          this._upHeap(i);
		        }
		      }
		      this.size = this._data.length - 1;
		    }
	
		    Heap.prototype.add = function(value) {
		      /*
		      **Remember:** rejects null and undefined for mentioned reasons.
		      
		      _Returns:_ the value added.
		      */
	
		      if (value == null) {
		        return;
		      }
		      this._data.push(value);
		      this._upHeap(this._data.length - 1);
		      this.size++;
		      return value;
		    };
	
		    Heap.prototype.removeMin = function() {
		      /*
		      _Returns:_ the smallest item (the root).
		      */
	
		      var min;
		      if (this._data.length === 1) {
		        return;
		      }
		      this.size--;
		      if (this._data.length === 2) {
		        return this._data.pop();
		      }
		      min = this._data[1];
		      this._data[1] = this._data.pop();
		      this._downHeap();
		      return min;
		    };
	
		    Heap.prototype.peekMin = function() {
		      /*
		      Check the smallest item without removing it.
		      
		      _Returns:_ the smallest item (the root).
		      */
	
		      return this._data[1];
		    };
	
		    Heap.prototype._upHeap = function(index) {
		      var valueHolder, _ref;
		      valueHolder = this._data[index];
		      while (this._data[index] < this._data[_parent(index)] && index > 1) {
		        _ref = [this._data[_parent(index)], this._data[index]], this._data[index] = _ref[0], this._data[_parent(index)] = _ref[1];
		        index = _parent(index);
		      }
		    };
	
		    Heap.prototype._downHeap = function() {
		      var currentIndex, smallerChildIndex, _ref;
		      currentIndex = 1;
		      while (_leftChild(currentIndex < this._data.length)) {
		        smallerChildIndex = _leftChild(currentIndex);
		        if (smallerChildIndex < this._data.length - 1) {
		          if (this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex]) {
		            smallerChildIndex = _rightChild(currentIndex);
		          }
		        }
		        if (this._data[smallerChildIndex] < this._data[currentIndex]) {
		          _ref = [this._data[currentIndex], this._data[smallerChildIndex]], this._data[smallerChildIndex] = _ref[0], this._data[currentIndex] = _ref[1];
		          currentIndex = smallerChildIndex;
		        } else {
		          break;
		        }
		      }
		    };
	
		    return Heap;
	
		  })();
	
		  _parent = function(index) {
		    return index >> 1;
		  };
	
		  _leftChild = function(index) {
		    return index << 1;
		  };
	
		  _rightChild = function(index) {
		    return (index << 1) + 1;
		  };
	
		  module.exports = Heap;
	
		}).call(this);
	
	
	/***/ },
	/* 4 */
	/***/ function(module, exports) {
	
		/*
		Doubly Linked.
	
		## Overview example:
	
		```js
		var list = new LinkedList([5, 4, 9]);
		list.add(12); // => 12
		list.head.next.value; // => 4
		list.tail.value; // => 12
		list.at(-1); // => 12
		list.removeAt(2); // => 9
		list.remove(4); // => 4
		list.indexOf(5); // => 0
		list.add(5, 1); // => 5. Second 5 at position 1.
		list.indexOf(5, 1); // => 1
		```
	
		## Properties:
	
		- head: first item.
		- tail: last item.
		- size: total number of items.
		- item.value: value passed to the item when calling `add()`.
		- item.prev: previous item.
		- item.next: next item.
		*/
	
	
		(function() {
		  var LinkedList;
	
		  LinkedList = (function() {
		    function LinkedList(valuesToAdd) {
		      var value, _i, _len;
		      if (valuesToAdd == null) {
		        valuesToAdd = [];
		      }
		      /*
		      Can pass an array of elements to link together during `new LinkedList()`
		      initiation.
		      */
	
		      this.head = {
		        prev: void 0,
		        value: void 0,
		        next: void 0
		      };
		      this.tail = {
		        prev: void 0,
		        value: void 0,
		        next: void 0
		      };
		      this.size = 0;
		      for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
		        value = valuesToAdd[_i];
		        this.add(value);
		      }
		    }
	
		    LinkedList.prototype.at = function(position) {
		      /*
		      Get the item at `position` (optional). Accepts negative index:
		      
		      ```js
		      myList.at(-1); // Returns the last element.
		      ```
		      However, passing a negative index that surpasses the boundary will return
		      undefined:
		      
		      ```js
		      myList = new LinkedList([2, 6, 8, 3])
		      myList.at(-5); // Undefined.
		      myList.at(-4); // 2.
		      ```
		      _Returns:_ item gotten, or undefined if not found.
		      */
	
		      var currentNode, i, _i, _j, _ref;
		      if (!((-this.size <= position && position < this.size))) {
		        return;
		      }
		      position = this._adjust(position);
		      if (position * 2 < this.size) {
		        currentNode = this.head;
		        for (i = _i = 1; _i <= position; i = _i += 1) {
		          currentNode = currentNode.next;
		        }
		      } else {
		        currentNode = this.tail;
		        for (i = _j = 1, _ref = this.size - position - 1; _j <= _ref; i = _j += 1) {
		          currentNode = currentNode.prev;
		        }
		      }
		      return currentNode;
		    };
	
		    LinkedList.prototype.add = function(value, position) {
		      var currentNode, nodeToAdd, _ref, _ref1, _ref2;
		      if (position == null) {
		        position = this.size;
		      }
		      /*
		      Add a new item at `position` (optional). Defaults to adding at the end.
		      `position`, just like in `at()`, can be negative (within the negative
		      boundary). Position specifies the place the value's going to be, and the old
		      node will be pushed higher. `add(-2)` on list of size 7 is the same as
		      `add(5)`.
		      
		      _Returns:_ item added.
		      */
	
		      if (!((-this.size <= position && position <= this.size))) {
		        return;
		      }
		      nodeToAdd = {
		        value: value
		      };
		      position = this._adjust(position);
		      if (this.size === 0) {
		        this.head = nodeToAdd;
		      } else {
		        if (position === 0) {
		          _ref = [nodeToAdd, this.head, nodeToAdd], this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2];
		        } else {
		          currentNode = this.at(position - 1);
		          _ref1 = [currentNode.next, nodeToAdd, nodeToAdd, currentNode], nodeToAdd.next = _ref1[0], (_ref2 = currentNode.next) != null ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], nodeToAdd.prev = _ref1[3];
		        }
		      }
		      if (position === this.size) {
		        this.tail = nodeToAdd;
		      }
		      this.size++;
		      return value;
		    };
	
		    LinkedList.prototype.removeAt = function(position) {
		      var currentNode, valueToReturn, _ref;
		      if (position == null) {
		        position = this.size - 1;
		      }
		      /*
		      Remove an item at index `position` (optional). Defaults to the last item.
		      Index can be negative (within the boundary).
		      
		      _Returns:_ item removed.
		      */
	
		      if (!((-this.size <= position && position < this.size))) {
		        return;
		      }
		      if (this.size === 0) {
		        return;
		      }
		      position = this._adjust(position);
		      if (this.size === 1) {
		        valueToReturn = this.head.value;
		        this.head.value = this.tail.value = void 0;
		      } else {
		        if (position === 0) {
		          valueToReturn = this.head.value;
		          this.head = this.head.next;
		          this.head.prev = void 0;
		        } else {
		          currentNode = this.at(position);
		          valueToReturn = currentNode.value;
		          currentNode.prev.next = currentNode.next;
		          if ((_ref = currentNode.next) != null) {
		            _ref.prev = currentNode.prev;
		          }
		          if (position === this.size - 1) {
		            this.tail = currentNode.prev;
		          }
		        }
		      }
		      this.size--;
		      return valueToReturn;
		    };
	
		    LinkedList.prototype.remove = function(value) {
		      /*
		      Remove the item using its value instead of position. **Will remove the fist
		      occurrence of `value`.**
		      
		      _Returns:_ the value, or undefined if value's not found.
		      */
	
		      var currentNode;
		      if (value == null) {
		        return;
		      }
		      currentNode = this.head;
		      while (currentNode && currentNode.value !== value) {
		        currentNode = currentNode.next;
		      }
		      if (!currentNode) {
		        return;
		      }
		      if (this.size === 1) {
		        this.head.value = this.tail.value = void 0;
		      } else if (currentNode === this.head) {
		        this.head = this.head.next;
		        this.head.prev = void 0;
		      } else if (currentNode === this.tail) {
		        this.tail = this.tail.prev;
		        this.tail.next = void 0;
		      } else {
		        currentNode.prev.next = currentNode.next;
		        currentNode.next.prev = currentNode.prev;
		      }
		      this.size--;
		      return value;
		    };
	
		    LinkedList.prototype.indexOf = function(value, startingPosition) {
		      var currentNode, position;
		      if (startingPosition == null) {
		        startingPosition = 0;
		      }
		      /*
		      Find the index of an item, similarly to `array.indexOf()`. Defaults to start
		      searching from the beginning, by can start at another position by passing
		      `startingPosition`. This parameter can also be negative; but unlike the
		      other methods of this class, `startingPosition` (optional) can be as small
		      as desired; a value of -999 for a list of size 5 will start searching
		      normally, at the beginning.
		      
		      **Note:** searches forwardly, **not** backwardly, i.e:
		      
		      ```js
		      var myList = new LinkedList([2, 3, 1, 4, 3, 5])
		      myList.indexOf(3, -3); // Returns 4, not 1
		      ```
		      _Returns:_ index of item found, or -1 if not found.
		      */
	
		      if (((this.head.value == null) && !this.head.next) || startingPosition >= this.size) {
		        return -1;
		      }
		      startingPosition = Math.max(0, this._adjust(startingPosition));
		      currentNode = this.at(startingPosition);
		      position = startingPosition;
		      while (currentNode) {
		        if (currentNode.value === value) {
		          break;
		        }
		        currentNode = currentNode.next;
		        position++;
		      }
		      if (position === this.size) {
		        return -1;
		      } else {
		        return position;
		      }
		    };
	
		    LinkedList.prototype._adjust = function(position) {
		      if (position < 0) {
		        return this.size + position;
		      } else {
		        return position;
		      }
		    };
	
		    return LinkedList;
	
		  })();
	
		  module.exports = LinkedList;
	
		}).call(this);
	
	
	/***/ },
	/* 5 */
	/***/ function(module, exports) {
	
		/*
		Kind of a stopgap measure for the upcoming [JavaScript
		Map](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)
	
		**Note:** due to JavaScript's limitations, hashing something other than Boolean,
		Number, String, Undefined, Null, RegExp, Function requires a hack that inserts a
		hidden unique property into the object. This means `set`, `get`, `has` and
		`delete` must employ the same object, and not a mere identical copy as in the
		case of, say, a string.
	
		## Overview example:
	
		```js
		var map = new Map({'alice': 'wonderland', 20: 'ok'});
		map.set('20', 5); // => 5
		map.get('20'); // => 5
		map.has('alice'); // => true
		map.delete(20) // => true
		var arr = [1, 2];
		map.add(arr, 'goody'); // => 'goody'
		map.has(arr); // => true
		map.has([1, 2]); // => false. Needs to compare by reference
		map.forEach(function(key, value) {
		  console.log(key, value);
		});
		```
	
		## Properties:
	
		- size: The total number of `(key, value)` pairs.
		*/
	
	
		(function() {
		  var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType,
		    __hasProp = {}.hasOwnProperty;
	
		  SPECIAL_TYPE_KEY_PREFIX = '_mapId_';
	
		  Map = (function() {
		    Map._mapIdTracker = 0;
	
		    Map._newMapId = function() {
		      return this._mapIdTracker++;
		    };
	
		    function Map(objectToMap) {
		      /*
		      Pass an optional object whose (key, value) pair will be hashed. **Careful**
		      not to pass something like {5: 'hi', '5': 'hello'}, since JavaScript's
		      native object behavior will crush the first 5 property before it gets to
		      constructor.
		      */
	
		      var key, value;
		      this._content = {};
		      this._itemId = 0;
		      this._id = Map._newMapId();
		      this.size = 0;
		      for (key in objectToMap) {
		        if (!__hasProp.call(objectToMap, key)) continue;
		        value = objectToMap[key];
		        this.set(key, value);
		      }
		    }
	
		    Map.prototype.hash = function(key, makeHash) {
		      var propertyForMap, type;
		      if (makeHash == null) {
		        makeHash = false;
		      }
		      /*
		      The hash function for hashing keys is public. Feel free to replace it with
		      your own. The `makeHash` parameter is optional and accepts a boolean
		      (defaults to `false`) indicating whether or not to produce a new hash (for
		      the first use, naturally).
		      
		      _Returns:_ the hash.
		      */
	
		      type = _extractDataType(key);
		      if (_isSpecialType(key)) {
		        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
		        if (makeHash && !key[propertyForMap]) {
		          key[propertyForMap] = this._itemId++;
		        }
		        return propertyForMap + '_' + key[propertyForMap];
		      } else {
		        return type + '_' + key;
		      }
		    };
	
		    Map.prototype.set = function(key, value) {
		      /*
		      _Returns:_ value.
		      */
	
		      if (!this.has(key)) {
		        this.size++;
		      }
		      this._content[this.hash(key, true)] = [value, key];
		      return value;
		    };
	
		    Map.prototype.get = function(key) {
		      /*
		      _Returns:_ value corresponding to the key, or undefined if not found.
		      */
	
		      var _ref;
		      return (_ref = this._content[this.hash(key)]) != null ? _ref[0] : void 0;
		    };
	
		    Map.prototype.has = function(key) {
		      /*
		      Check whether a value exists for the key.
		      
		      _Returns:_ true or false.
		      */
	
		      return this.hash(key) in this._content;
		    };
	
		    Map.prototype["delete"] = function(key) {
		      /*
		      Remove the (key, value) pair.
		      
		      _Returns:_ **true or false**. Unlike most of this library, this method
		      doesn't return the deleted value. This is so that it conforms to the future
		      JavaScript `map.delete()`'s behavior.
		      */
	
		      var hashedKey;
		      hashedKey = this.hash(key);
		      if (hashedKey in this._content) {
		        delete this._content[hashedKey];
		        if (_isSpecialType(key)) {
		          delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
		        }
		        this.size--;
		        return true;
		      }
		      return false;
		    };
	
		    Map.prototype.forEach = function(operation) {
		      /*
		      Traverse through the map. Pass a function of the form `fn(key, value)`.
		      
		      _Returns:_ undefined.
		      */
	
		      var key, value, _ref;
		      _ref = this._content;
		      for (key in _ref) {
		        if (!__hasProp.call(_ref, key)) continue;
		        value = _ref[key];
		        operation(value[1], value[0]);
		      }
		    };
	
		    return Map;
	
		  })();
	
		  _isSpecialType = function(key) {
		    var simpleHashableTypes, simpleType, type, _i, _len;
		    simpleHashableTypes = ['Boolean', 'Number', 'String', 'Undefined', 'Null', 'RegExp', 'Function'];
		    type = _extractDataType(key);
		    for (_i = 0, _len = simpleHashableTypes.length; _i < _len; _i++) {
		      simpleType = simpleHashableTypes[_i];
		      if (type === simpleType) {
		        return false;
		      }
		    }
		    return true;
		  };
	
		  _extractDataType = function(type) {
		    return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
		  };
	
		  module.exports = Map;
	
		}).call(this);
	
	
	/***/ },
	/* 6 */
	/***/ function(module, exports) {
	
		/*
		Amortized O(1) dequeue!
	
		## Overview example:
	
		```js
		var queue = new Queue([1, 6, 4]);
		queue.enqueue(10); // => 10
		queue.dequeue(); // => 1
		queue.dequeue(); // => 6
		queue.dequeue(); // => 4
		queue.peek(); // => 10
		queue.dequeue(); // => 10
		queue.peek(); // => undefined
		```
	
		## Properties:
	
		- size: The total number of items.
		*/
	
	
		(function() {
		  var Queue;
	
		  Queue = (function() {
		    function Queue(initialArray) {
		      if (initialArray == null) {
		        initialArray = [];
		      }
		      /*
		      Pass an optional array to be transformed into a queue. The item at index 0
		      is the first to be dequeued.
		      */
	
		      this._content = initialArray;
		      this._dequeueIndex = 0;
		      this.size = this._content.length;
		    }
	
		    Queue.prototype.enqueue = function(item) {
		      /*
		      _Returns:_ the item.
		      */
	
		      this.size++;
		      this._content.push(item);
		      return item;
		    };
	
		    Queue.prototype.dequeue = function() {
		      /*
		      _Returns:_ the dequeued item.
		      */
	
		      var itemToDequeue;
		      if (this.size === 0) {
		        return;
		      }
		      this.size--;
		      itemToDequeue = this._content[this._dequeueIndex];
		      this._dequeueIndex++;
		      if (this._dequeueIndex * 2 > this._content.length) {
		        this._content = this._content.slice(this._dequeueIndex);
		        this._dequeueIndex = 0;
		      }
		      return itemToDequeue;
		    };
	
		    Queue.prototype.peek = function() {
		      /*
		      Check the next item to be dequeued, without removing it.
		      
		      _Returns:_ the item.
		      */
	
		      return this._content[this._dequeueIndex];
		    };
	
		    return Queue;
	
		  })();
	
		  module.exports = Queue;
	
		}).call(this);
	
	
	/***/ },
	/* 7 */
	/***/ function(module, exports) {
	
		/*
		Credit to Wikipedia's article on [Red-black
		tree](http://en.wikipedia.org/wiki/Redblack_tree)
	
		**Note:** doesn't handle duplicate entries, undefined and null. This is by
		design.
	
		## Overview example:
	
		```js
		var rbt = new RedBlackTree([7, 5, 1, 8]);
		rbt.add(2); // => 2
		rbt.add(10); // => 10
		rbt.has(5); // => true
		rbt.peekMin(); // => 1
		rbt.peekMax(); // => 10
		rbt.removeMin(); // => 1
		rbt.removeMax(); // => 10
		rbt.remove(8); // => 8
		```
	
		## Properties:
	
		- size: The total number of items.
		*/
	
	
		(function() {
		  var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
	
		  NODE_FOUND = 0;
	
		  NODE_TOO_BIG = 1;
	
		  NODE_TOO_SMALL = 2;
	
		  STOP_SEARCHING = 3;
	
		  RED = 1;
	
		  BLACK = 2;
	
		  RedBlackTree = (function() {
		    function RedBlackTree(valuesToAdd) {
		      var value, _i, _len;
		      if (valuesToAdd == null) {
		        valuesToAdd = [];
		      }
		      /*
		      Pass an optional array to be turned into binary tree. **Note:** does not
		      accept duplicate, undefined and null.
		      */
	
		      this._root;
		      this.size = 0;
		      for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
		        value = valuesToAdd[_i];
		        if (value != null) {
		          this.add(value);
		        }
		      }
		    }
	
		    RedBlackTree.prototype.add = function(value) {
		      /*
		      Again, make sure to not pass a value already in the tree, or undefined, or
		      null.
		      
		      _Returns:_ value added.
		      */
	
		      var currentNode, foundNode, nodeToInsert, _ref;
		      if (value == null) {
		        return;
		      }
		      this.size++;
		      nodeToInsert = {
		        value: value,
		        _color: RED
		      };
		      if (!this._root) {
		        this._root = nodeToInsert;
		      } else {
		        foundNode = _findNode(this._root, function(node) {
		          if (value === node.value) {
		            return NODE_FOUND;
		          } else {
		            if (value < node.value) {
		              if (node._left) {
		                return NODE_TOO_BIG;
		              } else {
		                nodeToInsert._parent = node;
		                node._left = nodeToInsert;
		                return STOP_SEARCHING;
		              }
		            } else {
		              if (node._right) {
		                return NODE_TOO_SMALL;
		              } else {
		                nodeToInsert._parent = node;
		                node._right = nodeToInsert;
		                return STOP_SEARCHING;
		              }
		            }
		          }
		        });
		        if (foundNode != null) {
		          return;
		        }
		      }
		      currentNode = nodeToInsert;
		      while (true) {
		        if (currentNode === this._root) {
		          currentNode._color = BLACK;
		          break;
		        }
		        if (currentNode._parent._color === BLACK) {
		          break;
		        }
		        if (((_ref = _uncleOf(currentNode)) != null ? _ref._color : void 0) === RED) {
		          currentNode._parent._color = BLACK;
		          _uncleOf(currentNode)._color = BLACK;
		          _grandParentOf(currentNode)._color = RED;
		          currentNode = _grandParentOf(currentNode);
		          continue;
		        }
		        if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
		          this._rotateLeft(currentNode._parent);
		          currentNode = currentNode._left;
		        } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
		          this._rotateRight(currentNode._parent);
		          currentNode = currentNode._right;
		        }
		        currentNode._parent._color = BLACK;
		        _grandParentOf(currentNode)._color = RED;
		        if (_isLeft(currentNode)) {
		          this._rotateRight(_grandParentOf(currentNode));
		        } else {
		          this._rotateLeft(_grandParentOf(currentNode));
		        }
		        break;
		      }
		      return value;
		    };
	
		    RedBlackTree.prototype.has = function(value) {
		      /*
		      _Returns:_ true or false.
		      */
	
		      var foundNode;
		      foundNode = _findNode(this._root, function(node) {
		        if (value === node.value) {
		          return NODE_FOUND;
		        } else if (value < node.value) {
		          return NODE_TOO_BIG;
		        } else {
		          return NODE_TOO_SMALL;
		        }
		      });
		      if (foundNode) {
		        return true;
		      } else {
		        return false;
		      }
		    };
	
		    RedBlackTree.prototype.peekMin = function() {
		      /*
		      Check the minimum value without removing it.
		      
		      _Returns:_ the minimum value.
		      */
	
		      var _ref;
		      return (_ref = _peekMinNode(this._root)) != null ? _ref.value : void 0;
		    };
	
		    RedBlackTree.prototype.peekMax = function() {
		      /*
		      Check the maximum value without removing it.
		      
		      _Returns:_ the maximum value.
		      */
	
		      var _ref;
		      return (_ref = _peekMaxNode(this._root)) != null ? _ref.value : void 0;
		    };
	
		    RedBlackTree.prototype.remove = function(value) {
		      /*
		      _Returns:_ the value removed, or undefined if the value's not found.
		      */
	
		      var foundNode;
		      foundNode = _findNode(this._root, function(node) {
		        if (value === node.value) {
		          return NODE_FOUND;
		        } else if (value < node.value) {
		          return NODE_TOO_BIG;
		        } else {
		          return NODE_TOO_SMALL;
		        }
		      });
		      if (!foundNode) {
		        return;
		      }
		      this._removeNode(this._root, foundNode);
		      this.size--;
		      return value;
		    };
	
		    RedBlackTree.prototype.removeMin = function() {
		      /*
		      _Returns:_ smallest item removed, or undefined if tree's empty.
		      */
	
		      var nodeToRemove, valueToReturn;
		      nodeToRemove = _peekMinNode(this._root);
		      if (!nodeToRemove) {
		        return;
		      }
		      valueToReturn = nodeToRemove.value;
		      this._removeNode(this._root, nodeToRemove);
		      return valueToReturn;
		    };
	
		    RedBlackTree.prototype.removeMax = function() {
		      /*
		      _Returns:_ biggest item removed, or undefined if tree's empty.
		      */
	
		      var nodeToRemove, valueToReturn;
		      nodeToRemove = _peekMaxNode(this._root);
		      if (!nodeToRemove) {
		        return;
		      }
		      valueToReturn = nodeToRemove.value;
		      this._removeNode(this._root, nodeToRemove);
		      return valueToReturn;
		    };
	
		    RedBlackTree.prototype._removeNode = function(root, node) {
		      var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
		      if (node._left && node._right) {
		        successor = _peekMinNode(node._right);
		        node.value = successor.value;
		        node = successor;
		      }
		      successor = node._left || node._right;
		      if (!successor) {
		        successor = {
		          color: BLACK,
		          _right: void 0,
		          _left: void 0,
		          isLeaf: true
		        };
		      }
		      successor._parent = node._parent;
		      if ((_ref = node._parent) != null) {
		        _ref[_leftOrRight(node)] = successor;
		      }
		      if (node._color === BLACK) {
		        if (successor._color === RED) {
		          successor._color = BLACK;
		          if (!successor._parent) {
		            this._root = successor;
		          }
		        } else {
		          while (true) {
		            if (!successor._parent) {
		              if (!successor.isLeaf) {
		                this._root = successor;
		              } else {
		                this._root = void 0;
		              }
		              break;
		            }
		            sibling = _siblingOf(successor);
		            if ((sibling != null ? sibling._color : void 0) === RED) {
		              successor._parent._color = RED;
		              sibling._color = BLACK;
		              if (_isLeft(successor)) {
		                this._rotateLeft(successor._parent);
		              } else {
		                this._rotateRight(successor._parent);
		              }
		            }
		            sibling = _siblingOf(successor);
		            if (successor._parent._color === BLACK && (!sibling || (sibling._color === BLACK && (!sibling._left || sibling._left._color === BLACK) && (!sibling._right || sibling._right._color === BLACK)))) {
		              if (sibling != null) {
		                sibling._color = RED;
		              }
		              if (successor.isLeaf) {
		                successor._parent[_leftOrRight(successor)] = void 0;
		              }
		              successor = successor._parent;
		              continue;
		            }
		            if (successor._parent._color === RED && (!sibling || (sibling._color === BLACK && (!sibling._left || ((_ref1 = sibling._left) != null ? _ref1._color : void 0) === BLACK) && (!sibling._right || ((_ref2 = sibling._right) != null ? _ref2._color : void 0) === BLACK)))) {
		              if (sibling != null) {
		                sibling._color = RED;
		              }
		              successor._parent._color = BLACK;
		              break;
		            }
		            if ((sibling != null ? sibling._color : void 0) === BLACK) {
		              if (_isLeft(successor) && (!sibling._right || sibling._right._color === BLACK) && ((_ref3 = sibling._left) != null ? _ref3._color : void 0) === RED) {
		                sibling._color = RED;
		                if ((_ref4 = sibling._left) != null) {
		                  _ref4._color = BLACK;
		                }
		                this._rotateRight(sibling);
		              } else if (!_isLeft(successor) && (!sibling._left || sibling._left._color === BLACK) && ((_ref5 = sibling._right) != null ? _ref5._color : void 0) === RED) {
		                sibling._color = RED;
		                if ((_ref6 = sibling._right) != null) {
		                  _ref6._color = BLACK;
		                }
		                this._rotateLeft(sibling);
		              }
		              break;
		            }
		            sibling = _siblingOf(successor);
		            sibling._color = successor._parent._color;
		            if (_isLeft(successor)) {
		              sibling._right._color = BLACK;
		              this._rotateRight(successor._parent);
		            } else {
		              sibling._left._color = BLACK;
		              this._rotateLeft(successor._parent);
		            }
		          }
		        }
		      }
		      if (successor.isLeaf) {
		        return (_ref7 = successor._parent) != null ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
		      }
		    };
	
		    RedBlackTree.prototype._rotateLeft = function(node) {
		      var _ref, _ref1;
		      if ((_ref = node._parent) != null) {
		        _ref[_leftOrRight(node)] = node._right;
		      }
		      node._right._parent = node._parent;
		      node._parent = node._right;
		      node._right = node._right._left;
		      node._parent._left = node;
		      if ((_ref1 = node._right) != null) {
		        _ref1._parent = node;
		      }
		      if (node._parent._parent == null) {
		        return this._root = node._parent;
		      }
		    };
	
		    RedBlackTree.prototype._rotateRight = function(node) {
		      var _ref, _ref1;
		      if ((_ref = node._parent) != null) {
		        _ref[_leftOrRight(node)] = node._left;
		      }
		      node._left._parent = node._parent;
		      node._parent = node._left;
		      node._left = node._left._right;
		      node._parent._right = node;
		      if ((_ref1 = node._left) != null) {
		        _ref1._parent = node;
		      }
		      if (node._parent._parent == null) {
		        return this._root = node._parent;
		      }
		    };
	
		    return RedBlackTree;
	
		  })();
	
		  _isLeft = function(node) {
		    return node === node._parent._left;
		  };
	
		  _leftOrRight = function(node) {
		    if (_isLeft(node)) {
		      return '_left';
		    } else {
		      return '_right';
		    }
		  };
	
		  _findNode = function(startingNode, comparator) {
		    var comparisonResult, currentNode, foundNode;
		    currentNode = startingNode;
		    foundNode = void 0;
		    while (currentNode) {
		      comparisonResult = comparator(currentNode);
		      if (comparisonResult === NODE_FOUND) {
		        foundNode = currentNode;
		        break;
		      }
		      if (comparisonResult === NODE_TOO_BIG) {
		        currentNode = currentNode._left;
		      } else if (comparisonResult === NODE_TOO_SMALL) {
		        currentNode = currentNode._right;
		      } else if (comparisonResult === STOP_SEARCHING) {
		        break;
		      }
		    }
		    return foundNode;
		  };
	
		  _peekMinNode = function(startingNode) {
		    return _findNode(startingNode, function(node) {
		      if (node._left) {
		        return NODE_TOO_BIG;
		      } else {
		        return NODE_FOUND;
		      }
		    });
		  };
	
		  _peekMaxNode = function(startingNode) {
		    return _findNode(startingNode, function(node) {
		      if (node._right) {
		        return NODE_TOO_SMALL;
		      } else {
		        return NODE_FOUND;
		      }
		    });
		  };
	
		  _grandParentOf = function(node) {
		    var _ref;
		    return (_ref = node._parent) != null ? _ref._parent : void 0;
		  };
	
		  _uncleOf = function(node) {
		    if (!_grandParentOf(node)) {
		      return;
		    }
		    if (_isLeft(node._parent)) {
		      return _grandParentOf(node)._right;
		    } else {
		      return _grandParentOf(node)._left;
		    }
		  };
	
		  _siblingOf = function(node) {
		    if (_isLeft(node)) {
		      return node._parent._right;
		    } else {
		      return node._parent._left;
		    }
		  };
	
		  module.exports = RedBlackTree;
	
		}).call(this);
	
	
	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {
	
		/*
		Good for fast insertion/removal/lookup of strings.
	
		## Overview example:
	
		```js
		var trie = new Trie(['bear', 'beer']);
		trie.add('hello'); // => 'hello'
		trie.add('helloha!'); // => 'helloha!'
		trie.has('bears'); // => false
		trie.longestPrefixOf('beatrice'); // => 'bea'
		trie.wordsWithPrefix('hel'); // => ['hello', 'helloha!']
		trie.remove('beers'); // => undefined. 'beer' still exists
		trie.remove('Beer') // => undefined. Case-sensitive
		trie.remove('beer') // => 'beer'. Removed
		```
	
		## Properties:
	
		- size: The total number of words.
		*/
	
	
		(function() {
		  var Queue, Trie, WORD_END, _hasAtLeastNChildren,
		    __hasProp = {}.hasOwnProperty;
	
		  Queue = __webpack_require__(6);
	
		  WORD_END = 'end';
	
		  Trie = (function() {
		    function Trie(words) {
		      var word, _i, _len;
		      if (words == null) {
		        words = [];
		      }
		      /*
		      Pass an optional array of strings to be inserted initially.
		      */
	
		      this._root = {};
		      this.size = 0;
		      for (_i = 0, _len = words.length; _i < _len; _i++) {
		        word = words[_i];
		        this.add(word);
		      }
		    }
	
		    Trie.prototype.add = function(word) {
		      /*
		      Add a whole string to the trie.
		      
		      _Returns:_ the word added. Will return undefined (without adding the value)
		      if the word passed is null or undefined.
		      */
	
		      var currentNode, letter, _i, _len;
		      if (word == null) {
		        return;
		      }
		      this.size++;
		      currentNode = this._root;
		      for (_i = 0, _len = word.length; _i < _len; _i++) {
		        letter = word[_i];
		        if (currentNode[letter] == null) {
		          currentNode[letter] = {};
		        }
		        currentNode = currentNode[letter];
		      }
		      currentNode[WORD_END] = true;
		      return word;
		    };
	
		    Trie.prototype.has = function(word) {
		      /*
		      __Returns:_ true or false.
		      */
	
		      var currentNode, letter, _i, _len;
		      if (word == null) {
		        return false;
		      }
		      currentNode = this._root;
		      for (_i = 0, _len = word.length; _i < _len; _i++) {
		        letter = word[_i];
		        if (currentNode[letter] == null) {
		          return false;
		        }
		        currentNode = currentNode[letter];
		      }
		      if (currentNode[WORD_END]) {
		        return true;
		      } else {
		        return false;
		      }
		    };
	
		    Trie.prototype.longestPrefixOf = function(word) {
		      /*
		      Find all words containing the prefix. The word itself counts as a prefix.
		      
		      ```js
		      var trie = new Trie;
		      trie.add('hello');
		      trie.longestPrefixOf('he'); // 'he'
		      trie.longestPrefixOf('hello'); // 'hello'
		      trie.longestPrefixOf('helloha!'); // 'hello'
		      ```
		      
		      _Returns:_ the prefix string, or empty string if no prefix found.
		      */
	
		      var currentNode, letter, prefix, _i, _len;
		      if (word == null) {
		        return '';
		      }
		      currentNode = this._root;
		      prefix = '';
		      for (_i = 0, _len = word.length; _i < _len; _i++) {
		        letter = word[_i];
		        if (currentNode[letter] == null) {
		          break;
		        }
		        prefix += letter;
		        currentNode = currentNode[letter];
		      }
		      return prefix;
		    };
	
		    Trie.prototype.wordsWithPrefix = function(prefix) {
		      /*
		      Find all words containing the prefix. The word itself counts as a prefix.
		      **Watch out for edge cases.**
		      
		      ```js
		      var trie = new Trie;
		      trie.wordsWithPrefix(''); // []. Check later case below.
		      trie.add('');
		      trie.wordsWithPrefix(''); // ['']
		      trie.add('he');
		      trie.add('hello');
		      trie.add('hell');
		      trie.add('bear');
		      trie.add('z');
		      trie.add('zebra');
		      trie.wordsWithPrefix('hel'); // ['hell', 'hello']
		      ```
		      
		      _Returns:_ an array of strings, or empty array if no word found.
		      */
	
		      var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
		      if (prefix == null) {
		        return [];
		      }
		      (prefix != null) || (prefix = '');
		      words = [];
		      currentNode = this._root;
		      for (_i = 0, _len = prefix.length; _i < _len; _i++) {
		        letter = prefix[_i];
		        currentNode = currentNode[letter];
		        if (currentNode == null) {
		          return [];
		        }
		      }
		      queue = new Queue();
		      queue.enqueue([currentNode, '']);
		      while (queue.size !== 0) {
		        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
		        if (node[WORD_END]) {
		          words.push(prefix + accumulatedLetters);
		        }
		        for (letter in node) {
		          if (!__hasProp.call(node, letter)) continue;
		          subNode = node[letter];
		          queue.enqueue([subNode, accumulatedLetters + letter]);
		        }
		      }
		      return words;
		    };
	
		    Trie.prototype.remove = function(word) {
		      /*
		      _Returns:_ the string removed, or undefined if the word in its whole doesn't
		      exist. **Note:** this means removing `beers` when only `beer` exists will
		      return undefined and conserve `beer`.
		      */
	
		      var currentNode, i, letter, prefix, _i, _j, _len, _ref;
		      if (word == null) {
		        return;
		      }
		      currentNode = this._root;
		      prefix = [];
		      for (_i = 0, _len = word.length; _i < _len; _i++) {
		        letter = word[_i];
		        if (currentNode[letter] == null) {
		          return;
		        }
		        currentNode = currentNode[letter];
		        prefix.push([letter, currentNode]);
		      }
		      if (!currentNode[WORD_END]) {
		        return;
		      }
		      this.size--;
		      delete currentNode[WORD_END];
		      if (_hasAtLeastNChildren(currentNode, 1)) {
		        return word;
		      }
		      for (i = _j = _ref = prefix.length - 1; _ref <= 1 ? _j <= 1 : _j >= 1; i = _ref <= 1 ? ++_j : --_j) {
		        if (!_hasAtLeastNChildren(prefix[i][1], 1)) {
		          delete prefix[i - 1][1][prefix[i][0]];
		        } else {
		          break;
		        }
		      }
		      if (!_hasAtLeastNChildren(this._root[prefix[0][0]], 1)) {
		        delete this._root[prefix[0][0]];
		      }
		      return word;
		    };
	
		    return Trie;
	
		  })();
	
		  _hasAtLeastNChildren = function(node, n) {
		    var child, childCount;
		    if (n === 0) {
		      return true;
		    }
		    childCount = 0;
		    for (child in node) {
		      if (!__hasProp.call(node, child)) continue;
		      childCount++;
		      if (childCount >= n) {
		        return true;
		      }
		    }
		    return false;
		  };
	
		  module.exports = Trie;
	
		}).call(this);
	
	
	/***/ }
	/******/ ]);;angular.module('uiGmapgoogle-maps.wrapped')
	.service('uiGmapMarkerSpiderfier', [ 'uiGmapGoogleMapApi', function(GoogleMapApi) {
	  var self = this;
	  /* istanbul ignore next */
	  +function(){
	    
	/** @preserve OverlappingMarkerSpiderfier
	https://github.com/jawj/OverlappingMarkerSpiderfier
	Copyright (c) 2011 - 2013 George MacKerron
	Released under the MIT licence: http://opensource.org/licenses/mit-license
	Note: The Google Maps API v3 must be included *before* this code
	 */
	var hasProp = {}.hasOwnProperty,
	  slice = [].slice;
	
	this['OverlappingMarkerSpiderfier'] = (function() {
	  var ge, gm, j, lcH, lcU, len, mt, p, ref, twoPi, x;
	
	  p = _Class.prototype;
	
	  ref = [_Class, p];
	  for (j = 0, len = ref.length; j < len; j++) {
	    x = ref[j];
	    x['VERSION'] = '0.3.3';
	  }
	
	  gm = void 0;
	
	  ge = void 0;
	
	  mt = void 0;
	
	  twoPi = Math.PI * 2;
	
	  p['keepSpiderfied'] = false;
	
	  p['markersWontHide'] = false;
	
	  p['markersWontMove'] = false;
	
	  p['nearbyDistance'] = 20;
	
	  p['circleSpiralSwitchover'] = 9;
	
	  p['circleFootSeparation'] = 23;
	
	  p['circleStartAngle'] = twoPi / 12;
	
	  p['spiralFootSeparation'] = 26;
	
	  p['spiralLengthStart'] = 11;
	
	  p['spiralLengthFactor'] = 4;
	
	  p['spiderfiedZIndex'] = 1000;
	
	  p['usualLegZIndex'] = 10;
	
	  p['highlightedLegZIndex'] = 20;
	
	  p['event'] = 'click';
	
	  p['minZoomLevel'] = false;
	
	  p['legWeight'] = 1.5;
	
	  p['legColors'] = {
	    'usual': {},
	    'highlighted': {}
	  };
	
	  lcU = p['legColors']['usual'];
	
	  lcH = p['legColors']['highlighted'];
	
	  _Class['initializeGoogleMaps'] = function(google) {
	    gm = google.maps;
	    ge = gm.event;
	    mt = gm.MapTypeId;
	    lcU[mt.HYBRID] = lcU[mt.SATELLITE] = '#fff';
	    lcH[mt.HYBRID] = lcH[mt.SATELLITE] = '#f00';
	    lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = '#444';
	    lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = '#f00';
	    this.ProjHelper = function(map) {
	      return this.setMap(map);
	    };
	    this.ProjHelper.prototype = new gm.OverlayView();
	    return this.ProjHelper.prototype['draw'] = function() {};
	  };
	
	  function _Class(map1, opts) {
	    var e, k, l, len1, ref1, v;
	    this.map = map1;
	    if (opts == null) {
	      opts = {};
	    }
	    for (k in opts) {
	      if (!hasProp.call(opts, k)) continue;
	      v = opts[k];
	      this[k] = v;
	    }
	    this.projHelper = new this.constructor.ProjHelper(this.map);
	    this.initMarkerArrays();
	    this.listeners = {};
	    ref1 = ['click', 'zoom_changed', 'maptypeid_changed'];
	    for (l = 0, len1 = ref1.length; l < len1; l++) {
	      e = ref1[l];
	      ge.addListener(this.map, e, (function(_this) {
	        return function() {
	          return _this['unspiderfy']();
	        };
	      })(this));
	    }
	  }
	
	  p.initMarkerArrays = function() {
	    this.markers = [];
	    return this.markerListenerRefs = [];
	  };
	
	  p['addMarker'] = function(marker) {
	    var listenerRefs;
	    if (marker['_oms'] != null) {
	      return this;
	    }
	    marker['_oms'] = true;
	    listenerRefs = [
	      ge.addListener(marker, this['event'], (function(_this) {
	        return function(event) {
	          return _this.spiderListener(marker, event);
	        };
	      })(this))
	    ];
	    if (!this['markersWontHide']) {
	      listenerRefs.push(ge.addListener(marker, 'visible_changed', (function(_this) {
	        return function() {
	          return _this.markerChangeListener(marker, false);
	        };
	      })(this)));
	    }
	    if (!this['markersWontMove']) {
	      listenerRefs.push(ge.addListener(marker, 'position_changed', (function(_this) {
	        return function() {
	          return _this.markerChangeListener(marker, true);
	        };
	      })(this)));
	    }
	    this.markerListenerRefs.push(listenerRefs);
	    this.markers.push(marker);
	    return this;
	  };
	
	  p.markerChangeListener = function(marker, positionChanged) {
	    if ((marker['_omsData'] != null) && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {
	      return this['unspiderfy'](positionChanged ? marker : null);
	    }
	  };
	
	  p['getMarkers'] = function() {
	    return this.markers.slice(0);
	  };
	
	  p['removeMarker'] = function(marker) {
	    var i, l, len1, listenerRef, listenerRefs;
	    if (marker['_omsData'] != null) {
	      this['unspiderfy']();
	    }
	    i = this.arrIndexOf(this.markers, marker);
	    if (i < 0) {
	      return this;
	    }
	    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
	    for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
	      listenerRef = listenerRefs[l];
	      ge.removeListener(listenerRef);
	    }
	    delete marker['_oms'];
	    this.markers.splice(i, 1);
	    return this;
	  };
	
	  p['clearMarkers'] = function() {
	    var i, l, len1, len2, listenerRef, listenerRefs, marker, n, ref1;
	    this['unspiderfy']();
	    ref1 = this.markers;
	    for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
	      marker = ref1[i];
	      listenerRefs = this.markerListenerRefs[i];
	      for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
	        listenerRef = listenerRefs[n];
	        ge.removeListener(listenerRef);
	      }
	      delete marker['_oms'];
	    }
	    this.initMarkerArrays();
	    return this;
	  };
	
	  p['addListener'] = function(event, func) {
	    var base;
	    ((base = this.listeners)[event] != null ? base[event] : base[event] = []).push(func);
	    return this;
	  };
	
	  p['removeListener'] = function(event, func) {
	    var i;
	    i = this.arrIndexOf(this.listeners[event], func);
	    if (!(i < 0)) {
	      this.listeners[event].splice(i, 1);
	    }
	    return this;
	  };
	
	  p['clearListeners'] = function(event) {
	    this.listeners[event] = [];
	    return this;
	  };
	
	  p.trigger = function() {
	    var args, event, func, l, len1, ref1, ref2, results;
	    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
	    ref2 = (ref1 = this.listeners[event]) != null ? ref1 : [];
	    results = [];
	    for (l = 0, len1 = ref2.length; l < len1; l++) {
	      func = ref2[l];
	      results.push(func.apply(null, args));
	    }
	    return results;
	  };
	
	  p.generatePtsCircle = function(count, centerPt) {
	    var angle, angleStep, circumference, i, l, legLength, ref1, results;
	    circumference = this['circleFootSeparation'] * (2 + count);
	    legLength = circumference / twoPi;
	    angleStep = twoPi / count;
	    results = [];
	    for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
	      angle = this['circleStartAngle'] + i * angleStep;
	      results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
	    }
	    return results;
	  };
	
	  p.generatePtsSpiral = function(count, centerPt) {
	    var angle, i, l, legLength, pt, ref1, results;
	    legLength = this['spiralLengthStart'];
	    angle = 0;
	    results = [];
	    for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
	      angle += this['spiralFootSeparation'] / legLength + i * 0.0005;
	      pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
	      legLength += twoPi * this['spiralLengthFactor'] / angle;
	      results.push(pt);
	    }
	    return results;
	  };
	
	  p.spiderListener = function(marker, event) {
	    var $this, clear, l, len1, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref1;
	    markerSpiderfied = marker['_omsData'] != null;
	    if (!(markerSpiderfied && this['keepSpiderfied'])) {
	      if (this['event'] === 'mouseover') {
	        $this = this;
	        clear = function() {
	          return $this['unspiderfy']();
	        };
	        window.clearTimeout(p.timeout);
	        p.timeout = setTimeout(clear, 3000);
	      } else {
	        this['unspiderfy']();
	      }
	    }
	    if (markerSpiderfied || this.map.getStreetView().getVisible() || this.map.getMapTypeId() === 'GoogleEarthAPI') {
	      return this.trigger('click', marker, event);
	    } else {
	      nearbyMarkerData = [];
	      nonNearbyMarkers = [];
	      nDist = this['nearbyDistance'];
	      pxSq = nDist * nDist;
	      markerPt = this.llToPt(marker.position);
	      ref1 = this.markers;
	      for (l = 0, len1 = ref1.length; l < len1; l++) {
	        m = ref1[l];
	        if (!((m.map != null) && m.getVisible())) {
	          continue;
	        }
	        mPt = this.llToPt(m.position);
	        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
	          nearbyMarkerData.push({
	            marker: m,
	            markerPt: mPt
	          });
	        } else {
	          nonNearbyMarkers.push(m);
	        }
	      }
	      if (nearbyMarkerData.length === 1) {
	        return this.trigger('click', marker, event);
	      } else {
	        return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
	      }
	    }
	  };
	
	  p['markersNearMarker'] = function(marker, firstOnly) {
	    var l, len1, m, mPt, markerPt, markers, nDist, pxSq, ref1, ref2, ref3;
	    if (firstOnly == null) {
	      firstOnly = false;
	    }
	    if (this.projHelper.getProjection() == null) {
	      throw "Must wait for 'idle' event on map before calling markersNearMarker";
	    }
	    nDist = this['nearbyDistance'];
	    pxSq = nDist * nDist;
	    markerPt = this.llToPt(marker.position);
	    markers = [];
	    ref1 = this.markers;
	    for (l = 0, len1 = ref1.length; l < len1; l++) {
	      m = ref1[l];
	      if (m === marker || (m.map == null) || !m.getVisible()) {
	        continue;
	      }
	      mPt = this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position);
	      if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
	        markers.push(m);
	        if (firstOnly) {
	          break;
	        }
	      }
	    }
	    return markers;
	  };
	
	  p['markersNearAnyOtherMarker'] = function() {
	    var i, i1, i2, l, len1, len2, len3, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, q, ref1, ref2, ref3, results;
	    if (this.projHelper.getProjection() == null) {
	      throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
	    }
	    nDist = this['nearbyDistance'];
	    pxSq = nDist * nDist;
	    mData = (function() {
	      var l, len1, ref1, ref2, ref3, results;
	      ref1 = this.markers;
	      results = [];
	      for (l = 0, len1 = ref1.length; l < len1; l++) {
	        m = ref1[l];
	        results.push({
	          pt: this.llToPt((ref2 = (ref3 = m['_omsData']) != null ? ref3.usualPosition : void 0) != null ? ref2 : m.position),
	          willSpiderfy: false
	        });
	      }
	      return results;
	    }).call(this);
	    ref1 = this.markers;
	    for (i1 = l = 0, len1 = ref1.length; l < len1; i1 = ++l) {
	      m1 = ref1[i1];
	      if (!((m1.map != null) && m1.getVisible())) {
	        continue;
	      }
	      m1Data = mData[i1];
	      if (m1Data.willSpiderfy) {
	        continue;
	      }
	      ref2 = this.markers;
	      for (i2 = n = 0, len2 = ref2.length; n < len2; i2 = ++n) {
	        m2 = ref2[i2];
	        if (i2 === i1) {
	          continue;
	        }
	        if (!((m2.map != null) && m2.getVisible())) {
	          continue;
	        }
	        m2Data = mData[i2];
	        if (i2 < i1 && !m2Data.willSpiderfy) {
	          continue;
	        }
	        if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
	          m1Data.willSpiderfy = m2Data.willSpiderfy = true;
	          break;
	        }
	      }
	    }
	    ref3 = this.markers;
	    results = [];
	    for (i = q = 0, len3 = ref3.length; q < len3; i = ++q) {
	      m = ref3[i];
	      if (mData[i].willSpiderfy) {
	        results.push(m);
	      }
	    }
	    return results;
	  };
	
	  p.makeHighlightListenerFuncs = function(marker) {
	    return {
	      highlight: (function(_this) {
	        return function() {
	          return marker['_omsData'].leg.setOptions({
	            strokeColor: _this['legColors']['highlighted'][_this.map.mapTypeId],
	            zIndex: _this['highlightedLegZIndex']
	          });
	        };
	      })(this),
	      unhighlight: (function(_this) {
	        return function() {
	          return marker['_omsData'].leg.setOptions({
	            strokeColor: _this['legColors']['usual'][_this.map.mapTypeId],
	            zIndex: _this['usualLegZIndex']
	          });
	        };
	      })(this)
	    };
	  };
	
	  p.spiderfy = function(markerData, nonNearbyMarkers) {
	    var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;
	    if (this['minZoomLevel'] && this.map.getZoom() < this['minZoomLevel']) {
	      return false;
	    }
	    this.spiderfying = true;
	    numFeet = markerData.length;
	    bodyPt = this.ptAverage((function() {
	      var l, len1, results;
	      results = [];
	      for (l = 0, len1 = markerData.length; l < len1; l++) {
	        md = markerData[l];
	        results.push(md.markerPt);
	      }
	      return results;
	    })());
	    footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
	    spiderfiedMarkers = (function() {
	      var l, len1, results;
	      results = [];
	      for (l = 0, len1 = footPts.length; l < len1; l++) {
	        footPt = footPts[l];
	        footLl = this.ptToLl(footPt);
	        nearestMarkerDatum = this.minExtract(markerData, (function(_this) {
	          return function(md) {
	            return _this.ptDistanceSq(md.markerPt, footPt);
	          };
	        })(this));
	        marker = nearestMarkerDatum.marker;
	        leg = new gm.Polyline({
	          map: this.map,
	          path: [marker.position, footLl],
	          strokeColor: this['legColors']['usual'][this.map.mapTypeId],
	          strokeWeight: this['legWeight'],
	          zIndex: this['usualLegZIndex']
	        });
	        marker['_omsData'] = {
	          usualPosition: marker.position,
	          leg: leg
	        };
	        if (this['legColors']['highlighted'][this.map.mapTypeId] !== this['legColors']['usual'][this.map.mapTypeId]) {
	          highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
	          marker['_omsData'].hightlightListeners = {
	            highlight: ge.addListener(marker, 'mouseover', highlightListenerFuncs.highlight),
	            unhighlight: ge.addListener(marker, 'mouseout', highlightListenerFuncs.unhighlight)
	          };
	        }
	        marker.setPosition(footLl);
	        marker.setZIndex(Math.round(this['spiderfiedZIndex'] + footPt.y));
	        results.push(marker);
	      }
	      return results;
	    }).call(this);
	    delete this.spiderfying;
	    this.spiderfied = true;
	    return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);
	  };
	
	  p['unspiderfy'] = function(markerNotToMove) {
	    var l, len1, listeners, marker, nonNearbyMarkers, ref1, unspiderfiedMarkers;
	    if (markerNotToMove == null) {
	      markerNotToMove = null;
	    }
	    if (this.spiderfied == null) {
	      return this;
	    }
	    this.unspiderfying = true;
	    unspiderfiedMarkers = [];
	    nonNearbyMarkers = [];
	    ref1 = this.markers;
	    for (l = 0, len1 = ref1.length; l < len1; l++) {
	      marker = ref1[l];
	      if (marker['_omsData'] != null) {
	        marker['_omsData'].leg.setMap(null);
	        if (marker !== markerNotToMove) {
	          marker.setPosition(marker['_omsData'].usualPosition);
	        }
	        marker.setZIndex(null);
	        listeners = marker['_omsData'].hightlightListeners;
	        if (listeners != null) {
	          ge.removeListener(listeners.highlight);
	          ge.removeListener(listeners.unhighlight);
	        }
	        delete marker['_omsData'];
	        unspiderfiedMarkers.push(marker);
	      } else {
	        nonNearbyMarkers.push(marker);
	      }
	    }
	    delete this.unspiderfying;
	    delete this.spiderfied;
	    this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);
	    return this;
	  };
	
	  p.ptDistanceSq = function(pt1, pt2) {
	    var dx, dy;
	    dx = pt1.x - pt2.x;
	    dy = pt1.y - pt2.y;
	    return dx * dx + dy * dy;
	  };
	
	  p.ptAverage = function(pts) {
	    var l, len1, numPts, pt, sumX, sumY;
	    sumX = sumY = 0;
	    for (l = 0, len1 = pts.length; l < len1; l++) {
	      pt = pts[l];
	      sumX += pt.x;
	      sumY += pt.y;
	    }
	    numPts = pts.length;
	    return new gm.Point(sumX / numPts, sumY / numPts);
	  };
	
	  p.llToPt = function(ll) {
	    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
	  };
	
	  p.ptToLl = function(pt) {
	    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
	  };
	
	  p.minExtract = function(set, func) {
	    var bestIndex, bestVal, index, item, l, len1, val;
	    for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
	      item = set[index];
	      val = func(item);
	      if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
	        bestVal = val;
	        bestIndex = index;
	      }
	    }
	    return set.splice(bestIndex, 1)[0];
	  };
	
	  p.arrIndexOf = function(arr, obj) {
	    var i, l, len1, o;
	    if (arr.indexOf != null) {
	      return arr.indexOf(obj);
	    }
	    for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
	      o = arr[i];
	      if (o === obj) {
	        return i;
	      }
	    }
	    return -1;
	  };
	
	  return _Class;
	
	})();
	
	  }.apply(self);
	
	  GoogleMapApi.then(function(){
	    self.OverlappingMarkerSpiderfier.initializeGoogleMaps(window.google);
	  });
	  return this.OverlappingMarkerSpiderfier;
	}]);
	;/**
	 * Performance overrides on MarkerClusterer custom to Angular Google Maps
	 *
	 * Created by Petr Bruna ccg1415 and Nick McCready on 7/13/14.
	 */
	angular.module('uiGmapgoogle-maps.extensions')
	.service('uiGmapExtendMarkerClusterer',['uiGmapLodash', 'uiGmapPropMap', function (uiGmapLodash, PropMap) {
	  return {
	    init: _.once(function () {
	      (function () {
	        var __hasProp = {}.hasOwnProperty,
	          __extends = function (child, parent) {
	            for (var key in parent) {
	              if (__hasProp.call(parent, key)) child[key] = parent[key];
	            }
	            function ctor() {
	              this.constructor = child;
	            }
	
	            ctor.prototype = parent.prototype;
	            child.prototype = new ctor();
	            child.__super__ = parent.prototype;
	            return child;
	          };
	
	        window.NgMapCluster = (function (_super) {
	          __extends(NgMapCluster, _super);
	
	          function NgMapCluster(opts) {
	            NgMapCluster.__super__.constructor.call(this, opts);
	            this.markers_ = new PropMap();
	          }
	
	          /**
	           * Adds a marker to the cluster.
	           *
	           * @param {google.maps.Marker} marker The marker to be added.
	           * @return {boolean} True if the marker was added.
	           * @ignore
	           */
	          NgMapCluster.prototype.addMarker = function (marker) {
	            var i;
	            var mCount;
	            var mz;
	
	            if (this.isMarkerAlreadyAdded_(marker)) {
	              var oldMarker = this.markers_.get(marker.key);
	              if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) //if nothing has changed
	                return false;
	            }
	
	            if (!this.center_) {
	              this.center_ = marker.getPosition();
	              this.calculateBounds_();
	            } else {
	              if (this.averageCenter_) {
	                var l = this.markers_.length + 1;
	                var lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l;
	                var lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
	                this.center_ = new google.maps.LatLng(lat, lng);
	                this.calculateBounds_();
	              }
	            }
	            marker.isAdded = true;
	            this.markers_.push(marker);
	
	            mCount = this.markers_.length;
	            mz = this.markerClusterer_.getMaxZoom();
	            if (mz !== null && this.map_.getZoom() > mz) {
	              // Zoomed in past max zoom, so show the marker.
	              if (marker.getMap() !== this.map_) {
	                marker.setMap(this.map_);
	              }
	            } else if (mCount < this.minClusterSize_) {
	              // Min cluster size not reached so show the marker.
	              if (marker.getMap() !== this.map_) {
	                marker.setMap(this.map_);
	              }
	            } else if (mCount === this.minClusterSize_) {
	              // Hide the markers that were showing.
	              this.markers_.each(function (m) {
	                m.setMap(null);
	              });
	            } else {
	              marker.setMap(null);
	            }
	
	            //this.updateIcon_();
	            return true;
	          };
	
	          /**
	           * Determines if a marker has already been added to the cluster.
	           *
	           * @param {google.maps.Marker} marker The marker to check.
	           * @return {boolean} True if the marker has already been added.
	           */
	          NgMapCluster.prototype.isMarkerAlreadyAdded_ = function (marker) {
	            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
	          };
	
	
	          /**
	           * Returns the bounds of the cluster.
	           *
	           * @return {google.maps.LatLngBounds} the cluster bounds.
	           * @ignore
	           */
	          NgMapCluster.prototype.getBounds = function () {
	            var i;
	            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
	            this.getMarkers().each(function(m){
	              bounds.extend(m.getPosition());
	            });
	            return bounds;
	          };
	
	
	          /**
	           * Removes the cluster from the map.
	           *
	           * @ignore
	           */
	          NgMapCluster.prototype.remove = function () {
	            this.clusterIcon_.setMap(null);
	            this.markers_ = new PropMap();
	            delete this.markers_;
	          };
	
	
	          return NgMapCluster;
	
	        })(Cluster);
	
	
	        window.NgMapMarkerClusterer = (function (_super) {
	          __extends(NgMapMarkerClusterer, _super);
	
	          function NgMapMarkerClusterer(map, opt_markers, opt_options) {
	            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
	            this.markers_ = new PropMap();
	          }
	
	          /**
	           * Removes all clusters and markers from the map and also removes all markers
	           *  managed by the clusterer.
	           */
	          NgMapMarkerClusterer.prototype.clearMarkers = function () {
	            this.resetViewport_(true);
	            this.markers_ = new PropMap();
	          };
	          /**
	           * Removes a marker and returns true if removed, false if not.
	           *
	           * @param {google.maps.Marker} marker The marker to remove
	           * @return {boolean} Whether the marker was removed or not
	           */
	          NgMapMarkerClusterer.prototype.removeMarker_ = function (marker) {
	            if (!this.markers_.get(marker.key)) {
	              return false;
	            }
	            marker.setMap(null);
	            this.markers_.remove(marker.key); // Remove the marker from the list of managed markers
	            return true;
	          };
	
	          /**
	           * Creates the clusters. This is done in batches to avoid timeout errors
	           *  in some browsers when there is a huge number of markers.
	           *
	           * @param {number} iFirst The index of the first marker in the batch of
	           *  markers to be added to clusters.
	           */
	          NgMapMarkerClusterer.prototype.createClusters_ = function (iFirst) {
	            var i, marker;
	            var mapBounds;
	            var cMarkerClusterer = this;
	            if (!this.ready_) {
	              return;
	            }
	
	            // Cancel previous batch processing if we're working on the first batch:
	            if (iFirst === 0) {
	              /**
	               * This event is fired when the <code>MarkerClusterer</code> begins
	               *  clustering markers.
	               * @name MarkerClusterer#clusteringbegin
	               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
	               * @event
	               */
	              google.maps.event.trigger(this, 'clusteringbegin', this);
	
	              if (typeof this.timerRefStatic !== 'undefined') {
	                clearTimeout(this.timerRefStatic);
	                delete this.timerRefStatic;
	              }
	            }
	
	            // Get our current map view bounds.
	            // Create a new bounds object so we don't affect the map.
	            //
	            // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
	            if (this.getMap().getZoom() > 3) {
	              mapBounds = new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(),
	                this.getMap().getBounds().getNorthEast());
	            } else {
	              mapBounds = new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
	            }
	            var bounds = this.getExtendedBounds(mapBounds);
	
	            var iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
	
	            var _ms = this.markers_.values();
	            for (i = iFirst; i < iLast; i++) {
	              marker = _ms[i];
	              if (!marker.isAdded && this.isMarkerInBounds_(marker, bounds)) {
	                if (!this.ignoreHidden_ || (this.ignoreHidden_ && marker.getVisible())) {
	                  this.addToClosestCluster_(marker);
	                }
	              }
	            }
	
	            if (iLast < this.markers_.length) {
	              this.timerRefStatic = setTimeout(function () {
	                cMarkerClusterer.createClusters_(iLast);
	              }, 0);
	            } else {
	              // custom addition by ui-gmap
	              // update icon for all clusters
	              for (i = 0; i < this.clusters_.length; i++) {
	                this.clusters_[i].updateIcon_();
	              }
	
	              delete this.timerRefStatic;
	
	              /**
	               * This event is fired when the <code>MarkerClusterer</code> stops
	               *  clustering markers.
	               * @name MarkerClusterer#clusteringend
	               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
	               * @event
	               */
	              google.maps.event.trigger(this, 'clusteringend', this);
	            }
	          };
	
	          /**
	           * Adds a marker to a cluster, or creates a new cluster.
	           *
	           * @param {google.maps.Marker} marker The marker to add.
	           */
	          NgMapMarkerClusterer.prototype.addToClosestCluster_ = function (marker) {
	            var i, d, cluster, center;
	            var distance = 40000; // Some large number
	            var clusterToAddTo = null;
	            for (i = 0; i < this.clusters_.length; i++) {
	              cluster = this.clusters_[i];
	              center = cluster.getCenter();
	              if (center) {
	                d = this.distanceBetweenPoints_(center, marker.getPosition());
	                if (d < distance) {
	                  distance = d;
	                  clusterToAddTo = cluster;
	                }
	              }
	            }
	
	            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {
	              clusterToAddTo.addMarker(marker);
	            } else {
	              cluster = new NgMapCluster(this);
	              cluster.addMarker(marker);
	              this.clusters_.push(cluster);
	            }
	          };
	
	          /**
	           * Redraws all the clusters.
	           */
	          NgMapMarkerClusterer.prototype.redraw_ = function () {
	            this.createClusters_(0);
	          };
	
	
	          /**
	           * Removes all clusters from the map. The markers are also removed from the map
	           *  if <code>opt_hide</code> is set to <code>true</code>.
	           *
	           * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
	           *  from the map.
	           */
	          NgMapMarkerClusterer.prototype.resetViewport_ = function (opt_hide) {
	            var i, marker;
	            // Remove all the clusters
	            for (i = 0; i < this.clusters_.length; i++) {
	              this.clusters_[i].remove();
	            }
	            this.clusters_ = [];
	
	            // Reset the markers to not be added and to be removed from the map.
	            this.markers_.each(function (marker) {
	              marker.isAdded = false;
	              if (opt_hide) {
	                marker.setMap(null);
	              }
	            });
	          };
	
	          /**
	           * Extends an object's prototype by another's.
	           *
	           * @param {Object} obj1 The object to be extended.
	           * @param {Object} obj2 The object to extend with.
	           * @return {Object} The new extended object.
	           * @ignore
	           */
	          NgMapMarkerClusterer.prototype.extend = function (obj1, obj2) {
	            return (function (object) {
	              var property;
	              for (property in object.prototype) {
	                if (property !== 'constructor')
	                  this.prototype[property] = object.prototype[property];
	              }
	              return this;
	            }).apply(obj1, [obj2]);
	          };
	          ////////////////////////////////////////////////////////////////////////////////
	          /*
	          Other overrides relevant to MarkerClusterPlus
	          */
	          ////////////////////////////////////////////////////////////////////////////////
	          /**
	          * Positions and shows the icon.
	          */
	          ClusterIcon.prototype.show = function () {
	            if (this.div_) {
	              var img = "";
	              // NOTE: values must be specified in px units
	              var bp = this.backgroundPosition_.split(" ");
	              var spriteH = parseInt(bp[0].trim(), 10);
	              var spriteV = parseInt(bp[1].trim(), 10);
	              var pos = this.getPosFromLatLng_(this.center_);
	              this.div_.style.cssText = this.createCss(pos);
	              img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
	              if (!this.cluster_.getMarkerClusterer().enableRetinaIcons_) {
	                img += "clip: rect(" + (-1 * spriteV) + "px, " + ((-1 * spriteH) + this.width_) + "px, " +
	                ((-1 * spriteV) + this.height_) + "px, " + (-1 * spriteH) + "px);";
	              }
	              // ADDED FOR RETINA SUPPORT
	              else {
	                img += "width: " + this.width_ + "px;" + "height: " + this.height_ + "px;";
	              }
	              // END ADD
	              img += "'>";
	              this.div_.innerHTML = img + "<div style='" +
	              "position: absolute;" +
	              "top: " + this.anchorText_[0] + "px;" +
	              "left: " + this.anchorText_[1] + "px;" +
	              "color: " + this.textColor_ + ";" +
	              "font-size: " + this.textSize_ + "px;" +
	              "font-family: " + this.fontFamily_ + ";" +
	              "font-weight: " + this.fontWeight_ + ";" +
	              "font-style: " + this.fontStyle_ + ";" +
	              "text-decoration: " + this.textDecoration_ + ";" +
	              "text-align: center;" +
	              "width: " + this.width_ + "px;" +
	              "line-height:" + this.height_ + "px;" +
	              "'>" + this.sums_.text + "</div>";
	              if (typeof this.sums_.title === "undefined" || this.sums_.title === "") {
	                this.div_.title = this.cluster_.getMarkerClusterer().getTitle();
	              } else {
	                this.div_.title = this.sums_.title;
	              }
	              this.div_.style.display = "";
	            }
	            this.visible_ = true;
	          };
	          //END OTHER OVERRIDES
	          ////////////////////////////////////////////////////////////////////////////////
	
	          return NgMapMarkerClusterer;
	
	        })(MarkerClusterer);
	      }).call(this);
	    })
	  };
	}]);
	}( window, angular, _));

/***/ },
/* 308 */
/*!***********************************************************!*\
  !*** ./~/multiple-date-picker/dist/multipleDatePicker.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _ = __webpack_require__(/*! lodash */ 309);
	
	/*
	 @author : Maelig GOHIN For ARCA-Computing - www.arca-computing.fr
	 @version: 2.0.2
	
	 @description:  MultipleDatePicker is an Angular directive to show a simple calendar allowing user to select multiple dates.
	 Css style can be changed by editing less or css stylesheet.
	 See scope declaration below for options you can pass through html directive.
	 Feel free to edit and share this piece of code, our idea is to keep it simple ;)
	
	 Demo page : http://arca-computing.github.io/MultipleDatePicker/
	 */
	(function (angular) {
	    var multipleDatePicker = function multipleDatePicker() {
	        return {
	            restrict: 'AE',
	            scope: {
	                /*
	                 * Type : Array of moment dates
	                 * Array will mutate when user select/unselect a date
	                 */
	                ngModel: '=?',
	                /*
	                 * Type: array of objects (see doc)
	                 * Days to highlights
	                 * */
	                highlightDays: '=?',
	                /*
	                 * Type : function
	                 * Will be called to manage (un)selection of a date
	                 */
	                dayClick: '=?',
	                /*
	                 * Type : function
	                 * Will be called to manage hover of a date
	                 */
	                dayHover: '=?',
	
	                /*
	                 * Type: moment date
	                 * Month to be displayed
	                 * Default is current month
	                 */
	                month: '=?',
	
	                /*
	                 * Type: function(newMonth, oldMonth)
	                 * Will be called when month changed
	                 * Param newMonth/oldMonth will be the first day of month at midnight
	                 * */
	                monthChanged: '=?',
	                /*
	                 * Type: array of integers
	                 * Recurrent week days not selectables
	                 * /!\ Sunday = 0, Monday = 1 ... Saturday = 6
	                 * */
	                weekDaysOff: '=?',
	                /*
	                 * Type: boolean
	                 * Set all days off
	                 * */
	                allDaysOff: '=?',
	                /*
	                 * Type: array of moment dates
	                 * Set days allowed (only thos dates will be selectable)
	                 * */
	                daysAllowed: '=?',
	                /*
	                 * Type: boolean
	                 * Sunday be the first day of week, default will be Monday
	                 * */
	                sundayFirstDay: '=?',
	                /*
	                 * Type: boolean
	                 * if true can't go back in months before today's month
	                 * */
	                disallowBackPastMonths: '=?',
	                /*
	                 * Type: boolean
	                 * if true can't go in futur months after today's month
	                 * */
	                disallowGoFuturMonths: '=?',
	                /*
	                 * Type: boolean
	                 * if true empty boxes will be filled with days of previous/next month
	                 * */
	                showDaysOfSurroundingMonths: '=?',
	                /*
	                 * Type: string
	                 * CSS classes to apply to days of next/previous months
	                 * */
	                cssDaysOfSurroundingMonths: '=?',
	                /*
	                 * Type: boolean
	                 * if true events on empty boxes (or next/previous month) will be fired
	                 * */
	                fireEventsForDaysOfSurroundingMonths: '=?',
	                /*
	                 * Type: any type moment can parse
	                 * If filled will disable all days before this one (not included)
	                 * */
	                disableDaysBefore: '=?',
	                /*
	                 * Type: any type moment can parse
	                 * If filled will disable all days after this one (not included)
	                 * */
	                disableDaysAfter: '=?',
	
	                /*
	                   Type: integers
	                   */
	                utcOffset: '=?'
	            },
	            template: '\n<div class="multiple-date-picker">\n    <div class="picker-top-row">\n        <div class="text-center picker-navigate picker-navigate-left-arrow"\n             ng-class="{\'disabled\':disableBackButton}" ng-click="previousMonth()">&lt;</div\n             ><div class="text-center picker-month">{{month.format(\'MMMM YYYY\')}}</div\n             ><div class="text-center picker-navigate picker-navigate-right-arrow"\n             ng-class="{\'disabled\':disableNextButton}" ng-click="nextMonth()">&gt;</div>\n    </div>\n  <div class="picker-days-week-row">\n    <div class="text-center" ng-repeat="day in daysOfWeek">{{day}}</div>\n  </div>\n  <div class="picker-days-row">\n    <div class="text-center\n                picker-day\n                {{!day.mdp.otherMonth || showDaysOfSurroundingMonths ? day.css : \'\'}}\n                {{ day.mdp.otherMonth ? cssDaysOfSurroundingMonths : \'\'}}"\n         title="{{day.title}}"\n         ng-repeat="day in days track by $index"\n         ng-click="toggleDay($event, day)"\n         ng-mouseover="hoverDay($event, day)"\n         ng-mouseleave="dayHover($event, day)"\n         ng-class="{\n            \'picker-selected\':    is.selected(day.date),\n            \'picker-off\':         !day.selectable,\n            \'today\':              day.mdp.today,\n            \'past\':               day.mdp.past,\n            \'future\':             day.mdp.future,\n            \'picker-other-month\': day.mdp.otherMonth\n          }">\n          {{day ? day.mdp.otherMonth && !showDaysOfSurroundingMonths ? \'&nbsp;\' : day.date.format(\'D\') : \'\'}}\n\n          <div ng-if="day.annotation" class="annotation">\n            {{day.annotation}}\n          </div>\n    </div>\n  </div>\n</div>',
	            link: function link(scope) {
	
	                scope.ngModel = scope.ngModel || [];
	
	                /* Optimizations to speed things up */
	                scope.cache = {
	                    selectedDates: {},
	                    highlightDays: {},
	                    daysAllowed: {},
	                    today: moment()
	                };
	
	                scope.is = {
	                    selected: function selected(dv) {
	                        return dv.valueOf() in scope.cache.selectedDates;
	                    }
	                };
	
	                /*utility functions*/
	
	                // today(dv) {
	                //   return scope.cache.today.isSame(dv, 'day');
	                // },
	                // past(dv) {
	                //   return scope.cache.today.isBefore(dv, 'day');
	                // },
	                // future(dv) {
	                //   return scope.cache.today.isAfter(dv, 'day');
	                // },
	                // otherMonth(dv) {
	                //   return !scope.month.isSame(dv, 'month');
	                // },
	                var checkNavigationButtons = function checkNavigationButtons() {
	                    var today = moment(),
	                        previousMonth = moment(scope.month).subtract(1, 'month'),
	                        nextMonth = moment(scope.month).add(1, 'month');
	                    scope.disableBackButton = scope.disallowBackPastMonths && today.isAfter(previousMonth, 'month');
	                    scope.disableNextButton = scope.disallowGoFuturMonths && today.isBefore(nextMonth, 'month');
	                },
	                    getDaysOfWeek = function getDaysOfWeek() {
	                    /*To display days of week names in moment.lang*/
	                    var momentDaysOfWeek = moment().localeData()._weekdaysMin,
	                        days = [];
	
	                    for (var i = 1; i < 7; i++) {
	                        days.push(momentDaysOfWeek[i]);
	                    }
	
	                    if (scope.sundayFirstDay) {
	                        days.splice(0, 0, momentDaysOfWeek[0]);
	                    } else {
	                        days.push(momentDaysOfWeek[0]);
	                    }
	
	                    return days;
	                };
	
	                /*scope functions*/
	                // FIXME: Use shallower watch functions here
	                scope.$watch(function () {
	                    return scope.ngModel.map(function (m) {
	                        return m.valueOf();
	                    });
	                }, function (selectedDates) {
	                    scope.cache.selectedDates = selectedDates ? _.keyBy(selectedDates, function (m) {
	                        return m.valueOf();
	                    }) : {};
	                }, true);
	
	                scope.$watch('highlightDays', function (hlDays) {
	                    if (angular.isArray(hlDays)) {
	                        scope.cache.highlightDays = _.keyBy(hlDays, function (hld) {
	                            var hldMoment = moment(hld.date);
	                            return Date.UTC(hldMoment.year(), hldMoment.month(), hldMoment.date());
	                        });
	                    } else {
	                        scope.cache.highlightDays = {};
	                    }
	                }, true);
	
	                scope.$watch(function () {
	                    return scope.daysAllowed && scope.daysAllowed.map(function (m) {
	                        return m.valueOf();
	                    });
	                }, function () {
	                    if (angular.isArray(scope.daysAllowed)) {
	                        scope.cache.daysAllowed = _.keyBy(scope.daysAllowed, function (hld) {
	                            var hldMoment = moment(hld);
	                            return Date.UTC(hldMoment.year(), hldMoment.month(), hldMoment.date());
	                        });
	                    } else {
	                        scope.cache.daysAllowed = null;
	                    }
	                }, true);
	
	                scope.$watchGroup([
	                // 'cache.selectedDates', // not this one -- this one is more optimized
	                'cache.highlightDays', 'cache.daysAllowed', 'weekDaysOff', // FIXME: Not exactly correct (needs deep)
	                'allDaysOff'], function () {
	                    scope.generate();
	                });
	
	                //default values
	                scope.month = scope.month || moment().startOf('day');
	                scope.days = [];
	                scope.weekDaysOff = scope.weekDaysOff || [];
	                scope.daysOff = scope.daysOff || [];
	                scope.disableBackButton = false;
	                scope.disableNextButton = false;
	                scope.daysOfWeek = getDaysOfWeek();
	                scope.cssDaysOfSurroundingMonths = scope.cssDaysOfSurroundingMonths || 'picker-empty';
	
	                /**
	                 * Called when user clicks a date
	                 * @param event event the click event
	                 * @param day "complex" mdp object with all properties
	                 */
	                scope.toggleDay = function (event, day) {
	                    event.preventDefault();
	
	                    if (day.mdp.otherMonth && !scope.fireEventsForDaysOfSurroundingMonths) {
	                        return;
	                    }
	
	                    var prevented = false;
	
	                    event.preventDefault = function () {
	                        prevented = true;
	                    };
	
	                    if (typeof scope.dayClick == 'function') {
	                        scope.dayClick(event, day);
	                    }
	
	                    if (day.selectable && !prevented) {
	                        if (_.some(scope.ngModel, function (m) {
	                            return m.isSame(day.date, 'day');
	                        })) {
	                            scope.ngModel = _.filter(scope.ngModel, function (m) {
	                                return !m.isSame(day.date, 'day');
	                            });
	                        } else {
	                            scope.ngModel.push(day.date);
	                        }
	                    }
	                };
	
	                /**
	                 * Hover day
	                 * @param event hover event
	                 * @param day "complex" mdp object with all properties
	                 */
	                scope.hoverDay = function (event, day) {
	                    event.preventDefault();
	                    var prevented = false;
	
	                    event.preventDefault = function () {
	                        prevented = true;
	                    };
	
	                    if (typeof scope.dayHover == 'function') {
	                        scope.dayHover(event, day);
	                    }
	                };
	
	                /*Navigate to previous month*/
	                scope.previousMonth = function () {
	                    if (!scope.disableBackButton) {
	                        var oldMonth = moment(scope.month);
	                        scope.month = scope.month.subtract(1, 'month');
	                        if (typeof scope.monthChanged == 'function') {
	                            scope.monthChanged(scope.month, oldMonth);
	                        }
	                        scope.generate();
	                    }
	                };
	
	                /*Navigate to next month*/
	                scope.nextMonth = function () {
	                    if (!scope.disableNextButton) {
	                        var oldMonth = moment(scope.month);
	                        scope.month = scope.month.add(1, 'month');
	                        if (typeof scope.monthChanged == 'function') {
	                            scope.monthChanged(scope.month, oldMonth);
	                        }
	                        scope.generate();
	                    }
	                };
	
	                /*Check if the date is off : unselectable*/
	                scope.isDayOff = function (day) {
	                    var dateRef = Date.UTC(day.date.year(), day.date.month(), day.date.date());
	                    return scope.allDaysOff || !!scope.disableDaysBefore && moment(day.date).isBefore(scope.disableDaysBefore, 'day') || !!scope.disableDaysAfter && moment(day.date).isAfter(scope.disableDaysAfter, 'day') || angular.isArray(scope.weekDaysOff) && scope.weekDaysOff.some(function (dayOff) {
	                        return day.date.day() === dayOff;
	                    }) || angular.isArray(scope.daysOff) && scope.daysOff.some(function (dayOff) {
	                        return day.date.isSame(dayOff, 'day');
	                    }) || scope.cache.daysAllowed && !scope.cache.daysAllowed[dateRef] || dateRef in scope.cache.highlightDays && !scope.cache.highlightDays[dateRef].selectable;
	                };
	
	                /*Check if the date is selected*/
	                scope.isSelected = function (day) {
	                    return scope.ngModel.some(function (d) {
	                        return day.date.isSame(d, 'day');
	                    });
	                };
	
	                /*Generate the calendar*/
	                scope.generate = function () {
	                    var previousDay = moment(scope.month).date(0).day(scope.sundayFirstDay ? 0 : 1).subtract(1, 'day');
	
	                    if (moment(scope.month).date(0).diff(previousDay, 'day') > 6) {
	                        previousDay = previousDay.add(1, 'week');
	                    }
	
	                    var firstDayOfMonth = moment(scope.month).date(1),
	                        days = [],
	                        now = moment(),
	                        lastDay = moment(firstDayOfMonth).endOf('month'),
	                        createDate = function createDate() {
	                        var day = {
	                            date: moment(previousDay.add(1, 'day')),
	                            dateValue: 0,
	                            annotation: null,
	                            mdp: {}
	                        };
	
	                        day.dateValue = day.date.valueOf();
	
	                        var dayKey = Date.UTC(day.date.year(), day.date.month(), day.date.date());
	
	                        if (angular.isArray(scope.highlightDays)) {
	                            // Assume it's cached
	                            var hlDay = scope.cache.highlightDays[dayKey];
	
	                            if (hlDay) {
	                                day.css = hlDay.css;
	                                day.title = hlDay.title;
	                                day.annotation = hlDay.annotation;
	                            } else {
	                                day.css = '';
	                                day.title = '';
	                                day.annotation = null;
	                            }
	                        }
	                        day.selectable = !scope.isDayOff(day);
	
	                        /* Date computations are expensive, so cache the values */
	                        //
	                        // isSame / isBefore / isAfter doesn't work correctly.
	                        // See: https://github.com/moment/moment/issues/2427
	                        // Test:
	                        // moment('2016-08-29T00:00:00Z').utcOffset('+0000').isSame(moment('2016-08-29T07:30:00+0800'), 'date')
	                        //
	                        // Expected: true
	                        // Actual: false (because second moment is interpreted in time zone of first moment)
	                        day.mdp.today = day.date.format('YYYY-MM-DD') === now.format('YYYY-MM-DD');
	                        day.mdp.past = day.date.format('YYYY-MM-DD') < now.format('YYYY-MM-DD');
	                        day.mdp.future = day.date.format('YYYY-MM-DD') > now.format('YYYY-MM-DD');
	                        if (!day.date.isSame(scope.month, 'month')) {
	                            day.mdp.otherMonth = true;
	                        }
	                        return day;
	                    },
	                        maxDays = lastDay.diff(previousDay, 'days'),
	                        lastDayOfWeek = scope.sundayFirstDay ? 6 : 0;
	
	                    if (lastDay.day() !== lastDayOfWeek) {
	                        maxDays += (scope.sundayFirstDay ? 6 : 7) - lastDay.day();
	                    }
	
	                    for (var j = 0; j < maxDays; j++) {
	                        days.push(createDate());
	                    }
	
	                    scope.days = days;
	                    checkNavigationButtons();
	                };
	            }
	        };
	    };
	
	    angular.module('multipleDatePicker', []).directive('multipleDatePicker', multipleDatePicker);
	})(window.angular);

/***/ },
/* 309 */
/*!********************!*\
  !*** external "_" ***!
  \********************/
/***/ function(module, exports) {

	module.exports = _;

/***/ },
/* 310 */
/*!***************************!*\
  !*** ./beeline/router.js ***!
  \***************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($stateProvider, $urlRouterProvider) {
	  $stateProvider
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Introductory slides
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('intro', {
	    url: '/intro',
	    templateUrl: 'templates/intro-slides.html',
	    controller: 'IntroSlidesController'
	  }).state('welcome', {
	    url: '/welcome?refCode',
	    templateUrl: 'templates/welcome.html',
	    controller: 'WelcomeController'
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface
	  // ////////////////////////////////////////////////////////////////////////////
	  /** Instead of using abstract: true, we make this page not abstract, because
	      we want to provide the $backOrDefault method to the tabs scope.
	      When our back button is clicked, this method will be called.
	      (We are overriding the default back button. cf tabs.html)
	      **/
	  .state('tabs', {
	    url: '/tabs',
	    abstract: true,
	    templateUrl: 'templates/tabs.html'
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface, Routes Tab
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('tabs.routes', {
	    url: '/routes',
	    views: {
	      'tab-routes': {
	        templateUrl: 'templates/routes-list.html',
	        controller: 'RoutesListController'
	      }
	    }
	  }).state('tabs.booking', {
	    url: '/booking',
	    abstract: true
	  }).state('tabs.bookingPickup', {
	    url: '/booking/:routeId/stops?boardStop&alightStop&sessionId',
	    views: {
	      'tab-booking': {
	        templateUrl: 'templates/tab-booking-stops.html',
	        controller: 'BookingStopsController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.booking-dates', {
	    url: '/booking/:routeId/dates?boardStop&alightStop&sessionId',
	    views: {
	      'tab-booking': {
	        templateUrl: 'templates/tab-booking-dates.html',
	        controller: 'BookingDatesController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.booking-summary', {
	    url: '/booking/:routeId/summary?boardStop&alightStop&selectedDates&sessionId&promoCode',
	    views: {
	      'tab-booking': {
	        templateUrl: 'templates/tab-booking-summary.html',
	        controller: 'BookingSummaryController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.booking-confirmation', {
	    url: '/booking/confirmation',
	    views: {
	      'tab-booking': {
	        templateUrl: 'templates/tab-booking-confirmation.html',
	        controller: 'BookingConfirmationController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.lite-summary', {
	    url: '/lite/summary/:label',
	    views: {
	      'tab-lite': {
	        templateUrl: 'templates/tab-lite-summary.html',
	        controller: 'LiteSummaryController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.lite-more-info', {
	    url: '/lite/more-info/:label/:companyId/',
	    views: {
	      'tab-lite': {
	        templateUrl: 'templates/tab-lite-more-info.html',
	        controller: 'LiteMoreInfoController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface, Sugesstions Tab
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('tabs.suggest', {
	    url: '/suggest/:action',
	    views: {
	      'tab-suggest': {
	        templateUrl: 'templates/tab-suggest.html',
	        controller: 'SuggestController'
	      }
	    }
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface, Tickets Tab
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('tabs.tickets', {
	    url: '/tickets',
	    views: {
	      'tab-tickets': {
	        templateUrl: 'templates/tickets.html',
	        controller: 'TicketsController'
	      }
	    }
	  }).state('tabs.ticket-detail', {
	    url: '/tickets/:ticketId',
	    views: {
	      'tab-tickets': {
	        templateUrl: 'templates/ticket-detail.html',
	        controller: 'TicketDetailController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.lite-route-tracker', {
	    url: '/tickets/liteRoute/:liteRouteLabel',
	    views: {
	      'tab-tickets': {
	        templateUrl: 'templates/lite-route-tracker.html',
	        controller: 'LiteRouteTrackerController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface, Kickstarter Tab
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('tabs.crowdstart', {
	    url: '/crowdstart',
	    views: {
	      'tab-crowdstart': {
	        templateUrl: 'templates/kickstarter.html',
	        controller: 'KickstarterController'
	      }
	    }
	  }).state('tabs.crowdstart-recap', {
	    url: '/crowdstart/:routeId/recap',
	    views: {
	      'tab-crowdstart': {
	        templateUrl: 'templates/kickstarter-recap.html',
	        controller: 'KickstarterRecapController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.crowdstart-detail', {
	    url: '/crowdstart/:routeId/detail',
	    views: {
	      'tab-crowdstart': {
	        templateUrl: 'templates/kickstarter-detail.html',
	        controller: 'KickstarterDetailController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.crowdstart-summary', {
	    url: '/crowdstart/:routeId/summary?bidPrice',
	    views: {
	      'tab-crowdstart': {
	        templateUrl: 'templates/kickstarter-summary.html',
	        controller: 'KickstarterSummaryController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.crowdstart-commit', {
	    url: '/crowdstart/:routeId/commit',
	    views: {
	      'tab-crowdstart': {
	        templateUrl: 'templates/kickstarter-commit.html',
	        controller: 'KickstarterCommitController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  })
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Main interface, Settings Tab
	  // ////////////////////////////////////////////////////////////////////////////
	  .state('tabs.settings', {
	    url: '/settings',
	    views: {
	      'tab-settings': {
	        templateUrl: 'templates/settings.html',
	        controller: 'SettingsController'
	      }
	    }
	  }).state('tabs.booking-history', {
	    url: '/settings/booking-history',
	    views: {
	      'tab-settings': {
	        templateUrl: 'templates/booking-history.html',
	        controller: 'BookingHistoryController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.search', {
	    url: '/search',
	    views: {
	      'tab-search': {
	        templateUrl: 'templates/search.html',
	        controller: 'SearchController'
	      }
	    },
	    params: {
	      backPage: null
	    },
	    data: {
	      hideTabs: true
	    }
	  }).state('tabs.search-results', {
	    url: '/search-results?originLat&originLng&destinationLat&destinationLng',
	    views: {
	      'tab-search': {
	        templateUrl: 'templates/search-results.html',
	        controller: 'SearchResultsController'
	      }
	    },
	    data: {
	      hideTabs: true
	    }
	  });
	
	  var viewedIntroSlidesVersion = window.localStorage['viewedBeelineSlidesVersion'];
	  // if none of the above states are matched, use this as the fallback
	  if (viewedIntroSlidesVersion && viewedIntroSlidesVersion >= introSlidesVersion) {
	    $urlRouterProvider.otherwise('/tabs/routes');
	  } else {
	    // $urlRouterProvider.otherwise('/tabs/routes/map');
	    window.localStorage.viewedBeelineSlidesVersion = introSlidesVersion;
	
	    $urlRouterProvider.otherwise('/intro');
	  }
	};
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Version follows '[date] comment' format
	var introSlidesVersion = '2017-02-20';
	
	/**
	  * If you want to hide tabs while maintaining proper back button functionality
	  * then add data: {hideTabs: true} to the state definition. The hiding of the
	  * tabs will be handled globally in main.js ($rootScope.$on('$stateChangeSuccess'))
	  *
	  * I have absolutely no idea what happens if you use subtabs.
	  * The point is, don't use subtabs.
	**/
	
	/**
	  * The other parameters we define is
	    @prop data.back : stateParams -> Array
	      A function that returns a state array [state name, state params]
	      given a state params. The state array represents the "default back page"
	      for a given state, thus preventing the user from getting "stucK".

	**/

/***/ },
/* 311 */
/*!****************************!*\
  !*** ./~/moment/moment.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {//! moment.js
	//! version : 2.17.0
	//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
	//! license : MIT
	//! momentjs.com
	
	;(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    global.moment = factory()
	}(this, (function () { 'use strict';
	
	var hookCallback;
	
	function hooks () {
	    return hookCallback.apply(null, arguments);
	}
	
	// This is done to register the method called with moment()
	// without creating circular dependencies.
	function setHookCallback (callback) {
	    hookCallback = callback;
	}
	
	function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	}
	
	function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	}
	
	function isObjectEmpty(obj) {
	    var k;
	    for (k in obj) {
	        // even if its not own property I'd still call it non-empty
	        return false;
	    }
	    return true;
	}
	
	function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	}
	
	function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	}
	
	function map(arr, fn) {
	    var res = [], i;
	    for (i = 0; i < arr.length; ++i) {
	        res.push(fn(arr[i], i));
	    }
	    return res;
	}
	
	function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	}
	
	function extend(a, b) {
	    for (var i in b) {
	        if (hasOwnProp(b, i)) {
	            a[i] = b[i];
	        }
	    }
	
	    if (hasOwnProp(b, 'toString')) {
	        a.toString = b.toString;
	    }
	
	    if (hasOwnProp(b, 'valueOf')) {
	        a.valueOf = b.valueOf;
	    }
	
	    return a;
	}
	
	function createUTC (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	}
	
	function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	        empty           : false,
	        unusedTokens    : [],
	        unusedInput     : [],
	        overflow        : -2,
	        charsLeftOver   : 0,
	        nullInput       : false,
	        invalidMonth    : null,
	        invalidFormat   : false,
	        userInvalidated : false,
	        iso             : false,
	        parsedDateParts : [],
	        meridiem        : null
	    };
	}
	
	function getParsingFlags(m) {
	    if (m._pf == null) {
	        m._pf = defaultParsingFlags();
	    }
	    return m._pf;
	}
	
	var some;
	if (Array.prototype.some) {
	    some = Array.prototype.some;
	} else {
	    some = function (fun) {
	        var t = Object(this);
	        var len = t.length >>> 0;
	
	        for (var i = 0; i < len; i++) {
	            if (i in t && fun.call(this, t[i], i, t)) {
	                return true;
	            }
	        }
	
	        return false;
	    };
	}
	
	var some$1 = some;
	
	function isValid(m) {
	    if (m._isValid == null) {
	        var flags = getParsingFlags(m);
	        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
	            return i != null;
	        });
	        var isNowValid = !isNaN(m._d.getTime()) &&
	            flags.overflow < 0 &&
	            !flags.empty &&
	            !flags.invalidMonth &&
	            !flags.invalidWeekday &&
	            !flags.nullInput &&
	            !flags.invalidFormat &&
	            !flags.userInvalidated &&
	            (!flags.meridiem || (flags.meridiem && parsedParts));
	
	        if (m._strict) {
	            isNowValid = isNowValid &&
	                flags.charsLeftOver === 0 &&
	                flags.unusedTokens.length === 0 &&
	                flags.bigHour === undefined;
	        }
	
	        if (Object.isFrozen == null || !Object.isFrozen(m)) {
	            m._isValid = isNowValid;
	        }
	        else {
	            return isNowValid;
	        }
	    }
	    return m._isValid;
	}
	
	function createInvalid (flags) {
	    var m = createUTC(NaN);
	    if (flags != null) {
	        extend(getParsingFlags(m), flags);
	    }
	    else {
	        getParsingFlags(m).userInvalidated = true;
	    }
	
	    return m;
	}
	
	function isUndefined(input) {
	    return input === void 0;
	}
	
	// Plugins that add properties should also add the key here (null value),
	// so we can properly clone ourselves.
	var momentProperties = hooks.momentProperties = [];
	
	function copyConfig(to, from) {
	    var i, prop, val;
	
	    if (!isUndefined(from._isAMomentObject)) {
	        to._isAMomentObject = from._isAMomentObject;
	    }
	    if (!isUndefined(from._i)) {
	        to._i = from._i;
	    }
	    if (!isUndefined(from._f)) {
	        to._f = from._f;
	    }
	    if (!isUndefined(from._l)) {
	        to._l = from._l;
	    }
	    if (!isUndefined(from._strict)) {
	        to._strict = from._strict;
	    }
	    if (!isUndefined(from._tzm)) {
	        to._tzm = from._tzm;
	    }
	    if (!isUndefined(from._isUTC)) {
	        to._isUTC = from._isUTC;
	    }
	    if (!isUndefined(from._offset)) {
	        to._offset = from._offset;
	    }
	    if (!isUndefined(from._pf)) {
	        to._pf = getParsingFlags(from);
	    }
	    if (!isUndefined(from._locale)) {
	        to._locale = from._locale;
	    }
	
	    if (momentProperties.length > 0) {
	        for (i in momentProperties) {
	            prop = momentProperties[i];
	            val = from[prop];
	            if (!isUndefined(val)) {
	                to[prop] = val;
	            }
	        }
	    }
	
	    return to;
	}
	
	var updateInProgress = false;
	
	// Moment prototype object
	function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
	    if (!this.isValid()) {
	        this._d = new Date(NaN);
	    }
	    // Prevent infinite loop in case updateOffset creates new moment
	    // objects.
	    if (updateInProgress === false) {
	        updateInProgress = true;
	        hooks.updateOffset(this);
	        updateInProgress = false;
	    }
	}
	
	function isMoment (obj) {
	    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
	}
	
	function absFloor (number) {
	    if (number < 0) {
	        // -0 -> 0
	        return Math.ceil(number) || 0;
	    } else {
	        return Math.floor(number);
	    }
	}
	
	function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;
	
	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	        value = absFloor(coercedNumber);
	    }
	
	    return value;
	}
	
	// compare two arrays, return the number of differences
	function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;
	    for (i = 0; i < len; i++) {
	        if ((dontConvert && array1[i] !== array2[i]) ||
	            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
	            diffs++;
	        }
	    }
	    return diffs + lengthDiff;
	}
	
	function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false &&
	            (typeof console !==  'undefined') && console.warn) {
	        console.warn('Deprecation warning: ' + msg);
	    }
	}
	
	function deprecate(msg, fn) {
	    var firstTime = true;
	
	    return extend(function () {
	        if (hooks.deprecationHandler != null) {
	            hooks.deprecationHandler(null, msg);
	        }
	        if (firstTime) {
	            var args = [];
	            var arg;
	            for (var i = 0; i < arguments.length; i++) {
	                arg = '';
	                if (typeof arguments[i] === 'object') {
	                    arg += '\n[' + i + '] ';
	                    for (var key in arguments[0]) {
	                        arg += key + ': ' + arguments[0][key] + ', ';
	                    }
	                    arg = arg.slice(0, -2); // Remove trailing comma and space
	                } else {
	                    arg = arguments[i];
	                }
	                args.push(arg);
	            }
	            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
	            firstTime = false;
	        }
	        return fn.apply(this, arguments);
	    }, fn);
	}
	
	var deprecations = {};
	
	function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(name, msg);
	    }
	    if (!deprecations[name]) {
	        warn(msg);
	        deprecations[name] = true;
	    }
	}
	
	hooks.suppressDeprecationWarnings = false;
	hooks.deprecationHandler = null;
	
	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}
	
	function set (config) {
	    var prop, i;
	    for (i in config) {
	        prop = config[i];
	        if (isFunction(prop)) {
	            this[i] = prop;
	        } else {
	            this['_' + i] = prop;
	        }
	    }
	    this._config = config;
	    // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _ordinalParseLenient.
	    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
	}
	
	function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig), prop;
	    for (prop in childConfig) {
	        if (hasOwnProp(childConfig, prop)) {
	            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	                res[prop] = {};
	                extend(res[prop], parentConfig[prop]);
	                extend(res[prop], childConfig[prop]);
	            } else if (childConfig[prop] != null) {
	                res[prop] = childConfig[prop];
	            } else {
	                delete res[prop];
	            }
	        }
	    }
	    for (prop in parentConfig) {
	        if (hasOwnProp(parentConfig, prop) &&
	                !hasOwnProp(childConfig, prop) &&
	                isObject(parentConfig[prop])) {
	            // make sure changes to properties don't modify parent config
	            res[prop] = extend({}, res[prop]);
	        }
	    }
	    return res;
	}
	
	function Locale(config) {
	    if (config != null) {
	        this.set(config);
	    }
	}
	
	var keys;
	
	if (Object.keys) {
	    keys = Object.keys;
	} else {
	    keys = function (obj) {
	        var i, res = [];
	        for (i in obj) {
	            if (hasOwnProp(obj, i)) {
	                res.push(i);
	            }
	        }
	        return res;
	    };
	}
	
	var keys$1 = keys;
	
	var defaultCalendar = {
	    sameDay : '[Today at] LT',
	    nextDay : '[Tomorrow at] LT',
	    nextWeek : 'dddd [at] LT',
	    lastDay : '[Yesterday at] LT',
	    lastWeek : '[Last] dddd [at] LT',
	    sameElse : 'L'
	};
	
	function calendar (key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	}
	
	var defaultLongDateFormat = {
	    LTS  : 'h:mm:ss A',
	    LT   : 'h:mm A',
	    L    : 'MM/DD/YYYY',
	    LL   : 'MMMM D, YYYY',
	    LLL  : 'MMMM D, YYYY h:mm A',
	    LLLL : 'dddd, MMMM D, YYYY h:mm A'
	};
	
	function longDateFormat (key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];
	
	    if (format || !formatUpper) {
	        return format;
	    }
	
	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	        return val.slice(1);
	    });
	
	    return this._longDateFormat[key];
	}
	
	var defaultInvalidDate = 'Invalid date';
	
	function invalidDate () {
	    return this._invalidDate;
	}
	
	var defaultOrdinal = '%d';
	var defaultOrdinalParse = /\d{1,2}/;
	
	function ordinal (number) {
	    return this._ordinal.replace('%d', number);
	}
	
	var defaultRelativeTime = {
	    future : 'in %s',
	    past   : '%s ago',
	    s  : 'a few seconds',
	    m  : 'a minute',
	    mm : '%d minutes',
	    h  : 'an hour',
	    hh : '%d hours',
	    d  : 'a day',
	    dd : '%d days',
	    M  : 'a month',
	    MM : '%d months',
	    y  : 'a year',
	    yy : '%d years'
	};
	
	function relativeTime (number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return (isFunction(output)) ?
	        output(number, withoutSuffix, string, isFuture) :
	        output.replace(/%d/i, number);
	}
	
	function pastFuture (diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	}
	
	var aliases = {};
	
	function addUnitAlias (unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	}
	
	function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	}
	
	function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;
	
	    for (prop in inputObject) {
	        if (hasOwnProp(inputObject, prop)) {
	            normalizedProp = normalizeUnits(prop);
	            if (normalizedProp) {
	                normalizedInput[normalizedProp] = inputObject[prop];
	            }
	        }
	    }
	
	    return normalizedInput;
	}
	
	var priorities = {};
	
	function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	}
	
	function getPrioritizedUnits(unitsObj) {
	    var units = [];
	    for (var u in unitsObj) {
	        units.push({unit: u, priority: priorities[u]});
	    }
	    units.sort(function (a, b) {
	        return a.priority - b.priority;
	    });
	    return units;
	}
	
	function makeGetSet (unit, keepTime) {
	    return function (value) {
	        if (value != null) {
	            set$1(this, unit, value);
	            hooks.updateOffset(this, keepTime);
	            return this;
	        } else {
	            return get(this, unit);
	        }
	    };
	}
	
	function get (mom, unit) {
	    return mom.isValid() ?
	        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	}
	
	function set$1 (mom, unit, value) {
	    if (mom.isValid()) {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	    }
	}
	
	// MOMENTS
	
	function stringGet (units) {
	    units = normalizeUnits(units);
	    if (isFunction(this[units])) {
	        return this[units]();
	    }
	    return this;
	}
	
	
	function stringSet (units, value) {
	    if (typeof units === 'object') {
	        units = normalizeObjectUnits(units);
	        var prioritized = getPrioritizedUnits(units);
	        for (var i = 0; i < prioritized.length; i++) {
	            this[prioritized[i].unit](units[prioritized[i].unit]);
	        }
	    } else {
	        units = normalizeUnits(units);
	        if (isFunction(this[units])) {
	            return this[units](value);
	        }
	    }
	    return this;
	}
	
	function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? (forceSign ? '+' : '') : '-') +
	        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	}
	
	var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	
	var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	
	var formatFunctions = {};
	
	var formatTokenFunctions = {};
	
	// token:    'M'
	// padded:   ['MM', 2]
	// ordinal:  'Mo'
	// callback: function () { this.month() + 1 }
	function addFormatToken (token, padded, ordinal, callback) {
	    var func = callback;
	    if (typeof callback === 'string') {
	        func = function () {
	            return this[callback]();
	        };
	    }
	    if (token) {
	        formatTokenFunctions[token] = func;
	    }
	    if (padded) {
	        formatTokenFunctions[padded[0]] = function () {
	            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	        };
	    }
	    if (ordinal) {
	        formatTokenFunctions[ordinal] = function () {
	            return this.localeData().ordinal(func.apply(this, arguments), token);
	        };
	    }
	}
	
	function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	        return input.replace(/^\[|\]$/g, '');
	    }
	    return input.replace(/\\/g, '');
	}
	
	function makeFormatFunction(format) {
	    var array = format.match(formattingTokens), i, length;
	
	    for (i = 0, length = array.length; i < length; i++) {
	        if (formatTokenFunctions[array[i]]) {
	            array[i] = formatTokenFunctions[array[i]];
	        } else {
	            array[i] = removeFormattingTokens(array[i]);
	        }
	    }
	
	    return function (mom) {
	        var output = '', i;
	        for (i = 0; i < length; i++) {
	            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
	        }
	        return output;
	    };
	}
	
	// format date using native date object
	function formatMoment(m, format) {
	    if (!m.isValid()) {
	        return m.localeData().invalidDate();
	    }
	
	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	
	    return formatFunctions[format](m);
	}
	
	function expandFormat(format, locale) {
	    var i = 5;
	
	    function replaceLongDateFormatTokens(input) {
	        return locale.longDateFormat(input) || input;
	    }
	
	    localFormattingTokens.lastIndex = 0;
	    while (i >= 0 && localFormattingTokens.test(format)) {
	        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	        localFormattingTokens.lastIndex = 0;
	        i -= 1;
	    }
	
	    return format;
	}
	
	var match1         = /\d/;            //       0 - 9
	var match2         = /\d\d/;          //      00 - 99
	var match3         = /\d{3}/;         //     000 - 999
	var match4         = /\d{4}/;         //    0000 - 9999
	var match6         = /[+-]?\d{6}/;    // -999999 - 999999
	var match1to2      = /\d\d?/;         //       0 - 99
	var match3to4      = /\d\d\d\d?/;     //     999 - 9999
	var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
	var match1to3      = /\d{1,3}/;       //       0 - 999
	var match1to4      = /\d{1,4}/;       //       0 - 9999
	var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
	
	var matchUnsigned  = /\d+/;           //       0 - inf
	var matchSigned    = /[+-]?\d+/;      //    -inf - inf
	
	var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
	var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
	
	var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	
	// any word (or two) characters or numbers including two/three word month in arabic.
	// includes scottish gaelic two word and hyphenated months
	var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
	
	
	var regexes = {};
	
	function addRegexToken (token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	        return (isStrict && strictRegex) ? strictRegex : regex;
	    };
	}
	
	function getParseRegexForToken (token, config) {
	    if (!hasOwnProp(regexes, token)) {
	        return new RegExp(unescapeFormat(token));
	    }
	
	    return regexes[token](config._strict, config._locale);
	}
	
	// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
	function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	        return p1 || p2 || p3 || p4;
	    }));
	}
	
	function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	}
	
	var tokens = {};
	
	function addParseToken (token, callback) {
	    var i, func = callback;
	    if (typeof token === 'string') {
	        token = [token];
	    }
	    if (isNumber(callback)) {
	        func = function (input, array) {
	            array[callback] = toInt(input);
	        };
	    }
	    for (i = 0; i < token.length; i++) {
	        tokens[token[i]] = func;
	    }
	}
	
	function addWeekParseToken (token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	        config._w = config._w || {};
	        callback(input, config._w, config, token);
	    });
	}
	
	function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	        tokens[token](input, config._a, config, token);
	    }
	}
	
	var YEAR = 0;
	var MONTH = 1;
	var DATE = 2;
	var HOUR = 3;
	var MINUTE = 4;
	var SECOND = 5;
	var MILLISECOND = 6;
	var WEEK = 7;
	var WEEKDAY = 8;
	
	var indexOf;
	
	if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	} else {
	    indexOf = function (o) {
	        // I know
	        var i;
	        for (i = 0; i < this.length; ++i) {
	            if (this[i] === o) {
	                return i;
	            }
	        }
	        return -1;
	    };
	}
	
	var indexOf$1 = indexOf;
	
	function daysInMonth(year, month) {
	    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
	}
	
	// FORMATTING
	
	addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	});
	
	addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	});
	
	addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	});
	
	// ALIASES
	
	addUnitAlias('month', 'M');
	
	// PRIORITY
	
	addUnitPriority('month', 8);
	
	// PARSING
	
	addRegexToken('M',    match1to2);
	addRegexToken('MM',   match1to2, match2);
	addRegexToken('MMM',  function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	});
	addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	});
	
	addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	});
	
	addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict);
	    // if we didn't find a month name, mark the date as invalid.
	    if (month != null) {
	        array[MONTH] = month;
	    } else {
	        getParsingFlags(config).invalidMonth = input;
	    }
	});
	
	// LOCALES
	
	var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
	function localeMonths (m, format) {
	    if (!m) {
	        return this._months;
	    }
	    return isArray(this._months) ? this._months[m.month()] :
	        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	}
	
	var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
	function localeMonthsShort (m, format) {
	    if (!m) {
	        return this._monthsShort;
	    }
	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
	        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	}
	
	function handleStrictParse(monthName, format, strict) {
	    var i, ii, mom, llc = monthName.toLocaleLowerCase();
	    if (!this._monthsParse) {
	        // this is not used
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	        for (i = 0; i < 12; ++i) {
	            mom = createUTC([2000, i]);
	            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	        }
	    }
	
	    if (strict) {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'MMM') {
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._longMonthsParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortMonthsParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}
	
	function localeMonthsParse (monthName, format, strict) {
	    var i, mom, regex;
	
	    if (this._monthsParseExact) {
	        return handleStrictParse.call(this, monthName, format, strict);
	    }
	
	    if (!this._monthsParse) {
	        this._monthsParse = [];
	        this._longMonthsParse = [];
	        this._shortMonthsParse = [];
	    }
	
	    // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        if (strict && !this._longMonthsParse[i]) {
	            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	        }
	        if (!strict && !this._monthsParse[i]) {
	            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	            return i;
	        } else if (!strict && this._monthsParse[i].test(monthName)) {
	            return i;
	        }
	    }
	}
	
	// MOMENTS
	
	function setMonth (mom, value) {
	    var dayOfMonth;
	
	    if (!mom.isValid()) {
	        // No op
	        return mom;
	    }
	
	    if (typeof value === 'string') {
	        if (/^\d+$/.test(value)) {
	            value = toInt(value);
	        } else {
	            value = mom.localeData().monthsParse(value);
	            // TODO: Another silent failure?
	            if (!isNumber(value)) {
	                return mom;
	            }
	        }
	    }
	
	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
	    return mom;
	}
	
	function getSetMonth (value) {
	    if (value != null) {
	        setMonth(this, value);
	        hooks.updateOffset(this, true);
	        return this;
	    } else {
	        return get(this, 'Month');
	    }
	}
	
	function getDaysInMonth () {
	    return daysInMonth(this.year(), this.month());
	}
	
	var defaultMonthsShortRegex = matchWord;
	function monthsShortRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsShortStrictRegex;
	        } else {
	            return this._monthsShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsShortRegex')) {
	            this._monthsShortRegex = defaultMonthsShortRegex;
	        }
	        return this._monthsShortStrictRegex && isStrict ?
	            this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	}
	
	var defaultMonthsRegex = matchWord;
	function monthsRegex (isStrict) {
	    if (this._monthsParseExact) {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            computeMonthsParse.call(this);
	        }
	        if (isStrict) {
	            return this._monthsStrictRegex;
	        } else {
	            return this._monthsRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_monthsRegex')) {
	            this._monthsRegex = defaultMonthsRegex;
	        }
	        return this._monthsStrictRegex && isStrict ?
	            this._monthsStrictRegex : this._monthsRegex;
	    }
	}
	
	function computeMonthsParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }
	
	    var shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom;
	    for (i = 0; i < 12; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, i]);
	        shortPieces.push(this.monthsShort(mom, ''));
	        longPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.months(mom, ''));
	        mixedPieces.push(this.monthsShort(mom, ''));
	    }
	    // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 12; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	    }
	    for (i = 0; i < 24; i++) {
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }
	
	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	}
	
	// FORMATTING
	
	addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	});
	
	addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	});
	
	addFormatToken(0, ['YYYY',   4],       0, 'year');
	addFormatToken(0, ['YYYYY',  5],       0, 'year');
	addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
	
	// ALIASES
	
	addUnitAlias('year', 'y');
	
	// PRIORITIES
	
	addUnitPriority('year', 1);
	
	// PARSING
	
	addRegexToken('Y',      matchSigned);
	addRegexToken('YY',     match1to2, match2);
	addRegexToken('YYYY',   match1to4, match4);
	addRegexToken('YYYYY',  match1to6, match6);
	addRegexToken('YYYYYY', match1to6, match6);
	
	addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	});
	addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	});
	addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	});
	
	// HELPERS
	
	function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	}
	
	function isLeapYear(year) {
	    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
	}
	
	// HOOKS
	
	hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	};
	
	// MOMENTS
	
	var getSetYear = makeGetSet('FullYear', true);
	
	function getIsLeapYear () {
	    return isLeapYear(this.year());
	}
	
	function createDate (y, m, d, h, M, s, ms) {
	    //can't just apply() to create a date:
	    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
	    var date = new Date(y, m, d, h, M, s, ms);
	
	    //the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	    }
	    return date;
	}
	
	function createUTCDate (y) {
	    var date = new Date(Date.UTC.apply(null, arguments));
	
	    //the Date.UTC function remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	    }
	    return date;
	}
	
	// start-of-first-week - start-of-year
	function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	        fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	
	    return -fwdlw + fwd - 1;
	}
	
	//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
	function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear, resDayOfYear;
	
	    if (dayOfYear <= 0) {
	        resYear = year - 1;
	        resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	        resYear = year + 1;
	        resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	        resYear = year;
	        resDayOfYear = dayOfYear;
	    }
	
	    return {
	        year: resYear,
	        dayOfYear: resDayOfYear
	    };
	}
	
	function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek, resYear;
	
	    if (week < 1) {
	        resYear = mom.year() - 1;
	        resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	        resWeek = week - weeksInYear(mom.year(), dow, doy);
	        resYear = mom.year() + 1;
	    } else {
	        resYear = mom.year();
	        resWeek = week;
	    }
	
	    return {
	        week: resWeek,
	        year: resYear
	    };
	}
	
	function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	}
	
	// FORMATTING
	
	addFormatToken('w', ['ww', 2], 'wo', 'week');
	addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
	
	// ALIASES
	
	addUnitAlias('week', 'w');
	addUnitAlias('isoWeek', 'W');
	
	// PRIORITIES
	
	addUnitPriority('week', 5);
	addUnitPriority('isoWeek', 5);
	
	// PARSING
	
	addRegexToken('w',  match1to2);
	addRegexToken('ww', match1to2, match2);
	addRegexToken('W',  match1to2);
	addRegexToken('WW', match1to2, match2);
	
	addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	});
	
	// HELPERS
	
	// LOCALES
	
	function localeWeek (mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	}
	
	var defaultLocaleWeek = {
	    dow : 0, // Sunday is the first day of the week.
	    doy : 6  // The week that contains Jan 1st is the first week of the year.
	};
	
	function localeFirstDayOfWeek () {
	    return this._week.dow;
	}
	
	function localeFirstDayOfYear () {
	    return this._week.doy;
	}
	
	// MOMENTS
	
	function getSetWeek (input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}
	
	function getSetISOWeek (input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	}
	
	// FORMATTING
	
	addFormatToken('d', 0, 'do', 'day');
	
	addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	});
	
	addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	});
	
	addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	});
	
	addFormatToken('e', 0, 0, 'weekday');
	addFormatToken('E', 0, 0, 'isoWeekday');
	
	// ALIASES
	
	addUnitAlias('day', 'd');
	addUnitAlias('weekday', 'e');
	addUnitAlias('isoWeekday', 'E');
	
	// PRIORITY
	addUnitPriority('day', 11);
	addUnitPriority('weekday', 11);
	addUnitPriority('isoWeekday', 11);
	
	// PARSING
	
	addRegexToken('d',    match1to2);
	addRegexToken('e',    match1to2);
	addRegexToken('E',    match1to2);
	addRegexToken('dd',   function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	});
	addRegexToken('ddd',   function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	});
	addRegexToken('dddd',   function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	});
	
	addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict);
	    // if we didn't get a weekday name, mark the date as invalid
	    if (weekday != null) {
	        week.d = weekday;
	    } else {
	        getParsingFlags(config).invalidWeekday = input;
	    }
	});
	
	addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	});
	
	// HELPERS
	
	function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	        return input;
	    }
	
	    if (!isNaN(input)) {
	        return parseInt(input, 10);
	    }
	
	    input = locale.weekdaysParse(input);
	    if (typeof input === 'number') {
	        return input;
	    }
	
	    return null;
	}
	
	function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	        return locale.weekdaysParse(input) % 7 || 7;
	    }
	    return isNaN(input) ? null : input;
	}
	
	// LOCALES
	
	var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
	function localeWeekdays (m, format) {
	    if (!m) {
	        return this._weekdays;
	    }
	    return isArray(this._weekdays) ? this._weekdays[m.day()] :
	        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
	}
	
	var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
	function localeWeekdaysShort (m) {
	    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	}
	
	var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
	function localeWeekdaysMin (m) {
	    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	}
	
	function handleStrictParse$1(weekdayName, format, strict) {
	    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._minWeekdaysParse = [];
	
	        for (i = 0; i < 7; ++i) {
	            mom = createUTC([2000, 1]).day(i);
	            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	        }
	    }
	
	    if (strict) {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    } else {
	        if (format === 'dddd') {
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else if (format === 'ddd') {
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        } else {
	            ii = indexOf$1.call(this._minWeekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._weekdaysParse, llc);
	            if (ii !== -1) {
	                return ii;
	            }
	            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
	            return ii !== -1 ? ii : null;
	        }
	    }
	}
	
	function localeWeekdaysParse (weekdayName, format, strict) {
	    var i, mom, regex;
	
	    if (this._weekdaysParseExact) {
	        return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }
	
	    if (!this._weekdaysParse) {
	        this._weekdaysParse = [];
	        this._minWeekdaysParse = [];
	        this._shortWeekdaysParse = [];
	        this._fullWeekdaysParse = [];
	    }
	
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	
	        mom = createUTC([2000, 1]).day(i);
	        if (strict && !this._fullWeekdaysParse[i]) {
	            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
	            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
	            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
	        }
	        if (!this._weekdaysParse[i]) {
	            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	        }
	        // test the regex
	        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	            return i;
	        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	            return i;
	        }
	    }
	}
	
	// MOMENTS
	
	function getSetDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
	    if (input != null) {
	        input = parseWeekday(input, this.localeData());
	        return this.add(input - day, 'd');
	    } else {
	        return day;
	    }
	}
	
	function getSetLocaleDayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	}
	
	function getSetISODayOfWeek (input) {
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	
	    // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.
	
	    if (input != null) {
	        var weekday = parseIsoWeekday(input, this.localeData());
	        return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	        return this.day() || 7;
	    }
	}
	
	var defaultWeekdaysRegex = matchWord;
	function weekdaysRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysStrictRegex;
	        } else {
	            return this._weekdaysRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            this._weekdaysRegex = defaultWeekdaysRegex;
	        }
	        return this._weekdaysStrictRegex && isStrict ?
	            this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	}
	
	var defaultWeekdaysShortRegex = matchWord;
	function weekdaysShortRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysShortStrictRegex;
	        } else {
	            return this._weekdaysShortRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	        }
	        return this._weekdaysShortStrictRegex && isStrict ?
	            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	}
	
	var defaultWeekdaysMinRegex = matchWord;
	function weekdaysMinRegex (isStrict) {
	    if (this._weekdaysParseExact) {
	        if (!hasOwnProp(this, '_weekdaysRegex')) {
	            computeWeekdaysParse.call(this);
	        }
	        if (isStrict) {
	            return this._weekdaysMinStrictRegex;
	        } else {
	            return this._weekdaysMinRegex;
	        }
	    } else {
	        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	        }
	        return this._weekdaysMinStrictRegex && isStrict ?
	            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	}
	
	
	function computeWeekdaysParse () {
	    function cmpLenRev(a, b) {
	        return b.length - a.length;
	    }
	
	    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
	        i, mom, minp, shortp, longp;
	    for (i = 0; i < 7; i++) {
	        // make the regex if we don't have it already
	        mom = createUTC([2000, 1]).day(i);
	        minp = this.weekdaysMin(mom, '');
	        shortp = this.weekdaysShort(mom, '');
	        longp = this.weekdays(mom, '');
	        minPieces.push(minp);
	        shortPieces.push(shortp);
	        longPieces.push(longp);
	        mixedPieces.push(minp);
	        mixedPieces.push(shortp);
	        mixedPieces.push(longp);
	    }
	    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.
	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);
	    for (i = 0; i < 7; i++) {
	        shortPieces[i] = regexEscape(shortPieces[i]);
	        longPieces[i] = regexEscape(longPieces[i]);
	        mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }
	
	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;
	
	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	}
	
	// FORMATTING
	
	function hFormat() {
	    return this.hours() % 12 || 12;
	}
	
	function kFormat() {
	    return this.hours() || 24;
	}
	
	addFormatToken('H', ['HH', 2], 0, 'hour');
	addFormatToken('h', ['hh', 2], 0, hFormat);
	addFormatToken('k', ['kk', 2], 0, kFormat);
	
	addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	});
	
	addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});
	
	addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	});
	
	addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) +
	        zeroFill(this.seconds(), 2);
	});
	
	function meridiem (token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	}
	
	meridiem('a', true);
	meridiem('A', false);
	
	// ALIASES
	
	addUnitAlias('hour', 'h');
	
	// PRIORITY
	addUnitPriority('hour', 13);
	
	// PARSING
	
	function matchMeridiem (isStrict, locale) {
	    return locale._meridiemParse;
	}
	
	addRegexToken('a',  matchMeridiem);
	addRegexToken('A',  matchMeridiem);
	addRegexToken('H',  match1to2);
	addRegexToken('h',  match1to2);
	addRegexToken('HH', match1to2, match2);
	addRegexToken('hh', match1to2, match2);
	
	addRegexToken('hmm', match3to4);
	addRegexToken('hmmss', match5to6);
	addRegexToken('Hmm', match3to4);
	addRegexToken('Hmmss', match5to6);
	
	addParseToken(['H', 'HH'], HOUR);
	addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	});
	addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	});
	addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	});
	addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	});
	
	// LOCALES
	
	function localeIsPM (input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return ((input + '').toLowerCase().charAt(0) === 'p');
	}
	
	var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
	function localeMeridiem (hours, minutes, isLower) {
	    if (hours > 11) {
	        return isLower ? 'pm' : 'PM';
	    } else {
	        return isLower ? 'am' : 'AM';
	    }
	}
	
	
	// MOMENTS
	
	// Setting the hour should keep the time, because the user explicitly
	// specified which hour he wants. So trying to maintain the same hour (in
	// a new timezone) makes sense. Adding/subtracting hours does not follow
	// this rule.
	var getSetHour = makeGetSet('Hours', true);
	
	// months
	// week
	// weekdays
	// meridiem
	var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    ordinalParse: defaultOrdinalParse,
	    relativeTime: defaultRelativeTime,
	
	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,
	
	    week: defaultLocaleWeek,
	
	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,
	
	    meridiemParse: defaultLocaleMeridiemParse
	};
	
	// internal storage for locale config files
	var locales = {};
	var localeFamilies = {};
	var globalLocale;
	
	function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	}
	
	// pick the locale from the array
	// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
	function chooseLocale(names) {
	    var i = 0, j, next, locale, split;
	
	    while (i < names.length) {
	        split = normalizeLocale(names[i]).split('-');
	        j = split.length;
	        next = normalizeLocale(names[i + 1]);
	        next = next ? next.split('-') : null;
	        while (j > 0) {
	            locale = loadLocale(split.slice(0, j).join('-'));
	            if (locale) {
	                return locale;
	            }
	            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	                //the next array item is better than a shallower substring of this one
	                break;
	            }
	            j--;
	        }
	        i++;
	    }
	    return null;
	}
	
	function loadLocale(name) {
	    var oldLocale = null;
	    // TODO: Find a better way to register and load all the locales in Node
	    if (!locales[name] && (typeof module !== 'undefined') &&
	            module && module.exports) {
	        try {
	            oldLocale = globalLocale._abbr;
	            __webpack_require__(/*! ./locale */ 313)("./" + name);
	            // because defineLocale currently also sets the global locale, we
	            // want to undo that for lazy loaded locales
	            getSetGlobalLocale(oldLocale);
	        } catch (e) { }
	    }
	    return locales[name];
	}
	
	// This function will load locale and then set the global locale.  If
	// no arguments are passed in, it will simply return the current global
	// locale key.
	function getSetGlobalLocale (key, values) {
	    var data;
	    if (key) {
	        if (isUndefined(values)) {
	            data = getLocale(key);
	        }
	        else {
	            data = defineLocale(key, values);
	        }
	
	        if (data) {
	            // moment.duration._locale = moment._locale = data;
	            globalLocale = data;
	        }
	    }
	
	    return globalLocale._abbr;
	}
	
	function defineLocale (name, config) {
	    if (config !== null) {
	        var parentConfig = baseConfig;
	        config.abbr = name;
	        if (locales[name] != null) {
	            deprecateSimple('defineLocaleOverride',
	                    'use moment.updateLocale(localeName, config) to change ' +
	                    'an existing locale. moment.defineLocale(localeName, ' +
	                    'config) should only be used for creating a new locale ' +
	                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	            parentConfig = locales[name]._config;
	        } else if (config.parentLocale != null) {
	            if (locales[config.parentLocale] != null) {
	                parentConfig = locales[config.parentLocale]._config;
	            } else {
	                if (!localeFamilies[config.parentLocale]) {
	                    localeFamilies[config.parentLocale] = [];
	                }
	                localeFamilies[config.parentLocale].push({
	                    name: name,
	                    config: config
	                });
	                return null;
	            }
	        }
	        locales[name] = new Locale(mergeConfigs(parentConfig, config));
	
	        if (localeFamilies[name]) {
	            localeFamilies[name].forEach(function (x) {
	                defineLocale(x.name, x.config);
	            });
	        }
	
	        // backwards compat for now: also set the locale
	        // make sure we set the locale AFTER all child locales have been
	        // created, so we won't end up with the child locale set.
	        getSetGlobalLocale(name);
	
	
	        return locales[name];
	    } else {
	        // useful for testing
	        delete locales[name];
	        return null;
	    }
	}
	
	function updateLocale(name, config) {
	    if (config != null) {
	        var locale, parentConfig = baseConfig;
	        // MERGE
	        if (locales[name] != null) {
	            parentConfig = locales[name]._config;
	        }
	        config = mergeConfigs(parentConfig, config);
	        locale = new Locale(config);
	        locale.parentLocale = locales[name];
	        locales[name] = locale;
	
	        // backwards compat for now: also set the locale
	        getSetGlobalLocale(name);
	    } else {
	        // pass null for config to unupdate, useful for tests
	        if (locales[name] != null) {
	            if (locales[name].parentLocale != null) {
	                locales[name] = locales[name].parentLocale;
	            } else if (locales[name] != null) {
	                delete locales[name];
	            }
	        }
	    }
	    return locales[name];
	}
	
	// returns locale data
	function getLocale (key) {
	    var locale;
	
	    if (key && key._locale && key._locale._abbr) {
	        key = key._locale._abbr;
	    }
	
	    if (!key) {
	        return globalLocale;
	    }
	
	    if (!isArray(key)) {
	        //short-circuit everything else
	        locale = loadLocale(key);
	        if (locale) {
	            return locale;
	        }
	        key = [key];
	    }
	
	    return chooseLocale(key);
	}
	
	function listLocales() {
	    return keys$1(locales);
	}
	
	function checkOverflow (m) {
	    var overflow;
	    var a = m._a;
	
	    if (a && getParsingFlags(m).overflow === -2) {
	        overflow =
	            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
	            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
	            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
	            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
	            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
	            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
	            -1;
	
	        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	            overflow = DATE;
	        }
	        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	            overflow = WEEK;
	        }
	        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	            overflow = WEEKDAY;
	        }
	
	        getParsingFlags(m).overflow = overflow;
	    }
	
	    return m;
	}
	
	// iso 8601 regex
	// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
	var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	
	var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	
	var isoDates = [
	    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
	    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
	    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
	    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
	    ['YYYY-DDD', /\d{4}-\d{3}/],
	    ['YYYY-MM', /\d{4}-\d\d/, false],
	    ['YYYYYYMMDD', /[+-]\d{10}/],
	    ['YYYYMMDD', /\d{8}/],
	    // YYYYMM is NOT allowed by the standard
	    ['GGGG[W]WWE', /\d{4}W\d{3}/],
	    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
	    ['YYYYDDD', /\d{7}/]
	];
	
	// iso time formats and regexes
	var isoTimes = [
	    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
	    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
	    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
	    ['HH:mm', /\d\d:\d\d/],
	    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
	    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
	    ['HHmmss', /\d\d\d\d\d\d/],
	    ['HHmm', /\d\d\d\d/],
	    ['HH', /\d\d/]
	];
	
	var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
	
	// date from iso format
	function configFromISO(config) {
	    var i, l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime, dateFormat, timeFormat, tzFormat;
	
	    if (match) {
	        getParsingFlags(config).iso = true;
	
	        for (i = 0, l = isoDates.length; i < l; i++) {
	            if (isoDates[i][1].exec(match[1])) {
	                dateFormat = isoDates[i][0];
	                allowTime = isoDates[i][2] !== false;
	                break;
	            }
	        }
	        if (dateFormat == null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[3]) {
	            for (i = 0, l = isoTimes.length; i < l; i++) {
	                if (isoTimes[i][1].exec(match[3])) {
	                    // match[2] should be 'T' or space
	                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
	                    break;
	                }
	            }
	            if (timeFormat == null) {
	                config._isValid = false;
	                return;
	            }
	        }
	        if (!allowTime && timeFormat != null) {
	            config._isValid = false;
	            return;
	        }
	        if (match[4]) {
	            if (tzRegex.exec(match[4])) {
	                tzFormat = 'Z';
	            } else {
	                config._isValid = false;
	                return;
	            }
	        }
	        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	        configFromStringAndFormat(config);
	    } else {
	        config._isValid = false;
	    }
	}
	
	// date from iso format or fallback
	function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);
	
	    if (matched !== null) {
	        config._d = new Date(+matched[1]);
	        return;
	    }
	
	    configFromISO(config);
	    if (config._isValid === false) {
	        delete config._isValid;
	        hooks.createFromInputFallback(config);
	    }
	}
	
	hooks.createFromInputFallback = deprecate(
	    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
	    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
	    'discouraged and will be removed in an upcoming major release. Please refer to ' +
	    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
	    function (config) {
	        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	    }
	);
	
	// Pick the first defined of two or three arguments.
	function defaults(a, b, c) {
	    if (a != null) {
	        return a;
	    }
	    if (b != null) {
	        return b;
	    }
	    return c;
	}
	
	function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());
	    if (config._useUTC) {
	        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }
	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	}
	
	// convert an array to a date.
	// the array should mirror the parameters below
	// note: all values past the year are optional and will default to the lowest possible value.
	// [year, month, day , hour, minute, second, millisecond]
	function configFromArray (config) {
	    var i, date, input = [], currentDate, yearToUse;
	
	    if (config._d) {
	        return;
	    }
	
	    currentDate = currentDateArray(config);
	
	    //compute day of the year from weeks and weekdays
	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	        dayOfYearFromWeekInfo(config);
	    }
	
	    //if the day of the year is set, figure out what it is
	    if (config._dayOfYear) {
	        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
	
	        if (config._dayOfYear > daysInYear(yearToUse)) {
	            getParsingFlags(config)._overflowDayOfYear = true;
	        }
	
	        date = createUTCDate(yearToUse, 0, config._dayOfYear);
	        config._a[MONTH] = date.getUTCMonth();
	        config._a[DATE] = date.getUTCDate();
	    }
	
	    // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything
	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	        config._a[i] = input[i] = currentDate[i];
	    }
	
	    // Zero out whatever was not defaulted, including time
	    for (; i < 7; i++) {
	        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
	    }
	
	    // Check for 24:00:00.000
	    if (config._a[HOUR] === 24 &&
	            config._a[MINUTE] === 0 &&
	            config._a[SECOND] === 0 &&
	            config._a[MILLISECOND] === 0) {
	        config._nextDay = true;
	        config._a[HOUR] = 0;
	    }
	
	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.
	    if (config._tzm != null) {
	        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }
	
	    if (config._nextDay) {
	        config._a[HOUR] = 24;
	    }
	}
	
	function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	
	    w = config._w;
	    if (w.GG != null || w.W != null || w.E != null) {
	        dow = 1;
	        doy = 4;
	
	        // TODO: We need to take the current isoWeekYear, but that depends on
	        // how we interpret now (local, utc, fixed offset). So create
	        // a now version of current config (take local/utc/offset flags, and
	        // create now).
	        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	        week = defaults(w.W, 1);
	        weekday = defaults(w.E, 1);
	        if (weekday < 1 || weekday > 7) {
	            weekdayOverflow = true;
	        }
	    } else {
	        dow = config._locale._week.dow;
	        doy = config._locale._week.doy;
	
	        var curWeek = weekOfYear(createLocal(), dow, doy);
	
	        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
	
	        // Default to current week.
	        week = defaults(w.w, curWeek.week);
	
	        if (w.d != null) {
	            // weekday -- low day numbers are considered next week
	            weekday = w.d;
	            if (weekday < 0 || weekday > 6) {
	                weekdayOverflow = true;
	            }
	        } else if (w.e != null) {
	            // local weekday -- counting starts from begining of week
	            weekday = w.e + dow;
	            if (w.e < 0 || w.e > 6) {
	                weekdayOverflow = true;
	            }
	        } else {
	            // default to begining of week
	            weekday = dow;
	        }
	    }
	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	        getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	        getParsingFlags(config)._overflowWeekday = true;
	    } else {
	        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	        config._a[YEAR] = temp.year;
	        config._dayOfYear = temp.dayOfYear;
	    }
	}
	
	// constant that refers to the ISO standard
	hooks.ISO_8601 = function () {};
	
	// date from string and format string
	function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	        configFromISO(config);
	        return;
	    }
	
	    config._a = [];
	    getParsingFlags(config).empty = true;
	
	    // This array is used to make a Date, either with `new Date` or `Date.UTC`
	    var string = '' + config._i,
	        i, parsedInput, tokens, token, skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;
	
	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
	
	    for (i = 0; i < tokens.length; i++) {
	        token = tokens[i];
	        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
	        // console.log('token', token, 'parsedInput', parsedInput,
	        //         'regex', getParseRegexForToken(token, config));
	        if (parsedInput) {
	            skipped = string.substr(0, string.indexOf(parsedInput));
	            if (skipped.length > 0) {
	                getParsingFlags(config).unusedInput.push(skipped);
	            }
	            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	            totalParsedInputLength += parsedInput.length;
	        }
	        // don't parse if it's not a known token
	        if (formatTokenFunctions[token]) {
	            if (parsedInput) {
	                getParsingFlags(config).empty = false;
	            }
	            else {
	                getParsingFlags(config).unusedTokens.push(token);
	            }
	            addTimeToArrayFromToken(token, parsedInput, config);
	        }
	        else if (config._strict && !parsedInput) {
	            getParsingFlags(config).unusedTokens.push(token);
	        }
	    }
	
	    // add remaining unparsed input length to the string
	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
	    if (string.length > 0) {
	        getParsingFlags(config).unusedInput.push(string);
	    }
	
	    // clear _12h flag if hour is <= 12
	    if (config._a[HOUR] <= 12 &&
	        getParsingFlags(config).bigHour === true &&
	        config._a[HOUR] > 0) {
	        getParsingFlags(config).bigHour = undefined;
	    }
	
	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem;
	    // handle meridiem
	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	
	    configFromArray(config);
	    checkOverflow(config);
	}
	
	
	function meridiemFixWrap (locale, hour, meridiem) {
	    var isPm;
	
	    if (meridiem == null) {
	        // nothing to do
	        return hour;
	    }
	    if (locale.meridiemHour != null) {
	        return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	        // Fallback
	        isPm = locale.isPM(meridiem);
	        if (isPm && hour < 12) {
	            hour += 12;
	        }
	        if (!isPm && hour === 12) {
	            hour = 0;
	        }
	        return hour;
	    } else {
	        // this is not supposed to happen
	        return hour;
	    }
	}
	
	// date from string and array of format strings
	function configFromStringAndArray(config) {
	    var tempConfig,
	        bestMoment,
	
	        scoreToBeat,
	        i,
	        currentScore;
	
	    if (config._f.length === 0) {
	        getParsingFlags(config).invalidFormat = true;
	        config._d = new Date(NaN);
	        return;
	    }
	
	    for (i = 0; i < config._f.length; i++) {
	        currentScore = 0;
	        tempConfig = copyConfig({}, config);
	        if (config._useUTC != null) {
	            tempConfig._useUTC = config._useUTC;
	        }
	        tempConfig._f = config._f[i];
	        configFromStringAndFormat(tempConfig);
	
	        if (!isValid(tempConfig)) {
	            continue;
	        }
	
	        // if there is any input that was not parsed add a penalty for that format
	        currentScore += getParsingFlags(tempConfig).charsLeftOver;
	
	        //or tokens
	        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	
	        getParsingFlags(tempConfig).score = currentScore;
	
	        if (scoreToBeat == null || currentScore < scoreToBeat) {
	            scoreToBeat = currentScore;
	            bestMoment = tempConfig;
	        }
	    }
	
	    extend(config, bestMoment || tempConfig);
	}
	
	function configFromObject(config) {
	    if (config._d) {
	        return;
	    }
	
	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	        return obj && parseInt(obj, 10);
	    });
	
	    configFromArray(config);
	}
	
	function createFromConfig (config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));
	    if (res._nextDay) {
	        // Adding is smart enough around DST
	        res.add(1, 'd');
	        res._nextDay = undefined;
	    }
	
	    return res;
	}
	
	function prepareConfig (config) {
	    var input = config._i,
	        format = config._f;
	
	    config._locale = config._locale || getLocale(config._l);
	
	    if (input === null || (format === undefined && input === '')) {
	        return createInvalid({nullInput: true});
	    }
	
	    if (typeof input === 'string') {
	        config._i = input = config._locale.preparse(input);
	    }
	
	    if (isMoment(input)) {
	        return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	        config._d = input;
	    } else if (isArray(format)) {
	        configFromStringAndArray(config);
	    } else if (format) {
	        configFromStringAndFormat(config);
	    }  else {
	        configFromInput(config);
	    }
	
	    if (!isValid(config)) {
	        config._d = null;
	    }
	
	    return config;
	}
	
	function configFromInput(config) {
	    var input = config._i;
	    if (input === undefined) {
	        config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	        config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	        configFromString(config);
	    } else if (isArray(input)) {
	        config._a = map(input.slice(0), function (obj) {
	            return parseInt(obj, 10);
	        });
	        configFromArray(config);
	    } else if (typeof(input) === 'object') {
	        configFromObject(config);
	    } else if (isNumber(input)) {
	        // from milliseconds
	        config._d = new Date(input);
	    } else {
	        hooks.createFromInputFallback(config);
	    }
	}
	
	function createLocalOrUTC (input, format, locale, strict, isUTC) {
	    var c = {};
	
	    if (locale === true || locale === false) {
	        strict = locale;
	        locale = undefined;
	    }
	
	    if ((isObject(input) && isObjectEmpty(input)) ||
	            (isArray(input) && input.length === 0)) {
	        input = undefined;
	    }
	    // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423
	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;
	
	    return createFromConfig(c);
	}
	
	function createLocal (input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	}
	
	var prototypeMin = deprecate(
	    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other < this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);
	
	var prototypeMax = deprecate(
	    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
	    function () {
	        var other = createLocal.apply(null, arguments);
	        if (this.isValid() && other.isValid()) {
	            return other > this ? this : other;
	        } else {
	            return createInvalid();
	        }
	    }
	);
	
	// Pick a moment m from moments so that m[fn](other) is true for all
	// other. This relies on the function fn to be transitive.
	//
	// moments should either be an array of moment objects or an array, whose
	// first element is an array of moment objects.
	function pickBy(fn, moments) {
	    var res, i;
	    if (moments.length === 1 && isArray(moments[0])) {
	        moments = moments[0];
	    }
	    if (!moments.length) {
	        return createLocal();
	    }
	    res = moments[0];
	    for (i = 1; i < moments.length; ++i) {
	        if (!moments[i].isValid() || moments[i][fn](res)) {
	            res = moments[i];
	        }
	    }
	    return res;
	}
	
	// TODO: Use [].sort instead?
	function min () {
	    var args = [].slice.call(arguments, 0);
	
	    return pickBy('isBefore', args);
	}
	
	function max () {
	    var args = [].slice.call(arguments, 0);
	
	    return pickBy('isAfter', args);
	}
	
	var now = function () {
	    return Date.now ? Date.now() : +(new Date());
	};
	
	function Duration (duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;
	
	    // representation for dateAddRemove
	    this._milliseconds = +milliseconds +
	        seconds * 1e3 + // 1000
	        minutes * 6e4 + // 1000 * 60
	        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately
	    this._days = +days +
	        weeks * 7;
	    // It is impossible translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.
	    this._months = +months +
	        quarters * 3 +
	        years * 12;
	
	    this._data = {};
	
	    this._locale = getLocale();
	
	    this._bubble();
	}
	
	function isDuration (obj) {
	    return obj instanceof Duration;
	}
	
	function absRound (number) {
	    if (number < 0) {
	        return Math.round(-1 * number) * -1;
	    } else {
	        return Math.round(number);
	    }
	}
	
	// FORMATTING
	
	function offset (token, separator) {
	    addFormatToken(token, 0, 0, function () {
	        var offset = this.utcOffset();
	        var sign = '+';
	        if (offset < 0) {
	            offset = -offset;
	            sign = '-';
	        }
	        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
	    });
	}
	
	offset('Z', ':');
	offset('ZZ', '');
	
	// PARSING
	
	addRegexToken('Z',  matchShortOffset);
	addRegexToken('ZZ', matchShortOffset);
	addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	});
	
	// HELPERS
	
	// timezone chunker
	// '+10:00' > ['10',  '00']
	// '-1530'  > ['-15', '30']
	var chunkOffset = /([\+\-]|\d\d)/gi;
	
	function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);
	
	    if (matches === null) {
	        return null;
	    }
	
	    var chunk   = matches[matches.length - 1] || [];
	    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);
	
	    return minutes === 0 ?
	      0 :
	      parts[0] === '+' ? minutes : -minutes;
	}
	
	// Return a moment from input, that is local/utc/zone equivalent to model.
	function cloneWithOffset(input, model) {
	    var res, diff;
	    if (model._isUTC) {
	        res = model.clone();
	        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
	        // Use low-level api, because this fn is low-level api.
	        res._d.setTime(res._d.valueOf() + diff);
	        hooks.updateOffset(res, false);
	        return res;
	    } else {
	        return createLocal(input).local();
	    }
	}
	
	function getDateOffset (m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	}
	
	// HOOKS
	
	// This function will be called whenever a moment is mutated.
	// It is intended to keep the offset in sync with the timezone.
	hooks.updateOffset = function () {};
	
	// MOMENTS
	
	// keepLocalTime = true means only change the timezone, without
	// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	// +0200, so we adjust the time as needed, to be valid.
	//
	// Keeping the time actually adds/subtracts (one hour)
	// from the actual represented time. That is why we call updateOffset
	// a second time. In case it wants us to change the offset again
	// _changeInProgress == true case, then we have to adjust, because
	// there is no such time in the given timezone.
	function getSetOffset (input, keepLocalTime) {
	    var offset = this._offset || 0,
	        localAdjust;
	    if (!this.isValid()) {
	        return input != null ? this : NaN;
	    }
	    if (input != null) {
	        if (typeof input === 'string') {
	            input = offsetFromString(matchShortOffset, input);
	            if (input === null) {
	                return this;
	            }
	        } else if (Math.abs(input) < 16) {
	            input = input * 60;
	        }
	        if (!this._isUTC && keepLocalTime) {
	            localAdjust = getDateOffset(this);
	        }
	        this._offset = input;
	        this._isUTC = true;
	        if (localAdjust != null) {
	            this.add(localAdjust, 'm');
	        }
	        if (offset !== input) {
	            if (!keepLocalTime || this._changeInProgress) {
	                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	            } else if (!this._changeInProgress) {
	                this._changeInProgress = true;
	                hooks.updateOffset(this, true);
	                this._changeInProgress = null;
	            }
	        }
	        return this;
	    } else {
	        return this._isUTC ? offset : getDateOffset(this);
	    }
	}
	
	function getSetZone (input, keepLocalTime) {
	    if (input != null) {
	        if (typeof input !== 'string') {
	            input = -input;
	        }
	
	        this.utcOffset(input, keepLocalTime);
	
	        return this;
	    } else {
	        return -this.utcOffset();
	    }
	}
	
	function setOffsetToUTC (keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	}
	
	function setOffsetToLocal (keepLocalTime) {
	    if (this._isUTC) {
	        this.utcOffset(0, keepLocalTime);
	        this._isUTC = false;
	
	        if (keepLocalTime) {
	            this.subtract(getDateOffset(this), 'm');
	        }
	    }
	    return this;
	}
	
	function setOffsetToParsedOffset () {
	    if (this._tzm != null) {
	        this.utcOffset(this._tzm);
	    } else if (typeof this._i === 'string') {
	        var tZone = offsetFromString(matchOffset, this._i);
	        if (tZone != null) {
	            this.utcOffset(tZone);
	        }
	        else {
	            this.utcOffset(0, true);
	        }
	    }
	    return this;
	}
	
	function hasAlignedHourOffset (input) {
	    if (!this.isValid()) {
	        return false;
	    }
	    input = input ? createLocal(input).utcOffset() : 0;
	
	    return (this.utcOffset() - input) % 60 === 0;
	}
	
	function isDaylightSavingTime () {
	    return (
	        this.utcOffset() > this.clone().month(0).utcOffset() ||
	        this.utcOffset() > this.clone().month(5).utcOffset()
	    );
	}
	
	function isDaylightSavingTimeShifted () {
	    if (!isUndefined(this._isDSTShifted)) {
	        return this._isDSTShifted;
	    }
	
	    var c = {};
	
	    copyConfig(c, this);
	    c = prepareConfig(c);
	
	    if (c._a) {
	        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	        this._isDSTShifted = this.isValid() &&
	            compareArrays(c._a, other.toArray()) > 0;
	    } else {
	        this._isDSTShifted = false;
	    }
	
	    return this._isDSTShifted;
	}
	
	function isLocal () {
	    return this.isValid() ? !this._isUTC : false;
	}
	
	function isUtcOffset () {
	    return this.isValid() ? this._isUTC : false;
	}
	
	function isUtc () {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	}
	
	// ASP.NET json date format regex
	var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
	
	// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	// and further modified to allow for strings containing both week and day
	var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
	
	function createDuration (input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	        match = null,
	        sign,
	        ret,
	        diffRes;
	
	    if (isDuration(input)) {
	        duration = {
	            ms : input._milliseconds,
	            d  : input._days,
	            M  : input._months
	        };
	    } else if (isNumber(input)) {
	        duration = {};
	        if (key) {
	            duration[key] = input;
	        } else {
	            duration.milliseconds = input;
	        }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y  : 0,
	            d  : toInt(match[DATE])                         * sign,
	            h  : toInt(match[HOUR])                         * sign,
	            m  : toInt(match[MINUTE])                       * sign,
	            s  : toInt(match[SECOND])                       * sign,
	            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
	        };
	    } else if (!!(match = isoRegex.exec(input))) {
	        sign = (match[1] === '-') ? -1 : 1;
	        duration = {
	            y : parseIso(match[2], sign),
	            M : parseIso(match[3], sign),
	            w : parseIso(match[4], sign),
	            d : parseIso(match[5], sign),
	            h : parseIso(match[6], sign),
	            m : parseIso(match[7], sign),
	            s : parseIso(match[8], sign)
	        };
	    } else if (duration == null) {// checks for null or undefined
	        duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
	
	        duration = {};
	        duration.ms = diffRes.milliseconds;
	        duration.M = diffRes.months;
	    }
	
	    ret = new Duration(duration);
	
	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	        ret._locale = input._locale;
	    }
	
	    return ret;
	}
	
	createDuration.fn = Duration.prototype;
	
	function parseIso (inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.'));
	    // apply sign while we're at it
	    return (isNaN(res) ? 0 : res) * sign;
	}
	
	function positiveMomentsDifference(base, other) {
	    var res = {milliseconds: 0, months: 0};
	
	    res.months = other.month() - base.month() +
	        (other.year() - base.year()) * 12;
	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	        --res.months;
	    }
	
	    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
	
	    return res;
	}
	
	function momentsDifference(base, other) {
	    var res;
	    if (!(base.isValid() && other.isValid())) {
	        return {milliseconds: 0, months: 0};
	    }
	
	    other = cloneWithOffset(other, base);
	    if (base.isBefore(other)) {
	        res = positiveMomentsDifference(base, other);
	    } else {
	        res = positiveMomentsDifference(other, base);
	        res.milliseconds = -res.milliseconds;
	        res.months = -res.months;
	    }
	
	    return res;
	}
	
	// TODO: remove 'name' arg after deprecation is removed
	function createAdder(direction, name) {
	    return function (val, period) {
	        var dur, tmp;
	        //invert the arguments, but complain about it
	        if (period !== null && !isNaN(+period)) {
	            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
	            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	            tmp = val; val = period; period = tmp;
	        }
	
	        val = typeof val === 'string' ? +val : val;
	        dur = createDuration(val, period);
	        addSubtract(this, dur, direction);
	        return this;
	    };
	}
	
	function addSubtract (mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);
	
	    if (!mom.isValid()) {
	        // No op
	        return;
	    }
	
	    updateOffset = updateOffset == null ? true : updateOffset;
	
	    if (milliseconds) {
	        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }
	    if (days) {
	        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }
	    if (months) {
	        setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }
	    if (updateOffset) {
	        hooks.updateOffset(mom, days || months);
	    }
	}
	
	var add      = createAdder(1, 'add');
	var subtract = createAdder(-1, 'subtract');
	
	function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' :
	            diff < -1 ? 'lastWeek' :
	            diff < 0 ? 'lastDay' :
	            diff < 1 ? 'sameDay' :
	            diff < 2 ? 'nextDay' :
	            diff < 7 ? 'nextWeek' : 'sameElse';
	}
	
	function calendar$1 (time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';
	
	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
	
	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	}
	
	function clone () {
	    return new Moment(this);
	}
	
	function isAfter (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() > localInput.valueOf();
	    } else {
	        return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	}
	
	function isBefore (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() < localInput.valueOf();
	    } else {
	        return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	}
	
	function isBetween (from, to, units, inclusivity) {
	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
	        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
	}
	
	function isSame (input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;
	    if (!(this.isValid() && localInput.isValid())) {
	        return false;
	    }
	    units = normalizeUnits(units || 'millisecond');
	    if (units === 'millisecond') {
	        return this.valueOf() === localInput.valueOf();
	    } else {
	        inputMs = localInput.valueOf();
	        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	}
	
	function isSameOrAfter (input, units) {
	    return this.isSame(input, units) || this.isAfter(input,units);
	}
	
	function isSameOrBefore (input, units) {
	    return this.isSame(input, units) || this.isBefore(input,units);
	}
	
	function diff (input, units, asFloat) {
	    var that,
	        zoneDelta,
	        delta, output;
	
	    if (!this.isValid()) {
	        return NaN;
	    }
	
	    that = cloneWithOffset(input, this);
	
	    if (!that.isValid()) {
	        return NaN;
	    }
	
	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	
	    units = normalizeUnits(units);
	
	    if (units === 'year' || units === 'month' || units === 'quarter') {
	        output = monthDiff(this, that);
	        if (units === 'quarter') {
	            output = output / 3;
	        } else if (units === 'year') {
	            output = output / 12;
	        }
	    } else {
	        delta = this - that;
	        output = units === 'second' ? delta / 1e3 : // 1000
	            units === 'minute' ? delta / 6e4 : // 1000 * 60
	            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
	            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
	            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
	            delta;
	    }
	    return asFloat ? output : absFloor(output);
	}
	
	function monthDiff (a, b) {
	    // difference in months
	    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	        anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2, adjust;
	
	    if (b - anchor < 0) {
	        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
	        // linear across the month
	        adjust = (b - anchor) / (anchor2 - anchor);
	    }
	
	    //check for negative zero, return zero if negative zero
	    return -(wholeMonthDiff + adjust) || 0;
	}
	
	hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
	
	function toString () {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	}
	
	function toISOString () {
	    var m = this.clone().utc();
	    if (0 < m.year() && m.year() <= 9999) {
	        if (isFunction(Date.prototype.toISOString)) {
	            // native implementation is ~50x faster, use it when we can
	            return this.toDate().toISOString();
	        } else {
	            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	        }
	    } else {
	        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
	    }
	}
	
	/**
	 * Return a human readable representation of a moment that can
	 * also be evaluated to get a new moment which is the same
	 *
	 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	 */
	function inspect () {
	    if (!this.isValid()) {
	        return 'moment.invalid(/* ' + this._i + ' */)';
	    }
	    var func = 'moment';
	    var zone = '';
	    if (!this.isLocal()) {
	        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	        zone = 'Z';
	    }
	    var prefix = '[' + func + '("]';
	    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';
	
	    return this.format(prefix + year + datetime + suffix);
	}
	
	function format (inputString) {
	    if (!inputString) {
	        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }
	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	}
	
	function from (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}
	
	function fromNow (withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	}
	
	function to (time, withoutSuffix) {
	    if (this.isValid() &&
	            ((isMoment(time) && time.isValid()) ||
	             createLocal(time).isValid())) {
	        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	        return this.localeData().invalidDate();
	    }
	}
	
	function toNow (withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	}
	
	// If passed a locale key, it will set the locale for this
	// instance.  Otherwise, it will return the locale configuration
	// variables for this instance.
	function locale (key) {
	    var newLocaleData;
	
	    if (key === undefined) {
	        return this._locale._abbr;
	    } else {
	        newLocaleData = getLocale(key);
	        if (newLocaleData != null) {
	            this._locale = newLocaleData;
	        }
	        return this;
	    }
	}
	
	var lang = deprecate(
	    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
	    function (key) {
	        if (key === undefined) {
	            return this.localeData();
	        } else {
	            return this.locale(key);
	        }
	    }
	);
	
	function localeData () {
	    return this._locale;
	}
	
	function startOf (units) {
	    units = normalizeUnits(units);
	    // the following switch intentionally omits break keywords
	    // to utilize falling through the cases.
	    switch (units) {
	        case 'year':
	            this.month(0);
	            /* falls through */
	        case 'quarter':
	        case 'month':
	            this.date(1);
	            /* falls through */
	        case 'week':
	        case 'isoWeek':
	        case 'day':
	        case 'date':
	            this.hours(0);
	            /* falls through */
	        case 'hour':
	            this.minutes(0);
	            /* falls through */
	        case 'minute':
	            this.seconds(0);
	            /* falls through */
	        case 'second':
	            this.milliseconds(0);
	    }
	
	    // weeks are a special case
	    if (units === 'week') {
	        this.weekday(0);
	    }
	    if (units === 'isoWeek') {
	        this.isoWeekday(1);
	    }
	
	    // quarters are also special
	    if (units === 'quarter') {
	        this.month(Math.floor(this.month() / 3) * 3);
	    }
	
	    return this;
	}
	
	function endOf (units) {
	    units = normalizeUnits(units);
	    if (units === undefined || units === 'millisecond') {
	        return this;
	    }
	
	    // 'date' is an alias for 'day', so it should be considered as such.
	    if (units === 'date') {
	        units = 'day';
	    }
	
	    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
	}
	
	function valueOf () {
	    return this._d.valueOf() - ((this._offset || 0) * 60000);
	}
	
	function unix () {
	    return Math.floor(this.valueOf() / 1000);
	}
	
	function toDate () {
	    return new Date(this.valueOf());
	}
	
	function toArray () {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	}
	
	function toObject () {
	    var m = this;
	    return {
	        years: m.year(),
	        months: m.month(),
	        date: m.date(),
	        hours: m.hours(),
	        minutes: m.minutes(),
	        seconds: m.seconds(),
	        milliseconds: m.milliseconds()
	    };
	}
	
	function toJSON () {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	}
	
	function isValid$1 () {
	    return isValid(this);
	}
	
	function parsingFlags () {
	    return extend({}, getParsingFlags(this));
	}
	
	function invalidAt () {
	    return getParsingFlags(this).overflow;
	}
	
	function creationData() {
	    return {
	        input: this._i,
	        format: this._f,
	        locale: this._locale,
	        isUTC: this._isUTC,
	        strict: this._strict
	    };
	}
	
	// FORMATTING
	
	addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	});
	
	addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	});
	
	function addWeekYearFormatToken (token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	}
	
	addWeekYearFormatToken('gggg',     'weekYear');
	addWeekYearFormatToken('ggggg',    'weekYear');
	addWeekYearFormatToken('GGGG',  'isoWeekYear');
	addWeekYearFormatToken('GGGGG', 'isoWeekYear');
	
	// ALIASES
	
	addUnitAlias('weekYear', 'gg');
	addUnitAlias('isoWeekYear', 'GG');
	
	// PRIORITY
	
	addUnitPriority('weekYear', 1);
	addUnitPriority('isoWeekYear', 1);
	
	
	// PARSING
	
	addRegexToken('G',      matchSigned);
	addRegexToken('g',      matchSigned);
	addRegexToken('GG',     match1to2, match2);
	addRegexToken('gg',     match1to2, match2);
	addRegexToken('GGGG',   match1to4, match4);
	addRegexToken('gggg',   match1to4, match4);
	addRegexToken('GGGGG',  match1to6, match6);
	addRegexToken('ggggg',  match1to6, match6);
	
	addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	});
	
	addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	});
	
	// MOMENTS
	
	function getSetWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input,
	            this.week(),
	            this.weekday(),
	            this.localeData()._week.dow,
	            this.localeData()._week.doy);
	}
	
	function getSetISOWeekYear (input) {
	    return getSetWeekYearHelper.call(this,
	            input, this.isoWeek(), this.isoWeekday(), 1, 4);
	}
	
	function getISOWeeksInYear () {
	    return weeksInYear(this.year(), 1, 4);
	}
	
	function getWeeksInYear () {
	    var weekInfo = this.localeData()._week;
	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	}
	
	function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;
	    if (input == null) {
	        return weekOfYear(this, dow, doy).year;
	    } else {
	        weeksTarget = weeksInYear(input, dow, doy);
	        if (week > weeksTarget) {
	            week = weeksTarget;
	        }
	        return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	}
	
	function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	
	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	}
	
	// FORMATTING
	
	addFormatToken('Q', 0, 'Qo', 'quarter');
	
	// ALIASES
	
	addUnitAlias('quarter', 'Q');
	
	// PRIORITY
	
	addUnitPriority('quarter', 7);
	
	// PARSING
	
	addRegexToken('Q', match1);
	addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	});
	
	// MOMENTS
	
	function getSetQuarter (input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	}
	
	// FORMATTING
	
	addFormatToken('D', ['DD', 2], 'Do', 'date');
	
	// ALIASES
	
	addUnitAlias('date', 'D');
	
	// PRIOROITY
	addUnitPriority('date', 9);
	
	// PARSING
	
	addRegexToken('D',  match1to2);
	addRegexToken('DD', match1to2, match2);
	addRegexToken('Do', function (isStrict, locale) {
	    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
	});
	
	addParseToken(['D', 'DD'], DATE);
	addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0], 10);
	});
	
	// MOMENTS
	
	var getSetDayOfMonth = makeGetSet('Date', true);
	
	// FORMATTING
	
	addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
	
	// ALIASES
	
	addUnitAlias('dayOfYear', 'DDD');
	
	// PRIORITY
	addUnitPriority('dayOfYear', 4);
	
	// PARSING
	
	addRegexToken('DDD',  match1to3);
	addRegexToken('DDDD', match3);
	addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	});
	
	// HELPERS
	
	// MOMENTS
	
	function getSetDayOfYear (input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
	}
	
	// FORMATTING
	
	addFormatToken('m', ['mm', 2], 0, 'minute');
	
	// ALIASES
	
	addUnitAlias('minute', 'm');
	
	// PRIORITY
	
	addUnitPriority('minute', 14);
	
	// PARSING
	
	addRegexToken('m',  match1to2);
	addRegexToken('mm', match1to2, match2);
	addParseToken(['m', 'mm'], MINUTE);
	
	// MOMENTS
	
	var getSetMinute = makeGetSet('Minutes', false);
	
	// FORMATTING
	
	addFormatToken('s', ['ss', 2], 0, 'second');
	
	// ALIASES
	
	addUnitAlias('second', 's');
	
	// PRIORITY
	
	addUnitPriority('second', 15);
	
	// PARSING
	
	addRegexToken('s',  match1to2);
	addRegexToken('ss', match1to2, match2);
	addParseToken(['s', 'ss'], SECOND);
	
	// MOMENTS
	
	var getSetSecond = makeGetSet('Seconds', false);
	
	// FORMATTING
	
	addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	});
	
	addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	});
	
	addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	});
	addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	});
	addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	});
	addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	});
	addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	});
	addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	});
	
	
	// ALIASES
	
	addUnitAlias('millisecond', 'ms');
	
	// PRIORITY
	
	addUnitPriority('millisecond', 16);
	
	// PARSING
	
	addRegexToken('S',    match1to3, match1);
	addRegexToken('SS',   match1to3, match2);
	addRegexToken('SSS',  match1to3, match3);
	
	var token;
	for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	}
	
	function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	}
	
	for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	}
	// MOMENTS
	
	var getSetMillisecond = makeGetSet('Milliseconds', false);
	
	// FORMATTING
	
	addFormatToken('z',  0, 0, 'zoneAbbr');
	addFormatToken('zz', 0, 0, 'zoneName');
	
	// MOMENTS
	
	function getZoneAbbr () {
	    return this._isUTC ? 'UTC' : '';
	}
	
	function getZoneName () {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	}
	
	var proto = Moment.prototype;
	
	proto.add               = add;
	proto.calendar          = calendar$1;
	proto.clone             = clone;
	proto.diff              = diff;
	proto.endOf             = endOf;
	proto.format            = format;
	proto.from              = from;
	proto.fromNow           = fromNow;
	proto.to                = to;
	proto.toNow             = toNow;
	proto.get               = stringGet;
	proto.invalidAt         = invalidAt;
	proto.isAfter           = isAfter;
	proto.isBefore          = isBefore;
	proto.isBetween         = isBetween;
	proto.isSame            = isSame;
	proto.isSameOrAfter     = isSameOrAfter;
	proto.isSameOrBefore    = isSameOrBefore;
	proto.isValid           = isValid$1;
	proto.lang              = lang;
	proto.locale            = locale;
	proto.localeData        = localeData;
	proto.max               = prototypeMax;
	proto.min               = prototypeMin;
	proto.parsingFlags      = parsingFlags;
	proto.set               = stringSet;
	proto.startOf           = startOf;
	proto.subtract          = subtract;
	proto.toArray           = toArray;
	proto.toObject          = toObject;
	proto.toDate            = toDate;
	proto.toISOString       = toISOString;
	proto.inspect           = inspect;
	proto.toJSON            = toJSON;
	proto.toString          = toString;
	proto.unix              = unix;
	proto.valueOf           = valueOf;
	proto.creationData      = creationData;
	
	// Year
	proto.year       = getSetYear;
	proto.isLeapYear = getIsLeapYear;
	
	// Week Year
	proto.weekYear    = getSetWeekYear;
	proto.isoWeekYear = getSetISOWeekYear;
	
	// Quarter
	proto.quarter = proto.quarters = getSetQuarter;
	
	// Month
	proto.month       = getSetMonth;
	proto.daysInMonth = getDaysInMonth;
	
	// Week
	proto.week           = proto.weeks        = getSetWeek;
	proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
	proto.weeksInYear    = getWeeksInYear;
	proto.isoWeeksInYear = getISOWeeksInYear;
	
	// Day
	proto.date       = getSetDayOfMonth;
	proto.day        = proto.days             = getSetDayOfWeek;
	proto.weekday    = getSetLocaleDayOfWeek;
	proto.isoWeekday = getSetISODayOfWeek;
	proto.dayOfYear  = getSetDayOfYear;
	
	// Hour
	proto.hour = proto.hours = getSetHour;
	
	// Minute
	proto.minute = proto.minutes = getSetMinute;
	
	// Second
	proto.second = proto.seconds = getSetSecond;
	
	// Millisecond
	proto.millisecond = proto.milliseconds = getSetMillisecond;
	
	// Offset
	proto.utcOffset            = getSetOffset;
	proto.utc                  = setOffsetToUTC;
	proto.local                = setOffsetToLocal;
	proto.parseZone            = setOffsetToParsedOffset;
	proto.hasAlignedHourOffset = hasAlignedHourOffset;
	proto.isDST                = isDaylightSavingTime;
	proto.isLocal              = isLocal;
	proto.isUtcOffset          = isUtcOffset;
	proto.isUtc                = isUtc;
	proto.isUTC                = isUtc;
	
	// Timezone
	proto.zoneAbbr = getZoneAbbr;
	proto.zoneName = getZoneName;
	
	// Deprecations
	proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
	
	function createUnix (input) {
	    return createLocal(input * 1000);
	}
	
	function createInZone () {
	    return createLocal.apply(null, arguments).parseZone();
	}
	
	function preParsePostFormat (string) {
	    return string;
	}
	
	var proto$1 = Locale.prototype;
	
	proto$1.calendar        = calendar;
	proto$1.longDateFormat  = longDateFormat;
	proto$1.invalidDate     = invalidDate;
	proto$1.ordinal         = ordinal;
	proto$1.preparse        = preParsePostFormat;
	proto$1.postformat      = preParsePostFormat;
	proto$1.relativeTime    = relativeTime;
	proto$1.pastFuture      = pastFuture;
	proto$1.set             = set;
	
	// Month
	proto$1.months            =        localeMonths;
	proto$1.monthsShort       =        localeMonthsShort;
	proto$1.monthsParse       =        localeMonthsParse;
	proto$1.monthsRegex       = monthsRegex;
	proto$1.monthsShortRegex  = monthsShortRegex;
	
	// Week
	proto$1.week = localeWeek;
	proto$1.firstDayOfYear = localeFirstDayOfYear;
	proto$1.firstDayOfWeek = localeFirstDayOfWeek;
	
	// Day of Week
	proto$1.weekdays       =        localeWeekdays;
	proto$1.weekdaysMin    =        localeWeekdaysMin;
	proto$1.weekdaysShort  =        localeWeekdaysShort;
	proto$1.weekdaysParse  =        localeWeekdaysParse;
	
	proto$1.weekdaysRegex       =        weekdaysRegex;
	proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
	proto$1.weekdaysMinRegex    =        weekdaysMinRegex;
	
	// Hours
	proto$1.isPM = localeIsPM;
	proto$1.meridiem = localeMeridiem;
	
	function get$1 (format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	}
	
	function listMonthsImpl (format, index, field) {
	    if (isNumber(format)) {
	        index = format;
	        format = undefined;
	    }
	
	    format = format || '';
	
	    if (index != null) {
	        return get$1(format, index, field, 'month');
	    }
	
	    var i;
	    var out = [];
	    for (i = 0; i < 12; i++) {
	        out[i] = get$1(format, i, field, 'month');
	    }
	    return out;
	}
	
	// ()
	// (5)
	// (fmt, 5)
	// (fmt)
	// (true)
	// (true, 5)
	// (true, fmt, 5)
	// (true, fmt)
	function listWeekdaysImpl (localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	    } else {
	        format = localeSorted;
	        index = format;
	        localeSorted = false;
	
	        if (isNumber(format)) {
	            index = format;
	            format = undefined;
	        }
	
	        format = format || '';
	    }
	
	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;
	
	    if (index != null) {
	        return get$1(format, (index + shift) % 7, field, 'day');
	    }
	
	    var i;
	    var out = [];
	    for (i = 0; i < 7; i++) {
	        out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }
	    return out;
	}
	
	function listMonths (format, index) {
	    return listMonthsImpl(format, index, 'months');
	}
	
	function listMonthsShort (format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	}
	
	function listWeekdays (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	}
	
	function listWeekdaysShort (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	}
	
	function listWeekdaysMin (localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	}
	
	getSetGlobalLocale('en', {
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (toInt(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});
	
	// Side effect imports
	hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
	
	var mathAbs = Math.abs;
	
	function abs () {
	    var data           = this._data;
	
	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days         = mathAbs(this._days);
	    this._months       = mathAbs(this._months);
	
	    data.milliseconds  = mathAbs(data.milliseconds);
	    data.seconds       = mathAbs(data.seconds);
	    data.minutes       = mathAbs(data.minutes);
	    data.hours         = mathAbs(data.hours);
	    data.months        = mathAbs(data.months);
	    data.years         = mathAbs(data.years);
	
	    return this;
	}
	
	function addSubtract$1 (duration, input, value, direction) {
	    var other = createDuration(input, value);
	
	    duration._milliseconds += direction * other._milliseconds;
	    duration._days         += direction * other._days;
	    duration._months       += direction * other._months;
	
	    return duration._bubble();
	}
	
	// supports only 2.0-style add(1, 's') or add(duration)
	function add$1 (input, value) {
	    return addSubtract$1(this, input, value, 1);
	}
	
	// supports only 2.0-style subtract(1, 's') or subtract(duration)
	function subtract$1 (input, value) {
	    return addSubtract$1(this, input, value, -1);
	}
	
	function absCeil (number) {
	    if (number < 0) {
	        return Math.floor(number);
	    } else {
	        return Math.ceil(number);
	    }
	}
	
	function bubble () {
	    var milliseconds = this._milliseconds;
	    var days         = this._days;
	    var months       = this._months;
	    var data         = this._data;
	    var seconds, minutes, hours, years, monthsFromDays;
	
	    // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166
	    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
	            (milliseconds <= 0 && days <= 0 && months <= 0))) {
	        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	        days = 0;
	        months = 0;
	    }
	
	    // The following code bubbles up values, see the tests for
	    // examples of what that means.
	    data.milliseconds = milliseconds % 1000;
	
	    seconds           = absFloor(milliseconds / 1000);
	    data.seconds      = seconds % 60;
	
	    minutes           = absFloor(seconds / 60);
	    data.minutes      = minutes % 60;
	
	    hours             = absFloor(minutes / 60);
	    data.hours        = hours % 24;
	
	    days += absFloor(hours / 24);
	
	    // convert days to months
	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays));
	
	    // 12 months -> 1 year
	    years = absFloor(months / 12);
	    months %= 12;
	
	    data.days   = days;
	    data.months = months;
	    data.years  = years;
	
	    return this;
	}
	
	function daysToMonths (days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	}
	
	function monthsToDays (months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	}
	
	function as (units) {
	    var days;
	    var months;
	    var milliseconds = this._milliseconds;
	
	    units = normalizeUnits(units);
	
	    if (units === 'month' || units === 'year') {
	        days   = this._days   + milliseconds / 864e5;
	        months = this._months + daysToMonths(days);
	        return units === 'month' ? months : months / 12;
	    } else {
	        // handle milliseconds separately because of floating point math errors (issue #1867)
	        days = this._days + Math.round(monthsToDays(this._months));
	        switch (units) {
	            case 'week'   : return days / 7     + milliseconds / 6048e5;
	            case 'day'    : return days         + milliseconds / 864e5;
	            case 'hour'   : return days * 24    + milliseconds / 36e5;
	            case 'minute' : return days * 1440  + milliseconds / 6e4;
	            case 'second' : return days * 86400 + milliseconds / 1000;
	            // Math.floor prevents floating point math errors here
	            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
	            default: throw new Error('Unknown unit ' + units);
	        }
	    }
	}
	
	// TODO: Use this.as('ms')?
	function valueOf$1 () {
	    return (
	        this._milliseconds +
	        this._days * 864e5 +
	        (this._months % 12) * 2592e6 +
	        toInt(this._months / 12) * 31536e6
	    );
	}
	
	function makeAs (alias) {
	    return function () {
	        return this.as(alias);
	    };
	}
	
	var asMilliseconds = makeAs('ms');
	var asSeconds      = makeAs('s');
	var asMinutes      = makeAs('m');
	var asHours        = makeAs('h');
	var asDays         = makeAs('d');
	var asWeeks        = makeAs('w');
	var asMonths       = makeAs('M');
	var asYears        = makeAs('y');
	
	function get$2 (units) {
	    units = normalizeUnits(units);
	    return this[units + 's']();
	}
	
	function makeGetter(name) {
	    return function () {
	        return this._data[name];
	    };
	}
	
	var milliseconds = makeGetter('milliseconds');
	var seconds      = makeGetter('seconds');
	var minutes      = makeGetter('minutes');
	var hours        = makeGetter('hours');
	var days         = makeGetter('days');
	var months       = makeGetter('months');
	var years        = makeGetter('years');
	
	function weeks () {
	    return absFloor(this.days() / 7);
	}
	
	var round = Math.round;
	var thresholds = {
	    s: 45,  // seconds to minute
	    m: 45,  // minutes to hour
	    h: 22,  // hours to day
	    d: 26,  // days to month
	    M: 11   // months to year
	};
	
	// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
	function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	}
	
	function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds  = round(duration.as('s'));
	    var minutes  = round(duration.as('m'));
	    var hours    = round(duration.as('h'));
	    var days     = round(duration.as('d'));
	    var months   = round(duration.as('M'));
	    var years    = round(duration.as('y'));
	
	    var a = seconds < thresholds.s && ['s', seconds]  ||
	            minutes <= 1           && ['m']           ||
	            minutes < thresholds.m && ['mm', minutes] ||
	            hours   <= 1           && ['h']           ||
	            hours   < thresholds.h && ['hh', hours]   ||
	            days    <= 1           && ['d']           ||
	            days    < thresholds.d && ['dd', days]    ||
	            months  <= 1           && ['M']           ||
	            months  < thresholds.M && ['MM', months]  ||
	            years   <= 1           && ['y']           || ['yy', years];
	
	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	}
	
	// This function allows you to set the rounding function for relative time strings
	function getSetRelativeTimeRounding (roundingFunction) {
	    if (roundingFunction === undefined) {
	        return round;
	    }
	    if (typeof(roundingFunction) === 'function') {
	        round = roundingFunction;
	        return true;
	    }
	    return false;
	}
	
	// This function allows you to set a threshold for relative time strings
	function getSetRelativeTimeThreshold (threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	        return false;
	    }
	    if (limit === undefined) {
	        return thresholds[threshold];
	    }
	    thresholds[threshold] = limit;
	    return true;
	}
	
	function humanize (withSuffix) {
	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);
	
	    if (withSuffix) {
	        output = locale.pastFuture(+this, output);
	    }
	
	    return locale.postformat(output);
	}
	
	var abs$1 = Math.abs;
	
	function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days         = abs$1(this._days);
	    var months       = abs$1(this._months);
	    var minutes, hours, years;
	
	    // 3600 seconds -> 60 minutes -> 1 hour
	    minutes           = absFloor(seconds / 60);
	    hours             = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60;
	
	    // 12 months -> 1 year
	    years  = absFloor(months / 12);
	    months %= 12;
	
	
	    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds;
	    var total = this.asSeconds();
	
	    if (!total) {
	        // this is the same as C#'s (Noda) and python (isodate)...
	        // but not other JS (goog.date)
	        return 'P0D';
	    }
	
	    return (total < 0 ? '-' : '') +
	        'P' +
	        (Y ? Y + 'Y' : '') +
	        (M ? M + 'M' : '') +
	        (D ? D + 'D' : '') +
	        ((h || m || s) ? 'T' : '') +
	        (h ? h + 'H' : '') +
	        (m ? m + 'M' : '') +
	        (s ? s + 'S' : '');
	}
	
	var proto$2 = Duration.prototype;
	
	proto$2.abs            = abs;
	proto$2.add            = add$1;
	proto$2.subtract       = subtract$1;
	proto$2.as             = as;
	proto$2.asMilliseconds = asMilliseconds;
	proto$2.asSeconds      = asSeconds;
	proto$2.asMinutes      = asMinutes;
	proto$2.asHours        = asHours;
	proto$2.asDays         = asDays;
	proto$2.asWeeks        = asWeeks;
	proto$2.asMonths       = asMonths;
	proto$2.asYears        = asYears;
	proto$2.valueOf        = valueOf$1;
	proto$2._bubble        = bubble;
	proto$2.get            = get$2;
	proto$2.milliseconds   = milliseconds;
	proto$2.seconds        = seconds;
	proto$2.minutes        = minutes;
	proto$2.hours          = hours;
	proto$2.days           = days;
	proto$2.weeks          = weeks;
	proto$2.months         = months;
	proto$2.years          = years;
	proto$2.humanize       = humanize;
	proto$2.toISOString    = toISOString$1;
	proto$2.toString       = toISOString$1;
	proto$2.toJSON         = toISOString$1;
	proto$2.locale         = locale;
	proto$2.localeData     = localeData;
	
	// Deprecations
	proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	proto$2.lang = lang;
	
	// Side effect imports
	
	// FORMATTING
	
	addFormatToken('X', 0, 0, 'unix');
	addFormatToken('x', 0, 0, 'valueOf');
	
	// PARSING
	
	addRegexToken('x', matchSigned);
	addRegexToken('X', matchTimestamp);
	addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	});
	addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	});
	
	// Side effect imports
	
	
	hooks.version = '2.17.0';
	
	setHookCallback(createLocal);
	
	hooks.fn                    = proto;
	hooks.min                   = min;
	hooks.max                   = max;
	hooks.now                   = now;
	hooks.utc                   = createUTC;
	hooks.unix                  = createUnix;
	hooks.months                = listMonths;
	hooks.isDate                = isDate;
	hooks.locale                = getSetGlobalLocale;
	hooks.invalid               = createInvalid;
	hooks.duration              = createDuration;
	hooks.isMoment              = isMoment;
	hooks.weekdays              = listWeekdays;
	hooks.parseZone             = createInZone;
	hooks.localeData            = getLocale;
	hooks.isDuration            = isDuration;
	hooks.monthsShort           = listMonthsShort;
	hooks.weekdaysMin           = listWeekdaysMin;
	hooks.defineLocale          = defineLocale;
	hooks.updateLocale          = updateLocale;
	hooks.locales               = listLocales;
	hooks.weekdaysShort         = listWeekdaysShort;
	hooks.normalizeUnits        = normalizeUnits;
	hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	hooks.calendarFormat        = getCalendarFormat;
	hooks.prototype             = proto;
	
	return hooks;
	
	})));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../webpack/buildin/module.js */ 312)(module)))

/***/ },
/* 312 */
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 313 */
/*!**********************************!*\
  !*** ./~/moment/locale ^\.\/.*$ ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./af": 314,
		"./af.js": 314,
		"./ar": 315,
		"./ar-dz": 316,
		"./ar-dz.js": 316,
		"./ar-ly": 317,
		"./ar-ly.js": 317,
		"./ar-ma": 318,
		"./ar-ma.js": 318,
		"./ar-sa": 319,
		"./ar-sa.js": 319,
		"./ar-tn": 320,
		"./ar-tn.js": 320,
		"./ar.js": 315,
		"./az": 321,
		"./az.js": 321,
		"./be": 322,
		"./be.js": 322,
		"./bg": 323,
		"./bg-x": 324,
		"./bg-x.js": 324,
		"./bg.js": 323,
		"./bn": 325,
		"./bn.js": 325,
		"./bo": 326,
		"./bo.js": 326,
		"./br": 327,
		"./br.js": 327,
		"./bs": 328,
		"./bs.js": 328,
		"./ca": 329,
		"./ca.js": 329,
		"./cs": 330,
		"./cs.js": 330,
		"./cv": 331,
		"./cv.js": 331,
		"./cy": 332,
		"./cy.js": 332,
		"./da": 333,
		"./da.js": 333,
		"./de": 334,
		"./de-at": 335,
		"./de-at.js": 335,
		"./de.js": 334,
		"./dv": 336,
		"./dv.js": 336,
		"./el": 337,
		"./el.js": 337,
		"./en-au": 338,
		"./en-au.js": 338,
		"./en-ca": 339,
		"./en-ca.js": 339,
		"./en-gb": 340,
		"./en-gb.js": 340,
		"./en-ie": 341,
		"./en-ie.js": 341,
		"./en-nz": 342,
		"./en-nz.js": 342,
		"./eo": 343,
		"./eo.js": 343,
		"./es": 344,
		"./es-do": 345,
		"./es-do.js": 345,
		"./es.js": 344,
		"./et": 346,
		"./et.js": 346,
		"./eu": 347,
		"./eu.js": 347,
		"./fa": 348,
		"./fa.js": 348,
		"./fi": 349,
		"./fi.js": 349,
		"./fo": 350,
		"./fo.js": 350,
		"./fr": 351,
		"./fr-ca": 352,
		"./fr-ca.js": 352,
		"./fr-ch": 353,
		"./fr-ch.js": 353,
		"./fr.js": 351,
		"./fy": 354,
		"./fy.js": 354,
		"./gd": 355,
		"./gd.js": 355,
		"./gl": 356,
		"./gl.js": 356,
		"./he": 357,
		"./he.js": 357,
		"./hi": 358,
		"./hi.js": 358,
		"./hr": 359,
		"./hr.js": 359,
		"./hu": 360,
		"./hu.js": 360,
		"./hy-am": 361,
		"./hy-am.js": 361,
		"./id": 362,
		"./id.js": 362,
		"./is": 363,
		"./is.js": 363,
		"./it": 364,
		"./it.js": 364,
		"./ja": 365,
		"./ja.js": 365,
		"./jv": 366,
		"./jv.js": 366,
		"./ka": 367,
		"./ka.js": 367,
		"./kk": 368,
		"./kk.js": 368,
		"./km": 369,
		"./km.js": 369,
		"./ko": 370,
		"./ko.js": 370,
		"./ky": 371,
		"./ky.js": 371,
		"./lb": 372,
		"./lb.js": 372,
		"./lo": 373,
		"./lo.js": 373,
		"./lt": 374,
		"./lt.js": 374,
		"./lv": 375,
		"./lv.js": 375,
		"./me": 376,
		"./me.js": 376,
		"./mi": 377,
		"./mi.js": 377,
		"./mk": 378,
		"./mk.js": 378,
		"./ml": 379,
		"./ml.js": 379,
		"./mr": 380,
		"./mr.js": 380,
		"./ms": 381,
		"./ms-my": 382,
		"./ms-my.js": 382,
		"./ms.js": 381,
		"./my": 383,
		"./my.js": 383,
		"./nb": 384,
		"./nb.js": 384,
		"./ne": 385,
		"./ne.js": 385,
		"./nl": 386,
		"./nl-be": 387,
		"./nl-be.js": 387,
		"./nl.js": 386,
		"./nn": 388,
		"./nn.js": 388,
		"./pa-in": 389,
		"./pa-in.js": 389,
		"./pl": 390,
		"./pl.js": 390,
		"./pt": 391,
		"./pt-br": 392,
		"./pt-br.js": 392,
		"./pt.js": 391,
		"./ro": 393,
		"./ro.js": 393,
		"./ru": 394,
		"./ru.js": 394,
		"./se": 395,
		"./se.js": 395,
		"./si": 396,
		"./si.js": 396,
		"./sk": 397,
		"./sk.js": 397,
		"./sl": 398,
		"./sl.js": 398,
		"./sq": 399,
		"./sq.js": 399,
		"./sr": 400,
		"./sr-cyrl": 401,
		"./sr-cyrl.js": 401,
		"./sr.js": 400,
		"./ss": 402,
		"./ss.js": 402,
		"./sv": 403,
		"./sv.js": 403,
		"./sw": 404,
		"./sw.js": 404,
		"./ta": 405,
		"./ta.js": 405,
		"./te": 406,
		"./te.js": 406,
		"./tet": 407,
		"./tet.js": 407,
		"./th": 408,
		"./th.js": 408,
		"./tl-ph": 409,
		"./tl-ph.js": 409,
		"./tlh": 410,
		"./tlh.js": 410,
		"./tr": 411,
		"./tr.js": 411,
		"./tzl": 412,
		"./tzl.js": 412,
		"./tzm": 413,
		"./tzm-latn": 414,
		"./tzm-latn.js": 414,
		"./tzm.js": 413,
		"./uk": 415,
		"./uk.js": 415,
		"./uz": 416,
		"./uz.js": 416,
		"./vi": 417,
		"./vi.js": 417,
		"./x-pseudo": 418,
		"./x-pseudo.js": 418,
		"./yo": 419,
		"./yo.js": 419,
		"./zh-cn": 420,
		"./zh-cn.js": 420,
		"./zh-hk": 421,
		"./zh-hk.js": 421,
		"./zh-tw": 422,
		"./zh-tw.js": 422
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 313;


/***/ },
/* 314 */
/*!*******************************!*\
  !*** ./~/moment/locale/af.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Afrikaans [af]
	//! author : Werner Mollentze : https://github.com/wernerm
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var af = moment.defineLocale('af', {
	    months : 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
	    weekdaysShort : 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
	    weekdaysMin : 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
	    meridiemParse: /vm|nm/i,
	    isPM : function (input) {
	        return /^nm$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'vm' : 'VM';
	        } else {
	            return isLower ? 'nm' : 'NM';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Vandag om] LT',
	        nextDay : '[Mre om] LT',
	        nextWeek : 'dddd [om] LT',
	        lastDay : '[Gister om] LT',
	        lastWeek : '[Laas] dddd [om] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'oor %s',
	        past : '%s gelede',
	        s : '\'n paar sekondes',
	        m : '\'n minuut',
	        mm : '%d minute',
	        h : '\'n uur',
	        hh : '%d ure',
	        d : '\'n dag',
	        dd : '%d dae',
	        M : '\'n maand',
	        MM : '%d maande',
	        y : '\'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
	    },
	    week : {
	        dow : 1, // Maandag is die eerste dag van die week.
	        doy : 4  // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
	    }
	});
	
	return af;
	
	})));


/***/ },
/* 315 */
/*!*******************************!*\
  !*** ./~/moment/locale/ar.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic [ar]
	//! author : Abdel Said: https://github.com/abdelsaid
	//! author : Ahmed Elkhatib
	//! author : forabi https://github.com/forabi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '  ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    ' ',
	    '  ',
	    '  ',
	    '  '
	];
	
	var ar = moment.defineLocale('ar', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ar;
	
	})));


/***/ },
/* 316 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-dz.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Algeria) [ar-dz]
	//! author : Noureddine LOUAHEDJ : https://github.com/noureddineme
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arDz = moment.defineLocale('ar-dz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 4  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arDz;
	
	})));


/***/ },
/* 317 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-ly.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Lybia) [ar-ly]
	//! author : Ali Hmer: https://github.com/kikoanis
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '1',
	    '2': '2',
	    '3': '3',
	    '4': '4',
	    '5': '5',
	    '6': '6',
	    '7': '7',
	    '8': '8',
	    '9': '9',
	    '0': '0'
	};
	var pluralForm = function (n) {
	    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
	};
	var plurals = {
	    s : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    m : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    h : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    d : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    M : ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
	    y : ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
	};
	var pluralize = function (u) {
	    return function (number, withoutSuffix, string, isFuture) {
	        var f = pluralForm(number),
	            str = plurals[u][pluralForm(number)];
	        if (f === 2) {
	            str = str[withoutSuffix ? 0 : 1];
	        }
	        return str.replace(/%d/i, number);
	    };
	};
	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	
	var arLy = moment.defineLocale('ar-ly', {
	    months : months,
	    monthsShort : months,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/\u200FM/\u200FYYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : pluralize('s'),
	        m : pluralize('m'),
	        mm : pluralize('m'),
	        h : pluralize('h'),
	        hh : pluralize('h'),
	        d : pluralize('d'),
	        dd : pluralize('d'),
	        M : pluralize('M'),
	        MM : pluralize('M'),
	        y : pluralize('y'),
	        yy : pluralize('y')
	    },
	    preparse: function (string) {
	        return string.replace(/\u200f/g, '').replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arLy;
	
	})));


/***/ },
/* 318 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-ma.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Morocco) [ar-ma]
	//! author : ElFadili Yassine : https://github.com/ElFadiliY
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arMa = moment.defineLocale('ar-ma', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arMa;
	
	})));


/***/ },
/* 319 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-sa.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Arabic (Saudi Arabia) [ar-sa]
	//! author : Suhail Alkowaileet : https://github.com/xsoh
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var arSa = moment.defineLocale('ar-sa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return arSa;
	
	})));


/***/ },
/* 320 */
/*!**********************************!*\
  !*** ./~/moment/locale/ar-tn.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale  :  Arabic (Tunisia) [ar-tn]
	//! author : Nader Toukabri : https://github.com/naderio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var arTn = moment.defineLocale('ar-tn', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[  ] LT',
	        nextDay: '[  ] LT',
	        nextWeek: 'dddd [ ] LT',
	        lastDay: '[  ] LT',
	        lastWeek: 'dddd [ ] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s',
	        past: ' %s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return arTn;
	
	})));


/***/ },
/* 321 */
/*!*******************************!*\
  !*** ./~/moment/locale/az.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Azerbaijani [az]
	//! author : topchiyev : https://github.com/topchiyev
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    1: '-inci',
	    5: '-inci',
	    8: '-inci',
	    70: '-inci',
	    80: '-inci',
	    2: '-nci',
	    7: '-nci',
	    20: '-nci',
	    50: '-nci',
	    3: '-nc',
	    4: '-nc',
	    100: '-nc',
	    6: '-nc',
	    9: '-uncu',
	    10: '-uncu',
	    30: '-uncu',
	    60: '-nc',
	    90: '-nc'
	};
	
	var az = moment.defineLocale('az', {
	    months : 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
	    monthsShort : 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
	    weekdays : 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
	    weekdaysShort : 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
	    weekdaysMin : 'Bz_BE_A__CA_C_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[sabah saat] LT',
	        nextWeek : '[gln hft] dddd [saat] LT',
	        lastDay : '[dnn] LT',
	        lastWeek : '[ken hft] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s vvl',
	        s : 'birne saniyy',
	        m : 'bir dqiq',
	        mm : '%d dqiq',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir il',
	        yy : '%d il'
	    },
	    meridiemParse: /gec|shr|gndz|axam/,
	    isPM : function (input) {
	        return /^(gndz|axam)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return 'gec';
	        } else if (hour < 12) {
	            return 'shr';
	        } else if (hour < 17) {
	            return 'gndz';
	        } else {
	            return 'axam';
	        }
	    },
	    ordinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '-nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return az;
	
	})));


/***/ },
/* 322 */
/*!*******************************!*\
  !*** ./~/moment/locale/be.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Belarusian [be]
	//! author : Dmitry Demidov : https://github.com/demidov91
	//! author: Praleska: http://praleska.pro/
	//! Author : Menelion Elensle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	
	var be = moment.defineLocale('be', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        format: '______'.split('_'),
	        standalone: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function () {
	            return '[] dddd [] LT';
	        },
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithPlural,
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return (number % 10 === 2 || number % 10 === 3) && (number % 100 !== 12 && number % 100 !== 13) ? number + '-' : number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return be;
	
	})));


/***/ },
/* 323 */
/*!*******************************!*\
  !*** ./~/moment/locale/bg.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bulgarian [bg]
	//! author : Krasen Borisov : https://github.com/kraz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var bg = moment.defineLocale('bg', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[ ] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[ ] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bg;
	
	})));


/***/ },
/* 324 */
/*!*********************************!*\
  !*** ./~/moment/locale/bg-x.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	var bgX = moment.defineLocale('bg-x', {
	    parentLocale: 'bg'
	});
	
	return bgX;
	
	})));


/***/ },
/* 325 */
/*!*******************************!*\
  !*** ./~/moment/locale/bn.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bengali [bn]
	//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var bn = moment.defineLocale('bn', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bn;
	
	})));


/***/ },
/* 326 */
/*!*******************************!*\
  !*** ./~/moment/locale/bo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tibetan [bo]
	//! author : Thupten N. Chakrishar : https://github.com/vajradog
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var bo = moment.defineLocale('bo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[], LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                (meridiem === '' && hour < 5) ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bo;
	
	})));


/***/ },
/* 327 */
/*!*******************************!*\
  !*** ./~/moment/locale/br.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Breton [br]
	//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function relativeTimeWithMutation(number, withoutSuffix, key) {
	    var format = {
	        'mm': 'munutenn',
	        'MM': 'miz',
	        'dd': 'devezh'
	    };
	    return number + ' ' + mutation(format[key], number);
	}
	function specialMutationForYears(number) {
	    switch (lastNumber(number)) {
	        case 1:
	        case 3:
	        case 4:
	        case 5:
	        case 9:
	            return number + ' bloaz';
	        default:
	            return number + ' vloaz';
	    }
	}
	function lastNumber(number) {
	    if (number > 9) {
	        return lastNumber(number % 10);
	    }
	    return number;
	}
	function mutation(text, number) {
	    if (number === 2) {
	        return softMutation(text);
	    }
	    return text;
	}
	function softMutation(text) {
	    var mutationTable = {
	        'm': 'v',
	        'b': 'v',
	        'd': 'z'
	    };
	    if (mutationTable[text.charAt(0)] === undefined) {
	        return text;
	    }
	    return mutationTable[text.charAt(0)] + text.substring(1);
	}
	
	var br = moment.defineLocale('br', {
	    months : 'Genver_C\'hwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
	    monthsShort : 'Gen_C\'hwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
	    weekdays : 'Sul_Lun_Meurzh_Merc\'her_Yaou_Gwener_Sadorn'.split('_'),
	    weekdaysShort : 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
	    weekdaysMin : 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h[e]mm A',
	        LTS : 'h[e]mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [a viz] MMMM YYYY',
	        LLL : 'D [a viz] MMMM YYYY h[e]mm A',
	        LLLL : 'dddd, D [a viz] MMMM YYYY h[e]mm A'
	    },
	    calendar : {
	        sameDay : '[Hiziv da] LT',
	        nextDay : '[Warc\'hoazh da] LT',
	        nextWeek : 'dddd [da] LT',
	        lastDay : '[Dec\'h da] LT',
	        lastWeek : 'dddd [paset da] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'a-benn %s',
	        past : '%s \'zo',
	        s : 'un nebeud segondenno',
	        m : 'ur vunutenn',
	        mm : relativeTimeWithMutation,
	        h : 'un eur',
	        hh : '%d eur',
	        d : 'un devezh',
	        dd : relativeTimeWithMutation,
	        M : 'ur miz',
	        MM : relativeTimeWithMutation,
	        y : 'ur bloaz',
	        yy : specialMutationForYears
	    },
	    ordinalParse: /\d{1,2}(a|vet)/,
	    ordinal : function (number) {
	        var output = (number === 1) ? 'a' : 'vet';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return br;
	
	})));


/***/ },
/* 328 */
/*!*******************************!*\
  !*** ./~/moment/locale/bs.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Bosnian [bs]
	//! author : Nedim Cholich : https://github.com/frontyard
	//! based on (hr) translation by Bojan Markovi
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}
	
	var bs = moment.defineLocale('bs', {
	    months : 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return bs;
	
	})));


/***/ },
/* 329 */
/*!*******************************!*\
  !*** ./~/moment/locale/ca.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Catalan [ca]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ca = moment.defineLocale('ca', {
	    months : 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
	    monthsShort : 'gen._febr._mar._abr._mai._jun._jul._ag._set._oct._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
	    weekdaysShort : 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
	    weekdaysMin : 'Dg_Dl_Dt_Dc_Dj_Dv_Ds'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[avui a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextDay : function () {
	            return '[dem a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastDay : function () {
	            return '[ahir a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [passat a ' + ((this.hours() !== 1) ? 'les' : 'la') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'd\'aqu %s',
	        past : 'fa %s',
	        s : 'uns segons',
	        m : 'un minut',
	        mm : '%d minuts',
	        h : 'una hora',
	        hh : '%d hores',
	        d : 'un dia',
	        dd : '%d dies',
	        M : 'un mes',
	        MM : '%d mesos',
	        y : 'un any',
	        yy : '%d anys'
	    },
	    ordinalParse: /\d{1,2}(r|n|t||a)/,
	    ordinal : function (number, period) {
	        var output = (number === 1) ? 'r' :
	            (number === 2) ? 'n' :
	            (number === 3) ? 'r' :
	            (number === 4) ? 't' : '';
	        if (period === 'w' || period === 'W') {
	            output = 'a';
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return ca;
	
	})));


/***/ },
/* 330 */
/*!*******************************!*\
  !*** ./~/moment/locale/cs.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Czech [cs]
	//! author : petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_');
	var monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5) && (~~(n / 10) !== 1);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr sekund' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minuta' : (isFuture ? 'minutu' : 'minutou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minuty' : 'minut');
	            } else {
	                return result + 'minutami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodin');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'den' : 'dnem';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dny' : 'dn');
	            } else {
	                return result + 'dny';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'msc' : 'mscem';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'msce' : 'msc');
	            } else {
	                return result + 'msci';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokem';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'let');
	            } else {
	                return result + 'lety';
	            }
	            break;
	    }
	}
	
	var cs = moment.defineLocale('cs', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParse : (function (months, monthsShort) {
	        var i, _monthsParse = [];
	        for (i = 0; i < 12; i++) {
	            // use custom parser to solve problem with July (ervenec)
	            _monthsParse[i] = new RegExp('^' + months[i] + '$|^' + monthsShort[i] + '$', 'i');
	        }
	        return _monthsParse;
	    }(months, monthsShort)),
	    shortMonthsParse : (function (monthsShort) {
	        var i, _shortMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _shortMonthsParse[i] = new RegExp('^' + monthsShort[i] + '$', 'i');
	        }
	        return _shortMonthsParse;
	    }(monthsShort)),
	    longMonthsParse : (function (months) {
	        var i, _longMonthsParse = [];
	        for (i = 0; i < 12; i++) {
	            _longMonthsParse[i] = new RegExp('^' + months[i] + '$', 'i');
	        }
	        return _longMonthsParse;
	    }(months)),
	    weekdays : 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
	    weekdaysShort : 'ne_po_t_st_t_p_so'.split('_'),
	    weekdaysMin : 'ne_po_t_st_t_p_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm',
	        l : 'D. M. YYYY'
	    },
	    calendar : {
	        sameDay: '[dnes v] LT',
	        nextDay: '[ztra v] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedli v] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [v] LT';
	                case 3:
	                    return '[ve stedu v] LT';
	                case 4:
	                    return '[ve tvrtek v] LT';
	                case 5:
	                    return '[v ptek v] LT';
	                case 6:
	                    return '[v sobotu v] LT';
	            }
	        },
	        lastDay: '[vera v] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minulou nedli v] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [v] LT';
	                case 3:
	                    return '[minulou stedu v] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [v] LT';
	                case 6:
	                    return '[minulou sobotu v] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'ped %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse : /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return cs;
	
	})));


/***/ },
/* 331 */
/*!*******************************!*\
  !*** ./~/moment/locale/cv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chuvash [cv]
	//! author : Anatoly Mironov : https://github.com/mirontoli
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var cv = moment.defineLocale('cv', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'YYYY [] MMMM [] D[-]',
	        LLL : 'YYYY [] MMMM [] D[-], HH:mm',
	        LLLL : 'dddd, YYYY [] MMMM [] D[-], HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT []',
	        nextDay: '[] LT []',
	        lastDay: '[] LT []',
	        nextWeek: '[] dddd LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (output) {
	            var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
	            return output + affix;
	        },
	        past : '%s ',
	        s : '- ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-/,
	    ordinal : '%d-',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return cv;
	
	})));


/***/ },
/* 332 */
/*!*******************************!*\
  !*** ./~/moment/locale/cy.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Welsh [cy]
	//! author : Robert Allen : https://github.com/robgallen
	//! author : https://github.com/ryangreaves
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var cy = moment.defineLocale('cy', {
	    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
	    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
	    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
	    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
	    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
	    weekdaysParseExact : true,
	    // time formats are the same as en-gb
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[Heddiw am] LT',
	        nextDay: '[Yfory am] LT',
	        nextWeek: 'dddd [am] LT',
	        lastDay: '[Ddoe am] LT',
	        lastWeek: 'dddd [diwethaf am] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'mewn %s',
	        past: '%s yn l',
	        s: 'ychydig eiliadau',
	        m: 'munud',
	        mm: '%d munud',
	        h: 'awr',
	        hh: '%d awr',
	        d: 'diwrnod',
	        dd: '%d diwrnod',
	        M: 'mis',
	        MM: '%d mis',
	        y: 'blwyddyn',
	        yy: '%d flynedd'
	    },
	    ordinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
	    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
	    ordinal: function (number) {
	        var b = number,
	            output = '',
	            lookup = [
	                '', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
	                'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
	            ];
	        if (b > 20) {
	            if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
	                output = 'fed'; // not 30ain, 70ain or 90ain
	            } else {
	                output = 'ain';
	            }
	        } else if (b > 0) {
	            output = lookup[b];
	        }
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return cy;
	
	})));


/***/ },
/* 333 */
/*!*******************************!*\
  !*** ./~/moment/locale/da.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Danish [da]
	//! author : Ulrik Nielsen : https://github.com/mrbase
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var da = moment.defineLocale('da', {
	    months : 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_man_tir_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd [d.] D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[I dag kl.] LT',
	        nextDay : '[I morgen kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[I gr kl.] LT',
	        lastWeek : '[sidste] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'f sekunder',
	        m : 'et minut',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dage',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'et r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return da;
	
	})));


/***/ },
/* 334 */
/*!*******************************!*\
  !*** ./~/moment/locale/de.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German [de]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	
	var de = moment.defineLocale('de', {
	    months : 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jan._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return de;
	
	})));


/***/ },
/* 335 */
/*!**********************************!*\
  !*** ./~/moment/locale/de-at.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : German (Austria) [de-at]
	//! author : lluchs : https://github.com/lluchs
	//! author: Menelion Elensle: https://github.com/Oire
	//! author : Martin Groller : https://github.com/MadMG
	//! author : Mikolaj Dadela : https://github.com/mik01aj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eine Minute', 'einer Minute'],
	        'h': ['eine Stunde', 'einer Stunde'],
	        'd': ['ein Tag', 'einem Tag'],
	        'dd': [number + ' Tage', number + ' Tagen'],
	        'M': ['ein Monat', 'einem Monat'],
	        'MM': [number + ' Monate', number + ' Monaten'],
	        'y': ['ein Jahr', 'einem Jahr'],
	        'yy': [number + ' Jahre', number + ' Jahren']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	
	var deAt = moment.defineLocale('de-at', {
	    months : 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort : 'Jn._Febr._Mrz._Apr._Mai_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
	    weekdaysShort : 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
	    weekdaysMin : 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY HH:mm',
	        LLLL : 'dddd, D. MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[heute um] LT [Uhr]',
	        sameElse: 'L',
	        nextDay: '[morgen um] LT [Uhr]',
	        nextWeek: 'dddd [um] LT [Uhr]',
	        lastDay: '[gestern um] LT [Uhr]',
	        lastWeek: '[letzten] dddd [um] LT [Uhr]'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : 'vor %s',
	        s : 'ein paar Sekunden',
	        m : processRelativeTime,
	        mm : '%d Minuten',
	        h : processRelativeTime,
	        hh : '%d Stunden',
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return deAt;
	
	})));


/***/ },
/* 336 */
/*!*******************************!*\
  !*** ./~/moment/locale/dv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maldivian [dv]
	//! author : Jawish Hameed : https://github.com/jawish
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	var weekdays = [
	    '',
	    '',
	    '',
	    '',
	    '',
	    '',
	    ''
	];
	
	var dv = moment.defineLocale('dv', {
	    months : months,
	    monthsShort : months,
	    weekdays : weekdays,
	    weekdaysShort : weekdays,
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'D/M/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM : function (input) {
	        return '' === input;
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    preparse: function (string) {
	        return string.replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/,/g, '');
	    },
	    week : {
	        dow : 7,  // Sunday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return dv;
	
	})));


/***/ },
/* 337 */
/*!*******************************!*\
  !*** ./~/moment/locale/el.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Greek [el]
	//! author : Aggelos Karalias : https://github.com/mehiel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	}
	
	
	var el = moment.defineLocale('el', {
	    monthsNominativeEl : '___________'.split('_'),
	    monthsGenitiveEl : '___________'.split('_'),
	    months : function (momentToFormat, format) {
	        if (/D/.test(format.substring(0, format.indexOf('MMMM')))) { // if there is a day number before 'MMMM'
	            return this._monthsGenitiveEl[momentToFormat.month()];
	        } else {
	            return this._monthsNominativeEl[momentToFormat.month()];
	        }
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '' : '';
	        } else {
	            return isLower ? '' : '';
	        }
	    },
	    isPM : function (input) {
	        return ((input + '').toLowerCase()[0] === '');
	    },
	    meridiemParse : /[]\.??\.?/i,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendarEl : {
	        sameDay : '[ {}] LT',
	        nextDay : '[ {}] LT',
	        nextWeek : 'dddd [{}] LT',
	        lastDay : '[ {}] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 6:
	                    return '[ ] dddd [{}] LT';
	                default:
	                    return '[ ] dddd [{}] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    calendar : function (key, mom) {
	        var output = this._calendarEl[key],
	            hours = mom && mom.hours();
	        if (isFunction(output)) {
	            output = output.apply(mom);
	        }
	        return output.replace('{}', (hours % 12 === 1 ? '' : ''));
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4st is the first week of the year.
	    }
	});
	
	return el;
	
	})));


/***/ },
/* 338 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-au.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Australia) [en-au]
	//! author : Jared Morse : https://github.com/jarcoal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enAu = moment.defineLocale('en-au', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enAu;
	
	})));


/***/ },
/* 339 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-ca.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Canada) [en-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enCa = moment.defineLocale('en-ca', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'YYYY-MM-DD',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY h:mm A',
	        LLLL : 'dddd, MMMM D, YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    }
	});
	
	return enCa;
	
	})));


/***/ },
/* 340 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-gb.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (United Kingdom) [en-gb]
	//! author : Chris Gedrim : https://github.com/chrisgedrim
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enGb = moment.defineLocale('en-gb', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enGb;
	
	})));


/***/ },
/* 341 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-ie.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (Ireland) [en-ie]
	//! author : Chris Cartlidge : https://github.com/chriscartlidge
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enIe = moment.defineLocale('en-ie', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enIe;
	
	})));


/***/ },
/* 342 */
/*!**********************************!*\
  !*** ./~/moment/locale/en-nz.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : English (New Zealand) [en-nz]
	//! author : Luke McGregor : https://github.com/lukemcgregor
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var enNz = moment.defineLocale('en-nz', {
	    months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
	    weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
	    weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
	    weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Today at] LT',
	        nextDay : '[Tomorrow at] LT',
	        nextWeek : 'dddd [at] LT',
	        lastDay : '[Yesterday at] LT',
	        lastWeek : '[Last] dddd [at] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'in %s',
	        past : '%s ago',
	        s : 'a few seconds',
	        m : 'a minute',
	        mm : '%d minutes',
	        h : 'an hour',
	        hh : '%d hours',
	        d : 'a day',
	        dd : '%d days',
	        M : 'a month',
	        MM : '%d months',
	        y : 'a year',
	        yy : '%d years'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return enNz;
	
	})));


/***/ },
/* 343 */
/*!*******************************!*\
  !*** ./~/moment/locale/eo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Esperanto [eo]
	//! author : Colin Dean : https://github.com/colindean
	//! komento: Mi estas malcerta se mi korekte traktis akuzativojn en tiu traduko.
	//!          Se ne, bonvolu korekti kaj avizi min por ke mi povas lerni!
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var eo = moment.defineLocale('eo', {
	    months : 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_ag_sep_okt_nov_dec'.split('_'),
	    weekdays : 'Dimano_Lundo_Mardo_Merkredo_ado_Vendredo_Sabato'.split('_'),
	    weekdaysShort : 'Dim_Lun_Mard_Merk_a_Ven_Sab'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_a_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D[-an de] MMMM, YYYY',
	        LLL : 'D[-an de] MMMM, YYYY HH:mm',
	        LLLL : 'dddd, [la] D[-an de] MMMM, YYYY HH:mm'
	    },
	    meridiemParse: /[ap]\.t\.m/i,
	    isPM: function (input) {
	        return input.charAt(0).toLowerCase() === 'p';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'p.t.m.' : 'P.T.M.';
	        } else {
	            return isLower ? 'a.t.m.' : 'A.T.M.';
	        }
	    },
	    calendar : {
	        sameDay : '[Hodia je] LT',
	        nextDay : '[Morga je] LT',
	        nextWeek : 'dddd [je] LT',
	        lastDay : '[Hiera je] LT',
	        lastWeek : '[pasinta] dddd [je] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'je %s',
	        past : 'anta %s',
	        s : 'sekundoj',
	        m : 'minuto',
	        mm : '%d minutoj',
	        h : 'horo',
	        hh : '%d horoj',
	        d : 'tago',//ne 'diurno', ar estas uzita por proksimumo
	        dd : '%d tagoj',
	        M : 'monato',
	        MM : '%d monatoj',
	        y : 'jaro',
	        yy : '%d jaroj'
	    },
	    ordinalParse: /\d{1,2}a/,
	    ordinal : '%da',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return eo;
	
	})));


/***/ },
/* 344 */
/*!*******************************!*\
  !*** ./~/moment/locale/es.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish [es]
	//! author : Julio Napur : https://github.com/julionc
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	var es = moment.defineLocale('es', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return es;
	
	})));


/***/ },
/* 345 */
/*!**********************************!*\
  !*** ./~/moment/locale/es-do.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Spanish (Dominican Republic) [es-do]
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_');
	var monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_');
	
	var esDo = moment.defineLocale('es-do', {
	    months : 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShort[m.month()];
	        } else {
	            return monthsShortDot[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_mi_ju_vi_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY h:mm A',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoy a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[maana a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastDay : function () {
	            return '[ayer a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        lastWeek : function () {
	            return '[el] dddd [pasado a la' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'en %s',
	        past : 'hace %s',
	        s : 'unos segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'una hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ao',
	        yy : '%d aos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return esDo;
	
	})));


/***/ },
/* 346 */
/*!*******************************!*\
  !*** ./~/moment/locale/et.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Estonian [et]
	//! author : Henry Kehlmann : https://github.com/madhenry
	//! improvements : Illimar Tambek : https://github.com/ragulka
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's' : ['mne sekundi', 'mni sekund', 'paar sekundit'],
	        'm' : ['he minuti', 'ks minut'],
	        'mm': [number + ' minuti', number + ' minutit'],
	        'h' : ['he tunni', 'tund aega', 'ks tund'],
	        'hh': [number + ' tunni', number + ' tundi'],
	        'd' : ['he peva', 'ks pev'],
	        'M' : ['kuu aja', 'kuu aega', 'ks kuu'],
	        'MM': [number + ' kuu', number + ' kuud'],
	        'y' : ['he aasta', 'aasta', 'ks aasta'],
	        'yy': [number + ' aasta', number + ' aastat']
	    };
	    if (withoutSuffix) {
	        return format[key][2] ? format[key][2] : format[key][1];
	    }
	    return isFuture ? format[key][0] : format[key][1];
	}
	
	var et = moment.defineLocale('et', {
	    months        : 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
	    monthsShort   : 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
	    weekdays      : 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
	    weekdaysShort : 'P_E_T_K_N_R_L'.split('_'),
	    weekdaysMin   : 'P_E_T_K_N_R_L'.split('_'),
	    longDateFormat : {
	        LT   : 'H:mm',
	        LTS : 'H:mm:ss',
	        L    : 'DD.MM.YYYY',
	        LL   : 'D. MMMM YYYY',
	        LLL  : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[Tna,] LT',
	        nextDay  : '[Homme,] LT',
	        nextWeek : '[Jrgmine] dddd LT',
	        lastDay  : '[Eile,] LT',
	        lastWeek : '[Eelmine] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s prast',
	        past   : '%s tagasi',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : '%d peva',
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return et;
	
	})));


/***/ },
/* 347 */
/*!*******************************!*\
  !*** ./~/moment/locale/eu.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Basque [eu]
	//! author : Eneko Illarramendi : https://github.com/eillarra
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var eu = moment.defineLocale('eu', {
	    months : 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
	    monthsShort : 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
	    weekdaysShort : 'ig._al._ar._az._og._ol._lr.'.split('_'),
	    weekdaysMin : 'ig_al_ar_az_og_ol_lr'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY[ko] MMMM[ren] D[a]',
	        LLL : 'YYYY[ko] MMMM[ren] D[a] HH:mm',
	        LLLL : 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
	        l : 'YYYY-M-D',
	        ll : 'YYYY[ko] MMM D[a]',
	        lll : 'YYYY[ko] MMM D[a] HH:mm',
	        llll : 'ddd, YYYY[ko] MMM D[a] HH:mm'
	    },
	    calendar : {
	        sameDay : '[gaur] LT[etan]',
	        nextDay : '[bihar] LT[etan]',
	        nextWeek : 'dddd LT[etan]',
	        lastDay : '[atzo] LT[etan]',
	        lastWeek : '[aurreko] dddd LT[etan]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s barru',
	        past : 'duela %s',
	        s : 'segundo batzuk',
	        m : 'minutu bat',
	        mm : '%d minutu',
	        h : 'ordu bat',
	        hh : '%d ordu',
	        d : 'egun bat',
	        dd : '%d egun',
	        M : 'hilabete bat',
	        MM : '%d hilabete',
	        y : 'urte bat',
	        yy : '%d urte'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return eu;
	
	})));


/***/ },
/* 348 */
/*!*******************************!*\
  !*** ./~/moment/locale/fa.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Persian [fa]
	//! author : Ebrahim Byagowi : https://github.com/ebraminio
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var fa = moment.defineLocale('fa', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysShort : '\u200c__\u200c__\u200c__'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /  |  /,
	    isPM: function (input) {
	        return /  /.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '  ';
	        } else {
	            return '  ';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : 'dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[-]/g, function (match) {
	            return numberMap[match];
	        }).replace(//g, ',');
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        }).replace(/,/g, '');
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12 // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return fa;
	
	})));


/***/ },
/* 349 */
/*!*******************************!*\
  !*** ./~/moment/locale/fi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Finnish [fi]
	//! author : Tarmo Aidantausta : https://github.com/bleadof
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' ');
	var numbersFuture = [
	        'nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden',
	        numbersPast[7], numbersPast[8], numbersPast[9]
	    ];
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = '';
	    switch (key) {
	        case 's':
	            return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';
	        case 'm':
	            return isFuture ? 'minuutin' : 'minuutti';
	        case 'mm':
	            result = isFuture ? 'minuutin' : 'minuuttia';
	            break;
	        case 'h':
	            return isFuture ? 'tunnin' : 'tunti';
	        case 'hh':
	            result = isFuture ? 'tunnin' : 'tuntia';
	            break;
	        case 'd':
	            return isFuture ? 'pivn' : 'piv';
	        case 'dd':
	            result = isFuture ? 'pivn' : 'piv';
	            break;
	        case 'M':
	            return isFuture ? 'kuukauden' : 'kuukausi';
	        case 'MM':
	            result = isFuture ? 'kuukauden' : 'kuukautta';
	            break;
	        case 'y':
	            return isFuture ? 'vuoden' : 'vuosi';
	        case 'yy':
	            result = isFuture ? 'vuoden' : 'vuotta';
	            break;
	    }
	    result = verbalNumber(number, isFuture) + ' ' + result;
	    return result;
	}
	function verbalNumber(number, isFuture) {
	    return number < 10 ? (isFuture ? numbersFuture[number] : numbersPast[number]) : number;
	}
	
	var fi = moment.defineLocale('fi', {
	    months : 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
	    monthsShort : 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
	    weekdays : 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
	    weekdaysShort : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    weekdaysMin : 'su_ma_ti_ke_to_pe_la'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'Do MMMM[ta] YYYY',
	        LLL : 'Do MMMM[ta] YYYY, [klo] HH.mm',
	        LLLL : 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
	        l : 'D.M.YYYY',
	        ll : 'Do MMM YYYY',
	        lll : 'Do MMM YYYY, [klo] HH.mm',
	        llll : 'ddd, Do MMM YYYY, [klo] HH.mm'
	    },
	    calendar : {
	        sameDay : '[tnn] [klo] LT',
	        nextDay : '[huomenna] [klo] LT',
	        nextWeek : 'dddd [klo] LT',
	        lastDay : '[eilen] [klo] LT',
	        lastWeek : '[viime] dddd[na] [klo] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s pst',
	        past : '%s sitten',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fi;
	
	})));


/***/ },
/* 350 */
/*!*******************************!*\
  !*** ./~/moment/locale/fo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Faroese [fo]
	//! author : Ragnar Johannesen : https://github.com/ragnar123
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var fo = moment.defineLocale('fo', {
	    months : 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
	    weekdaysMin : 'su_m_t_mi_h_fr_le'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D. MMMM, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgin kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gjr kl.] LT',
	        lastWeek : '[sstu] dddd [kl] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'um %s',
	        past : '%s sani',
	        s : 'f sekund',
	        m : 'ein minutt',
	        mm : '%d minuttir',
	        h : 'ein tmi',
	        hh : '%d tmar',
	        d : 'ein dagur',
	        dd : '%d dagar',
	        M : 'ein mnai',
	        MM : '%d mnair',
	        y : 'eitt r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fo;
	
	})));


/***/ },
/* 351 */
/*!*******************************!*\
  !*** ./~/moment/locale/fr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French [fr]
	//! author : John Fischer : https://github.com/jfroffice
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var fr = moment.defineLocale('fr', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : '');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fr;
	
	})));


/***/ },
/* 352 */
/*!**********************************!*\
  !*** ./~/moment/locale/fr-ca.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Canada) [fr-ca]
	//! author : Jonathan Abourbih : https://github.com/jonbca
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var frCa = moment.defineLocale('fr-ca', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    }
	});
	
	return frCa;
	
	})));


/***/ },
/* 353 */
/*!**********************************!*\
  !*** ./~/moment/locale/fr-ch.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : French (Switzerland) [fr-ch]
	//! author : Gaspard Bucher : https://github.com/gaspard
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var frCh = moment.defineLocale('fr-ch', {
	    months : 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
	    monthsShort : 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
	    weekdaysShort : 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
	    weekdaysMin : 'Di_Lu_Ma_Me_Je_Ve_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Aujourd\'hui ] LT',
	        nextDay: '[Demain ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[Hier ] LT',
	        lastWeek: 'dddd [dernier ] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dans %s',
	        past : 'il y a %s',
	        s : 'quelques secondes',
	        m : 'une minute',
	        mm : '%d minutes',
	        h : 'une heure',
	        hh : '%d heures',
	        d : 'un jour',
	        dd : '%d jours',
	        M : 'un mois',
	        MM : '%d mois',
	        y : 'un an',
	        yy : '%d ans'
	    },
	    ordinalParse: /\d{1,2}(er|e)/,
	    ordinal : function (number) {
	        return number + (number === 1 ? 'er' : 'e');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return frCh;
	
	})));


/***/ },
/* 354 */
/*!*******************************!*\
  !*** ./~/moment/locale/fy.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Frisian [fy]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
	
	var fy = moment.defineLocale('fy', {
	    months : 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	    monthsParseExact : true,
	    weekdays : 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
	    weekdaysShort : 'si._mo._ti._wo._to._fr._so.'.split('_'),
	    weekdaysMin : 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[hjoed om] LT',
	        nextDay: '[moarn om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[juster om] LT',
	        lastWeek: '[frne] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'oer %s',
	        past : '%s lyn',
	        s : 'in pear sekonden',
	        m : 'ien mint',
	        mm : '%d minuten',
	        h : 'ien oere',
	        hh : '%d oeren',
	        d : 'ien dei',
	        dd : '%d dagen',
	        M : 'ien moanne',
	        MM : '%d moannen',
	        y : 'ien jier',
	        yy : '%d jierren'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return fy;
	
	})));


/***/ },
/* 355 */
/*!*******************************!*\
  !*** ./~/moment/locale/gd.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Scottish Gaelic [gd]
	//! author : Jon Ashdown : https://github.com/jonashdown
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = [
	    'Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'
	];
	
	var monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'];
	
	var weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'];
	
	var weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'];
	
	var weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
	
	var gd = moment.defineLocale('gd', {
	    months : months,
	    monthsShort : monthsShort,
	    monthsParseExact : true,
	    weekdays : weekdays,
	    weekdaysShort : weekdaysShort,
	    weekdaysMin : weekdaysMin,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[An-diugh aig] LT',
	        nextDay : '[A-mireach aig] LT',
	        nextWeek : 'dddd [aig] LT',
	        lastDay : '[An-d aig] LT',
	        lastWeek : 'dddd [seo chaidh] [aig] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ann an %s',
	        past : 'bho chionn %s',
	        s : 'beagan diogan',
	        m : 'mionaid',
	        mm : '%d mionaidean',
	        h : 'uair',
	        hh : '%d uairean',
	        d : 'latha',
	        dd : '%d latha',
	        M : 'mos',
	        MM : '%d mosan',
	        y : 'bliadhna',
	        yy : '%d bliadhna'
	    },
	    ordinalParse : /\d{1,2}(d|na|mh)/,
	    ordinal : function (number) {
	        var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return gd;
	
	})));


/***/ },
/* 356 */
/*!*******************************!*\
  !*** ./~/moment/locale/gl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Galician [gl]
	//! author : Juan G. Hurtado : https://github.com/juanghurtado
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var gl = moment.defineLocale('gl', {
	    months : 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
	    monthsShort : 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
	    weekdaysShort : 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
	    weekdaysMin : 'do_lu_ma_m_xo_ve_s'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY H:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY H:mm'
	    },
	    calendar : {
	        sameDay : function () {
	            return '[hoxe ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextDay : function () {
	            return '[ma ' + ((this.hours() !== 1) ? 's' : '') + '] LT';
	        },
	        nextWeek : function () {
	            return 'dddd [' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        lastDay : function () {
	            return '[onte ' + ((this.hours() !== 1) ? '' : 'a') + '] LT';
	        },
	        lastWeek : function () {
	            return '[o] dddd [pasado ' + ((this.hours() !== 1) ? 's' : 'a') + '] LT';
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (str) {
	            if (str.indexOf('un') === 0) {
	                return 'n' + str;
	            }
	            return 'en ' + str;
	        },
	        past : 'hai %s',
	        s : 'uns segundos',
	        m : 'un minuto',
	        mm : '%d minutos',
	        h : 'unha hora',
	        hh : '%d horas',
	        d : 'un da',
	        dd : '%d das',
	        M : 'un mes',
	        MM : '%d meses',
	        y : 'un ano',
	        yy : '%d anos'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return gl;
	
	})));


/***/ },
/* 357 */
/*!*******************************!*\
  !*** ./~/moment/locale/he.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hebrew [he]
	//! author : Tomer Cohen : https://github.com/tomer
	//! author : Moshe Simantov : https://github.com/DevelopmentIL
	//! author : Tal Ater : https://github.com/TalAter
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var he = moment.defineLocale('he', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D []MMMM YYYY',
	        LLL : 'D []MMMM YYYY HH:mm',
	        LLLL : 'dddd, D []MMMM YYYY HH:mm',
	        l : 'D/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ]LT',
	        nextDay : '[ ]LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ]LT',
	        lastWeek : '[] dddd [ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        d : '',
	        dd : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        M : '',
	        MM : function (number) {
	            if (number === 2) {
	                return '';
	            }
	            return number + ' ';
	        },
	        y : '',
	        yy : function (number) {
	            if (number === 2) {
	                return '';
	            } else if (number % 10 === 0 && number !== 10) {
	                return number + ' ';
	            }
	            return number + ' ';
	        }
	    },
	    meridiemParse: /"|"| | | ||/i,
	    isPM : function (input) {
	        return /^("| |)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 5) {
	            return ' ';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 12) {
	            return isLower ? '"' : ' ';
	        } else if (hour < 18) {
	            return isLower ? '"' : ' ';
	        } else {
	            return '';
	        }
	    }
	});
	
	return he;
	
	})));


/***/ },
/* 358 */
/*!*******************************!*\
  !*** ./~/moment/locale/hi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hindi [hi]
	//! author : Mayank Singhal : https://github.com/mayanksinghal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var hi = moment.defineLocale('hi', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hi;
	
	})));


/***/ },
/* 359 */
/*!*******************************!*\
  !*** ./~/moment/locale/hr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Croatian [hr]
	//! author : Bojan Markovi : https://github.com/bmarkovic
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'jedna minuta' : 'jedne minute';
	        case 'mm':
	            if (number === 1) {
	                result += 'minuta';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'minute';
	            } else {
	                result += 'minuta';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'jedan sat' : 'jednog sata';
	        case 'hh':
	            if (number === 1) {
	                result += 'sat';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'sata';
	            } else {
	                result += 'sati';
	            }
	            return result;
	        case 'dd':
	            if (number === 1) {
	                result += 'dan';
	            } else {
	                result += 'dana';
	            }
	            return result;
	        case 'MM':
	            if (number === 1) {
	                result += 'mjesec';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'mjeseca';
	            } else {
	                result += 'mjeseci';
	            }
	            return result;
	        case 'yy':
	            if (number === 1) {
	                result += 'godina';
	            } else if (number === 2 || number === 3 || number === 4) {
	                result += 'godine';
	            } else {
	                result += 'godina';
	            }
	            return result;
	    }
	}
	
	var hr = moment.defineLocale('hr', {
	    months : {
	        format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
	        standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
	    },
	    monthsShort : 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort : 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin : 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danas u] LT',
	        nextDay  : '[sutra u] LT',
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[juer u] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                    return '[prolu] dddd [u] LT';
	                case 6:
	                    return '[prole] [subote] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[proli] dddd [u] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'par sekundi',
	        m      : translate,
	        mm     : translate,
	        h      : translate,
	        hh     : translate,
	        d      : 'dan',
	        dd     : translate,
	        M      : 'mjesec',
	        MM     : translate,
	        y      : 'godinu',
	        yy     : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hr;
	
	})));


/***/ },
/* 360 */
/*!*******************************!*\
  !*** ./~/moment/locale/hu.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Hungarian [hu]
	//! author : Adam Brunner : https://github.com/adambrunner
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');
	function translate(number, withoutSuffix, key, isFuture) {
	    var num = number,
	        suffix;
	    switch (key) {
	        case 's':
	            return (isFuture || withoutSuffix) ? 'nhny msodperc' : 'nhny msodperce';
	        case 'm':
	            return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'mm':
	            return num + (isFuture || withoutSuffix ? ' perc' : ' perce');
	        case 'h':
	            return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'hh':
	            return num + (isFuture || withoutSuffix ? ' ra' : ' rja');
	        case 'd':
	            return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'dd':
	            return num + (isFuture || withoutSuffix ? ' nap' : ' napja');
	        case 'M':
	            return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'MM':
	            return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');
	        case 'y':
	            return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');
	        case 'yy':
	            return num + (isFuture || withoutSuffix ? ' v' : ' ve');
	    }
	    return '';
	}
	function week(isFuture) {
	    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
	}
	
	var hu = moment.defineLocale('hu', {
	    months : 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
	    monthsShort : 'jan_feb_mrc_pr_mj_jn_jl_aug_szept_okt_nov_dec'.split('_'),
	    weekdays : 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
	    weekdaysShort : 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
	    weekdaysMin : 'v_h_k_sze_cs_p_szo'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY.MM.DD.',
	        LL : 'YYYY. MMMM D.',
	        LLL : 'YYYY. MMMM D. H:mm',
	        LLLL : 'YYYY. MMMM D., dddd H:mm'
	    },
	    meridiemParse: /de|du/i,
	    isPM: function (input) {
	        return input.charAt(1).toLowerCase() === 'u';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower === true ? 'de' : 'DE';
	        } else {
	            return isLower === true ? 'du' : 'DU';
	        }
	    },
	    calendar : {
	        sameDay : '[ma] LT[-kor]',
	        nextDay : '[holnap] LT[-kor]',
	        nextWeek : function () {
	            return week.call(this, true);
	        },
	        lastDay : '[tegnap] LT[-kor]',
	        lastWeek : function () {
	            return week.call(this, false);
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s mlva',
	        past : '%s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return hu;
	
	})));


/***/ },
/* 361 */
/*!**********************************!*\
  !*** ./~/moment/locale/hy-am.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Armenian [hy-am]
	//! author : Armendarabyan : https://github.com/armendarabyan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var hyAm = moment.defineLocale('hy-am', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[] LT',
	        nextDay: '[] LT',
	        lastDay: '[] LT',
	        nextWeek: function () {
	            return 'dddd [ ] LT';
	        },
	        lastWeek: function () {
	            return '[] dddd [ ] LT';
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}|\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'DDD':
	            case 'w':
	            case 'W':
	            case 'DDDo':
	                if (number === 1) {
	                    return number + '-';
	                }
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return hyAm;
	
	})));


/***/ },
/* 362 */
/*!*******************************!*\
  !*** ./~/moment/locale/id.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Indonesian [id]
	//! author : Mohammad Satrio Utomo : https://github.com/tyok
	//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var id = moment.defineLocale('id', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|siang|sore|malam/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'siang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sore' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'siang';
	        } else if (hours < 19) {
	            return 'sore';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Besok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kemarin pukul] LT',
	        lastWeek : 'dddd [lalu pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lalu',
	        s : 'beberapa detik',
	        m : 'semenit',
	        mm : '%d menit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return id;
	
	})));


/***/ },
/* 363 */
/*!*******************************!*\
  !*** ./~/moment/locale/is.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Icelandic [is]
	//! author : Hinrik rn Sigursson : https://github.com/hinrik
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(n) {
	    if (n % 100 === 11) {
	        return true;
	    } else if (n % 10 === 1) {
	        return false;
	    }
	    return true;
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';
	        case 'm':
	            return withoutSuffix ? 'mnta' : 'mntu';
	        case 'mm':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
	            } else if (withoutSuffix) {
	                return result + 'mnta';
	            }
	            return result + 'mntu';
	        case 'hh':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
	            }
	            return result + 'klukkustund';
	        case 'd':
	            if (withoutSuffix) {
	                return 'dagur';
	            }
	            return isFuture ? 'dag' : 'degi';
	        case 'dd':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'dagar';
	                }
	                return result + (isFuture ? 'daga' : 'dgum');
	            } else if (withoutSuffix) {
	                return result + 'dagur';
	            }
	            return result + (isFuture ? 'dag' : 'degi');
	        case 'M':
	            if (withoutSuffix) {
	                return 'mnuur';
	            }
	            return isFuture ? 'mnu' : 'mnui';
	        case 'MM':
	            if (plural(number)) {
	                if (withoutSuffix) {
	                    return result + 'mnuir';
	                }
	                return result + (isFuture ? 'mnui' : 'mnuum');
	            } else if (withoutSuffix) {
	                return result + 'mnuur';
	            }
	            return result + (isFuture ? 'mnu' : 'mnui');
	        case 'y':
	            return withoutSuffix || isFuture ? 'r' : 'ri';
	        case 'yy':
	            if (plural(number)) {
	                return result + (withoutSuffix || isFuture ? 'r' : 'rum');
	            }
	            return result + (withoutSuffix || isFuture ? 'r' : 'ri');
	    }
	}
	
	var is = moment.defineLocale('is', {
	    months : 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
	    weekdays : 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
	    weekdaysShort : 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
	    weekdaysMin : 'Su_M_r_Mi_Fi_F_La'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd, D. MMMM YYYY [kl.] H:mm'
	    },
	    calendar : {
	        sameDay : '[ dag kl.] LT',
	        nextDay : '[ morgun kl.] LT',
	        nextWeek : 'dddd [kl.] LT',
	        lastDay : '[ gr kl.] LT',
	        lastWeek : '[sasta] dddd [kl.] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'eftir %s',
	        past : 'fyrir %s san',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : 'klukkustund',
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return is;
	
	})));


/***/ },
/* 364 */
/*!*******************************!*\
  !*** ./~/moment/locale/it.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Italian [it]
	//! author : Lorenzo : https://github.com/aliem
	//! author: Mattia Larentis: https://github.com/nostalgiaz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var it = moment.defineLocale('it', {
	    months : 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
	    monthsShort : 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
	    weekdays : 'Domenica_Luned_Marted_Mercoled_Gioved_Venerd_Sabato'.split('_'),
	    weekdaysShort : 'Dom_Lun_Mar_Mer_Gio_Ven_Sab'.split('_'),
	    weekdaysMin : 'Do_Lu_Ma_Me_Gi_Ve_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Oggi alle] LT',
	        nextDay: '[Domani alle] LT',
	        nextWeek: 'dddd [alle] LT',
	        lastDay: '[Ieri alle] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[la scorsa] dddd [alle] LT';
	                default:
	                    return '[lo scorso] dddd [alle] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return ((/^[0-9].+$/).test(s) ? 'tra' : 'in') + ' ' + s;
	        },
	        past : '%s fa',
	        s : 'alcuni secondi',
	        m : 'un minuto',
	        mm : '%d minuti',
	        h : 'un\'ora',
	        hh : '%d ore',
	        d : 'un giorno',
	        dd : '%d giorni',
	        M : 'un mese',
	        MM : '%d mesi',
	        y : 'un anno',
	        yy : '%d anni'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return it;
	
	})));


/***/ },
/* 365 */
/*!*******************************!*\
  !*** ./~/moment/locale/ja.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Japanese [ja]
	//! author : LI Long : https://github.com/baryon
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ja = moment.defineLocale('ja', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahm',
	        LTS : 'Ahms',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYYMD',
	        LLL : 'YYYYMDAhm',
	        LLLL : 'YYYYMDAhm dddd'
	    },
	    meridiemParse: /|/i,
	    isPM : function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd LT',
	        sameElse : 'L'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1',
	        mm : '%d',
	        h : '1',
	        hh : '%d',
	        d : '1',
	        dd : '%d',
	        M : '1',
	        MM : '%d',
	        y : '1',
	        yy : '%d'
	    }
	});
	
	return ja;
	
	})));


/***/ },
/* 366 */
/*!*******************************!*\
  !*** ./~/moment/locale/jv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Javanese [jv]
	//! author : Rony Lantip : https://github.com/lantip
	//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var jv = moment.defineLocale('jv', {
	    months : 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
	    monthsShort : 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
	    weekdays : 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
	    weekdaysShort : 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
	    weekdaysMin : 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /enjing|siyang|sonten|ndalu/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'enjing') {
	            return hour;
	        } else if (meridiem === 'siyang') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'enjing';
	        } else if (hours < 15) {
	            return 'siyang';
	        } else if (hours < 19) {
	            return 'sonten';
	        } else {
	            return 'ndalu';
	        }
	    },
	    calendar : {
	        sameDay : '[Dinten puniko pukul] LT',
	        nextDay : '[Mbenjang pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kala wingi pukul] LT',
	        lastWeek : 'dddd [kepengker pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'wonten ing %s',
	        past : '%s ingkang kepengker',
	        s : 'sawetawis detik',
	        m : 'setunggal menit',
	        mm : '%d menit',
	        h : 'setunggal jam',
	        hh : '%d jam',
	        d : 'sedinten',
	        dd : '%d dinten',
	        M : 'sewulan',
	        MM : '%d wulan',
	        y : 'setaun',
	        yy : '%d taun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return jv;
	
	})));


/***/ },
/* 367 */
/*!*******************************!*\
  !*** ./~/moment/locale/ka.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Georgian [ka]
	//! author : Irakli Janiashvili : https://github.com/irakli-janiashvili
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ka = moment.defineLocale('ka', {
	    months : {
	        standalone: '___________'.split('_'),
	        format: '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /(|)/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[] LT[-]',
	        nextDay : '[] LT[-]',
	        lastDay : '[] LT[-]',
	        nextWeek : '[] dddd LT[-]',
	        lastWeek : '[] dddd LT-',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : function (s) {
	            return (/(|||)/).test(s) ?
	                s.replace(/$/, '') :
	                s + '';
	        },
	        past : function (s) {
	            if ((/(||||)/).test(s)) {
	                return s.replace(/(|)$/, ' ');
	            }
	            if ((//).test(s)) {
	                return s.replace(/$/, ' ');
	            }
	        },
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
	    ordinal : function (number) {
	        if (number === 0) {
	            return number;
	        }
	        if (number === 1) {
	            return number + '-';
	        }
	        if ((number < 20) || (number <= 100 && (number % 20 === 0)) || (number % 100 === 0)) {
	            return '-' + number;
	        }
	        return number + '-';
	    },
	    week : {
	        dow : 1,
	        doy : 7
	    }
	});
	
	return ka;
	
	})));


/***/ },
/* 368 */
/*!*******************************!*\
  !*** ./~/moment/locale/kk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kazakh [kk]
	//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};
	
	var kk = moment.defineLocale('kk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return kk;
	
	})));


/***/ },
/* 369 */
/*!*******************************!*\
  !*** ./~/moment/locale/km.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Cambodian [km]
	//! author : Kruy Vanna : https://github.com/kruyvanna
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var km = moment.defineLocale('km', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] [] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: '%s',
	        past: '%s',
	        s: '',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return km;
	
	})));


/***/ },
/* 370 */
/*!*******************************!*\
  !*** ./~/moment/locale/ko.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Korean [ko]
	//! author : Kyungwook, Park : https://github.com/kyungw00k
	//! author : Jeeeyul Lee <jeeeyul@gmail.com>
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ko = moment.defineLocale('ko', {
	    months : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h m',
	        LTS : 'A h m s',
	        L : 'YYYY.MM.DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D A h m',
	        LLLL : 'YYYY MMMM D dddd A h m'
	    },
	    calendar : {
	        sameDay : ' LT',
	        nextDay : ' LT',
	        nextWeek : 'dddd LT',
	        lastDay : ' LT',
	        lastWeek : ' dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        ss : '%d',
	        m : '',
	        mm : '%d',
	        h : ' ',
	        hh : '%d',
	        d : '',
	        dd : '%d',
	        M : ' ',
	        MM : '%d',
	        y : ' ',
	        yy : '%d'
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    meridiemParse : /|/,
	    isPM : function (token) {
	        return token === '';
	    },
	    meridiem : function (hour, minute, isUpper) {
	        return hour < 12 ? '' : '';
	    }
	});
	
	return ko;
	
	})));


/***/ },
/* 371 */
/*!*******************************!*\
  !*** ./~/moment/locale/ky.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Kyrgyz [ky]
	//! author : Chyngyz Arystan uulu : https://github.com/chyngyz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var suffixes = {
	    0: '-',
	    1: '-',
	    2: '-',
	    3: '-',
	    4: '-',
	    5: '-',
	    6: '-',
	    7: '-',
	    8: '-',
	    9: '-',
	    10: '-',
	    20: '-',
	    30: '-',
	    40: '-',
	    50: '-',
	    60: '-',
	    70: '-',
	    80: '-',
	    90: '-',
	    100: '-'
	};
	
	var ky = moment.defineLocale('ky', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[ ] dddd [] [] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||)/,
	    ordinal : function (number) {
	        var a = number % 10,
	            b = number >= 100 ? 100 : null;
	        return number + (suffixes[number] || suffixes[a] || suffixes[b]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ky;
	
	})));


/***/ },
/* 372 */
/*!*******************************!*\
  !*** ./~/moment/locale/lb.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Luxembourgish [lb]
	//! author : mweimerskirch : https://github.com/mweimerskirch
	//! author : David Raison : https://github.com/kwisatz
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        'm': ['eng Minutt', 'enger Minutt'],
	        'h': ['eng Stonn', 'enger Stonn'],
	        'd': ['een Dag', 'engem Dag'],
	        'M': ['ee Mount', 'engem Mount'],
	        'y': ['ee Joer', 'engem Joer']
	    };
	    return withoutSuffix ? format[key][0] : format[key][1];
	}
	function processFutureTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'a ' + string;
	    }
	    return 'an ' + string;
	}
	function processPastTime(string) {
	    var number = string.substr(0, string.indexOf(' '));
	    if (eifelerRegelAppliesToNumber(number)) {
	        return 'viru ' + string;
	    }
	    return 'virun ' + string;
	}
	/**
	 * Returns true if the word before the given number loses the '-n' ending.
	 * e.g. 'an 10 Deeg' but 'a 5 Deeg'
	 *
	 * @param number {integer}
	 * @returns {boolean}
	 */
	function eifelerRegelAppliesToNumber(number) {
	    number = parseInt(number, 10);
	    if (isNaN(number)) {
	        return false;
	    }
	    if (number < 0) {
	        // Negative Number --> always true
	        return true;
	    } else if (number < 10) {
	        // Only 1 digit
	        if (4 <= number && number <= 7) {
	            return true;
	        }
	        return false;
	    } else if (number < 100) {
	        // 2 digits
	        var lastDigit = number % 10, firstDigit = number / 10;
	        if (lastDigit === 0) {
	            return eifelerRegelAppliesToNumber(firstDigit);
	        }
	        return eifelerRegelAppliesToNumber(lastDigit);
	    } else if (number < 10000) {
	        // 3 or 4 digits --> recursively check first digit
	        while (number >= 10) {
	            number = number / 10;
	        }
	        return eifelerRegelAppliesToNumber(number);
	    } else {
	        // Anything larger than 4 digits: recursively check first n-3 digits
	        number = number / 1000;
	        return eifelerRegelAppliesToNumber(number);
	    }
	}
	
	var lb = moment.defineLocale('lb', {
	    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
	    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
	    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
	    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm [Auer]',
	        LTS: 'H:mm:ss [Auer]',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm [Auer]',
	        LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
	    },
	    calendar: {
	        sameDay: '[Haut um] LT',
	        sameElse: 'L',
	        nextDay: '[Muer um] LT',
	        nextWeek: 'dddd [um] LT',
	        lastDay: '[Gschter um] LT',
	        lastWeek: function () {
	            // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
	            switch (this.day()) {
	                case 2:
	                case 4:
	                    return '[Leschten] dddd [um] LT';
	                default:
	                    return '[Leschte] dddd [um] LT';
	            }
	        }
	    },
	    relativeTime : {
	        future : processFutureTime,
	        past : processPastTime,
	        s : 'e puer Sekonnen',
	        m : processRelativeTime,
	        mm : '%d Minutten',
	        h : processRelativeTime,
	        hh : '%d Stonnen',
	        d : processRelativeTime,
	        dd : '%d Deeg',
	        M : processRelativeTime,
	        MM : '%d Mint',
	        y : processRelativeTime,
	        yy : '%d Joer'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal: '%d.',
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lb;
	
	})));


/***/ },
/* 373 */
/*!*******************************!*\
  !*** ./~/moment/locale/lo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lao [lo]
	//! author : Ryan Hart : https://github.com/ryanhart2
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var lo = moment.defineLocale('lo', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[]dddd[] LT',
	        lastDay : '[] LT',
	        lastWeek : '[]dddd[] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    ordinalParse: /()\d{1,2}/,
	    ordinal : function (number) {
	        return '' + number;
	    }
	});
	
	return lo;
	
	})));


/***/ },
/* 374 */
/*!*******************************!*\
  !*** ./~/moment/locale/lt.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Lithuanian [lt]
	//! author : Mindaugas Mozras : https://github.com/mmozuras
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var units = {
	    'm' : 'minut_minuts_minut',
	    'mm': 'minuts_minui_minutes',
	    'h' : 'valanda_valandos_valand',
	    'hh': 'valandos_valand_valandas',
	    'd' : 'diena_dienos_dien',
	    'dd': 'dienos_dien_dienas',
	    'M' : 'mnuo_mnesio_mnes',
	    'MM': 'mnesiai_mnesi_mnesius',
	    'y' : 'metai_met_metus',
	    'yy': 'metai_met_metus'
	};
	function translateSeconds(number, withoutSuffix, key, isFuture) {
	    if (withoutSuffix) {
	        return 'kelios sekunds';
	    } else {
	        return isFuture ? 'keli sekundi' : 'kelias sekundes';
	    }
	}
	function translateSingular(number, withoutSuffix, key, isFuture) {
	    return withoutSuffix ? forms(key)[0] : (isFuture ? forms(key)[1] : forms(key)[2]);
	}
	function special(number) {
	    return number % 10 === 0 || (number > 10 && number < 20);
	}
	function forms(key) {
	    return units[key].split('_');
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    if (number === 1) {
	        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
	    } else if (withoutSuffix) {
	        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
	    } else {
	        if (isFuture) {
	            return result + forms(key)[1];
	        } else {
	            return result + (special(number) ? forms(key)[1] : forms(key)[2]);
	        }
	    }
	}
	var lt = moment.defineLocale('lt', {
	    months : {
	        format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
	        standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
	        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
	    },
	    monthsShort : 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
	    weekdays : {
	        format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
	        standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
	        isFormat: /dddd HH:mm/
	    },
	    weekdaysShort : 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
	    weekdaysMin : 'S_P_A_T_K_Pn_'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYY [m.] MMMM D [d.]',
	        LLL : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        LLLL : 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYY [m.] MMMM D [d.]',
	        lll : 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
	        llll : 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
	    },
	    calendar : {
	        sameDay : '[iandien] LT',
	        nextDay : '[Rytoj] LT',
	        nextWeek : 'dddd LT',
	        lastDay : '[Vakar] LT',
	        lastWeek : '[Prajus] dddd LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'po %s',
	        past : 'prie %s',
	        s : translateSeconds,
	        m : translateSingular,
	        mm : translate,
	        h : translateSingular,
	        hh : translate,
	        d : translateSingular,
	        dd : translate,
	        M : translateSingular,
	        MM : translate,
	        y : translateSingular,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}-oji/,
	    ordinal : function (number) {
	        return number + '-oji';
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lt;
	
	})));


/***/ },
/* 375 */
/*!*******************************!*\
  !*** ./~/moment/locale/lv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Latvian [lv]
	//! author : Kristaps Karlsons : https://github.com/skakri
	//! author : Jnis Elmeris : https://github.com/JanisE
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var units = {
	    'm': 'mintes_mintm_minte_mintes'.split('_'),
	    'mm': 'mintes_mintm_minte_mintes'.split('_'),
	    'h': 'stundas_stundm_stunda_stundas'.split('_'),
	    'hh': 'stundas_stundm_stunda_stundas'.split('_'),
	    'd': 'dienas_dienm_diena_dienas'.split('_'),
	    'dd': 'dienas_dienm_diena_dienas'.split('_'),
	    'M': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'MM': 'mnea_mneiem_mnesis_mnei'.split('_'),
	    'y': 'gada_gadiem_gads_gadi'.split('_'),
	    'yy': 'gada_gadiem_gads_gadi'.split('_')
	};
	/**
	 * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
	 */
	function format(forms, number, withoutSuffix) {
	    if (withoutSuffix) {
	        // E.g. "21 minte", "3 mintes".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
	    } else {
	        // E.g. "21 mintes" as in "pc 21 mintes".
	        // E.g. "3 mintm" as in "pc 3 mintm".
	        return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
	    }
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    return number + ' ' + format(units[key], number, withoutSuffix);
	}
	function relativeTimeWithSingular(number, withoutSuffix, key) {
	    return format(units[key], number, withoutSuffix);
	}
	function relativeSeconds(number, withoutSuffix) {
	    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
	}
	
	var lv = moment.defineLocale('lv', {
	    months : 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
	    weekdaysShort : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysMin : 'Sv_P_O_T_C_Pk_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY.',
	        LL : 'YYYY. [gada] D. MMMM',
	        LLL : 'YYYY. [gada] D. MMMM, HH:mm',
	        LLLL : 'YYYY. [gada] D. MMMM, dddd, HH:mm'
	    },
	    calendar : {
	        sameDay : '[odien pulksten] LT',
	        nextDay : '[Rt pulksten] LT',
	        nextWeek : 'dddd [pulksten] LT',
	        lastDay : '[Vakar pulksten] LT',
	        lastWeek : '[Pagju] dddd [pulksten] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'pc %s',
	        past : 'pirms %s',
	        s : relativeSeconds,
	        m : relativeTimeWithSingular,
	        mm : relativeTimeWithPlural,
	        h : relativeTimeWithSingular,
	        hh : relativeTimeWithPlural,
	        d : relativeTimeWithSingular,
	        dd : relativeTimeWithPlural,
	        M : relativeTimeWithSingular,
	        MM : relativeTimeWithPlural,
	        y : relativeTimeWithSingular,
	        yy : relativeTimeWithPlural
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return lv;
	
	})));


/***/ },
/* 376 */
/*!*******************************!*\
  !*** ./~/moment/locale/me.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Montenegrin [me]
	//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jednog minuta'],
	        mm: ['minut', 'minuta', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mjesec', 'mjeseca', 'mjeseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var me = moment.defineLocale('me', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact : true,
	    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sjutra u] LT',
	
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedjelju] [u] LT';
	                case 3:
	                    return '[u] [srijedu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedjelje] [u] LT',
	                '[prolog] [ponedjeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srijede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'prije %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mjesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return me;
	
	})));


/***/ },
/* 377 */
/*!*******************************!*\
  !*** ./~/moment/locale/mi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Maori [mi]
	//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var mi = moment.defineLocale('mi', {
	    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
	    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
	    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
	    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
	    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
	    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY [i] HH:mm',
	        LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
	    },
	    calendar: {
	        sameDay: '[i teie mahana, i] LT',
	        nextDay: '[apopo i] LT',
	        nextWeek: 'dddd [i] LT',
	        lastDay: '[inanahi i] LT',
	        lastWeek: 'dddd [whakamutunga i] LT',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: 'i roto i %s',
	        past: '%s i mua',
	        s: 'te hkona ruarua',
	        m: 'he meneti',
	        mm: '%d meneti',
	        h: 'te haora',
	        hh: '%d haora',
	        d: 'he ra',
	        dd: '%d ra',
	        M: 'he marama',
	        MM: '%d marama',
	        y: 'he tau',
	        yy: '%d tau'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal: '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return mi;
	
	})));


/***/ },
/* 378 */
/*!*******************************!*\
  !*** ./~/moment/locale/mk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Macedonian [mk]
	//! author : Borislav Mickov : https://github.com/B0k0
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var mk = moment.defineLocale('mk', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : 'e_o_____a'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'D.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : '[] dddd [] LT',
	        lastDay : '[ ] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 6:
	                    return '[] dddd [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : ' %s',
	        s : ' ',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d ',
	        M : '',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}-(|||||)/,
	    ordinal : function (number) {
	        var lastDigit = number % 10,
	            last2Digits = number % 100;
	        if (number === 0) {
	            return number + '-';
	        } else if (last2Digits === 0) {
	            return number + '-';
	        } else if (last2Digits > 10 && last2Digits < 20) {
	            return number + '-';
	        } else if (lastDigit === 1) {
	            return number + '-';
	        } else if (lastDigit === 2) {
	            return number + '-';
	        } else if (lastDigit === 7 || lastDigit === 8) {
	            return number + '-';
	        } else {
	            return number + '-';
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return mk;
	
	})));


/***/ },
/* 379 */
/*!*******************************!*\
  !*** ./~/moment/locale/ml.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malayalam [ml]
	//! author : Floyd Pink : https://github.com/floydpink
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ml = moment.defineLocale('ml', {
	    months : '___________'.split('_'),
	    monthsShort : '._._._.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm -',
	        LTS : 'A h:mm:ss -',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm -',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm -'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    meridiemParse: /|| ||/i,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if ((meridiem === '' && hour >= 4) ||
	                meridiem === ' ' ||
	                meridiem === '') {
	            return hour + 12;
	        } else {
	            return hour;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return ' ';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    }
	});
	
	return ml;
	
	})));


/***/ },
/* 380 */
/*!*******************************!*\
  !*** ./~/moment/locale/mr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Marathi [mr]
	//! author : Harshad Kale : https://github.com/kalehv
	//! author : Vivek Athalye : https://github.com/vnathalye
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	function relativeTimeMr(number, withoutSuffix, string, isFuture)
	{
	    var output = '';
	    if (withoutSuffix) {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    else {
	        switch (string) {
	            case 's': output = ' '; break;
	            case 'm': output = ' '; break;
	            case 'mm': output = '%d '; break;
	            case 'h': output = ' '; break;
	            case 'hh': output = '%d '; break;
	            case 'd': output = ' '; break;
	            case 'dd': output = '%d '; break;
	            case 'M': output = ' '; break;
	            case 'MM': output = '%d '; break;
	            case 'y': output = ' '; break;
	            case 'yy': output = '%d '; break;
	        }
	    }
	    return output.replace(/%d/i, number);
	}
	
	var mr = moment.defineLocale('mr', {
	    months : '___________'.split('_'),
	    monthsShort: '._._._._._._._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek: '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future: '%s',
	        past: '%s',
	        s: relativeTimeMr,
	        m: relativeTimeMr,
	        mm: relativeTimeMr,
	        h: relativeTimeMr,
	        hh: relativeTimeMr,
	        d: relativeTimeMr,
	        dd: relativeTimeMr,
	        M: relativeTimeMr,
	        MM: relativeTimeMr,
	        y: relativeTimeMr,
	        yy: relativeTimeMr
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem: function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return mr;
	
	})));


/***/ },
/* 381 */
/*!*******************************!*\
  !*** ./~/moment/locale/ms.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ms = moment.defineLocale('ms', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ms;
	
	})));


/***/ },
/* 382 */
/*!**********************************!*\
  !*** ./~/moment/locale/ms-my.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Malay [ms-my]
	//! note : DEPRECATED, the correct one is [ms]
	//! author : Weldan Jamili : https://github.com/weldan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var msMy = moment.defineLocale('ms-my', {
	    months : 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
	    weekdays : 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
	    weekdaysShort : 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
	    weekdaysMin : 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [pukul] HH.mm',
	        LLLL : 'dddd, D MMMM YYYY [pukul] HH.mm'
	    },
	    meridiemParse: /pagi|tengahari|petang|malam/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'pagi') {
	            return hour;
	        } else if (meridiem === 'tengahari') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'petang' || meridiem === 'malam') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'pagi';
	        } else if (hours < 15) {
	            return 'tengahari';
	        } else if (hours < 19) {
	            return 'petang';
	        } else {
	            return 'malam';
	        }
	    },
	    calendar : {
	        sameDay : '[Hari ini pukul] LT',
	        nextDay : '[Esok pukul] LT',
	        nextWeek : 'dddd [pukul] LT',
	        lastDay : '[Kelmarin pukul] LT',
	        lastWeek : 'dddd [lepas pukul] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'dalam %s',
	        past : '%s yang lepas',
	        s : 'beberapa saat',
	        m : 'seminit',
	        mm : '%d minit',
	        h : 'sejam',
	        hh : '%d jam',
	        d : 'sehari',
	        dd : '%d hari',
	        M : 'sebulan',
	        MM : '%d bulan',
	        y : 'setahun',
	        yy : '%d tahun'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return msMy;
	
	})));


/***/ },
/* 383 */
/*!*******************************!*\
  !*** ./~/moment/locale/my.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Burmese [my]
	//! author : Squar team, mysquar.com
	//! author : David Rossellat : https://github.com/gholadr
	//! author : Tin Aung Lin : https://github.com/thanyawzinmin
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var my = moment.defineLocale('my', {
	    months: '___________'.split('_'),
	    monthsShort: '___________'.split('_'),
	    weekdays: '______'.split('_'),
	    weekdaysShort: '______'.split('_'),
	    weekdaysMin: '______'.split('_'),
	
	    longDateFormat: {
	        LT: 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L: 'DD/MM/YYYY',
	        LL: 'D MMMM YYYY',
	        LLL: 'D MMMM YYYY HH:mm',
	        LLLL: 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar: {
	        sameDay: '[.] LT []',
	        nextDay: '[] LT []',
	        nextWeek: 'dddd LT []',
	        lastDay: '[.] LT []',
	        lastWeek: '[] dddd LT []',
	        sameElse: 'L'
	    },
	    relativeTime: {
	        future: ' %s ',
	        past: ' %s ',
	        s: '.',
	        m: '',
	        mm: '%d ',
	        h: '',
	        hh: '%d ',
	        d: '',
	        dd: '%d ',
	        M: '',
	        MM: '%d ',
	        y: '',
	        yy: '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    week: {
	        dow: 1, // Monday is the first day of the week.
	        doy: 4 // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return my;
	
	})));


/***/ },
/* 384 */
/*!*******************************!*\
  !*** ./~/moment/locale/nb.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Norwegian Bokml [nb]
	//! authors : Espen Hovlandsdal : https://github.com/rexxars
	//!           Sigurd Gartmann : https://github.com/sigurdga
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var nb = moment.defineLocale('nb', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan._feb._mars_april_mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 's._ma._ti._on._to._fr._l.'.split('_'),
	    weekdaysMin : 's_ma_ti_on_to_fr_l'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[i dag kl.] LT',
	        nextDay: '[i morgen kl.] LT',
	        nextWeek: 'dddd [kl.] LT',
	        lastDay: '[i gr kl.] LT',
	        lastWeek: '[forrige] dddd [kl.] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s siden',
	        s : 'noen sekunder',
	        m : 'ett minutt',
	        mm : '%d minutter',
	        h : 'en time',
	        hh : '%d timer',
	        d : 'en dag',
	        dd : '%d dager',
	        M : 'en mned',
	        MM : '%d mneder',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nb;
	
	})));


/***/ },
/* 385 */
/*!*******************************!*\
  !*** ./~/moment/locale/ne.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nepalese [ne]
	//! author : suvash : https://github.com/suvash
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var ne = moment.defineLocale('ne', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.___._._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '._._._._._._.'.split('_'),
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 3) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 16) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : '[] dddd[,] LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd[,] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ne;
	
	})));


/***/ },
/* 386 */
/*!*******************************!*\
  !*** ./~/moment/locale/nl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch [nl]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
	
	var nl = moment.defineLocale('nl', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
	
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD-MM-YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nl;
	
	})));


/***/ },
/* 387 */
/*!**********************************!*\
  !*** ./~/moment/locale/nl-be.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Dutch (Belgium) [nl-be]
	//! author : Joris Rling : https://github.com/jorisroling
	//! author : Jacob Middag : https://github.com/middagj
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_');
	var monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_');
	
	var monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i];
	var monthsRegex = /^(januari|februari|maart|april|mei|april|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
	
	var nlBe = moment.defineLocale('nl-be', {
	    months : 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
	    monthsShort : function (m, format) {
	        if (/-MMM-/.test(format)) {
	            return monthsShortWithoutDots[m.month()];
	        } else {
	            return monthsShortWithDots[m.month()];
	        }
	    },
	
	    monthsRegex: monthsRegex,
	    monthsShortRegex: monthsRegex,
	    monthsStrictRegex: /^(januari|februari|maart|mei|ju[nl]i|april|augustus|september|oktober|november|december)/i,
	    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
	
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    weekdays : 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
	    weekdaysShort : 'zo._ma._di._wo._do._vr._za.'.split('_'),
	    weekdaysMin : 'Zo_Ma_Di_Wo_Do_Vr_Za'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[vandaag om] LT',
	        nextDay: '[morgen om] LT',
	        nextWeek: 'dddd [om] LT',
	        lastDay: '[gisteren om] LT',
	        lastWeek: '[afgelopen] dddd [om] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'over %s',
	        past : '%s geleden',
	        s : 'een paar seconden',
	        m : 'n minuut',
	        mm : '%d minuten',
	        h : 'n uur',
	        hh : '%d uur',
	        d : 'n dag',
	        dd : '%d dagen',
	        M : 'n maand',
	        MM : '%d maanden',
	        y : 'n jaar',
	        yy : '%d jaar'
	    },
	    ordinalParse: /\d{1,2}(ste|de)/,
	    ordinal : function (number) {
	        return number + ((number === 1 || number === 8 || number >= 20) ? 'ste' : 'de');
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nlBe;
	
	})));


/***/ },
/* 388 */
/*!*******************************!*\
  !*** ./~/moment/locale/nn.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Nynorsk [nn]
	//! author : https://github.com/mechuwind
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var nn = moment.defineLocale('nn', {
	    months : 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
	    weekdays : 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
	    weekdaysShort : 'sun_mn_tys_ons_tor_fre_lau'.split('_'),
	    weekdaysMin : 'su_m_ty_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY [kl.] H:mm',
	        LLLL : 'dddd D. MMMM YYYY [kl.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[I dag klokka] LT',
	        nextDay: '[I morgon klokka] LT',
	        nextWeek: 'dddd [klokka] LT',
	        lastDay: '[I gr klokka] LT',
	        lastWeek: '[Fregande] dddd [klokka] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : '%s sidan',
	        s : 'nokre sekund',
	        m : 'eit minutt',
	        mm : '%d minutt',
	        h : 'ein time',
	        hh : '%d timar',
	        d : 'ein dag',
	        dd : '%d dagar',
	        M : 'ein mnad',
	        MM : '%d mnader',
	        y : 'eit r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return nn;
	
	})));


/***/ },
/* 389 */
/*!**********************************!*\
  !*** ./~/moment/locale/pa-in.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Punjabi (India) [pa-in]
	//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var paIn = moment.defineLocale('pa-in', {
	    // There are months name as per Nanakshahi Calender but they are not used as rigidly in modern Punjabi.
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm ',
	        LTS : 'A h:mm:ss ',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm ',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm '
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
	    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return paIn;
	
	})));


/***/ },
/* 390 */
/*!*******************************!*\
  !*** ./~/moment/locale/pl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Polish [pl]
	//! author : Rafal Hirsz : https://github.com/evoL
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_');
	var monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_');
	function plural(n) {
	    return (n % 10 < 5) && (n % 10 > 1) && ((~~(n / 10) % 10) !== 1);
	}
	function translate(number, withoutSuffix, key) {
	    var result = number + ' ';
	    switch (key) {
	        case 'm':
	            return withoutSuffix ? 'minuta' : 'minut';
	        case 'mm':
	            return result + (plural(number) ? 'minuty' : 'minut');
	        case 'h':
	            return withoutSuffix  ? 'godzina'  : 'godzin';
	        case 'hh':
	            return result + (plural(number) ? 'godziny' : 'godzin');
	        case 'MM':
	            return result + (plural(number) ? 'miesice' : 'miesicy');
	        case 'yy':
	            return result + (plural(number) ? 'lata' : 'lat');
	    }
	}
	
	var pl = moment.defineLocale('pl', {
	    months : function (momentToFormat, format) {
	        if (format === '') {
	            // Hack: if format empty we know this is used to generate
	            // RegExp by moment. Give then back both valid forms of months
	            // in RegExp ready format.
	            return '(' + monthsSubjective[momentToFormat.month()] + '|' + monthsNominative[momentToFormat.month()] + ')';
	        } else if (/D MMMM/.test(format)) {
	            return monthsSubjective[momentToFormat.month()];
	        } else {
	            return monthsNominative[momentToFormat.month()];
	        }
	    },
	    monthsShort : 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
	    weekdays : 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
	    weekdaysShort : 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
	    weekdaysMin : 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Dzi o] LT',
	        nextDay: '[Jutro o] LT',
	        nextWeek: '[W] dddd [o] LT',
	        lastDay: '[Wczoraj o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[W zesz niedziel o] LT';
	                case 3:
	                    return '[W zesz rod o] LT';
	                case 6:
	                    return '[W zesz sobot o] LT';
	                default:
	                    return '[W zeszy] dddd [o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : '%s temu',
	        s : 'kilka sekund',
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : '1 dzie',
	        dd : '%d dni',
	        M : 'miesic',
	        MM : translate,
	        y : 'rok',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return pl;
	
	})));


/***/ },
/* 391 */
/*!*******************************!*\
  !*** ./~/moment/locale/pt.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese [pt]
	//! author : Jefferson : https://github.com/jalex79
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var pt = moment.defineLocale('pt', {
	    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-Feira_Tera-Feira_Quarta-Feira_Quinta-Feira_Sexta-Feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : 'h %s',
	        s : 'segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return pt;
	
	})));


/***/ },
/* 392 */
/*!**********************************!*\
  !*** ./~/moment/locale/pt-br.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Portuguese (Brazil) [pt-br]
	//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var ptBr = moment.defineLocale('pt-br', {
	    months : 'Janeiro_Fevereiro_Maro_Abril_Maio_Junho_Julho_Agosto_Setembro_Outubro_Novembro_Dezembro'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
	    weekdaysMin : 'Dom_2_3_4_5_6_Sb'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D [de] MMMM [de] YYYY',
	        LLL : 'D [de] MMMM [de] YYYY [s] HH:mm',
	        LLLL : 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hoje s] LT',
	        nextDay: '[Amanh s] LT',
	        nextWeek: 'dddd [s] LT',
	        lastDay: '[Ontem s] LT',
	        lastWeek: function () {
	            return (this.day() === 0 || this.day() === 6) ?
	                '[ltimo] dddd [s] LT' : // Saturday + Sunday
	                '[ltima] dddd [s] LT'; // Monday - Friday
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'em %s',
	        past : '%s atrs',
	        s : 'poucos segundos',
	        m : 'um minuto',
	        mm : '%d minutos',
	        h : 'uma hora',
	        hh : '%d horas',
	        d : 'um dia',
	        dd : '%d dias',
	        M : 'um ms',
	        MM : '%d meses',
	        y : 'um ano',
	        yy : '%d anos'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d'
	});
	
	return ptBr;
	
	})));


/***/ },
/* 393 */
/*!*******************************!*\
  !*** ./~/moment/locale/ro.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Romanian [ro]
	//! author : Vlad Gurdiga : https://github.com/gurdiga
	//! author : Valentin Agachi : https://github.com/avaly
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	            'mm': 'minute',
	            'hh': 'ore',
	            'dd': 'zile',
	            'MM': 'luni',
	            'yy': 'ani'
	        },
	        separator = ' ';
	    if (number % 100 >= 20 || (number >= 100 && number % 100 === 0)) {
	        separator = ' de ';
	    }
	    return number + separator + format[key];
	}
	
	var ro = moment.defineLocale('ro', {
	    months : 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
	    monthsShort : 'ian._febr._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
	    weekdaysShort : 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
	    weekdaysMin : 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY H:mm',
	        LLLL : 'dddd, D MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[azi la] LT',
	        nextDay: '[mine la] LT',
	        nextWeek: 'dddd [la] LT',
	        lastDay: '[ieri la] LT',
	        lastWeek: '[fosta] dddd [la] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'peste %s',
	        past : '%s n urm',
	        s : 'cteva secunde',
	        m : 'un minut',
	        mm : relativeTimeWithPlural,
	        h : 'o or',
	        hh : relativeTimeWithPlural,
	        d : 'o zi',
	        dd : relativeTimeWithPlural,
	        M : 'o lun',
	        MM : relativeTimeWithPlural,
	        y : 'un an',
	        yy : relativeTimeWithPlural
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ro;
	
	})));


/***/ },
/* 394 */
/*!*******************************!*\
  !*** ./~/moment/locale/ru.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Russian [ru]
	//! author : Viktorminator : https://github.com/Viktorminator
	//! Author : Menelion Elensle : https://github.com/Oire
	//! author :   : https://github.com/socketpair
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
	
	// http://new.gramota.ru/spravka/rules/139-prop :  103
	//  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
	// CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753
	var ru = moment.defineLocale('ru', {
	    months : {
	        format: '___________'.split('_'),
	        standalone: '___________'.split('_')
	    },
	    monthsShort : {
	        //  CLDR  "."  ".",        ?
	        format: '._._._.____._._._._.'.split('_'),
	        standalone: '._.__.____._._._._.'.split('_')
	    },
	    weekdays : {
	        standalone: '______'.split('_'),
	        format: '______'.split('_'),
	        isFormat: /\[ ?[] ?(?:||)? ?\] ?dddd/
	    },
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    monthsParse : monthsParse,
	    longMonthsParse : monthsParse,
	    shortMonthsParse : monthsParse,
	
	    //    ,   ,  ,  4 ,      
	    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
	
	    //  
	    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
	
	    //    
	    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
	
	    // ,     
	    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        lastDay: '[ ] LT',
	        nextWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        lastWeek: function (now) {
	            if (now.week() !== this.week()) {
	                switch (this.day()) {
	                    case 0:
	                        return '[ ] dddd [] LT';
	                    case 1:
	                    case 2:
	                    case 4:
	                        return '[ ] dddd [] LT';
	                    case 3:
	                    case 5:
	                    case 6:
	                        return '[ ] dddd [] LT';
	                }
	            } else {
	                if (this.day() === 2) {
	                    return '[] dddd [] LT';
	                } else {
	                    return '[] dddd [] LT';
	                }
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    meridiemParse: /|||/i,
	    isPM : function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(||)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            case 'w':
	            case 'W':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ru;
	
	})));


/***/ },
/* 395 */
/*!*******************************!*\
  !*** ./~/moment/locale/se.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Northern Sami [se]
	//! authors : Brd Rolstad Henriksen : https://github.com/karamell
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var se = moment.defineLocale('se', {
	    months : 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
	    monthsShort : 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
	    weekdays : 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
	    weekdaysShort : 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
	    weekdaysMin : 's_v_m_g_d_b_L'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'MMMM D. [b.] YYYY',
	        LLL : 'MMMM D. [b.] YYYY [ti.] HH:mm',
	        LLLL : 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
	    },
	    calendar : {
	        sameDay: '[otne ti] LT',
	        nextDay: '[ihttin ti] LT',
	        nextWeek: 'dddd [ti] LT',
	        lastDay: '[ikte ti] LT',
	        lastWeek: '[ovddit] dddd [ti] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s geaes',
	        past : 'mait %s',
	        s : 'moadde sekunddat',
	        m : 'okta minuhta',
	        mm : '%d minuhtat',
	        h : 'okta diimmu',
	        hh : '%d diimmut',
	        d : 'okta beaivi',
	        dd : '%d beaivvit',
	        M : 'okta mnnu',
	        MM : '%d mnut',
	        y : 'okta jahki',
	        yy : '%d jagit'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return se;
	
	})));


/***/ },
/* 396 */
/*!*******************************!*\
  !*** ./~/moment/locale/si.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Sinhalese [si]
	//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	/*jshint -W100*/
	var si = moment.defineLocale('si', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'a h:mm',
	        LTS : 'a h:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'YYYY MMMM D',
	        LLL : 'YYYY MMMM D, a h:mm',
	        LLLL : 'YYYY MMMM D [] dddd, a h:mm:ss'
	    },
	    calendar : {
	        sameDay : '[] LT[]',
	        nextDay : '[] LT[]',
	        nextWeek : 'dddd LT[]',
	        lastDay : '[] LT[]',
	        lastWeek : '[] dddd LT[]',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s ',
	        s : ' ',
	        m : '',
	        mm : ' %d',
	        h : '',
	        hh : ' %d',
	        d : '',
	        dd : ' %d',
	        M : '',
	        MM : ' %d',
	        y : '',
	        yy : ' %d'
	    },
	    ordinalParse: /\d{1,2} /,
	    ordinal : function (number) {
	        return number + ' ';
	    },
	    meridiemParse : / | |.|../,
	    isPM : function (input) {
	        return input === '..' || input === ' ';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? '..' : ' ';
	        } else {
	            return isLower ? '..' : ' ';
	        }
	    }
	});
	
	return si;
	
	})));


/***/ },
/* 397 */
/*!*******************************!*\
  !*** ./~/moment/locale/sk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovak [sk]
	//! author : Martin Minka : https://github.com/k2s
	//! based on work of petrbela : https://github.com/petrbela
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_');
	var monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');
	function plural(n) {
	    return (n > 1) && (n < 5);
	}
	function translate(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':  // a few seconds / in a few seconds / a few seconds ago
	            return (withoutSuffix || isFuture) ? 'pr seknd' : 'pr sekundami';
	        case 'm':  // a minute / in a minute / a minute ago
	            return withoutSuffix ? 'minta' : (isFuture ? 'mintu' : 'mintou');
	        case 'mm': // 9 minutes / in 9 minutes / 9 minutes ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'minty' : 'mint');
	            } else {
	                return result + 'mintami';
	            }
	            break;
	        case 'h':  // an hour / in an hour / an hour ago
	            return withoutSuffix ? 'hodina' : (isFuture ? 'hodinu' : 'hodinou');
	        case 'hh': // 9 hours / in 9 hours / 9 hours ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'hodiny' : 'hodn');
	            } else {
	                return result + 'hodinami';
	            }
	            break;
	        case 'd':  // a day / in a day / a day ago
	            return (withoutSuffix || isFuture) ? 'de' : 'dom';
	        case 'dd': // 9 days / in 9 days / 9 days ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'dni' : 'dn');
	            } else {
	                return result + 'dami';
	            }
	            break;
	        case 'M':  // a month / in a month / a month ago
	            return (withoutSuffix || isFuture) ? 'mesiac' : 'mesiacom';
	        case 'MM': // 9 months / in 9 months / 9 months ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'mesiace' : 'mesiacov');
	            } else {
	                return result + 'mesiacmi';
	            }
	            break;
	        case 'y':  // a year / in a year / a year ago
	            return (withoutSuffix || isFuture) ? 'rok' : 'rokom';
	        case 'yy': // 9 years / in 9 years / 9 years ago
	            if (withoutSuffix || isFuture) {
	                return result + (plural(number) ? 'roky' : 'rokov');
	            } else {
	                return result + 'rokmi';
	            }
	            break;
	    }
	}
	
	var sk = moment.defineLocale('sk', {
	    months : months,
	    monthsShort : monthsShort,
	    weekdays : 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
	    weekdaysShort : 'ne_po_ut_st_t_pi_so'.split('_'),
	    weekdaysMin : 'ne_po_ut_st_t_pi_so'.split('_'),
	    longDateFormat : {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay: '[dnes o] LT',
	        nextDay: '[zajtra o] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[v] dddd [o] LT';
	                case 3:
	                    return '[v stredu o] LT';
	                case 4:
	                    return '[vo tvrtok o] LT';
	                case 5:
	                    return '[v piatok o] LT';
	                case 6:
	                    return '[v sobotu o] LT';
	            }
	        },
	        lastDay: '[vera o] LT',
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[minul nedeu o] LT';
	                case 1:
	                case 2:
	                    return '[minul] dddd [o] LT';
	                case 3:
	                    return '[minul stredu o] LT';
	                case 4:
	                case 5:
	                    return '[minul] dddd [o] LT';
	                case 6:
	                    return '[minul sobotu o] LT';
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past : 'pred %s',
	        s : translate,
	        m : translate,
	        mm : translate,
	        h : translate,
	        hh : translate,
	        d : translate,
	        dd : translate,
	        M : translate,
	        MM : translate,
	        y : translate,
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sk;
	
	})));


/***/ },
/* 398 */
/*!*******************************!*\
  !*** ./~/moment/locale/sl.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Slovenian [sl]
	//! author : Robert Sedovek : https://github.com/sedovsek
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var result = number + ' ';
	    switch (key) {
	        case 's':
	            return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';
	        case 'm':
	            return withoutSuffix ? 'ena minuta' : 'eno minuto';
	        case 'mm':
	            if (number === 1) {
	                result += withoutSuffix ? 'minuta' : 'minuto';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'minute' : 'minutami';
	            } else {
	                result += withoutSuffix || isFuture ? 'minut' : 'minutami';
	            }
	            return result;
	        case 'h':
	            return withoutSuffix ? 'ena ura' : 'eno uro';
	        case 'hh':
	            if (number === 1) {
	                result += withoutSuffix ? 'ura' : 'uro';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'uri' : 'urama';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'ure' : 'urami';
	            } else {
	                result += withoutSuffix || isFuture ? 'ur' : 'urami';
	            }
	            return result;
	        case 'd':
	            return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';
	        case 'dd':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'dan' : 'dnem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
	            } else {
	                result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
	            }
	            return result;
	        case 'M':
	            return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';
	        case 'MM':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
	            } else {
	                result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
	            }
	            return result;
	        case 'y':
	            return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';
	        case 'yy':
	            if (number === 1) {
	                result += withoutSuffix || isFuture ? 'leto' : 'letom';
	            } else if (number === 2) {
	                result += withoutSuffix || isFuture ? 'leti' : 'letoma';
	            } else if (number < 5) {
	                result += withoutSuffix || isFuture ? 'leta' : 'leti';
	            } else {
	                result += withoutSuffix || isFuture ? 'let' : 'leti';
	            }
	            return result;
	    }
	}
	
	var sl = moment.defineLocale('sl', {
	    months : 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays : 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
	    weekdaysShort : 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
	    weekdaysMin : 'ne_po_to_sr_e_pe_so'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM YYYY',
	        LLL : 'D. MMMM YYYY H:mm',
	        LLLL : 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar : {
	        sameDay  : '[danes ob] LT',
	        nextDay  : '[jutri ob] LT',
	
	        nextWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[v] [nedeljo] [ob] LT';
	                case 3:
	                    return '[v] [sredo] [ob] LT';
	                case 6:
	                    return '[v] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[v] dddd [ob] LT';
	            }
	        },
	        lastDay  : '[veraj ob] LT',
	        lastWeek : function () {
	            switch (this.day()) {
	                case 0:
	                    return '[prejnjo] [nedeljo] [ob] LT';
	                case 3:
	                    return '[prejnjo] [sredo] [ob] LT';
	                case 6:
	                    return '[prejnjo] [soboto] [ob] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[prejnji] dddd [ob] LT';
	            }
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ez %s',
	        past   : 'pred %s',
	        s      : processRelativeTime,
	        m      : processRelativeTime,
	        mm     : processRelativeTime,
	        h      : processRelativeTime,
	        hh     : processRelativeTime,
	        d      : processRelativeTime,
	        dd     : processRelativeTime,
	        M      : processRelativeTime,
	        MM     : processRelativeTime,
	        y      : processRelativeTime,
	        yy     : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sl;
	
	})));


/***/ },
/* 399 */
/*!*******************************!*\
  !*** ./~/moment/locale/sq.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Albanian [sq]
	//! author : Flakrim Ismani : https://github.com/flakerimi
	//! author : Menelion Elensle : https://github.com/Oire
	//! author : Oerd Cukalla : https://github.com/oerd
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sq = moment.defineLocale('sq', {
	    months : 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
	    monthsShort : 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
	    weekdays : 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
	    weekdaysShort : 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
	    weekdaysMin : 'D_H_Ma_M_E_P_Sh'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /PD|MD/,
	    isPM: function (input) {
	        return input.charAt(0) === 'M';
	    },
	    meridiem : function (hours, minutes, isLower) {
	        return hours < 12 ? 'PD' : 'MD';
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[Sot n] LT',
	        nextDay : '[Nesr n] LT',
	        nextWeek : 'dddd [n] LT',
	        lastDay : '[Dje n] LT',
	        lastWeek : 'dddd [e kaluar n] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'n %s',
	        past : '%s m par',
	        s : 'disa sekonda',
	        m : 'nj minut',
	        mm : '%d minuta',
	        h : 'nj or',
	        hh : '%d or',
	        d : 'nj dit',
	        dd : '%d dit',
	        M : 'nj muaj',
	        MM : '%d muaj',
	        y : 'nj vit',
	        yy : '%d vite'
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sq;
	
	})));


/***/ },
/* 400 */
/*!*******************************!*\
  !*** ./~/moment/locale/sr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian [sr]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: ['jedan minut', 'jedne minute'],
	        mm: ['minut', 'minute', 'minuta'],
	        h: ['jedan sat', 'jednog sata'],
	        hh: ['sat', 'sata', 'sati'],
	        dd: ['dan', 'dana', 'dana'],
	        MM: ['mesec', 'meseca', 'meseci'],
	        yy: ['godina', 'godine', 'godina']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var sr = moment.defineLocale('sr', {
	    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
	    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
	    monthsParseExact: true,
	    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
	    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
	    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[danas u] LT',
	        nextDay: '[sutra u] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[u] [nedelju] [u] LT';
	                case 3:
	                    return '[u] [sredu] [u] LT';
	                case 6:
	                    return '[u] [subotu] [u] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[u] dddd [u] LT';
	            }
	        },
	        lastDay  : '[jue u] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[prole] [nedelje] [u] LT',
	                '[prolog] [ponedeljka] [u] LT',
	                '[prolog] [utorka] [u] LT',
	                '[prole] [srede] [u] LT',
	                '[prolog] [etvrtka] [u] LT',
	                '[prolog] [petka] [u] LT',
	                '[prole] [subote] [u] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'za %s',
	        past   : 'pre %s',
	        s      : 'nekoliko sekundi',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : 'dan',
	        dd     : translator.translate,
	        M      : 'mesec',
	        MM     : translator.translate,
	        y      : 'godinu',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sr;
	
	})));


/***/ },
/* 401 */
/*!************************************!*\
  !*** ./~/moment/locale/sr-cyrl.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Serbian Cyrillic [sr-cyrl]
	//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var translator = {
	    words: { //Different grammatical cases
	        m: [' ', ' '],
	        mm: ['', '', ''],
	        h: [' ', ' '],
	        hh: ['', '', ''],
	        dd: ['', '', ''],
	        MM: ['', '', ''],
	        yy: ['', '', '']
	    },
	    correctGrammaticalCase: function (number, wordKey) {
	        return number === 1 ? wordKey[0] : (number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]);
	    },
	    translate: function (number, withoutSuffix, key) {
	        var wordKey = translator.words[key];
	        if (key.length === 1) {
	            return withoutSuffix ? wordKey[0] : wordKey[1];
	        } else {
	            return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
	        }
	    }
	};
	
	var srCyrl = moment.defineLocale('sr-cyrl', {
	    months: '___________'.split('_'),
	    monthsShort: '._._._.____._._._._.'.split('_'),
	    monthsParseExact: true,
	    weekdays: '______'.split('_'),
	    weekdaysShort: '._._._._._._.'.split('_'),
	    weekdaysMin: '______'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat: {
	        LT: 'H:mm',
	        LTS : 'H:mm:ss',
	        L: 'DD.MM.YYYY',
	        LL: 'D. MMMM YYYY',
	        LLL: 'D. MMMM YYYY H:mm',
	        LLLL: 'dddd, D. MMMM YYYY H:mm'
	    },
	    calendar: {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: function () {
	            switch (this.day()) {
	                case 0:
	                    return '[] [] [] LT';
	                case 3:
	                    return '[] [] [] LT';
	                case 6:
	                    return '[] [] [] LT';
	                case 1:
	                case 2:
	                case 4:
	                case 5:
	                    return '[] dddd [] LT';
	            }
	        },
	        lastDay  : '[ ] LT',
	        lastWeek : function () {
	            var lastWeekDays = [
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT',
	                '[] [] [] LT'
	            ];
	            return lastWeekDays[this.day()];
	        },
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past   : ' %s',
	        s      : ' ',
	        m      : translator.translate,
	        mm     : translator.translate,
	        h      : translator.translate,
	        hh     : translator.translate,
	        d      : '',
	        dd     : translator.translate,
	        M      : '',
	        MM     : translator.translate,
	        y      : '',
	        yy     : translator.translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return srCyrl;
	
	})));


/***/ },
/* 402 */
/*!*******************************!*\
  !*** ./~/moment/locale/ss.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : siSwati [ss]
	//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	
	var ss = moment.defineLocale('ss', {
	    months : "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
	    monthsShort : 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
	    weekdays : 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
	    weekdaysShort : 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
	    weekdaysMin : 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Namuhla nga] LT',
	        nextDay : '[Kusasa nga] LT',
	        nextWeek : 'dddd [nga] LT',
	        lastDay : '[Itolo nga] LT',
	        lastWeek : 'dddd [leliphelile] [nga] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'nga %s',
	        past : 'wenteka nga %s',
	        s : 'emizuzwana lomcane',
	        m : 'umzuzu',
	        mm : '%d emizuzu',
	        h : 'lihora',
	        hh : '%d emahora',
	        d : 'lilanga',
	        dd : '%d emalanga',
	        M : 'inyanga',
	        MM : '%d tinyanga',
	        y : 'umnyaka',
	        yy : '%d iminyaka'
	    },
	    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 11) {
	            return 'ekuseni';
	        } else if (hours < 15) {
	            return 'emini';
	        } else if (hours < 19) {
	            return 'entsambama';
	        } else {
	            return 'ebusuku';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === 'ekuseni') {
	            return hour;
	        } else if (meridiem === 'emini') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
	            if (hour === 0) {
	                return 0;
	            }
	            return hour + 12;
	        }
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : '%d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return ss;
	
	})));


/***/ },
/* 403 */
/*!*******************************!*\
  !*** ./~/moment/locale/sv.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swedish [sv]
	//! author : Jens Alm : https://github.com/ulmus
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sv = moment.defineLocale('sv', {
	    months : 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
	    monthsShort : 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
	    weekdays : 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
	    weekdaysShort : 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
	    weekdaysMin : 's_m_ti_on_to_fr_l'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'YYYY-MM-DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY [kl.] HH:mm',
	        LLLL : 'dddd D MMMM YYYY [kl.] HH:mm',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Idag] LT',
	        nextDay: '[Imorgon] LT',
	        lastDay: '[Igr] LT',
	        nextWeek: '[P] dddd LT',
	        lastWeek: '[I] dddd[s] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'om %s',
	        past : 'fr %s sedan',
	        s : 'ngra sekunder',
	        m : 'en minut',
	        mm : '%d minuter',
	        h : 'en timme',
	        hh : '%d timmar',
	        d : 'en dag',
	        dd : '%d dagar',
	        M : 'en mnad',
	        MM : '%d mnader',
	        y : 'ett r',
	        yy : '%d r'
	    },
	    ordinalParse: /\d{1,2}(e|a)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'e' :
	            (b === 1) ? 'a' :
	            (b === 2) ? 'a' :
	            (b === 3) ? 'e' : 'e';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return sv;
	
	})));


/***/ },
/* 404 */
/*!*******************************!*\
  !*** ./~/moment/locale/sw.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Swahili [sw]
	//! author : Fahad Kassim : https://github.com/fadsel
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var sw = moment.defineLocale('sw', {
	    months : 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
	    monthsShort : 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
	    weekdays : 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
	    weekdaysShort : 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
	    weekdaysMin : 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[leo saa] LT',
	        nextDay : '[kesho saa] LT',
	        nextWeek : '[wiki ijayo] dddd [saat] LT',
	        lastDay : '[jana] LT',
	        lastWeek : '[wiki iliyopita] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s baadaye',
	        past : 'tokea %s',
	        s : 'hivi punde',
	        m : 'dakika moja',
	        mm : 'dakika %d',
	        h : 'saa limoja',
	        hh : 'masaa %d',
	        d : 'siku moja',
	        dd : 'masiku %d',
	        M : 'mwezi mmoja',
	        MM : 'miezi %d',
	        y : 'mwaka mmoja',
	        yy : 'miaka %d'
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return sw;
	
	})));


/***/ },
/* 405 */
/*!*******************************!*\
  !*** ./~/moment/locale/ta.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tamil [ta]
	//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var symbolMap = {
	    '1': '',
	    '2': '',
	    '3': '',
	    '4': '',
	    '5': '',
	    '6': '',
	    '7': '',
	    '8': '',
	    '9': '',
	    '0': ''
	};
	var numberMap = {
	    '': '1',
	    '': '2',
	    '': '3',
	    '': '4',
	    '': '5',
	    '': '6',
	    '': '7',
	    '': '8',
	    '': '9',
	    '': '0'
	};
	
	var ta = moment.defineLocale('ta', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, HH:mm',
	        LLLL : 'dddd, D MMMM YYYY, HH:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[ ] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : '  ',
	        m : ' ',
	        mm : '%d ',
	        h : '  ',
	        hh : '%d  ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number + '';
	    },
	    preparse: function (string) {
	        return string.replace(/[]/g, function (match) {
	            return numberMap[match];
	        });
	    },
	    postformat: function (string) {
	        return string.replace(/\d/g, function (match) {
	            return symbolMap[match];
	        });
	    },
	    // refer http://ta.wikipedia.org/s/1er1
	    meridiemParse: /|||||/,
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 2) {
	            return ' ';
	        } else if (hour < 6) {
	            return ' ';  // 
	        } else if (hour < 10) {
	            return ' '; // 
	        } else if (hour < 14) {
	            return ' '; // 
	        } else if (hour < 18) {
	            return ' '; // 
	        } else if (hour < 22) {
	            return ' '; // 
	        } else {
	            return ' ';
	        }
	    },
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 2 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else {
	            return hour + 12;
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return ta;
	
	})));


/***/ },
/* 406 */
/*!*******************************!*\
  !*** ./~/moment/locale/te.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Telugu [te]
	//! author : Krishna Chaitanya Thota : https://github.com/kcthota
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var te = moment.defineLocale('te', {
	    months : '___________'.split('_'),
	    monthsShort : '._.__.____._._._._.'.split('_'),
	    monthsParseExact : true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'A h:mm',
	        LTS : 'A h:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY, A h:mm',
	        LLLL : 'dddd, D MMMM YYYY, A h:mm'
	    },
	    calendar : {
	        sameDay : '[] LT',
	        nextDay : '[] LT',
	        nextWeek : 'dddd, LT',
	        lastDay : '[] LT',
	        lastWeek : '[] dddd, LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s ',
	        past : '%s ',
	        s : ' ',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    ordinalParse : /\d{1,2}/,
	    ordinal : '%d',
	    meridiemParse: /|||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '') {
	            return hour < 4 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 10 ? hour : hour + 12;
	        } else if (meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 10) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else if (hour < 20) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    week : {
	        dow : 0, // Sunday is the first day of the week.
	        doy : 6  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return te;
	
	})));


/***/ },
/* 407 */
/*!********************************!*\
  !*** ./~/moment/locale/tet.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tetun Dili (East Timor) [tet]
	//! author : Joshua Brooks : https://github.com/joshbrooks
	//! author : Onorio De J. Afonso : https://github.com/marobo
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tet = moment.defineLocale('tet', {
	    months : 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juniu_Juliu_Augustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Aug_Set_Out_Nov_Dez'.split('_'),
	    weekdays : 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sexta_Sabadu'.split('_'),
	    weekdaysShort : 'Dom_Seg_Ters_Kua_Kint_Sext_Sab'.split('_'),
	    weekdaysMin : 'Do_Seg_Te_Ku_Ki_Sex_Sa'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Ohin iha] LT',
	        nextDay: '[Aban iha] LT',
	        nextWeek: 'dddd [iha] LT',
	        lastDay: '[Horiseik iha] LT',
	        lastWeek: 'dddd [semana kotuk] [iha] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'iha %s',
	        past : '%s liuba',
	        s : 'minutu balun',
	        m : 'minutu ida',
	        mm : 'minutus %d',
	        h : 'horas ida',
	        hh : 'horas %d',
	        d : 'loron ida',
	        dd : 'loron %d',
	        M : 'fulan ida',
	        MM : 'fulan %d',
	        y : 'tinan ida',
	        yy : 'tinan %d'
	    },
	    ordinalParse: /\d{1,2}(st|nd|rd|th)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tet;
	
	})));


/***/ },
/* 408 */
/*!*******************************!*\
  !*** ./~/moment/locale/th.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Thai [th]
	//! author : Kridsada Thanabulpong : https://github.com/sirn
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var th = moment.defineLocale('th', {
	    months : '___________'.split('_'),
	    monthsShort : '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
	    monthsParseExact: true,
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'), // yes, three characters difference
	    weekdaysMin : '._._._._._._.'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'H:mm',
	        LTS : 'H:mm:ss',
	        L : 'YYYY/MM/DD',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY  H:mm',
	        LLLL : 'dddd D MMMM YYYY  H:mm'
	    },
	    meridiemParse: /|/,
	    isPM: function (input) {
	        return input === '';
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 12) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[ ] LT',
	        nextDay : '[ ] LT',
	        nextWeek : 'dddd[ ] LT',
	        lastDay : '[ ] LT',
	        lastWeek : '[]dddd[ ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return th;
	
	})));


/***/ },
/* 409 */
/*!**********************************!*\
  !*** ./~/moment/locale/tl-ph.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Tagalog (Philippines) [tl-ph]
	//! author : Dan Hagman : https://github.com/hagmandan
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tlPh = moment.defineLocale('tl-ph', {
	    months : 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
	    monthsShort : 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
	    weekdays : 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
	    weekdaysShort : 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
	    weekdaysMin : 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'MM/D/YYYY',
	        LL : 'MMMM D, YYYY',
	        LLL : 'MMMM D, YYYY HH:mm',
	        LLLL : 'dddd, MMMM DD, YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: 'LT [ngayong araw]',
	        nextDay: '[Bukas ng] LT',
	        nextWeek: 'LT [sa susunod na] dddd',
	        lastDay: 'LT [kahapon]',
	        lastWeek: 'LT [noong nakaraang] dddd',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'sa loob ng %s',
	        past : '%s ang nakalipas',
	        s : 'ilang segundo',
	        m : 'isang minuto',
	        mm : '%d minuto',
	        h : 'isang oras',
	        hh : '%d oras',
	        d : 'isang araw',
	        dd : '%d araw',
	        M : 'isang buwan',
	        MM : '%d buwan',
	        y : 'isang taon',
	        yy : '%d taon'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tlPh;
	
	})));


/***/ },
/* 410 */
/*!********************************!*\
  !*** ./~/moment/locale/tlh.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Klingon [tlh]
	//! author : Dominika Kruk : https://github.com/amaranthrose
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');
	
	function translateFuture(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'leS' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'waQ' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'nem' :
	    time + ' pIq';
	    return time;
	}
	
	function translatePast(output) {
	    var time = output;
	    time = (output.indexOf('jaj') !== -1) ?
	    time.slice(0, -3) + 'Hu' :
	    (output.indexOf('jar') !== -1) ?
	    time.slice(0, -3) + 'wen' :
	    (output.indexOf('DIS') !== -1) ?
	    time.slice(0, -3) + 'ben' :
	    time + ' ret';
	    return time;
	}
	
	function translate(number, withoutSuffix, string, isFuture) {
	    var numberNoun = numberAsNoun(number);
	    switch (string) {
	        case 'mm':
	            return numberNoun + ' tup';
	        case 'hh':
	            return numberNoun + ' rep';
	        case 'dd':
	            return numberNoun + ' jaj';
	        case 'MM':
	            return numberNoun + ' jar';
	        case 'yy':
	            return numberNoun + ' DIS';
	    }
	}
	
	function numberAsNoun(number) {
	    var hundred = Math.floor((number % 1000) / 100),
	    ten = Math.floor((number % 100) / 10),
	    one = number % 10,
	    word = '';
	    if (hundred > 0) {
	        word += numbersNouns[hundred] + 'vatlh';
	    }
	    if (ten > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[ten] + 'maH';
	    }
	    if (one > 0) {
	        word += ((word !== '') ? ' ' : '') + numbersNouns[one];
	    }
	    return (word === '') ? 'pagh' : word;
	}
	
	var tlh = moment.defineLocale('tlh', {
	    months : 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
	    monthsShort : 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysShort : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    weekdaysMin : 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[DaHjaj] LT',
	        nextDay: '[waleS] LT',
	        nextWeek: 'LLL',
	        lastDay: '[waHu] LT',
	        lastWeek: 'LLL',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : translateFuture,
	        past : translatePast,
	        s : 'puS lup',
	        m : 'wa tup',
	        mm : translate,
	        h : 'wa rep',
	        hh : translate,
	        d : 'wa jaj',
	        dd : translate,
	        M : 'wa jar',
	        MM : translate,
	        y : 'wa DIS',
	        yy : translate
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return tlh;
	
	})));


/***/ },
/* 411 */
/*!*******************************!*\
  !*** ./~/moment/locale/tr.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Turkish [tr]
	//! authors : Erhan Gundogan : https://github.com/erhangundogan,
	//!           Burak Yiit Kaya: https://github.com/BYK
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var suffixes = {
	    1: '\'inci',
	    5: '\'inci',
	    8: '\'inci',
	    70: '\'inci',
	    80: '\'inci',
	    2: '\'nci',
	    7: '\'nci',
	    20: '\'nci',
	    50: '\'nci',
	    3: '\'nc',
	    4: '\'nc',
	    100: '\'nc',
	    6: '\'nc',
	    9: '\'uncu',
	    10: '\'uncu',
	    30: '\'uncu',
	    60: '\'nc',
	    90: '\'nc'
	};
	
	var tr = moment.defineLocale('tr', {
	    months : 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
	    monthsShort : 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
	    weekdays : 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
	    weekdaysShort : 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
	    weekdaysMin : 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[bugn saat] LT',
	        nextDay : '[yarn saat] LT',
	        nextWeek : '[haftaya] dddd [saat] LT',
	        lastDay : '[dn] LT',
	        lastWeek : '[geen hafta] dddd [saat] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '%s sonra',
	        past : '%s nce',
	        s : 'birka saniye',
	        m : 'bir dakika',
	        mm : '%d dakika',
	        h : 'bir saat',
	        hh : '%d saat',
	        d : 'bir gn',
	        dd : '%d gn',
	        M : 'bir ay',
	        MM : '%d ay',
	        y : 'bir yl',
	        yy : '%d yl'
	    },
	    ordinalParse: /\d{1,2}'(inci|nci|nc|nc|uncu|nc)/,
	    ordinal : function (number) {
	        if (number === 0) {  // special case for zero
	            return number + '\'nc';
	        }
	        var a = number % 10,
	            b = number % 100 - a,
	            c = number >= 100 ? 100 : null;
	        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tr;
	
	})));


/***/ },
/* 412 */
/*!********************************!*\
  !*** ./~/moment/locale/tzl.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Talossan [tzl]
	//! author : Robin van der Vliet : https://github.com/robin0van0der0v
	//! author : Iust Canun
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	// After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
	// This is currently too difficult (maybe even impossible) to add.
	var tzl = moment.defineLocale('tzl', {
	    months : 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
	    monthsShort : 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
	    weekdays : 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
	    weekdaysShort : 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
	    weekdaysMin : 'S_L_Ma_M_Xh_Vi_S'.split('_'),
	    longDateFormat : {
	        LT : 'HH.mm',
	        LTS : 'HH.mm.ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D. MMMM [dallas] YYYY',
	        LLL : 'D. MMMM [dallas] YYYY HH.mm',
	        LLLL : 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
	    },
	    meridiemParse: /d\'o|d\'a/i,
	    isPM : function (input) {
	        return 'd\'o' === input.toLowerCase();
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours > 11) {
	            return isLower ? 'd\'o' : 'D\'O';
	        } else {
	            return isLower ? 'd\'a' : 'D\'A';
	        }
	    },
	    calendar : {
	        sameDay : '[oxhi ] LT',
	        nextDay : '[dem ] LT',
	        nextWeek : 'dddd [] LT',
	        lastDay : '[ieiri ] LT',
	        lastWeek : '[sr el] dddd [lasteu ] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'osprei %s',
	        past : 'ja%s',
	        s : processRelativeTime,
	        m : processRelativeTime,
	        mm : processRelativeTime,
	        h : processRelativeTime,
	        hh : processRelativeTime,
	        d : processRelativeTime,
	        dd : processRelativeTime,
	        M : processRelativeTime,
	        MM : processRelativeTime,
	        y : processRelativeTime,
	        yy : processRelativeTime
	    },
	    ordinalParse: /\d{1,2}\./,
	    ordinal : '%d.',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	function processRelativeTime(number, withoutSuffix, key, isFuture) {
	    var format = {
	        's': ['viensas secunds', '\'iensas secunds'],
	        'm': ['\'n mut', '\'iens mut'],
	        'mm': [number + ' muts', '' + number + ' muts'],
	        'h': ['\'n ora', '\'iensa ora'],
	        'hh': [number + ' oras', '' + number + ' oras'],
	        'd': ['\'n ziua', '\'iensa ziua'],
	        'dd': [number + ' ziuas', '' + number + ' ziuas'],
	        'M': ['\'n mes', '\'iens mes'],
	        'MM': [number + ' mesen', '' + number + ' mesen'],
	        'y': ['\'n ar', '\'iens ar'],
	        'yy': [number + ' ars', '' + number + ' ars']
	    };
	    return isFuture ? format[key][0] : (withoutSuffix ? format[key][0] : format[key][1]);
	}
	
	return tzl;
	
	})));


/***/ },
/* 413 */
/*!********************************!*\
  !*** ./~/moment/locale/tzm.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight [tzm]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tzm = moment.defineLocale('tzm', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS: 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[ ] LT',
	        nextDay: '[ ] LT',
	        nextWeek: 'dddd [] LT',
	        lastDay: '[ ] LT',
	        lastWeek: 'dddd [] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '   %s',
	        past : ' %s',
	        s : '',
	        m : '',
	        mm : '%d ',
	        h : '',
	        hh : '%d ',
	        d : '',
	        dd : '%d o',
	        M : 'o',
	        MM : '%d ',
	        y : '',
	        yy : '%d '
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tzm;
	
	})));


/***/ },
/* 414 */
/*!*************************************!*\
  !*** ./~/moment/locale/tzm-latn.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Central Atlas Tamazight Latin [tzm-latn]
	//! author : Abdel Said : https://github.com/abdelsaid
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var tzmLatn = moment.defineLocale('tzm-latn', {
	    months : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    monthsShort : 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
	    weekdays : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysShort : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    weekdaysMin : 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[asdkh g] LT',
	        nextDay: '[aska g] LT',
	        nextWeek: 'dddd [g] LT',
	        lastDay: '[assant g] LT',
	        lastWeek: 'dddd [g] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : 'dadkh s yan %s',
	        past : 'yan %s',
	        s : 'imik',
	        m : 'minu',
	        mm : '%d minu',
	        h : 'saa',
	        hh : '%d tassain',
	        d : 'ass',
	        dd : '%d ossan',
	        M : 'ayowr',
	        MM : '%d iyyirn',
	        y : 'asgas',
	        yy : '%d isgasn'
	    },
	    week : {
	        dow : 6, // Saturday is the first day of the week.
	        doy : 12  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return tzmLatn;
	
	})));


/***/ },
/* 415 */
/*!*******************************!*\
  !*** ./~/moment/locale/uk.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Ukrainian [uk]
	//! author : zemlanin : https://github.com/zemlanin
	//! Author : Menelion Elensle : https://github.com/Oire
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	function plural(word, num) {
	    var forms = word.split('_');
	    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : (num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]);
	}
	function relativeTimeWithPlural(number, withoutSuffix, key) {
	    var format = {
	        'mm': withoutSuffix ? '__' : '__',
	        'hh': withoutSuffix ? '__' : '__',
	        'dd': '__',
	        'MM': '__',
	        'yy': '__'
	    };
	    if (key === 'm') {
	        return withoutSuffix ? '' : '';
	    }
	    else if (key === 'h') {
	        return withoutSuffix ? '' : '';
	    }
	    else {
	        return number + ' ' + plural(format[key], +number);
	    }
	}
	function weekdaysCaseReplace(m, format) {
	    var weekdays = {
	        'nominative': '______'.split('_'),
	        'accusative': '______'.split('_'),
	        'genitive': '______'.split('_')
	    },
	    nounCase = (/(\[[]\]) ?dddd/).test(format) ?
	        'accusative' :
	        ((/\[?(?:|)? ?\] ?dddd/).test(format) ?
	            'genitive' :
	            'nominative');
	    return weekdays[nounCase][m.day()];
	}
	function processHoursFunction(str) {
	    return function () {
	        return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
	    };
	}
	
	var uk = moment.defineLocale('uk', {
	    months : {
	        'format': '___________'.split('_'),
	        'standalone': '___________'.split('_')
	    },
	    monthsShort : '___________'.split('_'),
	    weekdays : weekdaysCaseReplace,
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD.MM.YYYY',
	        LL : 'D MMMM YYYY .',
	        LLL : 'D MMMM YYYY ., HH:mm',
	        LLLL : 'dddd, D MMMM YYYY ., HH:mm'
	    },
	    calendar : {
	        sameDay: processHoursFunction('[ '),
	        nextDay: processHoursFunction('[ '),
	        lastDay: processHoursFunction('[ '),
	        nextWeek: processHoursFunction('[] dddd ['),
	        lastWeek: function () {
	            switch (this.day()) {
	                case 0:
	                case 3:
	                case 5:
	                case 6:
	                    return processHoursFunction('[] dddd [').call(this);
	                case 1:
	                case 2:
	                case 4:
	                    return processHoursFunction('[] dddd [').call(this);
	            }
	        },
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : ' %s',
	        past : '%s ',
	        s : ' ',
	        m : relativeTimeWithPlural,
	        mm : relativeTimeWithPlural,
	        h : '',
	        hh : relativeTimeWithPlural,
	        d : '',
	        dd : relativeTimeWithPlural,
	        M : '',
	        MM : relativeTimeWithPlural,
	        y : '',
	        yy : relativeTimeWithPlural
	    },
	    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
	    meridiemParse: /|||/,
	    isPM: function (input) {
	        return /^(|)$/.test(input);
	    },
	    meridiem : function (hour, minute, isLower) {
	        if (hour < 4) {
	            return '';
	        } else if (hour < 12) {
	            return '';
	        } else if (hour < 17) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    ordinalParse: /\d{1,2}-(|)/,
	    ordinal: function (number, period) {
	        switch (period) {
	            case 'M':
	            case 'd':
	            case 'DDD':
	            case 'w':
	            case 'W':
	                return number + '-';
	            case 'D':
	                return number + '-';
	            default:
	                return number;
	        }
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 1st is the first week of the year.
	    }
	});
	
	return uk;
	
	})));


/***/ },
/* 416 */
/*!*******************************!*\
  !*** ./~/moment/locale/uz.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Uzbek [uz]
	//! author : Sardor Muminov : https://github.com/muminoff
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var uz = moment.defineLocale('uz', {
	    months : '___________'.split('_'),
	    monthsShort : '___________'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'D MMMM YYYY, dddd HH:mm'
	    },
	    calendar : {
	        sameDay : '[ ] LT []',
	        nextDay : '[] LT []',
	        nextWeek : 'dddd [ ] LT []',
	        lastDay : '[ ] LT []',
	        lastWeek : '[] dddd [ ] LT []',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : ' %s ',
	        past : '  %s ',
	        s : '',
	        m : ' ',
	        mm : '%d ',
	        h : ' ',
	        hh : '%d ',
	        d : ' ',
	        dd : '%d ',
	        M : ' ',
	        MM : '%d ',
	        y : ' ',
	        yy : '%d '
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 7  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return uz;
	
	})));


/***/ },
/* 417 */
/*!*******************************!*\
  !*** ./~/moment/locale/vi.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Vietnamese [vi]
	//! author : Bang Nguyen : https://github.com/bangnk
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var vi = moment.defineLocale('vi', {
	    months : 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
	    monthsShort : 'Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
	    weekdaysShort : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysMin : 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
	    weekdaysParseExact : true,
	    meridiemParse: /sa|ch/i,
	    isPM : function (input) {
	        return /^ch$/i.test(input);
	    },
	    meridiem : function (hours, minutes, isLower) {
	        if (hours < 12) {
	            return isLower ? 'sa' : 'SA';
	        } else {
	            return isLower ? 'ch' : 'CH';
	        }
	    },
	    longDateFormat : {
	        LT : 'HH:mm',
	        LTS : 'HH:mm:ss',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM [nm] YYYY',
	        LLL : 'D MMMM [nm] YYYY HH:mm',
	        LLLL : 'dddd, D MMMM [nm] YYYY HH:mm',
	        l : 'DD/M/YYYY',
	        ll : 'D MMM YYYY',
	        lll : 'D MMM YYYY HH:mm',
	        llll : 'ddd, D MMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay: '[Hm nay lc] LT',
	        nextDay: '[Ngy mai lc] LT',
	        nextWeek: 'dddd [tun ti lc] LT',
	        lastDay: '[Hm qua lc] LT',
	        lastWeek: 'dddd [tun ri lc] LT',
	        sameElse: 'L'
	    },
	    relativeTime : {
	        future : '%s ti',
	        past : '%s trc',
	        s : 'vi giy',
	        m : 'mt pht',
	        mm : '%d pht',
	        h : 'mt gi',
	        hh : '%d gi',
	        d : 'mt ngy',
	        dd : '%d ngy',
	        M : 'mt thng',
	        MM : '%d thng',
	        y : 'mt nm',
	        yy : '%d nm'
	    },
	    ordinalParse: /\d{1,2}/,
	    ordinal : function (number) {
	        return number;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return vi;
	
	})));


/***/ },
/* 418 */
/*!*************************************!*\
  !*** ./~/moment/locale/x-pseudo.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Pseudo [x-pseudo]
	//! author : Andrew Hood : https://github.com/andrewhood125
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var xPseudo = moment.defineLocale('x-pseudo', {
	    months : 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
	    monthsShort : 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
	    monthsParseExact : true,
	    weekdays : 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
	    weekdaysShort : 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
	    weekdaysMin : 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
	    weekdaysParseExact : true,
	    longDateFormat : {
	        LT : 'HH:mm',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY HH:mm',
	        LLLL : 'dddd, D MMMM YYYY HH:mm'
	    },
	    calendar : {
	        sameDay : '[T~d~ t] LT',
	        nextDay : '[T~m~rr~w t] LT',
	        nextWeek : 'dddd [t] LT',
	        lastDay : '[~st~rd~ t] LT',
	        lastWeek : '[L~st] dddd [t] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : '~ %s',
	        past : '%s ~g',
	        s : ' ~fw ~sc~ds',
	        m : ' ~m~t',
	        mm : '%d m~~ts',
	        h : '~ h~r',
	        hh : '%d h~rs',
	        d : ' ~d',
	        dd : '%d d~s',
	        M : ' ~m~th',
	        MM : '%d m~t~hs',
	        y : ' ~r',
	        yy : '%d ~rs'
	    },
	    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal : function (number) {
	        var b = number % 10,
	            output = (~~(number % 100 / 10) === 1) ? 'th' :
	            (b === 1) ? 'st' :
	            (b === 2) ? 'nd' :
	            (b === 3) ? 'rd' : 'th';
	        return number + output;
	    },
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return xPseudo;
	
	})));


/***/ },
/* 419 */
/*!*******************************!*\
  !*** ./~/moment/locale/yo.js ***!
  \*******************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Yoruba Nigeria (yo)
	//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var yo = moment.defineLocale('yo', {
	    months : 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
	    monthsShort : 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
	    weekdays : 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
	    weekdaysShort : 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
	    weekdaysMin : 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
	    longDateFormat : {
	        LT : 'h:mm A',
	        LTS : 'h:mm:ss A',
	        L : 'DD/MM/YYYY',
	        LL : 'D MMMM YYYY',
	        LLL : 'D MMMM YYYY h:mm A',
	        LLLL : 'dddd, D MMMM YYYY h:mm A'
	    },
	    calendar : {
	        sameDay : '[Oni ni] LT',
	        nextDay : '[la ni] LT',
	        nextWeek : 'dddd [s ton\'b] [ni] LT',
	        lastDay : '[Ana ni] LT',
	        lastWeek : 'dddd [s tol] [ni] LT',
	        sameElse : 'L'
	    },
	    relativeTime : {
	        future : 'ni %s',
	        past : '%s kja',
	        s : 'isju aaya die',
	        m : 'isju kan',
	        mm : 'isju %d',
	        h : 'wakati kan',
	        hh : 'wakati %d',
	        d : 'j kan',
	        dd : 'j %d',
	        M : 'osu kan',
	        MM : 'osu %d',
	        y : 'dun kan',
	        yy : 'dun %d'
	    },
	    ordinalParse : /j\s\d{1,2}/,
	    ordinal : 'j %d',
	    week : {
	        dow : 1, // Monday is the first day of the week.
	        doy : 4 // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return yo;
	
	})));


/***/ },
/* 420 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-cn.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (China) [zh-cn]
	//! author : suupic : https://github.com/suupic
	//! author : Zeno Zeng : https://github.com/zenozeng
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhCn = moment.defineLocale('zh-cn', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYY-MM-DD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYY-MM-DD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour: function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' ||
	                meridiem === '') {
	            return hour;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        } else {
	            // ''
	            return hour >= 11 ? hour : hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        nextDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        lastDay : function () {
	            return this.minutes() === 0 ? '[]Ah[]' : '[]LT';
	        },
	        nextWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.diff(startOfWeek, 'days') >= 7 ? '[]' : '[]';
	            return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	        },
	        lastWeek : function () {
	            var startOfWeek, prefix;
	            startOfWeek = moment().startOf('week');
	            prefix = this.unix() < startOfWeek.unix()  ? '[]' : '[]';
	            return this.minutes() === 0 ? prefix + 'dddAh' : prefix + 'dddAhmm';
	        },
	        sameElse : 'LL'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd':
	            case 'D':
	            case 'DDD':
	                return number + '';
	            case 'M':
	                return number + '';
	            case 'w':
	            case 'W':
	                return number + '';
	            default:
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    },
	    week : {
	        // GB/T 7408-1994ISO 8601:1988
	        dow : 1, // Monday is the first day of the week.
	        doy : 4  // The week that contains Jan 4th is the first week of the year.
	    }
	});
	
	return zhCn;
	
	})));


/***/ },
/* 421 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-hk.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Hong Kong) [zh-hk]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	//! author : Konstantin : https://github.com/skfd
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhHk = moment.defineLocale('zh-hk', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return zhHk;
	
	})));


/***/ },
/* 422 */
/*!**********************************!*\
  !*** ./~/moment/locale/zh-tw.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	//! moment.js locale configuration
	//! locale : Chinese (Taiwan) [zh-tw]
	//! author : Ben : https://github.com/ben-lin
	//! author : Chris Lam : https://github.com/hehachris
	
	;(function (global, factory) {
	    true ? factory(__webpack_require__(/*! ../moment */ 311)) :
	   typeof define === 'function' && define.amd ? define(['../moment'], factory) :
	   factory(global.moment)
	}(this, (function (moment) { 'use strict';
	
	
	var zhTw = moment.defineLocale('zh-tw', {
	    months : '___________'.split('_'),
	    monthsShort : '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
	    weekdays : '______'.split('_'),
	    weekdaysShort : '______'.split('_'),
	    weekdaysMin : '______'.split('_'),
	    longDateFormat : {
	        LT : 'Ahmm',
	        LTS : 'Ahms',
	        L : 'YYYYMMMD',
	        LL : 'YYYYMMMD',
	        LLL : 'YYYYMMMDAhmm',
	        LLLL : 'YYYYMMMDddddAhmm',
	        l : 'YYYYMMMD',
	        ll : 'YYYYMMMD',
	        lll : 'YYYYMMMDAhmm',
	        llll : 'YYYYMMMDddddAhmm'
	    },
	    meridiemParse: /|||||/,
	    meridiemHour : function (hour, meridiem) {
	        if (hour === 12) {
	            hour = 0;
	        }
	        if (meridiem === '' || meridiem === '' || meridiem === '') {
	            return hour;
	        } else if (meridiem === '') {
	            return hour >= 11 ? hour : hour + 12;
	        } else if (meridiem === '' || meridiem === '') {
	            return hour + 12;
	        }
	    },
	    meridiem : function (hour, minute, isLower) {
	        var hm = hour * 100 + minute;
	        if (hm < 600) {
	            return '';
	        } else if (hm < 900) {
	            return '';
	        } else if (hm < 1130) {
	            return '';
	        } else if (hm < 1230) {
	            return '';
	        } else if (hm < 1800) {
	            return '';
	        } else {
	            return '';
	        }
	    },
	    calendar : {
	        sameDay : '[]LT',
	        nextDay : '[]LT',
	        nextWeek : '[]ddddLT',
	        lastDay : '[]LT',
	        lastWeek : '[]ddddLT',
	        sameElse : 'L'
	    },
	    ordinalParse: /\d{1,2}(||)/,
	    ordinal : function (number, period) {
	        switch (period) {
	            case 'd' :
	            case 'D' :
	            case 'DDD' :
	                return number + '';
	            case 'M' :
	                return number + '';
	            case 'w' :
	            case 'W' :
	                return number + '';
	            default :
	                return number;
	        }
	    },
	    relativeTime : {
	        future : '%s',
	        past : '%s',
	        s : '',
	        m : '1 ',
	        mm : '%d ',
	        h : '1 ',
	        hh : '%d ',
	        d : '1 ',
	        dd : '%d ',
	        M : '1 ',
	        MM : '%d ',
	        y : '1 ',
	        yy : '%d '
	    }
	});
	
	return zhTw;
	
	})));


/***/ },
/* 423 */
/*!************************************!*\
  !*** ./beeline/directives/extA.js ***!
  \************************************/
/***/ function(module, exports) {

	'use strict';
	
	angular.module('beeline').directive('extA', function () {
	
	  return {
	    template: '\n      <a href="{{href}}" ng-transclude\n          ng-click="openLink($event)">\n      </a>\n    ',
	    scope: {
	      href: '@'
	    },
	    transclude: true,
	    restrict: 'E',
	    controller: function controller($scope) {
	      $scope.openLink = function ($event) {
	        $event.preventDefault();
	        window.open($scope.href, '_system');
	      };
	    }
	  };
	});

/***/ },
/* 424 */
/*!*******************************************!*\
  !*** ./beeline/services/TicketService.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.default = TicketService;
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function TicketService($http, $filter, UserService, p) {
	  var ticketsCache = null;
	  var allTickets = null;
	  var ticketsByRouteId = null;
	
	  //set to true with setShouldRefreshTickets once a ticket is bought
	  //set to false once getCategorizedTickets is called
	  var shouldRefreshTickets = false;
	
	  return {
	
	    getShouldRefreshTickets: function getShouldRefreshTickets() {
	      return shouldRefreshTickets;
	    },
	
	    setShouldRefreshTickets: function setShouldRefreshTickets() {
	      shouldRefreshTickets = true;
	    },
	
	    fetchTickets: function fetchTickets(ignoreCache) {
	      if (ticketsCache && !ignoreCache) return ticketsCache;
	      var url = '/tickets';
	      if (p.transportCompanyId) {
	        url += '?' + _querystring2.default.stringify({ transportCompanyId: p.transportCompanyId });
	      }
	      return ticketsCache = UserService.beeline({
	        method: 'GET',
	        url: url
	      }).then(function (response) {
	        ticketsByRouteId = _lodash2.default.groupBy(response.data, function (ticket) {
	          return ticket.boardStop.trip.routeId;
	        });
	        return allTickets = response.data;
	      });
	    },
	
	    getTickets: function getTickets() {
	      return allTickets;
	    },
	
	    getTicketsByRouteId: function getTicketsByRouteId(rid, ignoreCache) {
	      return this.fetchTickets(ignoreCache).then(function () {
	        return ticketsByRouteId[rid];
	      });
	    },
	    getPreviouslyBookedDaysByRouteId: function getPreviouslyBookedDaysByRouteId(rid, ignoreCache) {
	      return this.getTicketsByRouteId(rid, ignoreCache).then(function (tickets) {
	        var dates = _lodash2.default.keyBy(tickets, function (t) {
	          return new Date(t.boardStop.trip.date).getTime();
	        });
	        return dates || {};
	      });
	    },
	
	
	    getTicketById: function getTicketById(id, ignoreCache) {
	      _assert2.default.equal(typeof id === 'undefined' ? 'undefined' : _typeof(id), 'number');
	      return this.fetchTickets(ignoreCache).then(function (tickets) {
	        return _lodash2.default.find(tickets, { id: id });
	      });
	    },
	
	    getCategorizedTickets: function getCategorizedTickets(ignoreCache) {
	      shouldRefreshTickets = false;
	      return this.fetchTickets(ignoreCache).then(function (tickets) {
	        var now = new Date();
	        var lastMidnight = now.setHours(0, 0, 0, 0);
	        var nextMidnight = now.setHours(24, 0, 0, 0);
	        var categorizedTickets = {};
	        categorizedTickets.today = tickets.filter(function (ticket) {
	          return ticket.boardStop !== null && Date.parse(ticket.boardStop.time) >= lastMidnight && Date.parse(ticket.boardStop.time) < nextMidnight;
	        });
	        categorizedTickets.afterToday = tickets.filter(function (ticket) {
	          return ticket.boardStop !== null && Date.parse(ticket.boardStop.time) >= nextMidnight;
	        });
	        return categorizedTickets;
	      });
	    }
	  };
	}

/***/ },
/* 425 */
/*!********************************!*\
  !*** ./~/querystring/index.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(/*! ./decode */ 426);
	exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ 427);


/***/ },
/* 426 */
/*!*********************************!*\
  !*** ./~/querystring/decode.js ***!
  \*********************************/
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 427 */
/*!*********************************!*\
  !*** ./~/querystring/encode.js ***!
  \*********************************/
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 428 */
/*!**********************************************************!*\
  !*** ./beeline/services/LiteRouteSubscriptionService.js ***!
  \**********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = LiteRouteSubscriptionService;
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	function LiteRouteSubscriptionService($http, UserService, $q) {
	  var LiteRouteSubscriptionCache = null;
	  var liteRouteSubscriptionsSummary = [];
	
	  UserService.userEvents.on('userChanged', function () {
	    instance.getSubscriptions(true);
	  });
	
	  var instance = {
	
	    getSubscriptionSummary: function getSubscriptionSummary() {
	      return liteRouteSubscriptionsSummary;
	    },
	
	    getSubscriptions: function getSubscriptions(ignoreCache) {
	      if (UserService.getUser()) {
	        if (LiteRouteSubscriptionCache && !ignoreCache) return liteRouteSubscriptionsSummary;
	        return LiteRouteSubscriptionCache = UserService.beeline({
	          method: 'GET',
	          url: '/liteRoutes/subscriptions'
	        }).then(function (response) {
	          liteRouteSubscriptionsSummary = response.data.map(function (subs) {
	            return subs.routeLabel;
	          });
	          return liteRouteSubscriptionsSummary;
	        });
	      } else {
	        liteRouteSubscriptionsSummary = [];
	        return $q.resolve([]);
	      }
	    },
	
	    isSubscribed: function () {
	      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(label, ignoreCache) {
	        var subscriptions, subscription;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return this.getSubscriptions(ignoreCache);
	
	              case 2:
	                subscriptions = _context.sent;
	
	                (0, _assert2.default)(subscriptions);
	
	                subscription = subscriptions.includes(label);
	
	                if (!subscription) {
	                  _context.next = 9;
	                  break;
	                }
	
	                return _context.abrupt('return', true);
	
	              case 9:
	                return _context.abrupt('return', false);
	
	              case 10:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	
	      function isSubscribed(_x, _x2) {
	        return _ref.apply(this, arguments);
	      }
	
	      return isSubscribed;
	    }()
	  };
	
	  return instance;
	}

/***/ },
/* 429 */
/*!*****************************************!*\
  !*** ./beeline/services/UserService.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = UserService;
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _uuid = __webpack_require__(/*! uuid */ 430);
	
	var _uuid2 = _interopRequireDefault(_uuid);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _verifiedPrompt = __webpack_require__(/*! ../templates/verified-prompt.html */ 432);
	
	var _verifiedPrompt2 = _interopRequireDefault(_verifiedPrompt);
	
	var _requestingVerificationCode = __webpack_require__(/*! ../templates/requesting-verification-code.html */ 433);
	
	var _requestingVerificationCode2 = _interopRequireDefault(_requestingVerificationCode);
	
	var _sendingVerificationCode = __webpack_require__(/*! ../templates/sending-verification-code.html */ 434);
	
	var _sendingVerificationCode2 = _interopRequireDefault(_sendingVerificationCode);
	
	var _registeringWithServer = __webpack_require__(/*! ../templates/registering-with-server.html */ 435);
	
	var _registeringWithServer2 = _interopRequireDefault(_registeringWithServer);
	
	var _events = __webpack_require__(/*! events */ 436);
	
	var _events2 = _interopRequireDefault(_events);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var VALID_PHONE_REGEX = /^[8-9]{1}[0-9]{7}$/;
	var VALID_VERIFICATION_CODE_REGEX = /^[0-9]{6}$/;
	// user name must be at least 3 characters long, space in front
	// or after non-space characters are ignored e.g. "   a c   ",
	// "exe", "alieo" is valid name
	var VALID_USER_NAME = /^\s*\S.+\S\s*$/;
	// This file is dynamically generated by webpack from environment variables
	var env = __webpack_require__(/*! ../env.json */ 301);
	
	function UserService($http, $ionicPopup, $ionicLoading, $rootScope, LoginDialog, $q, loadingSpinner) {
	
	  // Use the referral code and apply rewards to newUser
	  // Input:
	  // - refCode - String: referral code
	  var applyRefCode = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(refCode) {
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              return _context4.abrupt('return', beelineRequest({
	                method: "POST",
	                url: "/user/applyRefCode",
	                data: {
	                  refCode: refCode
	                }
	              }));
	
	            case 1:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, this);
	    }));
	
	    return function applyRefCode(_x4) {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  var checkNewUser = function () {
	    var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(user) {
	      var accountResponse, updateResponse;
	      return regeneratorRuntime.wrap(function _callee5$(_context5) {
	        while (1) {
	          switch (_context5.prev = _context5.next) {
	            case 0:
	              if (!(user.name || user.email)) {
	                _context5.next = 2;
	                break;
	              }
	
	              return _context5.abrupt('return');
	
	            case 2:
	              _context5.prev = 2;
	              _context5.next = 5;
	              return verifiedPrompt({
	                title: 'Account Details',
	                bodyText: 'Welcome! This looks like your first login.\
	        Please complete the account setup.',
	                inputs: [{
	                  type: 'text',
	                  name: 'name',
	                  pattern: VALID_USER_NAME,
	                  inputPlaceHolder: 'Name',
	                  errorMsg: 'Please provide a name with 3 or more characters.'
	                }, {
	                  type: 'email',
	                  name: 'email',
	                  inputPlaceHolder: 'name@example.com',
	                  errorMsg: 'Email address does not appear to be in the correct format. \
	            Please provide a valid email address.'
	                }]
	              });
	
	            case 5:
	              accountResponse = _context5.sent;
	
	              if (accountResponse) {
	                _context5.next = 12;
	                break;
	              }
	
	              logOut();
	              $rootScope.$digest();
	              return _context5.abrupt('return');
	
	            case 12:
	              $ionicLoading.show({ template: _registeringWithServer2.default });
	              _context5.next = 15;
	              return updateUserInfo({
	                name: accountResponse.name,
	                email: accountResponse.email
	              });
	
	            case 15:
	              updateResponse = _context5.sent;
	
	              $ionicLoading.hide();
	
	            case 17:
	              _context5.next = 23;
	              break;
	
	            case 19:
	              _context5.prev = 19;
	              _context5.t0 = _context5['catch'](2);
	
	              $ionicLoading.hide();
	              $ionicPopup.alert({
	                title: "Error while trying to connect to server.",
	                subTitle: _context5.t0 && _context5.t0.data && _context5.t0.data.message
	              });
	
	            case 23:
	              ;
	
	            case 24:
	            case 'end':
	              return _context5.stop();
	          }
	        }
	      }, _callee5, this, [[2, 19]]);
	    }));
	
	    return function checkNewUser(_x5) {
	      return _ref5.apply(this, arguments);
	    };
	  }();
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Private internal methods and variables
	  // ////////////////////////////////////////////////////////////////////////////
	  var sessionToken = window.localStorage.sessionToken || null;
	  var user = window.localStorage.beelineUser ? JSON.parse(window.localStorage.beelineUser) : null;
	  var userEvents = new _events2.default();
	
	  // General purpose wrapper for making http requests to server
	  // Adds the appropriate http headers and token if signed in
	  var beelineRequest = function beelineRequest(options) {
	    options.url = env.BACKEND_URL + options.url;
	    options.headers = options.headers || {};
	    // Attach the session token if logged in
	    if (sessionToken) {
	      options.headers.authorization = 'Bearer ' + sessionToken;
	    }
	    // Attach headers to track execution environment
	    if (window.device) {
	      options.headers['Beeline-Device-UUID'] = window.device.uuid;
	      options.headers['Beeline-Device-Model'] = window.device.model;
	      options.headers['Beeline-Device-Platform'] = window.device.platform;
	      options.headers['Beeline-Device-Version'] = window.device.version;
	      options.headers['Beeline-Device-Manufacturer'] = window.device.manufacturer;
	      options.headers['Beeline-Device-Serial'] = window.device.serial;
	    } else {
	      window.localStorage.uuid = window.localStorage.uuid || _uuid2.default.v4();
	      options.headers['Beeline-Device-UUID'] = window.localStorage.uuid;
	      options.headers['Beeline-Device-Model'] = window.navigator.userAgent;
	      options.headers['Beeline-Device-Platform'] = 'Browser';
	    }
	    options.headers['Beeline-App-Name'] = $rootScope.o.APP.NAME.replace(/\s/g, '');
	    return $http(options);
	  };
	
	  // Requests a verification code to be sent to a mobile number
	  // Verification code is used to log in
	  var sendTelephoneVerificationCode = function sendTelephoneVerificationCode(number) {
	    return beelineRequest({
	      method: 'POST',
	      url: '/users/sendTelephoneVerification',
	      data: {
	        telephone: '+65' + number,
	        alphanumericId: $rootScope.o.APP.SMS_OTP_FROM.replace(/\s/g, ''),
	        appName: $rootScope.o.APP.NAME
	      },
	      headers: { 'Content-Type': 'application/json' }
	    }).then(function () {
	      return true;
	    });
	  };
	
	  // Submit the received code and number for verification to the server
	  var verifyTelephone = function verifyTelephone(telephoneNumber, code) {
	    return beelineRequest({
	      method: 'POST',
	      url: '/users/verifyTelephone',
	      data: {
	        telephone: '+65' + telephoneNumber,
	        code: code
	      }
	    }).then(function (response) {
	      sessionToken = response.data.sessionToken;
	      window.localStorage.setItem('sessionToken', sessionToken);
	      user = response.data.user;
	      userEvents.emit("userChanged");
	      window.localStorage.setItem('beelineUser', JSON.stringify(user));
	
	      return user;
	    });
	  };
	
	  // Prepares an update of the telephone number
	  // The returned update toke is used together with the verification number
	  // @returns Promise.<update token>
	  var requestUpdateTelephone = function requestUpdateTelephone(telephone) {
	    return beelineRequest({
	      url: '/user/requestUpdateTelephone',
	      method: 'POST',
	      data: { newTelephone: '+65' + telephone }
	    }).then(function (response) {
	      return response.data.updateToken;
	    });
	  };
	
	  // Really tell the server to update the telephone
	  // number. Pass this function the updateToken returned by
	  // requestUpdateTelephone and the verification key received
	  // by SMS
	  var updateTelephone = function updateTelephone(updateToken, verificationKey) {
	    return beelineRequest({
	      url: '/user/updateTelephone',
	      method: 'POST',
	      data: {
	        code: verificationKey,
	        updateToken: updateToken
	      }
	    }).then(function (reponse) {
	      user = reponse.data;
	      window.localStorage.setItem('beelineUser', JSON.stringify(user));
	      return user;
	    });
	  };
	
	  // Updates user fields
	  function updateUserInfo(update) {
	    return beelineRequest({
	      method: 'PUT',
	      url: '/user',
	      data: update
	    }).then(function (response) {
	      user = response.data;
	      return user;
	    });
	  };
	
	  var logOut = function logOut() {
	    sessionToken = null;
	    user = null;
	    userEvents.emit("userChanged");
	    delete window.localStorage.sessionToken;
	    delete window.localStorage.beelineUser;
	    return Promise.resolve();
	  };
	
	  // Queries the server to test if the session is still valid
	  // Updates the user info if necessary
	  // If the session is invalid then log out
	  var verifySession = function verifySession() {
	    return beelineRequest({
	      url: '/user',
	      method: 'GET'
	    }).then(function (response) {
	      user = response.data;
	
	      if (!user) {
	        logOut(); // user not found
	        return false;
	      }
	      userEvents.emit('userChanged');
	
	      return true;
	    }, function (error) {
	      if (error.status == 403 || error.status == 401) {
	        logOut();
	        return false;
	      }
	    });
	  };
	
	  var getReferralMsg = function getReferralMsg() {
	    var shareMsgTemplate = "Hey, here is $10 credits for you to try out Beeline rides. \nVisit https://app.beeline.sg/#/welcome?refCode=";
	    return shareMsgTemplate + user.referralCode.code;
	  };
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // UI methods
	  // ////////////////////////////////////////////////////////////////////////////
	  var verifiedPrompt = function verifiedPrompt(options) {
	    var promptScope = $rootScope.$new(true);
	    promptScope.form = {
	      verifiedPromptForm: {}
	    };
	    promptScope.data = {
	      inputs: options.inputs || [],
	      bodyText: options.bodyText || ''
	    };
	    _lodash2.default.defaultsDeep(options, {
	      template: _verifiedPrompt2.default,
	      title: '',
	      subTitle: '',
	      scope: promptScope,
	      buttons: [{ text: 'Cancel' }, {
	        text: 'OK',
	        type: 'button-positive',
	        onTap: function onTap(e) {
	          if (promptScope.form.verifiedPromptForm.$valid) {
	            return promptScope.data;
	          }
	          e.preventDefault();
	        }
	      }]
	    });
	    return $ionicPopup.show(options);
	  };
	
	  var promptTelephoneNumber = function promptTelephoneNumber(title, subtitle) {
	    return verifiedPrompt({
	      title: title,
	      bodyText: subtitle,
	      inputs: [{
	        type: 'tel',
	        name: 'phone',
	        pattern: VALID_PHONE_REGEX,
	        errorMsg: 'The phone no. you provide does not appear to be in the correct format. \
	          Please provide a valid 8-digit phone no. starting with the number 8 or 9.'
	      }]
	    });
	  };
	
	  var promptVerificationCode = function promptVerificationCode(telephone) {
	    return verifiedPrompt({
	      title: 'Verification',
	      bodyText: 'Enter the 6-digit code sent to ' + telephone,
	      inputs: [{
	        type: 'tel',
	        name: 'code',
	        pattern: VALID_VERIFICATION_CODE_REGEX
	      }]
	    });
	  };
	
	  // The combined prompt for phone number and subsequent prompt for verification code
	  var promptLogIn = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	      var result, _result, telephoneNumber, wantVerification, verificationCode, user;
	
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.prev = 0;
	              _context.next = 3;
	              return LoginDialog.show();
	
	            case 3:
	              result = _context.sent;
	
	              if (result) {
	                _context.next = 6;
	                break;
	              }
	
	              return _context.abrupt('return');
	
	            case 6:
	              _result = _slicedToArray(result, 2), telephoneNumber = _result[0], wantVerification = _result[1];
	
	              if (telephoneNumber) {
	                _context.next = 9;
	                break;
	              }
	
	              return _context.abrupt('return');
	
	            case 9:
	              if (!wantVerification) {
	                _context.next = 12;
	                break;
	              }
	
	              _context.next = 12;
	              return loadingSpinner(sendTelephoneVerificationCode(telephoneNumber));
	
	            case 12:
	              _context.next = 14;
	              return promptVerificationCode(telephoneNumber);
	
	            case 14:
	              verificationCode = _context.sent;
	
	              if (verificationCode) {
	                _context.next = 17;
	                break;
	              }
	
	              return _context.abrupt('return');
	
	            case 17:
	              _context.next = 19;
	              return loadingSpinner(verifyTelephone(telephoneNumber, verificationCode.code));
	
	            case 19:
	              user = _context.sent;
	
	
	              // Is the user name null?
	              checkNewUser(user);
	              _context.next = 27;
	              break;
	
	            case 23:
	              _context.prev = 23;
	              _context.t0 = _context['catch'](0);
	
	              if (_context.t0.status === 401) {
	                $ionicPopup.alert({
	                  title: "Incorrect login",
	                  subTitle: _context.t0 && _context.t0.data && _context.t0.data.message
	                });
	              } else {
	                $ionicPopup.alert({
	                  title: "Error while trying to connect to server.",
	                  subTitle: _context.t0 && _context.t0.data && _context.t0.data.message
	                });
	              }
	              throw _context.t0;
	
	            case 27:
	              ;
	
	            case 28:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this, [[0, 23]]);
	    }));
	
	    return function promptLogIn() {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  // Registration Sequence used for Welcome page (via Referral Link)
	  // Verifies telephone number and prompts for name and email for registration
	  // Saves referral code to user data
	  var registerViaReferralWelcome = function () {
	    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(telephoneNumber, refCode, refCodeOwner) {
	      var _this = this;
	
	      var verificationCode, user;
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              _context3.prev = 0;
	
	              if (telephoneNumber) {
	                _context3.next = 3;
	                break;
	              }
	
	              return _context3.abrupt('return');
	
	            case 3:
	              _context3.next = 5;
	              return loadingSpinner(sendTelephoneVerificationCode(telephoneNumber));
	
	            case 5:
	              _context3.next = 7;
	              return promptVerificationCode(telephoneNumber);
	
	            case 7:
	              verificationCode = _context3.sent;
	
	              if (verificationCode) {
	                _context3.next = 10;
	                break;
	              }
	
	              return _context3.abrupt('return');
	
	            case 10:
	              _context3.next = 12;
	              return loadingSpinner(verifyTelephone(telephoneNumber, verificationCode.code));
	
	            case 12:
	              user = _context3.sent;
	              _context3.next = 15;
	              return loadingSpinner(_asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	                return regeneratorRuntime.wrap(function _callee2$(_context2) {
	                  while (1) {
	                    switch (_context2.prev = _context2.next) {
	                      case 0:
	                        _context2.next = 2;
	                        return checkNewUser(user);
	
	                      case 2:
	                        if (!(refCode && refCodeOwner)) {
	                          _context2.next = 5;
	                          break;
	                        }
	
	                        _context2.next = 5;
	                        return applyRefCode(refCode);
	
	                      case 5:
	                      case 'end':
	                        return _context2.stop();
	                    }
	                  }
	                }, _callee2, _this);
	              }))());
	
	            case 15:
	              _context3.next = 21;
	              break;
	
	            case 17:
	              _context3.prev = 17;
	              _context3.t0 = _context3['catch'](0);
	
	              $ionicPopup.alert({
	                title: "Error while trying to connect to server.",
	                subTitle: _context3.t0 && _context3.t0.data && _context3.t0.data.message
	              });
	              throw _context3.t0;
	
	            case 21:
	              ;
	
	            case 22:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this, [[0, 17]]);
	    }));
	
	    return function registerViaReferralWelcome(_x, _x2, _x3) {
	      return _ref2.apply(this, arguments);
	    };
	  }();
	
	  function register(newUser) {
	    return beelineRequest({
	      method: 'POST',
	      url: '/users',
	      data: newUser
	    }).then(function (response) {
	      return response.data;
	    });
	  };
	
	  ;
	
	  // Similar to prompt login
	  // The combined prompt for phone number and subsequent prompt for verification code
	  var promptUpdatePhone = function () {
	    var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
	      var telephoneResponse, telephone, updateToken, updateCode;
	      return regeneratorRuntime.wrap(function _callee6$(_context6) {
	        while (1) {
	          switch (_context6.prev = _context6.next) {
	            case 0:
	              _context6.prev = 0;
	              _context6.next = 3;
	              return promptTelephoneNumber('Update Phone Number', 'Please enter your new 8-digit mobile number to receive a verification code.');
	
	            case 3:
	              telephoneResponse = _context6.sent;
	
	              if (telephoneResponse) {
	                _context6.next = 6;
	                break;
	              }
	
	              return _context6.abrupt('return');
	
	            case 6:
	              $ionicLoading.show({ template: _requestingVerificationCode2.default });
	              telephone = telephoneResponse.phone;
	              _context6.next = 10;
	              return requestUpdateTelephone(telephone);
	
	            case 10:
	              updateToken = _context6.sent;
	
	              $ionicLoading.hide();
	              _context6.next = 14;
	              return promptVerificationCode(telephone);
	
	            case 14:
	              updateCode = _context6.sent;
	
	              if (updateCode) {
	                _context6.next = 17;
	                break;
	              }
	
	              return _context6.abrupt('return');
	
	            case 17:
	              $ionicLoading.show({ template: _sendingVerificationCode2.default });
	              _context6.next = 20;
	              return updateTelephone(updateToken, updateCode.code);
	
	            case 20:
	              $ionicLoading.hide();
	              $ionicPopup.alert({
	                title: "Your phone number has been successfully updated.",
	                subTitle: "It is now " + telephone
	              });
	              _context6.next = 28;
	              break;
	
	            case 24:
	              _context6.prev = 24;
	              _context6.t0 = _context6['catch'](0);
	
	              $ionicLoading.hide();
	              $ionicPopup.alert({
	                title: "Error updating phone number.",
	                subTitle: _context6.t0 && _context6.t0.data && _context6.t0.data.message
	              });
	
	            case 28:
	              ;
	
	            case 29:
	            case 'end':
	              return _context6.stop();
	          }
	        }
	      }, _callee6, this, [[0, 24]]);
	    }));
	
	    return function promptUpdatePhone() {
	      return _ref6.apply(this, arguments);
	    };
	  }();
	
	  var promptUpdateUserInfo = function () {
	    var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(field) {
	      var filedInput, verifiedResponse, update;
	      return regeneratorRuntime.wrap(function _callee7$(_context7) {
	        while (1) {
	          switch (_context7.prev = _context7.next) {
	            case 0:
	              _context7.prev = 0;
	
	              if (field === 'name') {
	                filedInput = {
	                  type: 'text',
	                  name: 'name',
	                  pattern: VALID_USER_NAME,
	                  errorMsg: 'Please provide a name with 3 or more characters.'
	                };
	              }
	              if (field === 'email') {
	                filedInput = {
	                  type: 'email',
	                  name: 'email',
	                  errorMsg: 'Email address doesn\'t appear to be in the correct format. \
	          Please provide a valid email address.'
	                };
	              }
	              _context7.next = 5;
	              return verifiedPrompt({
	                title: 'Update ' + field,
	                bodyText: 'Enter your new ' + field,
	                inputs: [filedInput]
	              });
	
	            case 5:
	              verifiedResponse = _context7.sent;
	
	              if (verifiedResponse) {
	                _context7.next = 8;
	                break;
	              }
	
	              return _context7.abrupt('return');
	
	            case 8:
	              update = {};
	
	              update[field] = verifiedResponse[field];
	              return _context7.abrupt('return', updateUserInfo(update));
	
	            case 13:
	              _context7.prev = 13;
	              _context7.t0 = _context7['catch'](0);
	
	              $ionicPopup.alert({
	                title: 'Error updating ' + field + '.',
	                template: ''
	              });
	
	            case 16:
	            case 'end':
	              return _context7.stop();
	          }
	        }
	      }, _callee7, this, [[0, 13]]);
	    }));
	
	    return function promptUpdateUserInfo(_x6) {
	      return _ref7.apply(this, arguments);
	    };
	  }();
	
	  // Shows a confirmation dialogue asking if the user is sure they want to log out
	  var promptLogOut = function promptLogOut() {
	    $ionicPopup.confirm({
	      title: 'Are you sure you want to log out?',
	      subTitle: "You will not be able to make any bookings and view your tickets after you log out."
	    }).then(function (response) {
	      if (response) {
	        return logOut();
	      }
	    });
	  };
	
	  // Saves payment info to backend and update user object
	  var savePaymentInfo = function savePaymentInfo(stripeTokenId) {
	    return beelineRequest({
	      method: 'POST',
	      url: '/users/' + user.id + '/creditCards',
	      data: {
	        stripeToken: stripeTokenId
	      }
	    }).then(function (response) {
	      user.savedPaymentInfo = response.data;
	    });
	  };
	
	  // Update/change payment info to backend and update user object
	  var updatePaymentInfo = function updatePaymentInfo(stripeTokenId) {
	    return beelineRequest({
	      method: 'POST',
	      url: '/users/' + user.id + '/creditCards/replace',
	      data: {
	        stripeToken: stripeTokenId
	      }
	    }).then(function (response) {
	      user.savedPaymentInfo = response.data;
	    });
	  };
	
	  // Remove payment info from backend and update user object
	  var removePaymentInfo = function removePaymentInfo() {
	    return beelineRequest({
	      method: 'DELETE',
	      url: '/users/' + user.id + '/creditCards/' + user.savedPaymentInfo.sources.data[0].id
	    }).then(function (response) {
	      user.savedPaymentInfo = response.data;
	    });
	  };
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Initialization
	  // ////////////////////////////////////////////////////////////////////////////
	  verifySession();
	
	  // ////////////////////////////////////////////////////////////////////////////
	  // Public external interface
	  // ////////////////////////////////////////////////////////////////////////////
	  return {
	    getUser: function getUser() {
	      return user;
	    },
	    beeline: beelineRequest,
	    promptLogIn: promptLogIn,
	    promptUpdatePhone: promptUpdatePhone,
	    promptUpdateUserInfo: promptUpdateUserInfo,
	    promptLogOut: promptLogOut,
	    registerViaReferralWelcome: registerViaReferralWelcome,
	    verifySession: verifySession,
	    applyRefCode: applyRefCode,
	    userEvents: userEvents,
	    savePaymentInfo: savePaymentInfo,
	    updatePaymentInfo: updatePaymentInfo,
	    removePaymentInfo: removePaymentInfo,
	    getReferralMsg: getReferralMsg
	  };
	}

/***/ },
/* 430 */
/*!************************!*\
  !*** ./~/uuid/uuid.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	//     uuid.js
	//
	//     Copyright (c) 2010-2012 Robert Kieffer
	//     MIT License - http://opensource.org/licenses/mit-license.php
	
	// Unique ID creation requires a high quality random # generator.  We feature
	// detect to determine the best RNG source, normalizing to a function that
	// returns 128-bits of randomness, since that's what's usually required
	var _rng = __webpack_require__(/*! ./rng */ 431);
	
	// Maps for number <-> hex string conversion
	var _byteToHex = [];
	var _hexToByte = {};
	for (var i = 0; i < 256; i++) {
	  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
	  _hexToByte[_byteToHex[i]] = i;
	}
	
	// **`parse()` - Parse a UUID into it's component bytes**
	function parse(s, buf, offset) {
	  var i = (buf && offset) || 0, ii = 0;
	
	  buf = buf || [];
	  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
	    if (ii < 16) { // Don't overflow!
	      buf[i + ii++] = _hexToByte[oct];
	    }
	  });
	
	  // Zero out remaining bytes if string was short
	  while (ii < 16) {
	    buf[i + ii++] = 0;
	  }
	
	  return buf;
	}
	
	// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
	function unparse(buf, offset) {
	  var i = offset || 0, bth = _byteToHex;
	  return  bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] + '-' +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]] +
	          bth[buf[i++]] + bth[buf[i++]];
	}
	
	// **`v1()` - Generate time-based UUID**
	//
	// Inspired by https://github.com/LiosK/UUID.js
	// and http://docs.python.org/library/uuid.html
	
	// random #'s we need to init node and clockseq
	var _seedBytes = _rng();
	
	// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
	var _nodeId = [
	  _seedBytes[0] | 0x01,
	  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
	];
	
	// Per 4.2.2, randomize (14 bit) clockseq
	var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
	
	// Previous uuid creation time
	var _lastMSecs = 0, _lastNSecs = 0;
	
	// See https://github.com/broofa/node-uuid for API details
	function v1(options, buf, offset) {
	  var i = buf && offset || 0;
	  var b = buf || [];
	
	  options = options || {};
	
	  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
	
	  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
	  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
	  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
	  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
	  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();
	
	  // Per 4.2.1.2, use count of uuid's generated during the current clock
	  // cycle to simulate higher resolution clock
	  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
	
	  // Time since last uuid creation (in msecs)
	  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;
	
	  // Per 4.2.1.2, Bump clockseq on clock regression
	  if (dt < 0 && options.clockseq === undefined) {
	    clockseq = clockseq + 1 & 0x3fff;
	  }
	
	  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
	  // time interval
	  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
	    nsecs = 0;
	  }
	
	  // Per 4.2.1.2 Throw error if too many uuids are requested
	  if (nsecs >= 10000) {
	    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
	  }
	
	  _lastMSecs = msecs;
	  _lastNSecs = nsecs;
	  _clockseq = clockseq;
	
	  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
	  msecs += 12219292800000;
	
	  // `time_low`
	  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
	  b[i++] = tl >>> 24 & 0xff;
	  b[i++] = tl >>> 16 & 0xff;
	  b[i++] = tl >>> 8 & 0xff;
	  b[i++] = tl & 0xff;
	
	  // `time_mid`
	  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
	  b[i++] = tmh >>> 8 & 0xff;
	  b[i++] = tmh & 0xff;
	
	  // `time_high_and_version`
	  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
	  b[i++] = tmh >>> 16 & 0xff;
	
	  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
	  b[i++] = clockseq >>> 8 | 0x80;
	
	  // `clock_seq_low`
	  b[i++] = clockseq & 0xff;
	
	  // `node`
	  var node = options.node || _nodeId;
	  for (var n = 0; n < 6; n++) {
	    b[i + n] = node[n];
	  }
	
	  return buf ? buf : unparse(b);
	}
	
	// **`v4()` - Generate random UUID**
	
	// See https://github.com/broofa/node-uuid for API details
	function v4(options, buf, offset) {
	  // Deprecated - 'format' argument, as supported in v1.2
	  var i = buf && offset || 0;
	
	  if (typeof(options) == 'string') {
	    buf = options == 'binary' ? new Array(16) : null;
	    options = null;
	  }
	  options = options || {};
	
	  var rnds = options.random || (options.rng || _rng)();
	
	  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
	  rnds[6] = (rnds[6] & 0x0f) | 0x40;
	  rnds[8] = (rnds[8] & 0x3f) | 0x80;
	
	  // Copy bytes to buffer, if provided
	  if (buf) {
	    for (var ii = 0; ii < 16; ii++) {
	      buf[i + ii] = rnds[ii];
	    }
	  }
	
	  return buf || unparse(rnds);
	}
	
	// Export public API
	var uuid = v4;
	uuid.v1 = v1;
	uuid.v4 = v4;
	uuid.parse = parse;
	uuid.unparse = unparse;
	
	module.exports = uuid;


/***/ },
/* 431 */
/*!*******************************!*\
  !*** ./~/uuid/rng-browser.js ***!
  \*******************************/
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var rng;
	
	var crypto = global.crypto || global.msCrypto; // for IE 11
	if (crypto && crypto.getRandomValues) {
	  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
	  // Moderately fast, high quality
	  var _rnds8 = new Uint8Array(16);
	  rng = function whatwgRNG() {
	    crypto.getRandomValues(_rnds8);
	    return _rnds8;
	  };
	}
	
	if (!rng) {
	  // Math.random()-based (RNG)
	  //
	  // If all else fails, use Math.random().  It's fast, but is of unspecified
	  // quality.
	  var  _rnds = new Array(16);
	  rng = function() {
	    for (var i = 0, r; i < 16; i++) {
	      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
	      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
	    }
	
	    return _rnds;
	  };
	}
	
	module.exports = rng;
	
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 432 */
/*!************************************************!*\
  !*** ./beeline/templates/verified-prompt.html ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = "<p ng-if=\"data.bodyText\">{{data.bodyText}}</p>\n<form name=\"form.verifiedPromptForm\">\n  <input  ng-repeat-start=\"input in data.inputs\"\n          placeholder={{input.inputPlaceHolder}}\n          ng-required=\"true\"\n          type=\"{{input.type}}\"\n          ng-pattern=\"input.pattern\"\n          ng-model=\"data[input.name]\"\n          name=\"{{input.name}}\" />\n  <div  ng-repeat-end\n        ng-show=\"form.verifiedPromptForm[input.name].$invalid\n          && form.verifiedPromptForm[input.name].$dirty\">\n          <span ng-if=\"input.errorMsg\">{{input.errorMsg}}</span>\n          <span ng-if=\"!input.errorMsg\">Your {{input.name}} is invalid.</span>\n  </div>\n</form>\n";

/***/ },
/* 433 */
/*!*************************************************************!*\
  !*** ./beeline/templates/requesting-verification-code.html ***!
  \*************************************************************/
/***/ function(module, exports) {

	module.exports = "<div>Requesting verification code</div>\n<br>\n<ion-spinner icon='spiral'></ion-spinner>\n";

/***/ },
/* 434 */
/*!**********************************************************!*\
  !*** ./beeline/templates/sending-verification-code.html ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = "<div>Logging in</div>\n<br>\n<ion-spinner icon='spiral'></ion-spinner>\n";

/***/ },
/* 435 */
/*!********************************************************!*\
  !*** ./beeline/templates/registering-with-server.html ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = "<div>Registering with server</div>\n<br>\n<ion-spinner icon='spiral'></ion-spinner>\n";

/***/ },
/* 436 */
/*!****************************!*\
  !*** ./~/events/events.js ***!
  \****************************/
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 437 */
/*!*****************************************!*\
  !*** ./beeline/services/TripService.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = TripService;
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function TripService(UserService) {
	  return {
	
	    getTripData: function getTripData(id) {
	      (0, _assert2.default)(typeof id === 'number');
	      return UserService.beeline({
	        method: 'GET',
	        url: '/trips/' + id
	      }).then(function (response) {
	        return response.data;
	      });
	    },
	
	    DriverPings: function DriverPings(id) {
	      (0, _assert2.default)(typeof id === 'number');
	      return UserService.beeline({
	        method: 'GET',
	        url: '/trips/' + id + '/latestInfo',
	        timeout: 10000
	      }).then(function (response) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = response.data.pings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var ping = _step.value;
	
	            ping.time = new Date(ping.time);
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        return response.data;
	      });
	    }
	
	  };
	}

/***/ },
/* 438 */
/*!********************************************!*\
  !*** ./beeline/services/CompanyService.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = CompanyService;
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _commonmark = __webpack_require__(/*! commonmark */ 439);
	
	var _commonmark2 = _interopRequireDefault(_commonmark);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var reader = new _commonmark2.default.Parser({ safe: true });
	var writer = new _commonmark2.default.HtmlRenderer({ safe: true });
	
	function CompanyService(UserService, $ionicModal, $rootScope, $q) {
	  var companyCache = {};
	  var termsScope;
	
	  return {
	    getCompany: function getCompany(id, ignoreCache) {
	      (0, _assert2.default)(typeof id === 'number');
	      if (companyCache[id] && !ignoreCache) return companyCache[id];
	
	      return companyCache[id] = UserService.beeline({
	        url: '/companies/' + id,
	        method: 'GET'
	      }).then(function (response) {
	        return response.data;
	      });
	    },
	    showTerms: function showTerms(id) {
	      termsScope = $rootScope.$new();
	      termsScope.termsModal = $ionicModal.fromTemplate(__webpack_require__(/*! ../templates/termsModal.html */ 460), {
	        scope: termsScope
	      });
	
	      this.getCompany(id).then(function (company) {
	        termsScope.company = {
	          termsHTML: writer.render(reader.parse(company.terms))
	        };
	        termsScope.termsModal.show();
	      });
	
	      return new Promise(function (resolve, reject) {
	        termsScope.$on('modal.hidden', function () {
	          termsScope.$destroy();
	          resolve();
	        });
	      });
	    }
	  };
	}

/***/ },
/* 439 */
/*!***********************************!*\
  !*** ./~/commonmark/lib/index.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	// commonmark.js - CommomMark in JavaScript
	// Copyright (C) 2014 John MacFarlane
	// License: BSD3.
	
	// Basic usage:
	//
	// var commonmark = require('commonmark');
	// var parser = new commonmark.Parser();
	// var renderer = new commonmark.HtmlRenderer();
	// console.log(renderer.render(parser.parse('Hello *world*')));
	
	module.exports.version = '0.26.0';
	module.exports.Node = __webpack_require__(/*! ./node */ 440);
	module.exports.Parser = __webpack_require__(/*! ./blocks */ 441);
	// module.exports.HtmlRenderer = require('./html');
	module.exports.HtmlRenderer = __webpack_require__(/*! ./render/html */ 457);
	module.exports.XmlRenderer = __webpack_require__(/*! ./xml */ 459);


/***/ },
/* 440 */
/*!**********************************!*\
  !*** ./~/commonmark/lib/node.js ***!
  \**********************************/
/***/ function(module, exports) {

	"use strict";
	
	function isContainer(node) {
	    switch (node._type) {
	    case 'document':
	    case 'block_quote':
	    case 'list':
	    case 'item':
	    case 'paragraph':
	    case 'heading':
	    case 'emph':
	    case 'strong':
	    case 'link':
	    case 'image':
	    case 'custom_inline':
	    case 'custom_block':
	        return true;
	    default:
	        return false;
	    }
	}
	
	var resumeAt = function(node, entering) {
	    this.current = node;
	    this.entering = (entering === true);
	};
	
	var next = function(){
	    var cur = this.current;
	    var entering = this.entering;
	
	    if (cur === null) {
	        return null;
	    }
	
	    var container = isContainer(cur);
	
	    if (entering && container) {
	        if (cur._firstChild) {
	            this.current = cur._firstChild;
	            this.entering = true;
	        } else {
	            // stay on node but exit
	            this.entering = false;
	        }
	
	    } else if (cur === this.root) {
	        this.current = null;
	
	    } else if (cur._next === null) {
	        this.current = cur._parent;
	        this.entering = false;
	
	    } else {
	        this.current = cur._next;
	        this.entering = true;
	    }
	
	    return {entering: entering, node: cur};
	};
	
	var NodeWalker = function(root) {
	    return { current: root,
	             root: root,
	             entering: true,
	             next: next,
	             resumeAt: resumeAt };
	};
	
	var Node = function(nodeType, sourcepos) {
	    this._type = nodeType;
	    this._parent = null;
	    this._firstChild = null;
	    this._lastChild = null;
	    this._prev = null;
	    this._next = null;
	    this._sourcepos = sourcepos;
	    this._lastLineBlank = false;
	    this._open = true;
	    this._string_content = null;
	    this._literal = null;
	    this._listData = {};
	    this._info = null;
	    this._destination = null;
	    this._title = null;
	    this._isFenced = false;
	    this._fenceChar = null;
	    this._fenceLength = 0;
	    this._fenceOffset = null;
	    this._level = null;
	    this._onEnter = null;
	    this._onExit = null;
	};
	
	var proto = Node.prototype;
	
	Object.defineProperty(proto, 'isContainer', {
	    get: function () { return isContainer(this); }
	});
	
	Object.defineProperty(proto, 'type', {
	    get: function() { return this._type; }
	});
	
	Object.defineProperty(proto, 'firstChild', {
	    get: function() { return this._firstChild; }
	});
	
	Object.defineProperty(proto, 'lastChild', {
	    get: function() { return this._lastChild; }
	});
	
	Object.defineProperty(proto, 'next', {
	    get: function() { return this._next; }
	});
	
	Object.defineProperty(proto, 'prev', {
	    get: function() { return this._prev; }
	});
	
	Object.defineProperty(proto, 'parent', {
	    get: function() { return this._parent; }
	});
	
	Object.defineProperty(proto, 'sourcepos', {
	    get: function() { return this._sourcepos; }
	});
	
	Object.defineProperty(proto, 'literal', {
	    get: function() { return this._literal; },
	    set: function(s) { this._literal = s; }
	});
	
	Object.defineProperty(proto, 'destination', {
	    get: function() { return this._destination; },
	    set: function(s) { this._destination = s; }
	});
	
	Object.defineProperty(proto, 'title', {
	    get: function() { return this._title; },
	    set: function(s) { this._title = s; }
	});
	
	Object.defineProperty(proto, 'info', {
	    get: function() { return this._info; },
	    set: function(s) { this._info = s; }
	});
	
	Object.defineProperty(proto, 'level', {
	    get: function() { return this._level; },
	    set: function(s) { this._level = s; }
	});
	
	Object.defineProperty(proto, 'listType', {
	    get: function() { return this._listData.type; },
	    set: function(t) { this._listData.type = t; }
	});
	
	Object.defineProperty(proto, 'listTight', {
	    get: function() { return this._listData.tight; },
	    set: function(t) { this._listData.tight = t; }
	});
	
	Object.defineProperty(proto, 'listStart', {
	    get: function() { return this._listData.start; },
	    set: function(n) { this._listData.start = n; }
	});
	
	Object.defineProperty(proto, 'listDelimiter', {
	    get: function() { return this._listData.delimiter; },
	    set: function(delim) { this._listData.delimiter = delim; }
	});
	
	Object.defineProperty(proto, 'onEnter', {
	    get: function() { return this._onEnter; },
	    set: function(s) { this._onEnter = s; }
	});
	
	Object.defineProperty(proto, 'onExit', {
	    get: function() { return this._onExit; },
	    set: function(s) { this._onExit = s; }
	});
	
	Node.prototype.appendChild = function(child) {
	    child.unlink();
	    child._parent = this;
	    if (this._lastChild) {
	        this._lastChild._next = child;
	        child._prev = this._lastChild;
	        this._lastChild = child;
	    } else {
	        this._firstChild = child;
	        this._lastChild = child;
	    }
	};
	
	Node.prototype.prependChild = function(child) {
	    child.unlink();
	    child._parent = this;
	    if (this._firstChild) {
	        this._firstChild._prev = child;
	        child._next = this._firstChild;
	        this._firstChild = child;
	    } else {
	        this._firstChild = child;
	        this._lastChild = child;
	    }
	};
	
	Node.prototype.unlink = function() {
	    if (this._prev) {
	        this._prev._next = this._next;
	    } else if (this._parent) {
	        this._parent._firstChild = this._next;
	    }
	    if (this._next) {
	        this._next._prev = this._prev;
	    } else if (this._parent) {
	        this._parent._lastChild = this._prev;
	    }
	    this._parent = null;
	    this._next = null;
	    this._prev = null;
	};
	
	Node.prototype.insertAfter = function(sibling) {
	    sibling.unlink();
	    sibling._next = this._next;
	    if (sibling._next) {
	        sibling._next._prev = sibling;
	    }
	    sibling._prev = this;
	    this._next = sibling;
	    sibling._parent = this._parent;
	    if (!sibling._next) {
	        sibling._parent._lastChild = sibling;
	    }
	};
	
	Node.prototype.insertBefore = function(sibling) {
	    sibling.unlink();
	    sibling._prev = this._prev;
	    if (sibling._prev) {
	        sibling._prev._next = sibling;
	    }
	    sibling._next = this;
	    this._prev = sibling;
	    sibling._parent = this._parent;
	    if (!sibling._prev) {
	        sibling._parent._firstChild = sibling;
	    }
	};
	
	Node.prototype.walker = function() {
	    var walker = new NodeWalker(this);
	    return walker;
	};
	
	module.exports = Node;
	
	
	/* Example of use of walker:
	
	 var walker = w.walker();
	 var event;
	
	 while (event = walker.next()) {
	 console.log(event.entering, event.node.type);
	 }
	
	 */


/***/ },
/* 441 */
/*!************************************!*\
  !*** ./~/commonmark/lib/blocks.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Node = __webpack_require__(/*! ./node */ 440);
	var unescapeString = __webpack_require__(/*! ./common */ 442).unescapeString;
	var OPENTAG = __webpack_require__(/*! ./common */ 442).OPENTAG;
	var CLOSETAG = __webpack_require__(/*! ./common */ 442).CLOSETAG;
	
	var CODE_INDENT = 4;
	
	var C_TAB = 9;
	var C_NEWLINE = 10;
	var C_GREATERTHAN = 62;
	var C_LESSTHAN = 60;
	var C_SPACE = 32;
	var C_OPEN_BRACKET = 91;
	
	var InlineParser = __webpack_require__(/*! ./inlines */ 453);
	
	var reHtmlBlockOpen = [
	   /./, // dummy for 0
	   /^<(?:script|pre|style)(?:\s|>|$)/i,
	   /^<!--/,
	   /^<[?]/,
	   /^<![A-Z]/,
	   /^<!\[CDATA\[/,
	   /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|title|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
	    new RegExp('^(?:' + OPENTAG + '|' + CLOSETAG + ')\\s*$', 'i')
	];
	
	var reHtmlBlockClose = [
	   /./, // dummy for 0
	   /<\/(?:script|pre|style)>/i,
	   /-->/,
	   /\?>/,
	   />/,
	   /\]\]>/
	];
	
	var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;
	
	var reMaybeSpecial = /^[#`~*+_=<>0-9-]/;
	
	var reNonSpace = /[^ \t\f\v\r\n]/;
	
	var reBulletListMarker = /^[*+-]/;
	
	var reOrderedListMarker = /^(\d{1,9})([.)])/;
	
	var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;
	
	var reCodeFence = /^`{3,}(?!.*`)|^~{3,}(?!.*~)/;
	
	var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
	
	var reSetextHeadingLine = /^(?:=+|-+) *$/;
	
	var reLineEnding = /\r\n|\n|\r/;
	
	// Returns true if string contains only space characters.
	var isBlank = function(s) {
	    return !(reNonSpace.test(s));
	};
	
	var isSpaceOrTab = function(c) {
	    return c === C_SPACE || c === C_TAB;
	};
	
	var peek = function(ln, pos) {
	    if (pos < ln.length) {
	        return ln.charCodeAt(pos);
	    } else {
	        return -1;
	    }
	};
	
	// DOC PARSER
	
	// These are methods of a Parser object, defined below.
	
	// Returns true if block ends with a blank line, descending if needed
	// into lists and sublists.
	var endsWithBlankLine = function(block) {
	    while (block) {
	        if (block._lastLineBlank) {
	            return true;
	        }
	        var t = block.type;
	        if (t === 'list' || t === 'item') {
	            block = block._lastChild;
	        } else {
	            break;
	        }
	    }
	    return false;
	};
	
	// Add a line to the block at the tip.  We assume the tip
	// can accept lines -- that check should be done before calling this.
	var addLine = function() {
	    if (this.partiallyConsumedTab) {
	      this.offset += 1; // skip over tab
	      // add space characters:
	      var charsToTab = 4 - (this.column % 4);
	      this.tip._string_content += (' '.repeat(charsToTab));
	    }
	    this.tip._string_content += this.currentLine.slice(this.offset) + '\n';
	};
	
	// Add block of type tag as a child of the tip.  If the tip can't
	// accept children, close and finalize it and try its parent,
	// and so on til we find a block that can accept children.
	var addChild = function(tag, offset) {
	    while (!this.blocks[this.tip.type].canContain(tag)) {
	        this.finalize(this.tip, this.lineNumber - 1);
	    }
	
	    var column_number = offset + 1; // offset 0 = column 1
	    var newBlock = new Node(tag, [[this.lineNumber, column_number], [0, 0]]);
	    newBlock._string_content = '';
	    this.tip.appendChild(newBlock);
	    this.tip = newBlock;
	    return newBlock;
	};
	
	// Parse a list marker and return data on the marker (type,
	// start, delimiter, bullet character, padding) or null.
	var parseListMarker = function(parser, container) {
	    var rest = parser.currentLine.slice(parser.nextNonspace);
	    var match;
	    var nextc;
	    var spacesStartCol;
	    var spacesStartOffset;
	    var data = { type: null,
	                 tight: true,  // lists are tight by default
	                 bulletChar: null,
	                 start: null,
	                 delimiter: null,
	                 padding: null,
	                 markerOffset: parser.indent };
	    if ((match = rest.match(reBulletListMarker))) {
	        data.type = 'bullet';
	        data.bulletChar = match[0][0];
	
	    } else if ((match = rest.match(reOrderedListMarker)) &&
	                (container.type !== 'paragraph' ||
	                 match[1] === '1')) {
	        data.type = 'ordered';
	        data.start = parseInt(match[1]);
	        data.delimiter = match[2];
	    } else {
	        return null;
	    }
	    // make sure we have spaces after
	    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
	    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
	        return null;
	    }
	
	    // if it interrupts paragraph, make sure first line isn't blank
	    if (container.type === 'paragraph' && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
	        return null;
	    }
	
	    // we've got a match! advance offset and calculate padding
	    parser.advanceNextNonspace(); // to start of marker
	    parser.advanceOffset(match[0].length, true); // to end of marker
	    spacesStartCol = parser.column;
	    spacesStartOffset = parser.offset;
	    do {
	        parser.advanceOffset(1, true);
	        nextc = peek(parser.currentLine, parser.offset);
	    } while (parser.column - spacesStartCol < 5 &&
	           isSpaceOrTab(nextc));
	    var blank_item = peek(parser.currentLine, parser.offset) === -1;
	    var spaces_after_marker = parser.column - spacesStartCol;
	    if (spaces_after_marker >= 5 ||
	        spaces_after_marker < 1 ||
	        blank_item) {
	        data.padding = match[0].length + 1;
	        parser.column = spacesStartCol;
	        parser.offset = spacesStartOffset;
	        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
	            parser.advanceOffset(1, true);
	        }
	    } else {
	        data.padding = match[0].length + spaces_after_marker;
	    }
	    return data;
	};
	
	// Returns true if the two list items are of the same type,
	// with the same delimiter and bullet character.  This is used
	// in agglomerating list items into lists.
	var listsMatch = function(list_data, item_data) {
	    return (list_data.type === item_data.type &&
	            list_data.delimiter === item_data.delimiter &&
	            list_data.bulletChar === item_data.bulletChar);
	};
	
	// Finalize and close any unmatched blocks.
	var closeUnmatchedBlocks = function() {
	    if (!this.allClosed) {
	        // finalize any blocks not matched
	        while (this.oldtip !== this.lastMatchedContainer) {
	            var parent = this.oldtip._parent;
	            this.finalize(this.oldtip, this.lineNumber - 1);
	            this.oldtip = parent;
	        }
	        this.allClosed = true;
	    }
	};
	
	// 'finalize' is run when the block is closed.
	// 'continue' is run to check whether the block is continuing
	// at a certain line and offset (e.g. whether a block quote
	// contains a `>`.  It returns 0 for matched, 1 for not matched,
	// and 2 for "we've dealt with this line completely, go to next."
	var blocks = {
	    document: {
	        continue: function() { return 0; },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    list: {
	        continue: function() { return 0; },
	        finalize: function(parser, block) {
	            var item = block._firstChild;
	            while (item) {
	                // check for non-final list item ending with blank line:
	                if (endsWithBlankLine(item) && item._next) {
	                    block._listData.tight = false;
	                    break;
	                }
	                // recurse into children of list item, to see if there are
	                // spaces between any of them:
	                var subitem = item._firstChild;
	                while (subitem) {
	                    if (endsWithBlankLine(subitem) &&
	                        (item._next || subitem._next)) {
	                        block._listData.tight = false;
	                        break;
	                    }
	                    subitem = subitem._next;
	                }
	                item = item._next;
	            }
	        },
	        canContain: function(t) { return (t === 'item'); },
	        acceptsLines: false
	    },
	    block_quote: {
	        continue: function(parser) {
	            var ln = parser.currentLine;
	            if (!parser.indented &&
	                peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
	                parser.advanceNextNonspace();
	                parser.advanceOffset(1, false);
	                if (isSpaceOrTab(peek(ln, parser.offset))) {
	                    parser.advanceOffset(1, true);
	                }
	            } else {
	                return 1;
	            }
	            return 0;
	        },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    item: {
	        continue: function(parser, container) {
	            if (parser.blank) {
	                if (container._firstChild == null) {
	                    // Blank line after empty list item
	                    return 1;
	                } else {
	                    parser.advanceNextNonspace();
	                }
	            } else if (parser.indent >=
	                       container._listData.markerOffset +
	                       container._listData.padding) {
	                parser.advanceOffset(container._listData.markerOffset +
	                    container._listData.padding, true);
	            } else {
	                return 1;
	            }
	            return 0;
	        },
	        finalize: function() { return; },
	        canContain: function(t) { return (t !== 'item'); },
	        acceptsLines: false
	    },
	    heading: {
	        continue: function() {
	            // a heading can never container > 1 line, so fail to match:
	            return 1;
	        },
	        finalize: function() { return; },
	        canContain: function() { return false; },
	        acceptsLines: false
	    },
	    thematic_break: {
	        continue: function() {
	            // a thematic break can never container > 1 line, so fail to match:
	            return 1;
	        },
	        finalize: function() { return; },
	        canContain: function() { return false; },
	        acceptsLines: false
	    },
	    code_block: {
	        continue: function(parser, container) {
	            var ln = parser.currentLine;
	            var indent = parser.indent;
	            if (container._isFenced) { // fenced
	                var match = (indent <= 3 &&
	                    ln.charAt(parser.nextNonspace) === container._fenceChar &&
	                    ln.slice(parser.nextNonspace).match(reClosingCodeFence));
	                if (match && match[0].length >= container._fenceLength) {
	                    // closing fence - we're at end of line, so we can return
	                    parser.finalize(container, parser.lineNumber);
	                    return 2;
	                } else {
	                    // skip optional spaces of fence offset
	                    var i = container._fenceOffset;
	                    while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
	                        parser.advanceOffset(1, true);
	                        i--;
	                    }
	                }
	            } else { // indented
	                if (indent >= CODE_INDENT) {
	                    parser.advanceOffset(CODE_INDENT, true);
	                } else if (parser.blank) {
	                    parser.advanceNextNonspace();
	                } else {
	                    return 1;
	                }
	            }
	            return 0;
	        },
	        finalize: function(parser, block) {
	            if (block._isFenced) { // fenced
	                // first line becomes info string
	                var content = block._string_content;
	                var newlinePos = content.indexOf('\n');
	                var firstLine = content.slice(0, newlinePos);
	                var rest = content.slice(newlinePos + 1);
	                block.info = unescapeString(firstLine.trim());
	                block._literal = rest;
	            } else { // indented
	                block._literal = block._string_content.replace(/(\n *)+$/, '\n');
	            }
	            block._string_content = null; // allow GC
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    },
	    html_block: {
	        continue: function(parser, container) {
	            return ((parser.blank &&
	                     (container._htmlBlockType === 6 ||
	                      container._htmlBlockType === 7)) ? 1 : 0);
	        },
	        finalize: function(parser, block) {
	            block._literal = block._string_content.replace(/(\n *)+$/, '');
	            block._string_content = null; // allow GC
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    },
	    paragraph: {
	        continue: function(parser) {
	            return (parser.blank ? 1 : 0);
	        },
	        finalize: function(parser, block) {
	            var pos;
	            var hasReferenceDefs = false;
	
	            // try parsing the beginning as link reference definitions:
	            while (peek(block._string_content, 0) === C_OPEN_BRACKET &&
	                   (pos =
	                    parser.inlineParser.parseReference(block._string_content,
	                                                       parser.refmap))) {
	                block._string_content = block._string_content.slice(pos);
	                hasReferenceDefs = true;
	            }
	            if (hasReferenceDefs && isBlank(block._string_content)) {
	                block.unlink();
	            }
	        },
	        canContain: function() { return false; },
	        acceptsLines: true
	    }
	};
	
	// block start functions.  Return values:
	// 0 = no match
	// 1 = matched container, keep going
	// 2 = matched leaf, no more block starts
	var blockStarts = [
	    // block quote
	    function(parser) {
	        if (!parser.indented &&
	            peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
	            parser.advanceNextNonspace();
	            parser.advanceOffset(1, false);
	            // optional following space
	            if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
	                parser.advanceOffset(1, true);
	            }
	            parser.closeUnmatchedBlocks();
	            parser.addChild('block_quote', parser.nextNonspace);
	            return 1;
	        } else {
	            return 0;
	        }
	    },
	
	    // ATX heading
	    function(parser) {
	        var match;
	        if (!parser.indented &&
	            (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
	            parser.advanceNextNonspace();
	            parser.advanceOffset(match[0].length, false);
	            parser.closeUnmatchedBlocks();
	            var container = parser.addChild('heading', parser.nextNonspace);
	            container.level = match[0].trim().length; // number of #s
	            // remove trailing ###s:
	            container._string_content =
	                parser.currentLine.slice(parser.offset).replace(/^ *#+ *$/, '').replace(/ +#+ *$/, '');
	            parser.advanceOffset(parser.currentLine.length - parser.offset);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // Fenced code block
	    function(parser) {
	        var match;
	        if (!parser.indented &&
	            (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
	            var fenceLength = match[0].length;
	            parser.closeUnmatchedBlocks();
	            var container = parser.addChild('code_block', parser.nextNonspace);
	            container._isFenced = true;
	            container._fenceLength = fenceLength;
	            container._fenceChar = match[0][0];
	            container._fenceOffset = parser.indent;
	            parser.advanceNextNonspace();
	            parser.advanceOffset(fenceLength, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // HTML block
	    function(parser, container) {
	        if (!parser.indented &&
	            peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
	            var s = parser.currentLine.slice(parser.nextNonspace);
	            var blockType;
	
	            for (blockType = 1; blockType <= 7; blockType++) {
	                if (reHtmlBlockOpen[blockType].test(s) &&
	                    (blockType < 7 ||
	                     container.type !== 'paragraph')) {
	                    parser.closeUnmatchedBlocks();
	                    // We don't adjust parser.offset;
	                    // spaces are part of the HTML block:
	                    var b = parser.addChild('html_block',
	                                            parser.offset);
	                    b._htmlBlockType = blockType;
	                    return 2;
	                }
	            }
	        }
	
	        return 0;
	
	    },
	
	    // Setext heading
	    function(parser, container) {
	        var match;
	        if (!parser.indented &&
	            container.type === 'paragraph' &&
	                   ((match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine)))) {
	            parser.closeUnmatchedBlocks();
	            var heading = new Node('heading', container.sourcepos);
	            heading.level = match[0][0] === '=' ? 1 : 2;
	            heading._string_content = container._string_content;
	            container.insertAfter(heading);
	            container.unlink();
	            parser.tip = heading;
	            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // thematic break
	    function(parser) {
	        if (!parser.indented &&
	            reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
	            parser.closeUnmatchedBlocks();
	            parser.addChild('thematic_break', parser.nextNonspace);
	            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
	            return 2;
	        } else {
	            return 0;
	        }
	    },
	
	    // list item
	    function(parser, container) {
	        var data;
	
	        if ((!parser.indented || container.type === 'list')
	                && (data = parseListMarker(parser, container))) {
	            parser.closeUnmatchedBlocks();
	
	            // add the list if needed
	            if (parser.tip.type !== 'list' ||
	                !(listsMatch(container._listData, data))) {
	                container = parser.addChild('list', parser.nextNonspace);
	                container._listData = data;
	            }
	
	            // add the list item
	            container = parser.addChild('item', parser.nextNonspace);
	            container._listData = data;
	            return 1;
	        } else {
	            return 0;
	        }
	    },
	
	    // indented code block
	    function(parser) {
	        if (parser.indented &&
	            parser.tip.type !== 'paragraph' &&
	            !parser.blank) {
	            // indented code
	            parser.advanceOffset(CODE_INDENT, true);
	            parser.closeUnmatchedBlocks();
	            parser.addChild('code_block', parser.offset);
	            return 2;
	        } else {
	            return 0;
	        }
	     }
	
	];
	
	var advanceOffset = function(count, columns) {
	    var currentLine = this.currentLine;
	    var charsToTab, charsToAdvance;
	    var c;
	    while (count > 0 && (c = currentLine[this.offset])) {
	        if (c === '\t') {
	            charsToTab = 4 - (this.column % 4);
	            if (columns) {
	                this.partiallyConsumedTab = charsToTab > count;
	                charsToAdvance = charsToTab > count ? count : charsToTab;
	                this.column += charsToAdvance;
	                this.offset += this.partiallyConsumedTab ? 0 : 1;
	                count -= charsToAdvance;
	            } else {
	                this.partiallyConsumedTab = false;
	                this.column += charsToTab;
	                this.offset += 1;
	                count -= 1;
	            }
	        } else {
	            this.partiallyConsumedTab = false;
	            this.offset += 1;
	            this.column += 1; // assume ascii; block starts are ascii
	            count -= 1;
	        }
	    }
	};
	
	var advanceNextNonspace = function() {
	    this.offset = this.nextNonspace;
	    this.column = this.nextNonspaceColumn;
	    this.partiallyConsumedTab = false;
	};
	
	var findNextNonspace = function() {
	    var currentLine = this.currentLine;
	    var i = this.offset;
	    var cols = this.column;
	    var c;
	
	    while ((c = currentLine.charAt(i)) !== '') {
	        if (c === ' ') {
	            i++;
	            cols++;
	        } else if (c === '\t') {
	            i++;
	            cols += (4 - (cols % 4));
	        } else {
	            break;
	        }
	    }
	    this.blank = (c === '\n' || c === '\r' || c === '');
	    this.nextNonspace = i;
	    this.nextNonspaceColumn = cols;
	    this.indent = this.nextNonspaceColumn - this.column;
	    this.indented = this.indent >= CODE_INDENT;
	};
	
	// Analyze a line of text and update the document appropriately.
	// We parse markdown text by calling this on each line of input,
	// then finalizing the document.
	var incorporateLine = function(ln) {
	    var all_matched = true;
	    var t;
	
	    var container = this.doc;
	    this.oldtip = this.tip;
	    this.offset = 0;
	    this.column = 0;
	    this.blank = false;
	    this.partiallyConsumedTab = false;
	    this.lineNumber += 1;
	
	    // replace NUL characters for security
	    if (ln.indexOf('\u0000') !== -1) {
	        ln = ln.replace(/\0/g, '\uFFFD');
	    }
	
	    this.currentLine = ln;
	
	    // For each containing block, try to parse the associated line start.
	    // Bail out on failure: container will point to the last matching block.
	    // Set all_matched to false if not all containers match.
	    var lastChild;
	    while ((lastChild = container._lastChild) && lastChild._open) {
	        container = lastChild;
	
	        this.findNextNonspace();
	
	        switch (this.blocks[container.type].continue(this, container)) {
	        case 0: // we've matched, keep going
	            break;
	        case 1: // we've failed to match a block
	            all_matched = false;
	            break;
	        case 2: // we've hit end of line for fenced code close and can return
	            this.lastLineLength = ln.length;
	            return;
	        default:
	            throw 'continue returned illegal value, must be 0, 1, or 2';
	        }
	        if (!all_matched) {
	            container = container._parent; // back up to last matching block
	            break;
	        }
	    }
	
	    this.allClosed = (container === this.oldtip);
	    this.lastMatchedContainer = container;
	
	    var matchedLeaf = container.type !== 'paragraph' &&
	            blocks[container.type].acceptsLines;
	    var starts = this.blockStarts;
	    var startsLen = starts.length;
	    // Unless last matched container is a code block, try new container starts,
	    // adding children to the last matched container:
	    while (!matchedLeaf) {
	
	        this.findNextNonspace();
	
	        // this is a little performance optimization:
	        if (!this.indented &&
	            !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
	            this.advanceNextNonspace();
	            break;
	        }
	
	        var i = 0;
	        while (i < startsLen) {
	            var res = starts[i](this, container);
	            if (res === 1) {
	                container = this.tip;
	                break;
	            } else if (res === 2) {
	                container = this.tip;
	                matchedLeaf = true;
	                break;
	            } else {
	                i++;
	            }
	        }
	
	        if (i === startsLen) { // nothing matched
	            this.advanceNextNonspace();
	            break;
	        }
	    }
	
	    // What remains at the offset is a text line.  Add the text to the
	    // appropriate container.
	
	   // First check for a lazy paragraph continuation:
	    if (!this.allClosed && !this.blank &&
	        this.tip.type === 'paragraph') {
	        // lazy paragraph continuation
	        this.addLine();
	
	    } else { // not a lazy continuation
	
	        // finalize any blocks not matched
	        this.closeUnmatchedBlocks();
	        if (this.blank && container.lastChild) {
	            container.lastChild._lastLineBlank = true;
	        }
	
	        t = container.type;
	
	        // Block quote lines are never blank as they start with >
	        // and we don't count blanks in fenced code for purposes of tight/loose
	        // lists or breaking out of lists.  We also don't set _lastLineBlank
	        // on an empty list item, or if we just closed a fenced block.
	        var lastLineBlank = this.blank &&
	            !(t === 'block_quote' ||
	              (t === 'code_block' && container._isFenced) ||
	              (t === 'item' &&
	               !container._firstChild &&
	               container.sourcepos[0][0] === this.lineNumber));
	
	        // propagate lastLineBlank up through parents:
	        var cont = container;
	        while (cont) {
	            cont._lastLineBlank = lastLineBlank;
	            cont = cont._parent;
	        }
	
	        if (this.blocks[t].acceptsLines) {
	            this.addLine();
	            // if HtmlBlock, check for end condition
	            if (t === 'html_block' &&
	                container._htmlBlockType >= 1 &&
	                container._htmlBlockType <= 5 &&
	                reHtmlBlockClose[container._htmlBlockType].test(this.currentLine.slice(this.offset))) {
	                this.finalize(container, this.lineNumber);
	            }
	
	        } else if (this.offset < ln.length && !this.blank) {
	            // create paragraph container for line
	            container = this.addChild('paragraph', this.offset);
	            this.advanceNextNonspace();
	            this.addLine();
	        }
	    }
	    this.lastLineLength = ln.length;
	};
	
	// Finalize a block.  Close it and do any necessary postprocessing,
	// e.g. creating string_content from strings, setting the 'tight'
	// or 'loose' status of a list, and parsing the beginnings
	// of paragraphs for reference definitions.  Reset the tip to the
	// parent of the closed block.
	var finalize = function(block, lineNumber) {
	    var above = block._parent;
	    block._open = false;
	    block.sourcepos[1] = [lineNumber, this.lastLineLength];
	
	    this.blocks[block.type].finalize(this, block);
	
	    this.tip = above;
	};
	
	// Walk through a block & children recursively, parsing string content
	// into inline content where appropriate.
	var processInlines = function(block) {
	    var node, event, t;
	    var walker = block.walker();
	    this.inlineParser.refmap = this.refmap;
	    this.inlineParser.options = this.options;
	    while ((event = walker.next())) {
	        node = event.node;
	        t = node.type;
	        if (!event.entering && (t === 'paragraph' || t === 'heading')) {
	            this.inlineParser.parse(node);
	        }
	    }
	};
	
	var Document = function() {
	    var doc = new Node('document', [[1, 1], [0, 0]]);
	    return doc;
	};
	
	// The main parsing function.  Returns a parsed document AST.
	var parse = function(input) {
	    this.doc = new Document();
	    this.tip = this.doc;
	    this.refmap = {};
	    this.lineNumber = 0;
	    this.lastLineLength = 0;
	    this.offset = 0;
	    this.column = 0;
	    this.lastMatchedContainer = this.doc;
	    this.currentLine = "";
	    if (this.options.time) { console.time("preparing input"); }
	    var lines = input.split(reLineEnding);
	    var len = lines.length;
	    if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
	        // ignore last blank line created by final newline
	        len -= 1;
	    }
	    if (this.options.time) { console.timeEnd("preparing input"); }
	    if (this.options.time) { console.time("block parsing"); }
	    for (var i = 0; i < len; i++) {
	        this.incorporateLine(lines[i]);
	    }
	    while (this.tip) {
	        this.finalize(this.tip, len);
	    }
	    if (this.options.time) { console.timeEnd("block parsing"); }
	    if (this.options.time) { console.time("inline parsing"); }
	    this.processInlines(this.doc);
	    if (this.options.time) { console.timeEnd("inline parsing"); }
	    return this.doc;
	};
	
	
	// The Parser object.
	function Parser(options){
	    return {
	        doc: new Document(),
	        blocks: blocks,
	        blockStarts: blockStarts,
	        tip: this.doc,
	        oldtip: this.doc,
	        currentLine: "",
	        lineNumber: 0,
	        offset: 0,
	        column: 0,
	        nextNonspace: 0,
	        nextNonspaceColumn: 0,
	        indent: 0,
	        indented: false,
	        blank: false,
	        partiallyConsumedTab: false,
	        allClosed: true,
	        lastMatchedContainer: this.doc,
	        refmap: {},
	        lastLineLength: 0,
	        inlineParser: new InlineParser(options),
	        findNextNonspace: findNextNonspace,
	        advanceOffset: advanceOffset,
	        advanceNextNonspace: advanceNextNonspace,
	        addLine: addLine,
	        addChild: addChild,
	        incorporateLine: incorporateLine,
	        finalize: finalize,
	        processInlines: processInlines,
	        closeUnmatchedBlocks: closeUnmatchedBlocks,
	        parse: parse,
	        options: options || {}
	    };
	}
	
	module.exports = Parser;


/***/ },
/* 442 */
/*!************************************!*\
  !*** ./~/commonmark/lib/common.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var encode = __webpack_require__(/*! mdurl/encode */ 443);
	var decode = __webpack_require__(/*! mdurl/decode */ 444);
	
	var C_BACKSLASH = 92;
	
	var decodeHTML = __webpack_require__(/*! entities */ 445).decodeHTML;
	
	var ENTITY = "&(?:#x[a-f0-9]{1,8}|#[0-9]{1,8}|[a-z][a-z0-9]{1,31});";
	
	var TAGNAME = '[A-Za-z][A-Za-z0-9-]*';
	var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
	var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
	var SINGLEQUOTEDVALUE = "'[^']*'";
	var DOUBLEQUOTEDVALUE = '"[^"]*"';
	var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
	var ATTRIBUTEVALUESPEC = "(?:" + "\\s*=" + "\\s*" + ATTRIBUTEVALUE + ")";
	var ATTRIBUTE = "(?:" + "\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
	var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*" + "\\s*/?>";
	var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
	var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
	var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
	var DECLARATION = "<![A-Z]+" + "\\s+[^>]*>";
	var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
	var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" +
	        PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
	var reHtmlTag = new RegExp('^' + HTMLTAG, 'i');
	
	var reBackslashOrAmp = /[\\&]/;
	
	var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';
	
	var reEntityOrEscapedChar = new RegExp('\\\\' + ESCAPABLE + '|' + ENTITY, 'gi');
	
	var XMLSPECIAL = '[&<>"]';
	
	var reXmlSpecial = new RegExp(XMLSPECIAL, 'g');
	
	var reXmlSpecialOrEntity = new RegExp(ENTITY + '|' + XMLSPECIAL, 'gi');
	
	var unescapeChar = function(s) {
	    if (s.charCodeAt(0) === C_BACKSLASH) {
	        return s.charAt(1);
	    } else {
	        return decodeHTML(s);
	    }
	};
	
	// Replace entities and backslash escapes with literal characters.
	var unescapeString = function(s) {
	    if (reBackslashOrAmp.test(s)) {
	        return s.replace(reEntityOrEscapedChar, unescapeChar);
	    } else {
	        return s;
	    }
	};
	
	var normalizeURI = function(uri) {
	    try {
	        return encode(decode(uri));
	    }
	    catch(err) {
	        return uri;
	    }
	};
	
	var replaceUnsafeChar = function(s) {
	    switch (s) {
	    case '&':
	        return '&amp;';
	    case '<':
	        return '&lt;';
	    case '>':
	        return '&gt;';
	    case '"':
	        return '&quot;';
	    default:
	        return s;
	    }
	};
	
	var escapeXml = function(s, preserve_entities) {
	    if (reXmlSpecial.test(s)) {
	        if (preserve_entities) {
	            return s.replace(reXmlSpecialOrEntity, replaceUnsafeChar);
	        } else {
	            return s.replace(reXmlSpecial, replaceUnsafeChar);
	        }
	    } else {
	        return s;
	    }
	};
	
	module.exports = { unescapeString: unescapeString,
	                   normalizeURI: normalizeURI,
	                   escapeXml: escapeXml,
	                   reHtmlTag: reHtmlTag,
	                   OPENTAG: OPENTAG,
	                   CLOSETAG: CLOSETAG,
	                   ENTITY: ENTITY,
	                   ESCAPABLE: ESCAPABLE
	                 };


/***/ },
/* 443 */
/*!***************************!*\
  !*** ./~/mdurl/encode.js ***!
  \***************************/
/***/ function(module, exports) {

	
	'use strict';
	
	
	var encodeCache = {};
	
	
	// Create a lookup array where anything but characters in `chars` string
	// and alphanumeric chars is percent-encoded.
	//
	function getEncodeCache(exclude) {
	  var i, ch, cache = encodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = encodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	
	    if (/^[0-9a-z]$/i.test(ch)) {
	      // always allow unencoded alphanumeric characters
	      cache.push(ch);
	    } else {
	      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
	    }
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    cache[exclude.charCodeAt(i)] = exclude[i];
	  }
	
	  return cache;
	}
	
	
	// Encode unsafe characters with percent-encoding, skipping already
	// encoded sequences.
	//
	//  - string       - string to encode
	//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
	//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
	//
	function encode(string, exclude, keepEscaped) {
	  var i, l, code, nextCode, cache,
	      result = '';
	
	  if (typeof exclude !== 'string') {
	    // encode(string, keepEscaped)
	    keepEscaped  = exclude;
	    exclude = encode.defaultChars;
	  }
	
	  if (typeof keepEscaped === 'undefined') {
	    keepEscaped = true;
	  }
	
	  cache = getEncodeCache(exclude);
	
	  for (i = 0, l = string.length; i < l; i++) {
	    code = string.charCodeAt(i);
	
	    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
	      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
	        result += string.slice(i, i + 3);
	        i += 2;
	        continue;
	      }
	    }
	
	    if (code < 128) {
	      result += cache[code];
	      continue;
	    }
	
	    if (code >= 0xD800 && code <= 0xDFFF) {
	      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
	        nextCode = string.charCodeAt(i + 1);
	        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
	          result += encodeURIComponent(string[i] + string[i + 1]);
	          i++;
	          continue;
	        }
	      }
	      result += '%EF%BF%BD';
	      continue;
	    }
	
	    result += encodeURIComponent(string[i]);
	  }
	
	  return result;
	}
	
	encode.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
	encode.componentChars = "-_.!~*'()";
	
	
	module.exports = encode;


/***/ },
/* 444 */
/*!***************************!*\
  !*** ./~/mdurl/decode.js ***!
  \***************************/
/***/ function(module, exports) {

	
	'use strict';
	
	
	/* eslint-disable no-bitwise */
	
	var decodeCache = {};
	
	function getDecodeCache(exclude) {
	  var i, ch, cache = decodeCache[exclude];
	  if (cache) { return cache; }
	
	  cache = decodeCache[exclude] = [];
	
	  for (i = 0; i < 128; i++) {
	    ch = String.fromCharCode(i);
	    cache.push(ch);
	  }
	
	  for (i = 0; i < exclude.length; i++) {
	    ch = exclude.charCodeAt(i);
	    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
	  }
	
	  return cache;
	}
	
	
	// Decode percent-encoded string.
	//
	function decode(string, exclude) {
	  var cache;
	
	  if (typeof exclude !== 'string') {
	    exclude = decode.defaultChars;
	  }
	
	  cache = getDecodeCache(exclude);
	
	  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
	    var i, l, b1, b2, b3, b4, chr,
	        result = '';
	
	    for (i = 0, l = seq.length; i < l; i += 3) {
	      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
	
	      if (b1 < 0x80) {
	        result += cache[b1];
	        continue;
	      }
	
	      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
	        // 110xxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	
	        if ((b2 & 0xC0) === 0x80) {
	          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);
	
	          if (chr < 0x80) {
	            result += '\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 3;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
	        // 1110xxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
	          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);
	
	          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
	            result += '\ufffd\ufffd\ufffd';
	          } else {
	            result += String.fromCharCode(chr);
	          }
	
	          i += 6;
	          continue;
	        }
	      }
	
	      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
	        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
	        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
	        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
	        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
	
	        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
	          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);
	
	          if (chr < 0x10000 || chr > 0x10FFFF) {
	            result += '\ufffd\ufffd\ufffd\ufffd';
	          } else {
	            chr -= 0x10000;
	            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
	          }
	
	          i += 9;
	          continue;
	        }
	      }
	
	      result += '\ufffd';
	    }
	
	    return result;
	  });
	}
	
	
	decode.defaultChars   = ';/?:@&=+$,#';
	decode.componentChars = '';
	
	
	module.exports = decode;


/***/ },
/* 445 */
/*!*****************************!*\
  !*** ./~/entities/index.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	var encode = __webpack_require__(/*! ./lib/encode.js */ 446),
	    decode = __webpack_require__(/*! ./lib/decode.js */ 449);
	
	exports.decode = function(data, level){
		return (!level || level <= 0 ? decode.XML : decode.HTML)(data);
	};
	
	exports.decodeStrict = function(data, level){
		return (!level || level <= 0 ? decode.XML : decode.HTMLStrict)(data);
	};
	
	exports.encode = function(data, level){
		return (!level || level <= 0 ? encode.XML : encode.HTML)(data);
	};
	
	exports.encodeXML = encode.XML;
	
	exports.encodeHTML4 =
	exports.encodeHTML5 =
	exports.encodeHTML  = encode.HTML;
	
	exports.decodeXML =
	exports.decodeXMLStrict = decode.XML;
	
	exports.decodeHTML4 =
	exports.decodeHTML5 =
	exports.decodeHTML = decode.HTML;
	
	exports.decodeHTML4Strict =
	exports.decodeHTML5Strict =
	exports.decodeHTMLStrict = decode.HTMLStrict;
	
	exports.escape = encode.escape;


/***/ },
/* 446 */
/*!**********************************!*\
  !*** ./~/entities/lib/encode.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var inverseXML = getInverseObj(__webpack_require__(/*! ../maps/xml.json */ 447)),
	    xmlReplacer = getInverseReplacer(inverseXML);
	
	exports.XML = getInverse(inverseXML, xmlReplacer);
	
	var inverseHTML = getInverseObj(__webpack_require__(/*! ../maps/entities.json */ 448)),
	    htmlReplacer = getInverseReplacer(inverseHTML);
	
	exports.HTML = getInverse(inverseHTML, htmlReplacer);
	
	function getInverseObj(obj){
		return Object.keys(obj).sort().reduce(function(inverse, name){
			inverse[obj[name]] = "&" + name + ";";
			return inverse;
		}, {});
	}
	
	function getInverseReplacer(inverse){
		var single = [],
		    multiple = [];
	
		Object.keys(inverse).forEach(function(k){
			if(k.length === 1){
				single.push("\\" + k);
			} else {
				multiple.push(k);
			}
		});
	
		//TODO add ranges
		multiple.unshift("[" + single.join("") + "]");
	
		return new RegExp(multiple.join("|"), "g");
	}
	
	var re_nonASCII = /[^\0-\x7F]/g,
	    re_astralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	
	function singleCharReplacer(c){
		return "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";";
	}
	
	function astralReplacer(c){
		// http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
		var high = c.charCodeAt(0);
		var low  = c.charCodeAt(1);
		var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
		return "&#x" + codePoint.toString(16).toUpperCase() + ";";
	}
	
	function getInverse(inverse, re){
		function func(name){
			return inverse[name];
		}
	
		return function(data){
			return data
					.replace(re, func)
					.replace(re_astralSymbols, astralReplacer)
					.replace(re_nonASCII, singleCharReplacer);
		};
	}
	
	var re_xmlChars = getInverseReplacer(inverseXML);
	
	function escapeXML(data){
		return data
				.replace(re_xmlChars, singleCharReplacer)
				.replace(re_astralSymbols, astralReplacer)
				.replace(re_nonASCII, singleCharReplacer);
	}
	
	exports.escape = escapeXML;


/***/ },
/* 447 */
/*!**********************************!*\
  !*** ./~/entities/maps/xml.json ***!
  \**********************************/
/***/ function(module, exports) {

	module.exports = {
		"amp": "&",
		"apos": "'",
		"gt": ">",
		"lt": "<",
		"quot": "\""
	};

/***/ },
/* 448 */
/*!***************************************!*\
  !*** ./~/entities/maps/entities.json ***!
  \***************************************/
/***/ function(module, exports) {

	module.exports = {
		"Aacute": "",
		"aacute": "",
		"Abreve": "",
		"abreve": "",
		"ac": "",
		"acd": "",
		"acE": "",
		"Acirc": "",
		"acirc": "",
		"acute": "",
		"Acy": "",
		"acy": "",
		"AElig": "",
		"aelig": "",
		"af": "",
		"Afr": "",
		"afr": "",
		"Agrave": "",
		"agrave": "",
		"alefsym": "",
		"aleph": "",
		"Alpha": "",
		"alpha": "",
		"Amacr": "",
		"amacr": "",
		"amalg": "",
		"amp": "&",
		"AMP": "&",
		"andand": "",
		"And": "",
		"and": "",
		"andd": "",
		"andslope": "",
		"andv": "",
		"ang": "",
		"ange": "",
		"angle": "",
		"angmsdaa": "",
		"angmsdab": "",
		"angmsdac": "",
		"angmsdad": "",
		"angmsdae": "",
		"angmsdaf": "",
		"angmsdag": "",
		"angmsdah": "",
		"angmsd": "",
		"angrt": "",
		"angrtvb": "",
		"angrtvbd": "",
		"angsph": "",
		"angst": "",
		"angzarr": "",
		"Aogon": "",
		"aogon": "",
		"Aopf": "",
		"aopf": "",
		"apacir": "",
		"ap": "",
		"apE": "",
		"ape": "",
		"apid": "",
		"apos": "'",
		"ApplyFunction": "",
		"approx": "",
		"approxeq": "",
		"Aring": "",
		"aring": "",
		"Ascr": "",
		"ascr": "",
		"Assign": "",
		"ast": "*",
		"asymp": "",
		"asympeq": "",
		"Atilde": "",
		"atilde": "",
		"Auml": "",
		"auml": "",
		"awconint": "",
		"awint": "",
		"backcong": "",
		"backepsilon": "",
		"backprime": "",
		"backsim": "",
		"backsimeq": "",
		"Backslash": "",
		"Barv": "",
		"barvee": "",
		"barwed": "",
		"Barwed": "",
		"barwedge": "",
		"bbrk": "",
		"bbrktbrk": "",
		"bcong": "",
		"Bcy": "",
		"bcy": "",
		"bdquo": "",
		"becaus": "",
		"because": "",
		"Because": "",
		"bemptyv": "",
		"bepsi": "",
		"bernou": "",
		"Bernoullis": "",
		"Beta": "",
		"beta": "",
		"beth": "",
		"between": "",
		"Bfr": "",
		"bfr": "",
		"bigcap": "",
		"bigcirc": "",
		"bigcup": "",
		"bigodot": "",
		"bigoplus": "",
		"bigotimes": "",
		"bigsqcup": "",
		"bigstar": "",
		"bigtriangledown": "",
		"bigtriangleup": "",
		"biguplus": "",
		"bigvee": "",
		"bigwedge": "",
		"bkarow": "",
		"blacklozenge": "",
		"blacksquare": "",
		"blacktriangle": "",
		"blacktriangledown": "",
		"blacktriangleleft": "",
		"blacktriangleright": "",
		"blank": "",
		"blk12": "",
		"blk14": "",
		"blk34": "",
		"block": "",
		"bne": "=",
		"bnequiv": "",
		"bNot": "",
		"bnot": "",
		"Bopf": "",
		"bopf": "",
		"bot": "",
		"bottom": "",
		"bowtie": "",
		"boxbox": "",
		"boxdl": "",
		"boxdL": "",
		"boxDl": "",
		"boxDL": "",
		"boxdr": "",
		"boxdR": "",
		"boxDr": "",
		"boxDR": "",
		"boxh": "",
		"boxH": "",
		"boxhd": "",
		"boxHd": "",
		"boxhD": "",
		"boxHD": "",
		"boxhu": "",
		"boxHu": "",
		"boxhU": "",
		"boxHU": "",
		"boxminus": "",
		"boxplus": "",
		"boxtimes": "",
		"boxul": "",
		"boxuL": "",
		"boxUl": "",
		"boxUL": "",
		"boxur": "",
		"boxuR": "",
		"boxUr": "",
		"boxUR": "",
		"boxv": "",
		"boxV": "",
		"boxvh": "",
		"boxvH": "",
		"boxVh": "",
		"boxVH": "",
		"boxvl": "",
		"boxvL": "",
		"boxVl": "",
		"boxVL": "",
		"boxvr": "",
		"boxvR": "",
		"boxVr": "",
		"boxVR": "",
		"bprime": "",
		"breve": "",
		"Breve": "",
		"brvbar": "",
		"bscr": "",
		"Bscr": "",
		"bsemi": "",
		"bsim": "",
		"bsime": "",
		"bsolb": "",
		"bsol": "\\",
		"bsolhsub": "",
		"bull": "",
		"bullet": "",
		"bump": "",
		"bumpE": "",
		"bumpe": "",
		"Bumpeq": "",
		"bumpeq": "",
		"Cacute": "",
		"cacute": "",
		"capand": "",
		"capbrcup": "",
		"capcap": "",
		"cap": "",
		"Cap": "",
		"capcup": "",
		"capdot": "",
		"CapitalDifferentialD": "",
		"caps": "",
		"caret": "",
		"caron": "",
		"Cayleys": "",
		"ccaps": "",
		"Ccaron": "",
		"ccaron": "",
		"Ccedil": "",
		"ccedil": "",
		"Ccirc": "",
		"ccirc": "",
		"Cconint": "",
		"ccups": "",
		"ccupssm": "",
		"Cdot": "",
		"cdot": "",
		"cedil": "",
		"Cedilla": "",
		"cemptyv": "",
		"cent": "",
		"centerdot": "",
		"CenterDot": "",
		"cfr": "",
		"Cfr": "",
		"CHcy": "",
		"chcy": "",
		"check": "",
		"checkmark": "",
		"Chi": "",
		"chi": "",
		"circ": "",
		"circeq": "",
		"circlearrowleft": "",
		"circlearrowright": "",
		"circledast": "",
		"circledcirc": "",
		"circleddash": "",
		"CircleDot": "",
		"circledR": "",
		"circledS": "",
		"CircleMinus": "",
		"CirclePlus": "",
		"CircleTimes": "",
		"cir": "",
		"cirE": "",
		"cire": "",
		"cirfnint": "",
		"cirmid": "",
		"cirscir": "",
		"ClockwiseContourIntegral": "",
		"CloseCurlyDoubleQuote": "",
		"CloseCurlyQuote": "",
		"clubs": "",
		"clubsuit": "",
		"colon": ":",
		"Colon": "",
		"Colone": "",
		"colone": "",
		"coloneq": "",
		"comma": ",",
		"commat": "@",
		"comp": "",
		"compfn": "",
		"complement": "",
		"complexes": "",
		"cong": "",
		"congdot": "",
		"Congruent": "",
		"conint": "",
		"Conint": "",
		"ContourIntegral": "",
		"copf": "",
		"Copf": "",
		"coprod": "",
		"Coproduct": "",
		"copy": "",
		"COPY": "",
		"copysr": "",
		"CounterClockwiseContourIntegral": "",
		"crarr": "",
		"cross": "",
		"Cross": "",
		"Cscr": "",
		"cscr": "",
		"csub": "",
		"csube": "",
		"csup": "",
		"csupe": "",
		"ctdot": "",
		"cudarrl": "",
		"cudarrr": "",
		"cuepr": "",
		"cuesc": "",
		"cularr": "",
		"cularrp": "",
		"cupbrcap": "",
		"cupcap": "",
		"CupCap": "",
		"cup": "",
		"Cup": "",
		"cupcup": "",
		"cupdot": "",
		"cupor": "",
		"cups": "",
		"curarr": "",
		"curarrm": "",
		"curlyeqprec": "",
		"curlyeqsucc": "",
		"curlyvee": "",
		"curlywedge": "",
		"curren": "",
		"curvearrowleft": "",
		"curvearrowright": "",
		"cuvee": "",
		"cuwed": "",
		"cwconint": "",
		"cwint": "",
		"cylcty": "",
		"dagger": "",
		"Dagger": "",
		"daleth": "",
		"darr": "",
		"Darr": "",
		"dArr": "",
		"dash": "",
		"Dashv": "",
		"dashv": "",
		"dbkarow": "",
		"dblac": "",
		"Dcaron": "",
		"dcaron": "",
		"Dcy": "",
		"dcy": "",
		"ddagger": "",
		"ddarr": "",
		"DD": "",
		"dd": "",
		"DDotrahd": "",
		"ddotseq": "",
		"deg": "",
		"Del": "",
		"Delta": "",
		"delta": "",
		"demptyv": "",
		"dfisht": "",
		"Dfr": "",
		"dfr": "",
		"dHar": "",
		"dharl": "",
		"dharr": "",
		"DiacriticalAcute": "",
		"DiacriticalDot": "",
		"DiacriticalDoubleAcute": "",
		"DiacriticalGrave": "`",
		"DiacriticalTilde": "",
		"diam": "",
		"diamond": "",
		"Diamond": "",
		"diamondsuit": "",
		"diams": "",
		"die": "",
		"DifferentialD": "",
		"digamma": "",
		"disin": "",
		"div": "",
		"divide": "",
		"divideontimes": "",
		"divonx": "",
		"DJcy": "",
		"djcy": "",
		"dlcorn": "",
		"dlcrop": "",
		"dollar": "$",
		"Dopf": "",
		"dopf": "",
		"Dot": "",
		"dot": "",
		"DotDot": "",
		"doteq": "",
		"doteqdot": "",
		"DotEqual": "",
		"dotminus": "",
		"dotplus": "",
		"dotsquare": "",
		"doublebarwedge": "",
		"DoubleContourIntegral": "",
		"DoubleDot": "",
		"DoubleDownArrow": "",
		"DoubleLeftArrow": "",
		"DoubleLeftRightArrow": "",
		"DoubleLeftTee": "",
		"DoubleLongLeftArrow": "",
		"DoubleLongLeftRightArrow": "",
		"DoubleLongRightArrow": "",
		"DoubleRightArrow": "",
		"DoubleRightTee": "",
		"DoubleUpArrow": "",
		"DoubleUpDownArrow": "",
		"DoubleVerticalBar": "",
		"DownArrowBar": "",
		"downarrow": "",
		"DownArrow": "",
		"Downarrow": "",
		"DownArrowUpArrow": "",
		"DownBreve": "",
		"downdownarrows": "",
		"downharpoonleft": "",
		"downharpoonright": "",
		"DownLeftRightVector": "",
		"DownLeftTeeVector": "",
		"DownLeftVectorBar": "",
		"DownLeftVector": "",
		"DownRightTeeVector": "",
		"DownRightVectorBar": "",
		"DownRightVector": "",
		"DownTeeArrow": "",
		"DownTee": "",
		"drbkarow": "",
		"drcorn": "",
		"drcrop": "",
		"Dscr": "",
		"dscr": "",
		"DScy": "",
		"dscy": "",
		"dsol": "",
		"Dstrok": "",
		"dstrok": "",
		"dtdot": "",
		"dtri": "",
		"dtrif": "",
		"duarr": "",
		"duhar": "",
		"dwangle": "",
		"DZcy": "",
		"dzcy": "",
		"dzigrarr": "",
		"Eacute": "",
		"eacute": "",
		"easter": "",
		"Ecaron": "",
		"ecaron": "",
		"Ecirc": "",
		"ecirc": "",
		"ecir": "",
		"ecolon": "",
		"Ecy": "",
		"ecy": "",
		"eDDot": "",
		"Edot": "",
		"edot": "",
		"eDot": "",
		"ee": "",
		"efDot": "",
		"Efr": "",
		"efr": "",
		"eg": "",
		"Egrave": "",
		"egrave": "",
		"egs": "",
		"egsdot": "",
		"el": "",
		"Element": "",
		"elinters": "",
		"ell": "",
		"els": "",
		"elsdot": "",
		"Emacr": "",
		"emacr": "",
		"empty": "",
		"emptyset": "",
		"EmptySmallSquare": "",
		"emptyv": "",
		"EmptyVerySmallSquare": "",
		"emsp13": "",
		"emsp14": "",
		"emsp": "",
		"ENG": "",
		"eng": "",
		"ensp": "",
		"Eogon": "",
		"eogon": "",
		"Eopf": "",
		"eopf": "",
		"epar": "",
		"eparsl": "",
		"eplus": "",
		"epsi": "",
		"Epsilon": "",
		"epsilon": "",
		"epsiv": "",
		"eqcirc": "",
		"eqcolon": "",
		"eqsim": "",
		"eqslantgtr": "",
		"eqslantless": "",
		"Equal": "",
		"equals": "=",
		"EqualTilde": "",
		"equest": "",
		"Equilibrium": "",
		"equiv": "",
		"equivDD": "",
		"eqvparsl": "",
		"erarr": "",
		"erDot": "",
		"escr": "",
		"Escr": "",
		"esdot": "",
		"Esim": "",
		"esim": "",
		"Eta": "",
		"eta": "",
		"ETH": "",
		"eth": "",
		"Euml": "",
		"euml": "",
		"euro": "",
		"excl": "!",
		"exist": "",
		"Exists": "",
		"expectation": "",
		"exponentiale": "",
		"ExponentialE": "",
		"fallingdotseq": "",
		"Fcy": "",
		"fcy": "",
		"female": "",
		"ffilig": "",
		"fflig": "",
		"ffllig": "",
		"Ffr": "",
		"ffr": "",
		"filig": "",
		"FilledSmallSquare": "",
		"FilledVerySmallSquare": "",
		"fjlig": "fj",
		"flat": "",
		"fllig": "",
		"fltns": "",
		"fnof": "",
		"Fopf": "",
		"fopf": "",
		"forall": "",
		"ForAll": "",
		"fork": "",
		"forkv": "",
		"Fouriertrf": "",
		"fpartint": "",
		"frac12": "",
		"frac13": "",
		"frac14": "",
		"frac15": "",
		"frac16": "",
		"frac18": "",
		"frac23": "",
		"frac25": "",
		"frac34": "",
		"frac35": "",
		"frac38": "",
		"frac45": "",
		"frac56": "",
		"frac58": "",
		"frac78": "",
		"frasl": "",
		"frown": "",
		"fscr": "",
		"Fscr": "",
		"gacute": "",
		"Gamma": "",
		"gamma": "",
		"Gammad": "",
		"gammad": "",
		"gap": "",
		"Gbreve": "",
		"gbreve": "",
		"Gcedil": "",
		"Gcirc": "",
		"gcirc": "",
		"Gcy": "",
		"gcy": "",
		"Gdot": "",
		"gdot": "",
		"ge": "",
		"gE": "",
		"gEl": "",
		"gel": "",
		"geq": "",
		"geqq": "",
		"geqslant": "",
		"gescc": "",
		"ges": "",
		"gesdot": "",
		"gesdoto": "",
		"gesdotol": "",
		"gesl": "",
		"gesles": "",
		"Gfr": "",
		"gfr": "",
		"gg": "",
		"Gg": "",
		"ggg": "",
		"gimel": "",
		"GJcy": "",
		"gjcy": "",
		"gla": "",
		"gl": "",
		"glE": "",
		"glj": "",
		"gnap": "",
		"gnapprox": "",
		"gne": "",
		"gnE": "",
		"gneq": "",
		"gneqq": "",
		"gnsim": "",
		"Gopf": "",
		"gopf": "",
		"grave": "`",
		"GreaterEqual": "",
		"GreaterEqualLess": "",
		"GreaterFullEqual": "",
		"GreaterGreater": "",
		"GreaterLess": "",
		"GreaterSlantEqual": "",
		"GreaterTilde": "",
		"Gscr": "",
		"gscr": "",
		"gsim": "",
		"gsime": "",
		"gsiml": "",
		"gtcc": "",
		"gtcir": "",
		"gt": ">",
		"GT": ">",
		"Gt": "",
		"gtdot": "",
		"gtlPar": "",
		"gtquest": "",
		"gtrapprox": "",
		"gtrarr": "",
		"gtrdot": "",
		"gtreqless": "",
		"gtreqqless": "",
		"gtrless": "",
		"gtrsim": "",
		"gvertneqq": "",
		"gvnE": "",
		"Hacek": "",
		"hairsp": "",
		"half": "",
		"hamilt": "",
		"HARDcy": "",
		"hardcy": "",
		"harrcir": "",
		"harr": "",
		"hArr": "",
		"harrw": "",
		"Hat": "^",
		"hbar": "",
		"Hcirc": "",
		"hcirc": "",
		"hearts": "",
		"heartsuit": "",
		"hellip": "",
		"hercon": "",
		"hfr": "",
		"Hfr": "",
		"HilbertSpace": "",
		"hksearow": "",
		"hkswarow": "",
		"hoarr": "",
		"homtht": "",
		"hookleftarrow": "",
		"hookrightarrow": "",
		"hopf": "",
		"Hopf": "",
		"horbar": "",
		"HorizontalLine": "",
		"hscr": "",
		"Hscr": "",
		"hslash": "",
		"Hstrok": "",
		"hstrok": "",
		"HumpDownHump": "",
		"HumpEqual": "",
		"hybull": "",
		"hyphen": "",
		"Iacute": "",
		"iacute": "",
		"ic": "",
		"Icirc": "",
		"icirc": "",
		"Icy": "",
		"icy": "",
		"Idot": "",
		"IEcy": "",
		"iecy": "",
		"iexcl": "",
		"iff": "",
		"ifr": "",
		"Ifr": "",
		"Igrave": "",
		"igrave": "",
		"ii": "",
		"iiiint": "",
		"iiint": "",
		"iinfin": "",
		"iiota": "",
		"IJlig": "",
		"ijlig": "",
		"Imacr": "",
		"imacr": "",
		"image": "",
		"ImaginaryI": "",
		"imagline": "",
		"imagpart": "",
		"imath": "",
		"Im": "",
		"imof": "",
		"imped": "",
		"Implies": "",
		"incare": "",
		"in": "",
		"infin": "",
		"infintie": "",
		"inodot": "",
		"intcal": "",
		"int": "",
		"Int": "",
		"integers": "",
		"Integral": "",
		"intercal": "",
		"Intersection": "",
		"intlarhk": "",
		"intprod": "",
		"InvisibleComma": "",
		"InvisibleTimes": "",
		"IOcy": "",
		"iocy": "",
		"Iogon": "",
		"iogon": "",
		"Iopf": "",
		"iopf": "",
		"Iota": "",
		"iota": "",
		"iprod": "",
		"iquest": "",
		"iscr": "",
		"Iscr": "",
		"isin": "",
		"isindot": "",
		"isinE": "",
		"isins": "",
		"isinsv": "",
		"isinv": "",
		"it": "",
		"Itilde": "",
		"itilde": "",
		"Iukcy": "",
		"iukcy": "",
		"Iuml": "",
		"iuml": "",
		"Jcirc": "",
		"jcirc": "",
		"Jcy": "",
		"jcy": "",
		"Jfr": "",
		"jfr": "",
		"jmath": "",
		"Jopf": "",
		"jopf": "",
		"Jscr": "",
		"jscr": "",
		"Jsercy": "",
		"jsercy": "",
		"Jukcy": "",
		"jukcy": "",
		"Kappa": "",
		"kappa": "",
		"kappav": "",
		"Kcedil": "",
		"kcedil": "",
		"Kcy": "",
		"kcy": "",
		"Kfr": "",
		"kfr": "",
		"kgreen": "",
		"KHcy": "",
		"khcy": "",
		"KJcy": "",
		"kjcy": "",
		"Kopf": "",
		"kopf": "",
		"Kscr": "",
		"kscr": "",
		"lAarr": "",
		"Lacute": "",
		"lacute": "",
		"laemptyv": "",
		"lagran": "",
		"Lambda": "",
		"lambda": "",
		"lang": "",
		"Lang": "",
		"langd": "",
		"langle": "",
		"lap": "",
		"Laplacetrf": "",
		"laquo": "",
		"larrb": "",
		"larrbfs": "",
		"larr": "",
		"Larr": "",
		"lArr": "",
		"larrfs": "",
		"larrhk": "",
		"larrlp": "",
		"larrpl": "",
		"larrsim": "",
		"larrtl": "",
		"latail": "",
		"lAtail": "",
		"lat": "",
		"late": "",
		"lates": "",
		"lbarr": "",
		"lBarr": "",
		"lbbrk": "",
		"lbrace": "{",
		"lbrack": "[",
		"lbrke": "",
		"lbrksld": "",
		"lbrkslu": "",
		"Lcaron": "",
		"lcaron": "",
		"Lcedil": "",
		"lcedil": "",
		"lceil": "",
		"lcub": "{",
		"Lcy": "",
		"lcy": "",
		"ldca": "",
		"ldquo": "",
		"ldquor": "",
		"ldrdhar": "",
		"ldrushar": "",
		"ldsh": "",
		"le": "",
		"lE": "",
		"LeftAngleBracket": "",
		"LeftArrowBar": "",
		"leftarrow": "",
		"LeftArrow": "",
		"Leftarrow": "",
		"LeftArrowRightArrow": "",
		"leftarrowtail": "",
		"LeftCeiling": "",
		"LeftDoubleBracket": "",
		"LeftDownTeeVector": "",
		"LeftDownVectorBar": "",
		"LeftDownVector": "",
		"LeftFloor": "",
		"leftharpoondown": "",
		"leftharpoonup": "",
		"leftleftarrows": "",
		"leftrightarrow": "",
		"LeftRightArrow": "",
		"Leftrightarrow": "",
		"leftrightarrows": "",
		"leftrightharpoons": "",
		"leftrightsquigarrow": "",
		"LeftRightVector": "",
		"LeftTeeArrow": "",
		"LeftTee": "",
		"LeftTeeVector": "",
		"leftthreetimes": "",
		"LeftTriangleBar": "",
		"LeftTriangle": "",
		"LeftTriangleEqual": "",
		"LeftUpDownVector": "",
		"LeftUpTeeVector": "",
		"LeftUpVectorBar": "",
		"LeftUpVector": "",
		"LeftVectorBar": "",
		"LeftVector": "",
		"lEg": "",
		"leg": "",
		"leq": "",
		"leqq": "",
		"leqslant": "",
		"lescc": "",
		"les": "",
		"lesdot": "",
		"lesdoto": "",
		"lesdotor": "",
		"lesg": "",
		"lesges": "",
		"lessapprox": "",
		"lessdot": "",
		"lesseqgtr": "",
		"lesseqqgtr": "",
		"LessEqualGreater": "",
		"LessFullEqual": "",
		"LessGreater": "",
		"lessgtr": "",
		"LessLess": "",
		"lesssim": "",
		"LessSlantEqual": "",
		"LessTilde": "",
		"lfisht": "",
		"lfloor": "",
		"Lfr": "",
		"lfr": "",
		"lg": "",
		"lgE": "",
		"lHar": "",
		"lhard": "",
		"lharu": "",
		"lharul": "",
		"lhblk": "",
		"LJcy": "",
		"ljcy": "",
		"llarr": "",
		"ll": "",
		"Ll": "",
		"llcorner": "",
		"Lleftarrow": "",
		"llhard": "",
		"lltri": "",
		"Lmidot": "",
		"lmidot": "",
		"lmoustache": "",
		"lmoust": "",
		"lnap": "",
		"lnapprox": "",
		"lne": "",
		"lnE": "",
		"lneq": "",
		"lneqq": "",
		"lnsim": "",
		"loang": "",
		"loarr": "",
		"lobrk": "",
		"longleftarrow": "",
		"LongLeftArrow": "",
		"Longleftarrow": "",
		"longleftrightarrow": "",
		"LongLeftRightArrow": "",
		"Longleftrightarrow": "",
		"longmapsto": "",
		"longrightarrow": "",
		"LongRightArrow": "",
		"Longrightarrow": "",
		"looparrowleft": "",
		"looparrowright": "",
		"lopar": "",
		"Lopf": "",
		"lopf": "",
		"loplus": "",
		"lotimes": "",
		"lowast": "",
		"lowbar": "_",
		"LowerLeftArrow": "",
		"LowerRightArrow": "",
		"loz": "",
		"lozenge": "",
		"lozf": "",
		"lpar": "(",
		"lparlt": "",
		"lrarr": "",
		"lrcorner": "",
		"lrhar": "",
		"lrhard": "",
		"lrm": "",
		"lrtri": "",
		"lsaquo": "",
		"lscr": "",
		"Lscr": "",
		"lsh": "",
		"Lsh": "",
		"lsim": "",
		"lsime": "",
		"lsimg": "",
		"lsqb": "[",
		"lsquo": "",
		"lsquor": "",
		"Lstrok": "",
		"lstrok": "",
		"ltcc": "",
		"ltcir": "",
		"lt": "<",
		"LT": "<",
		"Lt": "",
		"ltdot": "",
		"lthree": "",
		"ltimes": "",
		"ltlarr": "",
		"ltquest": "",
		"ltri": "",
		"ltrie": "",
		"ltrif": "",
		"ltrPar": "",
		"lurdshar": "",
		"luruhar": "",
		"lvertneqq": "",
		"lvnE": "",
		"macr": "",
		"male": "",
		"malt": "",
		"maltese": "",
		"Map": "",
		"map": "",
		"mapsto": "",
		"mapstodown": "",
		"mapstoleft": "",
		"mapstoup": "",
		"marker": "",
		"mcomma": "",
		"Mcy": "",
		"mcy": "",
		"mdash": "",
		"mDDot": "",
		"measuredangle": "",
		"MediumSpace": "",
		"Mellintrf": "",
		"Mfr": "",
		"mfr": "",
		"mho": "",
		"micro": "",
		"midast": "*",
		"midcir": "",
		"mid": "",
		"middot": "",
		"minusb": "",
		"minus": "",
		"minusd": "",
		"minusdu": "",
		"MinusPlus": "",
		"mlcp": "",
		"mldr": "",
		"mnplus": "",
		"models": "",
		"Mopf": "",
		"mopf": "",
		"mp": "",
		"mscr": "",
		"Mscr": "",
		"mstpos": "",
		"Mu": "",
		"mu": "",
		"multimap": "",
		"mumap": "",
		"nabla": "",
		"Nacute": "",
		"nacute": "",
		"nang": "",
		"nap": "",
		"napE": "",
		"napid": "",
		"napos": "",
		"napprox": "",
		"natural": "",
		"naturals": "",
		"natur": "",
		"nbsp": "",
		"nbump": "",
		"nbumpe": "",
		"ncap": "",
		"Ncaron": "",
		"ncaron": "",
		"Ncedil": "",
		"ncedil": "",
		"ncong": "",
		"ncongdot": "",
		"ncup": "",
		"Ncy": "",
		"ncy": "",
		"ndash": "",
		"nearhk": "",
		"nearr": "",
		"neArr": "",
		"nearrow": "",
		"ne": "",
		"nedot": "",
		"NegativeMediumSpace": "",
		"NegativeThickSpace": "",
		"NegativeThinSpace": "",
		"NegativeVeryThinSpace": "",
		"nequiv": "",
		"nesear": "",
		"nesim": "",
		"NestedGreaterGreater": "",
		"NestedLessLess": "",
		"NewLine": "\n",
		"nexist": "",
		"nexists": "",
		"Nfr": "",
		"nfr": "",
		"ngE": "",
		"nge": "",
		"ngeq": "",
		"ngeqq": "",
		"ngeqslant": "",
		"nges": "",
		"nGg": "",
		"ngsim": "",
		"nGt": "",
		"ngt": "",
		"ngtr": "",
		"nGtv": "",
		"nharr": "",
		"nhArr": "",
		"nhpar": "",
		"ni": "",
		"nis": "",
		"nisd": "",
		"niv": "",
		"NJcy": "",
		"njcy": "",
		"nlarr": "",
		"nlArr": "",
		"nldr": "",
		"nlE": "",
		"nle": "",
		"nleftarrow": "",
		"nLeftarrow": "",
		"nleftrightarrow": "",
		"nLeftrightarrow": "",
		"nleq": "",
		"nleqq": "",
		"nleqslant": "",
		"nles": "",
		"nless": "",
		"nLl": "",
		"nlsim": "",
		"nLt": "",
		"nlt": "",
		"nltri": "",
		"nltrie": "",
		"nLtv": "",
		"nmid": "",
		"NoBreak": "",
		"NonBreakingSpace": "",
		"nopf": "",
		"Nopf": "",
		"Not": "",
		"not": "",
		"NotCongruent": "",
		"NotCupCap": "",
		"NotDoubleVerticalBar": "",
		"NotElement": "",
		"NotEqual": "",
		"NotEqualTilde": "",
		"NotExists": "",
		"NotGreater": "",
		"NotGreaterEqual": "",
		"NotGreaterFullEqual": "",
		"NotGreaterGreater": "",
		"NotGreaterLess": "",
		"NotGreaterSlantEqual": "",
		"NotGreaterTilde": "",
		"NotHumpDownHump": "",
		"NotHumpEqual": "",
		"notin": "",
		"notindot": "",
		"notinE": "",
		"notinva": "",
		"notinvb": "",
		"notinvc": "",
		"NotLeftTriangleBar": "",
		"NotLeftTriangle": "",
		"NotLeftTriangleEqual": "",
		"NotLess": "",
		"NotLessEqual": "",
		"NotLessGreater": "",
		"NotLessLess": "",
		"NotLessSlantEqual": "",
		"NotLessTilde": "",
		"NotNestedGreaterGreater": "",
		"NotNestedLessLess": "",
		"notni": "",
		"notniva": "",
		"notnivb": "",
		"notnivc": "",
		"NotPrecedes": "",
		"NotPrecedesEqual": "",
		"NotPrecedesSlantEqual": "",
		"NotReverseElement": "",
		"NotRightTriangleBar": "",
		"NotRightTriangle": "",
		"NotRightTriangleEqual": "",
		"NotSquareSubset": "",
		"NotSquareSubsetEqual": "",
		"NotSquareSuperset": "",
		"NotSquareSupersetEqual": "",
		"NotSubset": "",
		"NotSubsetEqual": "",
		"NotSucceeds": "",
		"NotSucceedsEqual": "",
		"NotSucceedsSlantEqual": "",
		"NotSucceedsTilde": "",
		"NotSuperset": "",
		"NotSupersetEqual": "",
		"NotTilde": "",
		"NotTildeEqual": "",
		"NotTildeFullEqual": "",
		"NotTildeTilde": "",
		"NotVerticalBar": "",
		"nparallel": "",
		"npar": "",
		"nparsl": "",
		"npart": "",
		"npolint": "",
		"npr": "",
		"nprcue": "",
		"nprec": "",
		"npreceq": "",
		"npre": "",
		"nrarrc": "",
		"nrarr": "",
		"nrArr": "",
		"nrarrw": "",
		"nrightarrow": "",
		"nRightarrow": "",
		"nrtri": "",
		"nrtrie": "",
		"nsc": "",
		"nsccue": "",
		"nsce": "",
		"Nscr": "",
		"nscr": "",
		"nshortmid": "",
		"nshortparallel": "",
		"nsim": "",
		"nsime": "",
		"nsimeq": "",
		"nsmid": "",
		"nspar": "",
		"nsqsube": "",
		"nsqsupe": "",
		"nsub": "",
		"nsubE": "",
		"nsube": "",
		"nsubset": "",
		"nsubseteq": "",
		"nsubseteqq": "",
		"nsucc": "",
		"nsucceq": "",
		"nsup": "",
		"nsupE": "",
		"nsupe": "",
		"nsupset": "",
		"nsupseteq": "",
		"nsupseteqq": "",
		"ntgl": "",
		"Ntilde": "",
		"ntilde": "",
		"ntlg": "",
		"ntriangleleft": "",
		"ntrianglelefteq": "",
		"ntriangleright": "",
		"ntrianglerighteq": "",
		"Nu": "",
		"nu": "",
		"num": "#",
		"numero": "",
		"numsp": "",
		"nvap": "",
		"nvdash": "",
		"nvDash": "",
		"nVdash": "",
		"nVDash": "",
		"nvge": "",
		"nvgt": ">",
		"nvHarr": "",
		"nvinfin": "",
		"nvlArr": "",
		"nvle": "",
		"nvlt": "<",
		"nvltrie": "",
		"nvrArr": "",
		"nvrtrie": "",
		"nvsim": "",
		"nwarhk": "",
		"nwarr": "",
		"nwArr": "",
		"nwarrow": "",
		"nwnear": "",
		"Oacute": "",
		"oacute": "",
		"oast": "",
		"Ocirc": "",
		"ocirc": "",
		"ocir": "",
		"Ocy": "",
		"ocy": "",
		"odash": "",
		"Odblac": "",
		"odblac": "",
		"odiv": "",
		"odot": "",
		"odsold": "",
		"OElig": "",
		"oelig": "",
		"ofcir": "",
		"Ofr": "",
		"ofr": "",
		"ogon": "",
		"Ograve": "",
		"ograve": "",
		"ogt": "",
		"ohbar": "",
		"ohm": "",
		"oint": "",
		"olarr": "",
		"olcir": "",
		"olcross": "",
		"oline": "",
		"olt": "",
		"Omacr": "",
		"omacr": "",
		"Omega": "",
		"omega": "",
		"Omicron": "",
		"omicron": "",
		"omid": "",
		"ominus": "",
		"Oopf": "",
		"oopf": "",
		"opar": "",
		"OpenCurlyDoubleQuote": "",
		"OpenCurlyQuote": "",
		"operp": "",
		"oplus": "",
		"orarr": "",
		"Or": "",
		"or": "",
		"ord": "",
		"order": "",
		"orderof": "",
		"ordf": "",
		"ordm": "",
		"origof": "",
		"oror": "",
		"orslope": "",
		"orv": "",
		"oS": "",
		"Oscr": "",
		"oscr": "",
		"Oslash": "",
		"oslash": "",
		"osol": "",
		"Otilde": "",
		"otilde": "",
		"otimesas": "",
		"Otimes": "",
		"otimes": "",
		"Ouml": "",
		"ouml": "",
		"ovbar": "",
		"OverBar": "",
		"OverBrace": "",
		"OverBracket": "",
		"OverParenthesis": "",
		"para": "",
		"parallel": "",
		"par": "",
		"parsim": "",
		"parsl": "",
		"part": "",
		"PartialD": "",
		"Pcy": "",
		"pcy": "",
		"percnt": "%",
		"period": ".",
		"permil": "",
		"perp": "",
		"pertenk": "",
		"Pfr": "",
		"pfr": "",
		"Phi": "",
		"phi": "",
		"phiv": "",
		"phmmat": "",
		"phone": "",
		"Pi": "",
		"pi": "",
		"pitchfork": "",
		"piv": "",
		"planck": "",
		"planckh": "",
		"plankv": "",
		"plusacir": "",
		"plusb": "",
		"pluscir": "",
		"plus": "+",
		"plusdo": "",
		"plusdu": "",
		"pluse": "",
		"PlusMinus": "",
		"plusmn": "",
		"plussim": "",
		"plustwo": "",
		"pm": "",
		"Poincareplane": "",
		"pointint": "",
		"popf": "",
		"Popf": "",
		"pound": "",
		"prap": "",
		"Pr": "",
		"pr": "",
		"prcue": "",
		"precapprox": "",
		"prec": "",
		"preccurlyeq": "",
		"Precedes": "",
		"PrecedesEqual": "",
		"PrecedesSlantEqual": "",
		"PrecedesTilde": "",
		"preceq": "",
		"precnapprox": "",
		"precneqq": "",
		"precnsim": "",
		"pre": "",
		"prE": "",
		"precsim": "",
		"prime": "",
		"Prime": "",
		"primes": "",
		"prnap": "",
		"prnE": "",
		"prnsim": "",
		"prod": "",
		"Product": "",
		"profalar": "",
		"profline": "",
		"profsurf": "",
		"prop": "",
		"Proportional": "",
		"Proportion": "",
		"propto": "",
		"prsim": "",
		"prurel": "",
		"Pscr": "",
		"pscr": "",
		"Psi": "",
		"psi": "",
		"puncsp": "",
		"Qfr": "",
		"qfr": "",
		"qint": "",
		"qopf": "",
		"Qopf": "",
		"qprime": "",
		"Qscr": "",
		"qscr": "",
		"quaternions": "",
		"quatint": "",
		"quest": "?",
		"questeq": "",
		"quot": "\"",
		"QUOT": "\"",
		"rAarr": "",
		"race": "",
		"Racute": "",
		"racute": "",
		"radic": "",
		"raemptyv": "",
		"rang": "",
		"Rang": "",
		"rangd": "",
		"range": "",
		"rangle": "",
		"raquo": "",
		"rarrap": "",
		"rarrb": "",
		"rarrbfs": "",
		"rarrc": "",
		"rarr": "",
		"Rarr": "",
		"rArr": "",
		"rarrfs": "",
		"rarrhk": "",
		"rarrlp": "",
		"rarrpl": "",
		"rarrsim": "",
		"Rarrtl": "",
		"rarrtl": "",
		"rarrw": "",
		"ratail": "",
		"rAtail": "",
		"ratio": "",
		"rationals": "",
		"rbarr": "",
		"rBarr": "",
		"RBarr": "",
		"rbbrk": "",
		"rbrace": "}",
		"rbrack": "]",
		"rbrke": "",
		"rbrksld": "",
		"rbrkslu": "",
		"Rcaron": "",
		"rcaron": "",
		"Rcedil": "",
		"rcedil": "",
		"rceil": "",
		"rcub": "}",
		"Rcy": "",
		"rcy": "",
		"rdca": "",
		"rdldhar": "",
		"rdquo": "",
		"rdquor": "",
		"rdsh": "",
		"real": "",
		"realine": "",
		"realpart": "",
		"reals": "",
		"Re": "",
		"rect": "",
		"reg": "",
		"REG": "",
		"ReverseElement": "",
		"ReverseEquilibrium": "",
		"ReverseUpEquilibrium": "",
		"rfisht": "",
		"rfloor": "",
		"rfr": "",
		"Rfr": "",
		"rHar": "",
		"rhard": "",
		"rharu": "",
		"rharul": "",
		"Rho": "",
		"rho": "",
		"rhov": "",
		"RightAngleBracket": "",
		"RightArrowBar": "",
		"rightarrow": "",
		"RightArrow": "",
		"Rightarrow": "",
		"RightArrowLeftArrow": "",
		"rightarrowtail": "",
		"RightCeiling": "",
		"RightDoubleBracket": "",
		"RightDownTeeVector": "",
		"RightDownVectorBar": "",
		"RightDownVector": "",
		"RightFloor": "",
		"rightharpoondown": "",
		"rightharpoonup": "",
		"rightleftarrows": "",
		"rightleftharpoons": "",
		"rightrightarrows": "",
		"rightsquigarrow": "",
		"RightTeeArrow": "",
		"RightTee": "",
		"RightTeeVector": "",
		"rightthreetimes": "",
		"RightTriangleBar": "",
		"RightTriangle": "",
		"RightTriangleEqual": "",
		"RightUpDownVector": "",
		"RightUpTeeVector": "",
		"RightUpVectorBar": "",
		"RightUpVector": "",
		"RightVectorBar": "",
		"RightVector": "",
		"ring": "",
		"risingdotseq": "",
		"rlarr": "",
		"rlhar": "",
		"rlm": "",
		"rmoustache": "",
		"rmoust": "",
		"rnmid": "",
		"roang": "",
		"roarr": "",
		"robrk": "",
		"ropar": "",
		"ropf": "",
		"Ropf": "",
		"roplus": "",
		"rotimes": "",
		"RoundImplies": "",
		"rpar": ")",
		"rpargt": "",
		"rppolint": "",
		"rrarr": "",
		"Rrightarrow": "",
		"rsaquo": "",
		"rscr": "",
		"Rscr": "",
		"rsh": "",
		"Rsh": "",
		"rsqb": "]",
		"rsquo": "",
		"rsquor": "",
		"rthree": "",
		"rtimes": "",
		"rtri": "",
		"rtrie": "",
		"rtrif": "",
		"rtriltri": "",
		"RuleDelayed": "",
		"ruluhar": "",
		"rx": "",
		"Sacute": "",
		"sacute": "",
		"sbquo": "",
		"scap": "",
		"Scaron": "",
		"scaron": "",
		"Sc": "",
		"sc": "",
		"sccue": "",
		"sce": "",
		"scE": "",
		"Scedil": "",
		"scedil": "",
		"Scirc": "",
		"scirc": "",
		"scnap": "",
		"scnE": "",
		"scnsim": "",
		"scpolint": "",
		"scsim": "",
		"Scy": "",
		"scy": "",
		"sdotb": "",
		"sdot": "",
		"sdote": "",
		"searhk": "",
		"searr": "",
		"seArr": "",
		"searrow": "",
		"sect": "",
		"semi": ";",
		"seswar": "",
		"setminus": "",
		"setmn": "",
		"sext": "",
		"Sfr": "",
		"sfr": "",
		"sfrown": "",
		"sharp": "",
		"SHCHcy": "",
		"shchcy": "",
		"SHcy": "",
		"shcy": "",
		"ShortDownArrow": "",
		"ShortLeftArrow": "",
		"shortmid": "",
		"shortparallel": "",
		"ShortRightArrow": "",
		"ShortUpArrow": "",
		"shy": "",
		"Sigma": "",
		"sigma": "",
		"sigmaf": "",
		"sigmav": "",
		"sim": "",
		"simdot": "",
		"sime": "",
		"simeq": "",
		"simg": "",
		"simgE": "",
		"siml": "",
		"simlE": "",
		"simne": "",
		"simplus": "",
		"simrarr": "",
		"slarr": "",
		"SmallCircle": "",
		"smallsetminus": "",
		"smashp": "",
		"smeparsl": "",
		"smid": "",
		"smile": "",
		"smt": "",
		"smte": "",
		"smtes": "",
		"SOFTcy": "",
		"softcy": "",
		"solbar": "",
		"solb": "",
		"sol": "/",
		"Sopf": "",
		"sopf": "",
		"spades": "",
		"spadesuit": "",
		"spar": "",
		"sqcap": "",
		"sqcaps": "",
		"sqcup": "",
		"sqcups": "",
		"Sqrt": "",
		"sqsub": "",
		"sqsube": "",
		"sqsubset": "",
		"sqsubseteq": "",
		"sqsup": "",
		"sqsupe": "",
		"sqsupset": "",
		"sqsupseteq": "",
		"square": "",
		"Square": "",
		"SquareIntersection": "",
		"SquareSubset": "",
		"SquareSubsetEqual": "",
		"SquareSuperset": "",
		"SquareSupersetEqual": "",
		"SquareUnion": "",
		"squarf": "",
		"squ": "",
		"squf": "",
		"srarr": "",
		"Sscr": "",
		"sscr": "",
		"ssetmn": "",
		"ssmile": "",
		"sstarf": "",
		"Star": "",
		"star": "",
		"starf": "",
		"straightepsilon": "",
		"straightphi": "",
		"strns": "",
		"sub": "",
		"Sub": "",
		"subdot": "",
		"subE": "",
		"sube": "",
		"subedot": "",
		"submult": "",
		"subnE": "",
		"subne": "",
		"subplus": "",
		"subrarr": "",
		"subset": "",
		"Subset": "",
		"subseteq": "",
		"subseteqq": "",
		"SubsetEqual": "",
		"subsetneq": "",
		"subsetneqq": "",
		"subsim": "",
		"subsub": "",
		"subsup": "",
		"succapprox": "",
		"succ": "",
		"succcurlyeq": "",
		"Succeeds": "",
		"SucceedsEqual": "",
		"SucceedsSlantEqual": "",
		"SucceedsTilde": "",
		"succeq": "",
		"succnapprox": "",
		"succneqq": "",
		"succnsim": "",
		"succsim": "",
		"SuchThat": "",
		"sum": "",
		"Sum": "",
		"sung": "",
		"sup1": "",
		"sup2": "",
		"sup3": "",
		"sup": "",
		"Sup": "",
		"supdot": "",
		"supdsub": "",
		"supE": "",
		"supe": "",
		"supedot": "",
		"Superset": "",
		"SupersetEqual": "",
		"suphsol": "",
		"suphsub": "",
		"suplarr": "",
		"supmult": "",
		"supnE": "",
		"supne": "",
		"supplus": "",
		"supset": "",
		"Supset": "",
		"supseteq": "",
		"supseteqq": "",
		"supsetneq": "",
		"supsetneqq": "",
		"supsim": "",
		"supsub": "",
		"supsup": "",
		"swarhk": "",
		"swarr": "",
		"swArr": "",
		"swarrow": "",
		"swnwar": "",
		"szlig": "",
		"Tab": "\t",
		"target": "",
		"Tau": "",
		"tau": "",
		"tbrk": "",
		"Tcaron": "",
		"tcaron": "",
		"Tcedil": "",
		"tcedil": "",
		"Tcy": "",
		"tcy": "",
		"tdot": "",
		"telrec": "",
		"Tfr": "",
		"tfr": "",
		"there4": "",
		"therefore": "",
		"Therefore": "",
		"Theta": "",
		"theta": "",
		"thetasym": "",
		"thetav": "",
		"thickapprox": "",
		"thicksim": "",
		"ThickSpace": "",
		"ThinSpace": "",
		"thinsp": "",
		"thkap": "",
		"thksim": "",
		"THORN": "",
		"thorn": "",
		"tilde": "",
		"Tilde": "",
		"TildeEqual": "",
		"TildeFullEqual": "",
		"TildeTilde": "",
		"timesbar": "",
		"timesb": "",
		"times": "",
		"timesd": "",
		"tint": "",
		"toea": "",
		"topbot": "",
		"topcir": "",
		"top": "",
		"Topf": "",
		"topf": "",
		"topfork": "",
		"tosa": "",
		"tprime": "",
		"trade": "",
		"TRADE": "",
		"triangle": "",
		"triangledown": "",
		"triangleleft": "",
		"trianglelefteq": "",
		"triangleq": "",
		"triangleright": "",
		"trianglerighteq": "",
		"tridot": "",
		"trie": "",
		"triminus": "",
		"TripleDot": "",
		"triplus": "",
		"trisb": "",
		"tritime": "",
		"trpezium": "",
		"Tscr": "",
		"tscr": "",
		"TScy": "",
		"tscy": "",
		"TSHcy": "",
		"tshcy": "",
		"Tstrok": "",
		"tstrok": "",
		"twixt": "",
		"twoheadleftarrow": "",
		"twoheadrightarrow": "",
		"Uacute": "",
		"uacute": "",
		"uarr": "",
		"Uarr": "",
		"uArr": "",
		"Uarrocir": "",
		"Ubrcy": "",
		"ubrcy": "",
		"Ubreve": "",
		"ubreve": "",
		"Ucirc": "",
		"ucirc": "",
		"Ucy": "",
		"ucy": "",
		"udarr": "",
		"Udblac": "",
		"udblac": "",
		"udhar": "",
		"ufisht": "",
		"Ufr": "",
		"ufr": "",
		"Ugrave": "",
		"ugrave": "",
		"uHar": "",
		"uharl": "",
		"uharr": "",
		"uhblk": "",
		"ulcorn": "",
		"ulcorner": "",
		"ulcrop": "",
		"ultri": "",
		"Umacr": "",
		"umacr": "",
		"uml": "",
		"UnderBar": "_",
		"UnderBrace": "",
		"UnderBracket": "",
		"UnderParenthesis": "",
		"Union": "",
		"UnionPlus": "",
		"Uogon": "",
		"uogon": "",
		"Uopf": "",
		"uopf": "",
		"UpArrowBar": "",
		"uparrow": "",
		"UpArrow": "",
		"Uparrow": "",
		"UpArrowDownArrow": "",
		"updownarrow": "",
		"UpDownArrow": "",
		"Updownarrow": "",
		"UpEquilibrium": "",
		"upharpoonleft": "",
		"upharpoonright": "",
		"uplus": "",
		"UpperLeftArrow": "",
		"UpperRightArrow": "",
		"upsi": "",
		"Upsi": "",
		"upsih": "",
		"Upsilon": "",
		"upsilon": "",
		"UpTeeArrow": "",
		"UpTee": "",
		"upuparrows": "",
		"urcorn": "",
		"urcorner": "",
		"urcrop": "",
		"Uring": "",
		"uring": "",
		"urtri": "",
		"Uscr": "",
		"uscr": "",
		"utdot": "",
		"Utilde": "",
		"utilde": "",
		"utri": "",
		"utrif": "",
		"uuarr": "",
		"Uuml": "",
		"uuml": "",
		"uwangle": "",
		"vangrt": "",
		"varepsilon": "",
		"varkappa": "",
		"varnothing": "",
		"varphi": "",
		"varpi": "",
		"varpropto": "",
		"varr": "",
		"vArr": "",
		"varrho": "",
		"varsigma": "",
		"varsubsetneq": "",
		"varsubsetneqq": "",
		"varsupsetneq": "",
		"varsupsetneqq": "",
		"vartheta": "",
		"vartriangleleft": "",
		"vartriangleright": "",
		"vBar": "",
		"Vbar": "",
		"vBarv": "",
		"Vcy": "",
		"vcy": "",
		"vdash": "",
		"vDash": "",
		"Vdash": "",
		"VDash": "",
		"Vdashl": "",
		"veebar": "",
		"vee": "",
		"Vee": "",
		"veeeq": "",
		"vellip": "",
		"verbar": "|",
		"Verbar": "",
		"vert": "|",
		"Vert": "",
		"VerticalBar": "",
		"VerticalLine": "|",
		"VerticalSeparator": "",
		"VerticalTilde": "",
		"VeryThinSpace": "",
		"Vfr": "",
		"vfr": "",
		"vltri": "",
		"vnsub": "",
		"vnsup": "",
		"Vopf": "",
		"vopf": "",
		"vprop": "",
		"vrtri": "",
		"Vscr": "",
		"vscr": "",
		"vsubnE": "",
		"vsubne": "",
		"vsupnE": "",
		"vsupne": "",
		"Vvdash": "",
		"vzigzag": "",
		"Wcirc": "",
		"wcirc": "",
		"wedbar": "",
		"wedge": "",
		"Wedge": "",
		"wedgeq": "",
		"weierp": "",
		"Wfr": "",
		"wfr": "",
		"Wopf": "",
		"wopf": "",
		"wp": "",
		"wr": "",
		"wreath": "",
		"Wscr": "",
		"wscr": "",
		"xcap": "",
		"xcirc": "",
		"xcup": "",
		"xdtri": "",
		"Xfr": "",
		"xfr": "",
		"xharr": "",
		"xhArr": "",
		"Xi": "",
		"xi": "",
		"xlarr": "",
		"xlArr": "",
		"xmap": "",
		"xnis": "",
		"xodot": "",
		"Xopf": "",
		"xopf": "",
		"xoplus": "",
		"xotime": "",
		"xrarr": "",
		"xrArr": "",
		"Xscr": "",
		"xscr": "",
		"xsqcup": "",
		"xuplus": "",
		"xutri": "",
		"xvee": "",
		"xwedge": "",
		"Yacute": "",
		"yacute": "",
		"YAcy": "",
		"yacy": "",
		"Ycirc": "",
		"ycirc": "",
		"Ycy": "",
		"ycy": "",
		"yen": "",
		"Yfr": "",
		"yfr": "",
		"YIcy": "",
		"yicy": "",
		"Yopf": "",
		"yopf": "",
		"Yscr": "",
		"yscr": "",
		"YUcy": "",
		"yucy": "",
		"yuml": "",
		"Yuml": "",
		"Zacute": "",
		"zacute": "",
		"Zcaron": "",
		"zcaron": "",
		"Zcy": "",
		"zcy": "",
		"Zdot": "",
		"zdot": "",
		"zeetrf": "",
		"ZeroWidthSpace": "",
		"Zeta": "",
		"zeta": "",
		"zfr": "",
		"Zfr": "",
		"ZHcy": "",
		"zhcy": "",
		"zigrarr": "",
		"zopf": "",
		"Zopf": "",
		"Zscr": "",
		"zscr": "",
		"zwj": "",
		"zwnj": ""
	};

/***/ },
/* 449 */
/*!**********************************!*\
  !*** ./~/entities/lib/decode.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	var entityMap = __webpack_require__(/*! ../maps/entities.json */ 448),
	    legacyMap = __webpack_require__(/*! ../maps/legacy.json */ 450),
	    xmlMap    = __webpack_require__(/*! ../maps/xml.json */ 447),
	    decodeCodePoint = __webpack_require__(/*! ./decode_codepoint.js */ 451);
	
	var decodeXMLStrict  = getStrictDecoder(xmlMap),
	    decodeHTMLStrict = getStrictDecoder(entityMap);
	
	function getStrictDecoder(map){
		var keys = Object.keys(map).join("|"),
		    replace = getReplacer(map);
	
		keys += "|#[xX][\\da-fA-F]+|#\\d+";
	
		var re = new RegExp("&(?:" + keys + ");", "g");
	
		return function(str){
			return String(str).replace(re, replace);
		};
	}
	
	var decodeHTML = (function(){
		var legacy = Object.keys(legacyMap)
			.sort(sorter);
	
		var keys = Object.keys(entityMap)
			.sort(sorter);
	
		for(var i = 0, j = 0; i < keys.length; i++){
			if(legacy[j] === keys[i]){
				keys[i] += ";?";
				j++;
			} else {
				keys[i] += ";";
			}
		}
	
		var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
		    replace = getReplacer(entityMap);
	
		function replacer(str){
			if(str.substr(-1) !== ";") str += ";";
			return replace(str);
		}
	
		//TODO consider creating a merged map
		return function(str){
			return String(str).replace(re, replacer);
		};
	}());
	
	function sorter(a, b){
		return a < b ? 1 : -1;
	}
	
	function getReplacer(map){
		return function replace(str){
			if(str.charAt(1) === "#"){
				if(str.charAt(2) === "X" || str.charAt(2) === "x"){
					return decodeCodePoint(parseInt(str.substr(3), 16));
				}
				return decodeCodePoint(parseInt(str.substr(2), 10));
			}
			return map[str.slice(1, -1)];
		};
	}
	
	module.exports = {
		XML: decodeXMLStrict,
		HTML: decodeHTML,
		HTMLStrict: decodeHTMLStrict
	};

/***/ },
/* 450 */
/*!*************************************!*\
  !*** ./~/entities/maps/legacy.json ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = {
		"Aacute": "",
		"aacute": "",
		"Acirc": "",
		"acirc": "",
		"acute": "",
		"AElig": "",
		"aelig": "",
		"Agrave": "",
		"agrave": "",
		"amp": "&",
		"AMP": "&",
		"Aring": "",
		"aring": "",
		"Atilde": "",
		"atilde": "",
		"Auml": "",
		"auml": "",
		"brvbar": "",
		"Ccedil": "",
		"ccedil": "",
		"cedil": "",
		"cent": "",
		"copy": "",
		"COPY": "",
		"curren": "",
		"deg": "",
		"divide": "",
		"Eacute": "",
		"eacute": "",
		"Ecirc": "",
		"ecirc": "",
		"Egrave": "",
		"egrave": "",
		"ETH": "",
		"eth": "",
		"Euml": "",
		"euml": "",
		"frac12": "",
		"frac14": "",
		"frac34": "",
		"gt": ">",
		"GT": ">",
		"Iacute": "",
		"iacute": "",
		"Icirc": "",
		"icirc": "",
		"iexcl": "",
		"Igrave": "",
		"igrave": "",
		"iquest": "",
		"Iuml": "",
		"iuml": "",
		"laquo": "",
		"lt": "<",
		"LT": "<",
		"macr": "",
		"micro": "",
		"middot": "",
		"nbsp": "",
		"not": "",
		"Ntilde": "",
		"ntilde": "",
		"Oacute": "",
		"oacute": "",
		"Ocirc": "",
		"ocirc": "",
		"Ograve": "",
		"ograve": "",
		"ordf": "",
		"ordm": "",
		"Oslash": "",
		"oslash": "",
		"Otilde": "",
		"otilde": "",
		"Ouml": "",
		"ouml": "",
		"para": "",
		"plusmn": "",
		"pound": "",
		"quot": "\"",
		"QUOT": "\"",
		"raquo": "",
		"reg": "",
		"REG": "",
		"sect": "",
		"shy": "",
		"sup1": "",
		"sup2": "",
		"sup3": "",
		"szlig": "",
		"THORN": "",
		"thorn": "",
		"times": "",
		"Uacute": "",
		"uacute": "",
		"Ucirc": "",
		"ucirc": "",
		"Ugrave": "",
		"ugrave": "",
		"uml": "",
		"Uuml": "",
		"uuml": "",
		"Yacute": "",
		"yacute": "",
		"yen": "",
		"yuml": ""
	};

/***/ },
/* 451 */
/*!********************************************!*\
  !*** ./~/entities/lib/decode_codepoint.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	var decodeMap = __webpack_require__(/*! ../maps/decode.json */ 452);
	
	module.exports = decodeCodePoint;
	
	// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
	function decodeCodePoint(codePoint){
	
		if((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF){
			return "\uFFFD";
		}
	
		if(codePoint in decodeMap){
			codePoint = decodeMap[codePoint];
		}
	
		var output = "";
	
		if(codePoint > 0xFFFF){
			codePoint -= 0x10000;
			output += String.fromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
	
		output += String.fromCharCode(codePoint);
		return output;
	}


/***/ },
/* 452 */
/*!*************************************!*\
  !*** ./~/entities/maps/decode.json ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = {
		"0": 65533,
		"128": 8364,
		"130": 8218,
		"131": 402,
		"132": 8222,
		"133": 8230,
		"134": 8224,
		"135": 8225,
		"136": 710,
		"137": 8240,
		"138": 352,
		"139": 8249,
		"140": 338,
		"142": 381,
		"145": 8216,
		"146": 8217,
		"147": 8220,
		"148": 8221,
		"149": 8226,
		"150": 8211,
		"151": 8212,
		"152": 732,
		"153": 8482,
		"154": 353,
		"155": 8250,
		"156": 339,
		"158": 382,
		"159": 376
	};

/***/ },
/* 453 */
/*!*************************************!*\
  !*** ./~/commonmark/lib/inlines.js ***!
  \*************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Node = __webpack_require__(/*! ./node */ 440);
	var common = __webpack_require__(/*! ./common */ 442);
	var normalizeReference = __webpack_require__(/*! ./normalize-reference */ 454);
	
	var normalizeURI = common.normalizeURI;
	var unescapeString = common.unescapeString;
	var fromCodePoint = __webpack_require__(/*! ./from-code-point.js */ 455);
	var decodeHTML = __webpack_require__(/*! entities */ 445).decodeHTML;
	__webpack_require__(/*! string.prototype.repeat */ 456); // Polyfill for String.prototype.repeat
	
	// Constants for character codes:
	
	var C_NEWLINE = 10;
	var C_ASTERISK = 42;
	var C_UNDERSCORE = 95;
	var C_BACKTICK = 96;
	var C_OPEN_BRACKET = 91;
	var C_CLOSE_BRACKET = 93;
	var C_LESSTHAN = 60;
	var C_BANG = 33;
	var C_BACKSLASH = 92;
	var C_AMPERSAND = 38;
	var C_OPEN_PAREN = 40;
	var C_CLOSE_PAREN = 41;
	var C_COLON = 58;
	var C_SINGLEQUOTE = 39;
	var C_DOUBLEQUOTE = 34;
	
	// Some regexps used in inline parser:
	
	var ESCAPABLE = common.ESCAPABLE;
	var ESCAPED_CHAR = '\\\\' + ESCAPABLE;
	var REG_CHAR = '[^\\\\()\\x00-\\x20]';
	var IN_PARENS_NOSP = '\\((' + REG_CHAR + '|' + ESCAPED_CHAR + '|\\\\)*\\)';
	
	var ENTITY = common.ENTITY;
	var reHtmlTag = common.reHtmlTag;
	
	var rePunctuation = new RegExp(/^[\u2000-\u206F\u2E00-\u2E7F\\'!"#\$%&\(\)\*\+,\-\.\/:;<=>\?@\[\]\^_`\{\|\}~]/);
	
	var reLinkTitle = new RegExp(
	    '^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"' +
	        '|' +
	        '\'(' + ESCAPED_CHAR + '|[^\'\\x00])*\'' +
	        '|' +
	        '\\((' + ESCAPED_CHAR + '|[^)\\x00])*\\))');
	
	var reLinkDestinationBraces = new RegExp(
	    '^(?:[<](?:[^ <>\\t\\n\\\\\\x00]' + '|' + ESCAPED_CHAR + '|' + '\\\\)*[>])');
	
	var reLinkDestination = new RegExp(
	    '^(?:' + REG_CHAR + '+|' + ESCAPED_CHAR + '|\\\\|' + IN_PARENS_NOSP + ')*');
	
	var reEscapable = new RegExp('^' + ESCAPABLE);
	
	var reEntityHere = new RegExp('^' + ENTITY, 'i');
	
	var reTicks = /`+/;
	
	var reTicksHere = /^`+/;
	
	var reEllipses = /\.\.\./g;
	
	var reDash = /--+/g;
	
	var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
	
	var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;
	
	var reSpnl = /^ *(?:\n *)?/;
	
	var reWhitespaceChar = /^\s/;
	
	var reWhitespace = /\s+/g;
	
	var reFinalSpace = / *$/;
	
	var reInitialSpace = /^ */;
	
	var reSpaceAtEndOfLine = /^ *(?:\n|$)/;
	
	var reLinkLabel = new RegExp('^\\[(?:[^\\\\\\[\\]]|' + ESCAPED_CHAR +
	  '|\\\\){0,1000}\\]');
	
	// Matches a string of non-special characters.
	var reMain = /^[^\n`\[\]\\!<&*_'"]+/m;
	
	var text = function(s) {
	    var node = new Node('text');
	    node._literal = s;
	    return node;
	};
	
	// INLINE PARSER
	
	// These are methods of an InlineParser object, defined below.
	// An InlineParser keeps track of a subject (a string to be
	// parsed) and a position in that subject.
	
	// If re matches at current position in the subject, advance
	// position in subject and return the match; otherwise return null.
	var match = function(re) {
	    var m = re.exec(this.subject.slice(this.pos));
	    if (m === null) {
	        return null;
	    } else {
	        this.pos += m.index + m[0].length;
	        return m[0];
	    }
	};
	
	// Returns the code for the character at the current subject position, or -1
	// there are no more characters.
	var peek = function() {
	    if (this.pos < this.subject.length) {
	        return this.subject.charCodeAt(this.pos);
	    } else {
	        return -1;
	    }
	};
	
	// Parse zero or more space characters, including at most one newline
	var spnl = function() {
	    this.match(reSpnl);
	    return true;
	};
	
	// All of the parsers below try to match something at the current position
	// in the subject.  If they succeed in matching anything, they
	// return the inline matched, advancing the subject.
	
	// Attempt to parse backticks, adding either a backtick code span or a
	// literal sequence of backticks.
	var parseBackticks = function(block) {
	    var ticks = this.match(reTicksHere);
	    if (ticks === null) {
	        return false;
	    }
	    var afterOpenTicks = this.pos;
	    var matched;
	    var node;
	    while ((matched = this.match(reTicks)) !== null) {
	        if (matched === ticks) {
	            node = new Node('code');
	            node._literal = this.subject.slice(afterOpenTicks,
	                                        this.pos - ticks.length)
	                          .trim().replace(reWhitespace, ' ');
	            block.appendChild(node);
	            return true;
	        }
	    }
	    // If we got here, we didn't match a closing backtick sequence.
	    this.pos = afterOpenTicks;
	    block.appendChild(text(ticks));
	    return true;
	};
	
	// Parse a backslash-escaped special character, adding either the escaped
	// character, a hard line break (if the backslash is followed by a newline),
	// or a literal backslash to the block's children.  Assumes current character
	// is a backslash.
	var parseBackslash = function(block) {
	    var subj = this.subject;
	    var node;
	    this.pos += 1;
	    if (this.peek() === C_NEWLINE) {
	        this.pos += 1;
	        node = new Node('linebreak');
	        block.appendChild(node);
	    } else if (reEscapable.test(subj.charAt(this.pos))) {
	        block.appendChild(text(subj.charAt(this.pos)));
	        this.pos += 1;
	    } else {
	        block.appendChild(text('\\'));
	    }
	    return true;
	};
	
	// Attempt to parse an autolink (URL or email in pointy brackets).
	var parseAutolink = function(block) {
	    var m;
	    var dest;
	    var node;
	    if ((m = this.match(reEmailAutolink))) {
	        dest = m.slice(1, m.length - 1);
	        node = new Node('link');
	        node._destination = normalizeURI('mailto:' + dest);
	        node._title = '';
	        node.appendChild(text(dest));
	        block.appendChild(node);
	        return true;
	    } else if ((m = this.match(reAutolink))) {
	        dest = m.slice(1, m.length - 1);
	        node = new Node('link');
	        node._destination = normalizeURI(dest);
	        node._title = '';
	        node.appendChild(text(dest));
	        block.appendChild(node);
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Attempt to parse a raw HTML tag.
	var parseHtmlTag = function(block) {
	    var m = this.match(reHtmlTag);
	    if (m === null) {
	        return false;
	    } else {
	        var node = new Node('html_inline');
	        node._literal = m;
	        block.appendChild(node);
	        return true;
	    }
	};
	
	// Scan a sequence of characters with code cc, and return information about
	// the number of delimiters and whether they are positioned such that
	// they can open and/or close emphasis or strong emphasis.  A utility
	// function for strong/emph parsing.
	var scanDelims = function(cc) {
	    var numdelims = 0;
	    var char_before, char_after, cc_after;
	    var startpos = this.pos;
	    var left_flanking, right_flanking, can_open, can_close;
	    var after_is_whitespace, after_is_punctuation, before_is_whitespace, before_is_punctuation;
	
	    if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
	        numdelims++;
	        this.pos++;
	    } else {
	        while (this.peek() === cc) {
	            numdelims++;
	            this.pos++;
	        }
	    }
	
	    if (numdelims === 0) {
	        return null;
	    }
	
	    char_before = startpos === 0 ? '\n' : this.subject.charAt(startpos - 1);
	
	    cc_after = this.peek();
	    if (cc_after === -1) {
	        char_after = '\n';
	    } else {
	        char_after = fromCodePoint(cc_after);
	    }
	
	    after_is_whitespace = reWhitespaceChar.test(char_after);
	    after_is_punctuation = rePunctuation.test(char_after);
	    before_is_whitespace = reWhitespaceChar.test(char_before);
	    before_is_punctuation = rePunctuation.test(char_before);
	
	    left_flanking = !after_is_whitespace &&
	            !(after_is_punctuation && !before_is_whitespace && !before_is_punctuation);
	    right_flanking = !before_is_whitespace &&
	            !(before_is_punctuation && !after_is_whitespace && !after_is_punctuation);
	    if (cc === C_UNDERSCORE) {
	        can_open = left_flanking &&
	            (!right_flanking || before_is_punctuation);
	        can_close = right_flanking &&
	            (!left_flanking || after_is_punctuation);
	    } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
	        can_open = left_flanking && !right_flanking;
	        can_close = right_flanking;
	    } else {
	        can_open = left_flanking;
	        can_close = right_flanking;
	    }
	    this.pos = startpos;
	    return { numdelims: numdelims,
	             can_open: can_open,
	             can_close: can_close };
	};
	
	// Handle a delimiter marker for emphasis or a quote.
	var handleDelim = function(cc, block) {
	    var res = this.scanDelims(cc);
	    if (!res) {
	        return false;
	    }
	    var numdelims = res.numdelims;
	    var startpos = this.pos;
	    var contents;
	
	    this.pos += numdelims;
	    if (cc === C_SINGLEQUOTE) {
	        contents = "\u2019";
	    } else if (cc === C_DOUBLEQUOTE) {
	        contents = "\u201C";
	    } else {
	        contents = this.subject.slice(startpos, this.pos);
	    }
	    var node = text(contents);
	    block.appendChild(node);
	
	    // Add entry to stack for this opener
	    this.delimiters = { cc: cc,
	                        numdelims: numdelims,
	                        node: node,
	                        previous: this.delimiters,
	                        next: null,
	                        can_open: res.can_open,
	                        can_close: res.can_close };
	    if (this.delimiters.previous !== null) {
	        this.delimiters.previous.next = this.delimiters;
	    }
	
	    return true;
	
	};
	
	var removeDelimiter = function(delim) {
	    if (delim.previous !== null) {
	        delim.previous.next = delim.next;
	    }
	    if (delim.next === null) {
	        // top of stack
	        this.delimiters = delim.previous;
	    } else {
	        delim.next.previous = delim.previous;
	    }
	};
	
	var removeDelimitersBetween = function(bottom, top) {
	    if (bottom.next !== top) {
	        bottom.next = top;
	        top.previous = bottom;
	    }
	};
	
	var processEmphasis = function(stack_bottom) {
	    var opener, closer, old_closer;
	    var opener_inl, closer_inl;
	    var tempstack;
	    var use_delims;
	    var tmp, next;
	    var opener_found;
	    var openers_bottom = [];
	    var odd_match = false;
	
	    openers_bottom[C_UNDERSCORE] = stack_bottom;
	    openers_bottom[C_ASTERISK] = stack_bottom;
	    openers_bottom[C_SINGLEQUOTE] = stack_bottom;
	    openers_bottom[C_DOUBLEQUOTE] = stack_bottom;
	
	    // find first closer above stack_bottom:
	    closer = this.delimiters;
	    while (closer !== null && closer.previous !== stack_bottom) {
	        closer = closer.previous;
	    }
	    // move forward, looking for closers, and handling each
	    while (closer !== null) {
	        var closercc = closer.cc;
	        if (!closer.can_close) {
	            closer = closer.next;
	        } else {
	            // found emphasis closer. now look back for first matching opener:
	            opener = closer.previous;
	            opener_found = false;
	            while (opener !== null && opener !== stack_bottom &&
	                   opener !== openers_bottom[closercc]) {
	                odd_match = (closer.can_open || opener.can_close) &&
	                    (opener.numdelims + closer.numdelims) % 3 === 0;
	                if (opener.cc === closer.cc && opener.can_open && !odd_match) {
	                    opener_found = true;
	                    break;
	                }
	                opener = opener.previous;
	            }
	            old_closer = closer;
	
	            if (closercc === C_ASTERISK || closercc === C_UNDERSCORE) {
	                if (!opener_found) {
	                    closer = closer.next;
	                } else {
	                    // calculate actual number of delimiters used from closer
	                    if (closer.numdelims < 3 || opener.numdelims < 3) {
	                        use_delims = closer.numdelims <= opener.numdelims ?
	                            closer.numdelims : opener.numdelims;
	                    } else {
	                        use_delims = closer.numdelims % 2 === 0 ? 2 : 1;
	                    }
	
	                    opener_inl = opener.node;
	                    closer_inl = closer.node;
	
	                    // remove used delimiters from stack elts and inlines
	                    opener.numdelims -= use_delims;
	                    closer.numdelims -= use_delims;
	                    opener_inl._literal =
	                        opener_inl._literal.slice(0,
	                                                  opener_inl._literal.length - use_delims);
	                    closer_inl._literal =
	                        closer_inl._literal.slice(0,
	                                                  closer_inl._literal.length - use_delims);
	
	                    // build contents for new emph element
	                    var emph = new Node(use_delims === 1 ? 'emph' : 'strong');
	
	                    tmp = opener_inl._next;
	                    while (tmp && tmp !== closer_inl) {
	                        next = tmp._next;
	                        tmp.unlink();
	                        emph.appendChild(tmp);
	                        tmp = next;
	                    }
	
	                    opener_inl.insertAfter(emph);
	
	                    // remove elts between opener and closer in delimiters stack
	                    removeDelimitersBetween(opener, closer);
	
	                    // if opener has 0 delims, remove it and the inline
	                    if (opener.numdelims === 0) {
	                        opener_inl.unlink();
	                        this.removeDelimiter(opener);
	                    }
	
	                    if (closer.numdelims === 0) {
	                        closer_inl.unlink();
	                        tempstack = closer.next;
	                        this.removeDelimiter(closer);
	                        closer = tempstack;
	                    }
	
	                }
	
	            } else if (closercc === C_SINGLEQUOTE) {
	                closer.node._literal = "\u2019";
	                if (opener_found) {
	                    opener.node._literal = "\u2018";
	                }
	                closer = closer.next;
	
	            } else if (closercc === C_DOUBLEQUOTE) {
	                closer.node._literal = "\u201D";
	                if (opener_found) {
	                    opener.node.literal = "\u201C";
	                }
	                closer = closer.next;
	
	            }
	            if (!opener_found && !odd_match) {
	                // Set lower bound for future searches for openers:
	                // We don't do this with odd_match because a **
	                // that doesn't match an earlier * might turn into
	                // an opener, and the * might be matched by something
	                // else.
	                openers_bottom[closercc] = old_closer.previous;
	                if (!old_closer.can_open) {
	                    // We can remove a closer that can't be an opener,
	                    // once we've seen there's no matching opener:
	                    this.removeDelimiter(old_closer);
	                }
	            }
	        }
	
	    }
	
	    // remove all delimiters
	    while (this.delimiters !== null && this.delimiters !== stack_bottom) {
	        this.removeDelimiter(this.delimiters);
	    }
	};
	
	// Attempt to parse link title (sans quotes), returning the string
	// or null if no match.
	var parseLinkTitle = function() {
	    var title = this.match(reLinkTitle);
	    if (title === null) {
	        return null;
	    } else {
	        // chop off quotes from title and unescape:
	        return unescapeString(title.substr(1, title.length - 2));
	    }
	};
	
	// Attempt to parse link destination, returning the string or
	// null if no match.
	var parseLinkDestination = function() {
	    var res = this.match(reLinkDestinationBraces);
	    if (res === null) {
	        res = this.match(reLinkDestination);
	        if (res === null) {
	            return null;
	        } else {
	            return normalizeURI(unescapeString(res));
	        }
	    } else {  // chop off surrounding <..>:
	        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
	    }
	};
	
	// Attempt to parse a link label, returning number of characters parsed.
	var parseLinkLabel = function() {
	    var m = this.match(reLinkLabel);
	    if (m === null || m.length > 1001) {
	        return 0;
	    } else {
	        return m.length;
	    }
	};
	
	// Add open bracket to delimiter stack and add a text node to block's children.
	var parseOpenBracket = function(block) {
	    var startpos = this.pos;
	    this.pos += 1;
	
	    var node = text('[');
	    block.appendChild(node);
	
	    // Add entry to stack for this opener
	    this.addBracket(node, startpos, false);
	    return true;
	};
	
	// IF next character is [, and ! delimiter to delimiter stack and
	// add a text node to block's children.  Otherwise just add a text node.
	var parseBang = function(block) {
	    var startpos = this.pos;
	    this.pos += 1;
	    if (this.peek() === C_OPEN_BRACKET) {
	        this.pos += 1;
	
	        var node = text('![');
	        block.appendChild(node);
	
	        // Add entry to stack for this opener
	        this.addBracket(node, startpos + 1, true);
	    } else {
	        block.appendChild(text('!'));
	    }
	    return true;
	};
	
	// Try to match close bracket against an opening in the delimiter
	// stack.  Add either a link or image, or a plain [ character,
	// to block's children.  If there is a matching delimiter,
	// remove it from the delimiter stack.
	var parseCloseBracket = function(block) {
	    var startpos;
	    var is_image;
	    var dest;
	    var title;
	    var matched = false;
	    var reflabel;
	    var opener;
	
	    this.pos += 1;
	    startpos = this.pos;
	
	    // get last [ or ![
	    opener = this.brackets;
	
	    if (opener === null) {
	        // no matched opener, just return a literal
	        block.appendChild(text(']'));
	        return true;
	    }
	
	    if (!opener.active) {
	        // no matched opener, just return a literal
	        block.appendChild(text(']'));
	        // take opener off brackets stack
	        this.removeBracket();
	        return true;
	    }
	
	    // If we got here, open is a potential opener
	    is_image = opener.image;
	
	    // Check to see if we have a link/image
	
	    // Inline link?
	    if (this.peek() === C_OPEN_PAREN) {
	        this.pos++;
	        if (this.spnl() &&
	            ((dest = this.parseLinkDestination()) !== null) &&
	            this.spnl() &&
	            // make sure there's a space before the title:
	            (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
	             (title = this.parseLinkTitle()) || true) &&
	            this.spnl() &&
	            this.peek() === C_CLOSE_PAREN) {
	            this.pos += 1;
	            matched = true;
	        }
	    } else {
	
	        // Next, see if there's a link label
	        var savepos = this.pos;
	        var beforelabel = this.pos;
	        var n = this.parseLinkLabel();
	        if (n > 2) {
	            reflabel = this.subject.slice(beforelabel, beforelabel + n);
	        } else if (!opener.bracketAfter) {
	            // Empty or missing second label means to use the first label as the reference.
	            // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
	            reflabel = this.subject.slice(opener.index, startpos);
	        }
	        if (n === 0) {
	            // If shortcut reference link, rewind before spaces we skipped.
	            this.pos = savepos;
	        }
	
	        if (reflabel) {
	            // lookup rawlabel in refmap
	            var link = this.refmap[normalizeReference(reflabel)];
	            if (link) {
	                dest = link.destination;
	                title = link.title;
	                matched = true;
	            }
	        }
	    }
	
	    if (matched) {
	        var node = new Node(is_image ? 'image' : 'link');
	        node._destination = dest;
	        node._title = title || '';
	
	        var tmp, next;
	        tmp = opener.node._next;
	        while (tmp) {
	            next = tmp._next;
	            tmp.unlink();
	            node.appendChild(tmp);
	            tmp = next;
	        }
	        block.appendChild(node);
	        this.processEmphasis(opener.previousDelimiter);
	        this.removeBracket();
	        opener.node.unlink();
	
	        // We remove this bracket and processEmphasis will remove later delimiters.
	        // Now, for a link, we also deactivate earlier link openers.
	        // (no links in links)
	        if (!is_image) {
	          opener = this.brackets;
	          while (opener !== null) {
	            if (!opener.image) {
	                opener.active = false; // deactivate this opener
	            }
	            opener = opener.previous;
	          }
	        }
	
	        return true;
	
	    } else { // no match
	
	        this.removeBracket();  // remove this opener from stack
	        this.pos = startpos;
	        block.appendChild(text(']'));
	        return true;
	    }
	
	};
	
	var addBracket = function(node, index, image) {
	    if (this.brackets !== null) {
	        this.brackets.bracketAfter = true;
	    }
	    this.brackets = { node: node,
	                      previous: this.brackets,
	                      previousDelimiter: this.delimiters,
	                      index: index,
	                      image: image,
	                      active: true };
	};
	
	var removeBracket = function() {
	    this.brackets = this.brackets.previous;
	};
	
	// Attempt to parse an entity.
	var parseEntity = function(block) {
	    var m;
	    if ((m = this.match(reEntityHere))) {
	        block.appendChild(text(decodeHTML(m)));
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Parse a run of ordinary characters, or a single character with
	// a special meaning in markdown, as a plain string.
	var parseString = function(block) {
	    var m;
	    if ((m = this.match(reMain))) {
	        if (this.options.smart) {
	            block.appendChild(text(
	                m.replace(reEllipses, "\u2026")
	                    .replace(reDash, function(chars) {
	                        var enCount = 0;
	                        var emCount = 0;
	                        if (chars.length % 3 === 0) { // If divisible by 3, use all em dashes
	                            emCount = chars.length / 3;
	                        } else if (chars.length % 2 === 0) { // If divisible by 2, use all en dashes
	                            enCount = chars.length / 2;
	                        } else if (chars.length % 3 === 2) { // If 2 extra dashes, use en dash for last 2; em dashes for rest
	                            enCount = 1;
	                            emCount = (chars.length - 2) / 3;
	                        } else { // Use en dashes for last 4 hyphens; em dashes for rest
	                            enCount = 2;
	                            emCount = (chars.length - 4) / 3;
	                        }
	                        return "\u2014".repeat(emCount) + "\u2013".repeat(enCount);
	                    })));
	        } else {
	            block.appendChild(text(m));
	        }
	        return true;
	    } else {
	        return false;
	    }
	};
	
	// Parse a newline.  If it was preceded by two spaces, return a hard
	// line break; otherwise a soft line break.
	var parseNewline = function(block) {
	    this.pos += 1; // assume we're at a \n
	    // check previous node for trailing spaces
	    var lastc = block._lastChild;
	    if (lastc && lastc.type === 'text' && lastc._literal[lastc._literal.length - 1] === ' ') {
	        var hardbreak = lastc._literal[lastc._literal.length - 2] === ' ';
	        lastc._literal = lastc._literal.replace(reFinalSpace, '');
	        block.appendChild(new Node(hardbreak ? 'linebreak' : 'softbreak'));
	    } else {
	        block.appendChild(new Node('softbreak'));
	    }
	    this.match(reInitialSpace); // gobble leading spaces in next line
	    return true;
	};
	
	// Attempt to parse a link reference, modifying refmap.
	var parseReference = function(s, refmap) {
	    this.subject = s;
	    this.pos = 0;
	    var rawlabel;
	    var dest;
	    var title;
	    var matchChars;
	    var startpos = this.pos;
	
	    // label:
	    matchChars = this.parseLinkLabel();
	    if (matchChars === 0) {
	        return 0;
	    } else {
	        rawlabel = this.subject.substr(0, matchChars);
	    }
	
	    // colon:
	    if (this.peek() === C_COLON) {
	        this.pos++;
	    } else {
	        this.pos = startpos;
	        return 0;
	    }
	
	    //  link url
	    this.spnl();
	
	    dest = this.parseLinkDestination();
	    if (dest === null || dest.length === 0) {
	        this.pos = startpos;
	        return 0;
	    }
	
	    var beforetitle = this.pos;
	    this.spnl();
	    title = this.parseLinkTitle();
	    if (title === null) {
	        title = '';
	        // rewind before spaces
	        this.pos = beforetitle;
	    }
	
	    // make sure we're at line end:
	    var atLineEnd = true;
	    if (this.match(reSpaceAtEndOfLine) === null) {
	        if (title === '') {
	            atLineEnd = false;
	        } else {
	            // the potential title we found is not at the line end,
	            // but it could still be a legal link reference if we
	            // discard the title
	            title = '';
	            // rewind before spaces
	            this.pos = beforetitle;
	            // and instead check if the link URL is at the line end
	            atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
	        }
	    }
	
	    if (!atLineEnd) {
	        this.pos = startpos;
	        return 0;
	    }
	
	    var normlabel = normalizeReference(rawlabel);
	    if (normlabel === '') {
	        // label must contain non-whitespace characters
	        this.pos = startpos;
	        return 0;
	    }
	
	    if (!refmap[normlabel]) {
	        refmap[normlabel] = { destination: dest, title: title };
	    }
	    return this.pos - startpos;
	};
	
	// Parse the next inline element in subject, advancing subject position.
	// On success, add the result to block's children and return true.
	// On failure, return false.
	var parseInline = function(block) {
	    var res = false;
	    var c = this.peek();
	    if (c === -1) {
	        return false;
	    }
	    switch(c) {
	    case C_NEWLINE:
	        res = this.parseNewline(block);
	        break;
	    case C_BACKSLASH:
	        res = this.parseBackslash(block);
	        break;
	    case C_BACKTICK:
	        res = this.parseBackticks(block);
	        break;
	    case C_ASTERISK:
	    case C_UNDERSCORE:
	        res = this.handleDelim(c, block);
	        break;
	    case C_SINGLEQUOTE:
	    case C_DOUBLEQUOTE:
	        res = this.options.smart && this.handleDelim(c, block);
	        break;
	    case C_OPEN_BRACKET:
	        res = this.parseOpenBracket(block);
	        break;
	    case C_BANG:
	        res = this.parseBang(block);
	        break;
	    case C_CLOSE_BRACKET:
	        res = this.parseCloseBracket(block);
	        break;
	    case C_LESSTHAN:
	        res = this.parseAutolink(block) || this.parseHtmlTag(block);
	        break;
	    case C_AMPERSAND:
	        res = this.parseEntity(block);
	        break;
	    default:
	        res = this.parseString(block);
	        break;
	    }
	    if (!res) {
	        this.pos += 1;
	        block.appendChild(text(fromCodePoint(c)));
	    }
	
	    return true;
	};
	
	// Parse string content in block into inline children,
	// using refmap to resolve references.
	var parseInlines = function(block) {
	    this.subject = block._string_content.trim();
	    this.pos = 0;
	    this.delimiters = null;
	    this.brackets = null;
	    while (this.parseInline(block)) {
	    }
	    block._string_content = null; // allow raw string to be garbage collected
	    this.processEmphasis(null);
	};
	
	// The InlineParser object.
	function InlineParser(options){
	    return {
	        subject: '',
	        delimiters: null,  // used by handleDelim method
	        brackets: null,
	        pos: 0,
	        refmap: {},
	        match: match,
	        peek: peek,
	        spnl: spnl,
	        parseBackticks: parseBackticks,
	        parseBackslash: parseBackslash,
	        parseAutolink: parseAutolink,
	        parseHtmlTag: parseHtmlTag,
	        scanDelims: scanDelims,
	        handleDelim: handleDelim,
	        parseLinkTitle: parseLinkTitle,
	        parseLinkDestination: parseLinkDestination,
	        parseLinkLabel: parseLinkLabel,
	        parseOpenBracket: parseOpenBracket,
	        parseBang: parseBang,
	        parseCloseBracket: parseCloseBracket,
	        addBracket: addBracket,
	        removeBracket: removeBracket,
	        parseEntity: parseEntity,
	        parseString: parseString,
	        parseNewline: parseNewline,
	        parseReference: parseReference,
	        parseInline: parseInline,
	        processEmphasis: processEmphasis,
	        removeDelimiter: removeDelimiter,
	        options: options || {},
	        parse: parseInlines
	    };
	}
	
	module.exports = InlineParser;


/***/ },
/* 454 */
/*!*************************************************!*\
  !*** ./~/commonmark/lib/normalize-reference.js ***!
  \*************************************************/
/***/ function(module, exports) {

	"use strict";
	
	/* The bulk of this code derives from https://github.com/dmoscrop/fold-case
	But in addition to case-folding, we also normalize whitespace.
	
	fold-case is Copyright Mathias Bynens <https://mathiasbynens.be/>
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	/*eslint-disable  key-spacing, comma-spacing */
	
	var regex = /[ \t\r\n]+|[A-Z\xB5\xC0-\xD6\xD8-\xDF\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u0149\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u017F\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C5\u01C7\u01C8\u01CA\u01CB\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F0-\u01F2\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0345\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03AB\u03B0\u03C2\u03CF-\u03D1\u03D5\u03D6\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F0\u03F1\u03F4\u03F5\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u0587\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E96-\u1E9B\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F50\u1F52\u1F54\u1F56\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1F80-\u1FAF\u1FB2-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD2\u1FD3\u1FD6-\u1FDB\u1FE2-\u1FE4\u1FE6-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2126\u212A\u212B\u2132\u2160-\u216F\u2183\u24B6-\u24CF\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0\uA7B1\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A]|\uD801[\uDC00-\uDC27]|\uD806[\uDCA0-\uDCBF]/g;
	
	var map = {'A':'a','B':'b','C':'c','D':'d','E':'e','F':'f','G':'g','H':'h','I':'i','J':'j','K':'k','L':'l','M':'m','N':'n','O':'o','P':'p','Q':'q','R':'r','S':'s','T':'t','U':'u','V':'v','W':'w','X':'x','Y':'y','Z':'z','\xB5':'\u03BC','\xC0':'\xE0','\xC1':'\xE1','\xC2':'\xE2','\xC3':'\xE3','\xC4':'\xE4','\xC5':'\xE5','\xC6':'\xE6','\xC7':'\xE7','\xC8':'\xE8','\xC9':'\xE9','\xCA':'\xEA','\xCB':'\xEB','\xCC':'\xEC','\xCD':'\xED','\xCE':'\xEE','\xCF':'\xEF','\xD0':'\xF0','\xD1':'\xF1','\xD2':'\xF2','\xD3':'\xF3','\xD4':'\xF4','\xD5':'\xF5','\xD6':'\xF6','\xD8':'\xF8','\xD9':'\xF9','\xDA':'\xFA','\xDB':'\xFB','\xDC':'\xFC','\xDD':'\xFD','\xDE':'\xFE','\u0100':'\u0101','\u0102':'\u0103','\u0104':'\u0105','\u0106':'\u0107','\u0108':'\u0109','\u010A':'\u010B','\u010C':'\u010D','\u010E':'\u010F','\u0110':'\u0111','\u0112':'\u0113','\u0114':'\u0115','\u0116':'\u0117','\u0118':'\u0119','\u011A':'\u011B','\u011C':'\u011D','\u011E':'\u011F','\u0120':'\u0121','\u0122':'\u0123','\u0124':'\u0125','\u0126':'\u0127','\u0128':'\u0129','\u012A':'\u012B','\u012C':'\u012D','\u012E':'\u012F','\u0132':'\u0133','\u0134':'\u0135','\u0136':'\u0137','\u0139':'\u013A','\u013B':'\u013C','\u013D':'\u013E','\u013F':'\u0140','\u0141':'\u0142','\u0143':'\u0144','\u0145':'\u0146','\u0147':'\u0148','\u014A':'\u014B','\u014C':'\u014D','\u014E':'\u014F','\u0150':'\u0151','\u0152':'\u0153','\u0154':'\u0155','\u0156':'\u0157','\u0158':'\u0159','\u015A':'\u015B','\u015C':'\u015D','\u015E':'\u015F','\u0160':'\u0161','\u0162':'\u0163','\u0164':'\u0165','\u0166':'\u0167','\u0168':'\u0169','\u016A':'\u016B','\u016C':'\u016D','\u016E':'\u016F','\u0170':'\u0171','\u0172':'\u0173','\u0174':'\u0175','\u0176':'\u0177','\u0178':'\xFF','\u0179':'\u017A','\u017B':'\u017C','\u017D':'\u017E','\u017F':'s','\u0181':'\u0253','\u0182':'\u0183','\u0184':'\u0185','\u0186':'\u0254','\u0187':'\u0188','\u0189':'\u0256','\u018A':'\u0257','\u018B':'\u018C','\u018E':'\u01DD','\u018F':'\u0259','\u0190':'\u025B','\u0191':'\u0192','\u0193':'\u0260','\u0194':'\u0263','\u0196':'\u0269','\u0197':'\u0268','\u0198':'\u0199','\u019C':'\u026F','\u019D':'\u0272','\u019F':'\u0275','\u01A0':'\u01A1','\u01A2':'\u01A3','\u01A4':'\u01A5','\u01A6':'\u0280','\u01A7':'\u01A8','\u01A9':'\u0283','\u01AC':'\u01AD','\u01AE':'\u0288','\u01AF':'\u01B0','\u01B1':'\u028A','\u01B2':'\u028B','\u01B3':'\u01B4','\u01B5':'\u01B6','\u01B7':'\u0292','\u01B8':'\u01B9','\u01BC':'\u01BD','\u01C4':'\u01C6','\u01C5':'\u01C6','\u01C7':'\u01C9','\u01C8':'\u01C9','\u01CA':'\u01CC','\u01CB':'\u01CC','\u01CD':'\u01CE','\u01CF':'\u01D0','\u01D1':'\u01D2','\u01D3':'\u01D4','\u01D5':'\u01D6','\u01D7':'\u01D8','\u01D9':'\u01DA','\u01DB':'\u01DC','\u01DE':'\u01DF','\u01E0':'\u01E1','\u01E2':'\u01E3','\u01E4':'\u01E5','\u01E6':'\u01E7','\u01E8':'\u01E9','\u01EA':'\u01EB','\u01EC':'\u01ED','\u01EE':'\u01EF','\u01F1':'\u01F3','\u01F2':'\u01F3','\u01F4':'\u01F5','\u01F6':'\u0195','\u01F7':'\u01BF','\u01F8':'\u01F9','\u01FA':'\u01FB','\u01FC':'\u01FD','\u01FE':'\u01FF','\u0200':'\u0201','\u0202':'\u0203','\u0204':'\u0205','\u0206':'\u0207','\u0208':'\u0209','\u020A':'\u020B','\u020C':'\u020D','\u020E':'\u020F','\u0210':'\u0211','\u0212':'\u0213','\u0214':'\u0215','\u0216':'\u0217','\u0218':'\u0219','\u021A':'\u021B','\u021C':'\u021D','\u021E':'\u021F','\u0220':'\u019E','\u0222':'\u0223','\u0224':'\u0225','\u0226':'\u0227','\u0228':'\u0229','\u022A':'\u022B','\u022C':'\u022D','\u022E':'\u022F','\u0230':'\u0231','\u0232':'\u0233','\u023A':'\u2C65','\u023B':'\u023C','\u023D':'\u019A','\u023E':'\u2C66','\u0241':'\u0242','\u0243':'\u0180','\u0244':'\u0289','\u0245':'\u028C','\u0246':'\u0247','\u0248':'\u0249','\u024A':'\u024B','\u024C':'\u024D','\u024E':'\u024F','\u0345':'\u03B9','\u0370':'\u0371','\u0372':'\u0373','\u0376':'\u0377','\u037F':'\u03F3','\u0386':'\u03AC','\u0388':'\u03AD','\u0389':'\u03AE','\u038A':'\u03AF','\u038C':'\u03CC','\u038E':'\u03CD','\u038F':'\u03CE','\u0391':'\u03B1','\u0392':'\u03B2','\u0393':'\u03B3','\u0394':'\u03B4','\u0395':'\u03B5','\u0396':'\u03B6','\u0397':'\u03B7','\u0398':'\u03B8','\u0399':'\u03B9','\u039A':'\u03BA','\u039B':'\u03BB','\u039C':'\u03BC','\u039D':'\u03BD','\u039E':'\u03BE','\u039F':'\u03BF','\u03A0':'\u03C0','\u03A1':'\u03C1','\u03A3':'\u03C3','\u03A4':'\u03C4','\u03A5':'\u03C5','\u03A6':'\u03C6','\u03A7':'\u03C7','\u03A8':'\u03C8','\u03A9':'\u03C9','\u03AA':'\u03CA','\u03AB':'\u03CB','\u03C2':'\u03C3','\u03CF':'\u03D7','\u03D0':'\u03B2','\u03D1':'\u03B8','\u03D5':'\u03C6','\u03D6':'\u03C0','\u03D8':'\u03D9','\u03DA':'\u03DB','\u03DC':'\u03DD','\u03DE':'\u03DF','\u03E0':'\u03E1','\u03E2':'\u03E3','\u03E4':'\u03E5','\u03E6':'\u03E7','\u03E8':'\u03E9','\u03EA':'\u03EB','\u03EC':'\u03ED','\u03EE':'\u03EF','\u03F0':'\u03BA','\u03F1':'\u03C1','\u03F4':'\u03B8','\u03F5':'\u03B5','\u03F7':'\u03F8','\u03F9':'\u03F2','\u03FA':'\u03FB','\u03FD':'\u037B','\u03FE':'\u037C','\u03FF':'\u037D','\u0400':'\u0450','\u0401':'\u0451','\u0402':'\u0452','\u0403':'\u0453','\u0404':'\u0454','\u0405':'\u0455','\u0406':'\u0456','\u0407':'\u0457','\u0408':'\u0458','\u0409':'\u0459','\u040A':'\u045A','\u040B':'\u045B','\u040C':'\u045C','\u040D':'\u045D','\u040E':'\u045E','\u040F':'\u045F','\u0410':'\u0430','\u0411':'\u0431','\u0412':'\u0432','\u0413':'\u0433','\u0414':'\u0434','\u0415':'\u0435','\u0416':'\u0436','\u0417':'\u0437','\u0418':'\u0438','\u0419':'\u0439','\u041A':'\u043A','\u041B':'\u043B','\u041C':'\u043C','\u041D':'\u043D','\u041E':'\u043E','\u041F':'\u043F','\u0420':'\u0440','\u0421':'\u0441','\u0422':'\u0442','\u0423':'\u0443','\u0424':'\u0444','\u0425':'\u0445','\u0426':'\u0446','\u0427':'\u0447','\u0428':'\u0448','\u0429':'\u0449','\u042A':'\u044A','\u042B':'\u044B','\u042C':'\u044C','\u042D':'\u044D','\u042E':'\u044E','\u042F':'\u044F','\u0460':'\u0461','\u0462':'\u0463','\u0464':'\u0465','\u0466':'\u0467','\u0468':'\u0469','\u046A':'\u046B','\u046C':'\u046D','\u046E':'\u046F','\u0470':'\u0471','\u0472':'\u0473','\u0474':'\u0475','\u0476':'\u0477','\u0478':'\u0479','\u047A':'\u047B','\u047C':'\u047D','\u047E':'\u047F','\u0480':'\u0481','\u048A':'\u048B','\u048C':'\u048D','\u048E':'\u048F','\u0490':'\u0491','\u0492':'\u0493','\u0494':'\u0495','\u0496':'\u0497','\u0498':'\u0499','\u049A':'\u049B','\u049C':'\u049D','\u049E':'\u049F','\u04A0':'\u04A1','\u04A2':'\u04A3','\u04A4':'\u04A5','\u04A6':'\u04A7','\u04A8':'\u04A9','\u04AA':'\u04AB','\u04AC':'\u04AD','\u04AE':'\u04AF','\u04B0':'\u04B1','\u04B2':'\u04B3','\u04B4':'\u04B5','\u04B6':'\u04B7','\u04B8':'\u04B9','\u04BA':'\u04BB','\u04BC':'\u04BD','\u04BE':'\u04BF','\u04C0':'\u04CF','\u04C1':'\u04C2','\u04C3':'\u04C4','\u04C5':'\u04C6','\u04C7':'\u04C8','\u04C9':'\u04CA','\u04CB':'\u04CC','\u04CD':'\u04CE','\u04D0':'\u04D1','\u04D2':'\u04D3','\u04D4':'\u04D5','\u04D6':'\u04D7','\u04D8':'\u04D9','\u04DA':'\u04DB','\u04DC':'\u04DD','\u04DE':'\u04DF','\u04E0':'\u04E1','\u04E2':'\u04E3','\u04E4':'\u04E5','\u04E6':'\u04E7','\u04E8':'\u04E9','\u04EA':'\u04EB','\u04EC':'\u04ED','\u04EE':'\u04EF','\u04F0':'\u04F1','\u04F2':'\u04F3','\u04F4':'\u04F5','\u04F6':'\u04F7','\u04F8':'\u04F9','\u04FA':'\u04FB','\u04FC':'\u04FD','\u04FE':'\u04FF','\u0500':'\u0501','\u0502':'\u0503','\u0504':'\u0505','\u0506':'\u0507','\u0508':'\u0509','\u050A':'\u050B','\u050C':'\u050D','\u050E':'\u050F','\u0510':'\u0511','\u0512':'\u0513','\u0514':'\u0515','\u0516':'\u0517','\u0518':'\u0519','\u051A':'\u051B','\u051C':'\u051D','\u051E':'\u051F','\u0520':'\u0521','\u0522':'\u0523','\u0524':'\u0525','\u0526':'\u0527','\u0528':'\u0529','\u052A':'\u052B','\u052C':'\u052D','\u052E':'\u052F','\u0531':'\u0561','\u0532':'\u0562','\u0533':'\u0563','\u0534':'\u0564','\u0535':'\u0565','\u0536':'\u0566','\u0537':'\u0567','\u0538':'\u0568','\u0539':'\u0569','\u053A':'\u056A','\u053B':'\u056B','\u053C':'\u056C','\u053D':'\u056D','\u053E':'\u056E','\u053F':'\u056F','\u0540':'\u0570','\u0541':'\u0571','\u0542':'\u0572','\u0543':'\u0573','\u0544':'\u0574','\u0545':'\u0575','\u0546':'\u0576','\u0547':'\u0577','\u0548':'\u0578','\u0549':'\u0579','\u054A':'\u057A','\u054B':'\u057B','\u054C':'\u057C','\u054D':'\u057D','\u054E':'\u057E','\u054F':'\u057F','\u0550':'\u0580','\u0551':'\u0581','\u0552':'\u0582','\u0553':'\u0583','\u0554':'\u0584','\u0555':'\u0585','\u0556':'\u0586','\u10A0':'\u2D00','\u10A1':'\u2D01','\u10A2':'\u2D02','\u10A3':'\u2D03','\u10A4':'\u2D04','\u10A5':'\u2D05','\u10A6':'\u2D06','\u10A7':'\u2D07','\u10A8':'\u2D08','\u10A9':'\u2D09','\u10AA':'\u2D0A','\u10AB':'\u2D0B','\u10AC':'\u2D0C','\u10AD':'\u2D0D','\u10AE':'\u2D0E','\u10AF':'\u2D0F','\u10B0':'\u2D10','\u10B1':'\u2D11','\u10B2':'\u2D12','\u10B3':'\u2D13','\u10B4':'\u2D14','\u10B5':'\u2D15','\u10B6':'\u2D16','\u10B7':'\u2D17','\u10B8':'\u2D18','\u10B9':'\u2D19','\u10BA':'\u2D1A','\u10BB':'\u2D1B','\u10BC':'\u2D1C','\u10BD':'\u2D1D','\u10BE':'\u2D1E','\u10BF':'\u2D1F','\u10C0':'\u2D20','\u10C1':'\u2D21','\u10C2':'\u2D22','\u10C3':'\u2D23','\u10C4':'\u2D24','\u10C5':'\u2D25','\u10C7':'\u2D27','\u10CD':'\u2D2D','\u1E00':'\u1E01','\u1E02':'\u1E03','\u1E04':'\u1E05','\u1E06':'\u1E07','\u1E08':'\u1E09','\u1E0A':'\u1E0B','\u1E0C':'\u1E0D','\u1E0E':'\u1E0F','\u1E10':'\u1E11','\u1E12':'\u1E13','\u1E14':'\u1E15','\u1E16':'\u1E17','\u1E18':'\u1E19','\u1E1A':'\u1E1B','\u1E1C':'\u1E1D','\u1E1E':'\u1E1F','\u1E20':'\u1E21','\u1E22':'\u1E23','\u1E24':'\u1E25','\u1E26':'\u1E27','\u1E28':'\u1E29','\u1E2A':'\u1E2B','\u1E2C':'\u1E2D','\u1E2E':'\u1E2F','\u1E30':'\u1E31','\u1E32':'\u1E33','\u1E34':'\u1E35','\u1E36':'\u1E37','\u1E38':'\u1E39','\u1E3A':'\u1E3B','\u1E3C':'\u1E3D','\u1E3E':'\u1E3F','\u1E40':'\u1E41','\u1E42':'\u1E43','\u1E44':'\u1E45','\u1E46':'\u1E47','\u1E48':'\u1E49','\u1E4A':'\u1E4B','\u1E4C':'\u1E4D','\u1E4E':'\u1E4F','\u1E50':'\u1E51','\u1E52':'\u1E53','\u1E54':'\u1E55','\u1E56':'\u1E57','\u1E58':'\u1E59','\u1E5A':'\u1E5B','\u1E5C':'\u1E5D','\u1E5E':'\u1E5F','\u1E60':'\u1E61','\u1E62':'\u1E63','\u1E64':'\u1E65','\u1E66':'\u1E67','\u1E68':'\u1E69','\u1E6A':'\u1E6B','\u1E6C':'\u1E6D','\u1E6E':'\u1E6F','\u1E70':'\u1E71','\u1E72':'\u1E73','\u1E74':'\u1E75','\u1E76':'\u1E77','\u1E78':'\u1E79','\u1E7A':'\u1E7B','\u1E7C':'\u1E7D','\u1E7E':'\u1E7F','\u1E80':'\u1E81','\u1E82':'\u1E83','\u1E84':'\u1E85','\u1E86':'\u1E87','\u1E88':'\u1E89','\u1E8A':'\u1E8B','\u1E8C':'\u1E8D','\u1E8E':'\u1E8F','\u1E90':'\u1E91','\u1E92':'\u1E93','\u1E94':'\u1E95','\u1E9B':'\u1E61','\u1EA0':'\u1EA1','\u1EA2':'\u1EA3','\u1EA4':'\u1EA5','\u1EA6':'\u1EA7','\u1EA8':'\u1EA9','\u1EAA':'\u1EAB','\u1EAC':'\u1EAD','\u1EAE':'\u1EAF','\u1EB0':'\u1EB1','\u1EB2':'\u1EB3','\u1EB4':'\u1EB5','\u1EB6':'\u1EB7','\u1EB8':'\u1EB9','\u1EBA':'\u1EBB','\u1EBC':'\u1EBD','\u1EBE':'\u1EBF','\u1EC0':'\u1EC1','\u1EC2':'\u1EC3','\u1EC4':'\u1EC5','\u1EC6':'\u1EC7','\u1EC8':'\u1EC9','\u1ECA':'\u1ECB','\u1ECC':'\u1ECD','\u1ECE':'\u1ECF','\u1ED0':'\u1ED1','\u1ED2':'\u1ED3','\u1ED4':'\u1ED5','\u1ED6':'\u1ED7','\u1ED8':'\u1ED9','\u1EDA':'\u1EDB','\u1EDC':'\u1EDD','\u1EDE':'\u1EDF','\u1EE0':'\u1EE1','\u1EE2':'\u1EE3','\u1EE4':'\u1EE5','\u1EE6':'\u1EE7','\u1EE8':'\u1EE9','\u1EEA':'\u1EEB','\u1EEC':'\u1EED','\u1EEE':'\u1EEF','\u1EF0':'\u1EF1','\u1EF2':'\u1EF3','\u1EF4':'\u1EF5','\u1EF6':'\u1EF7','\u1EF8':'\u1EF9','\u1EFA':'\u1EFB','\u1EFC':'\u1EFD','\u1EFE':'\u1EFF','\u1F08':'\u1F00','\u1F09':'\u1F01','\u1F0A':'\u1F02','\u1F0B':'\u1F03','\u1F0C':'\u1F04','\u1F0D':'\u1F05','\u1F0E':'\u1F06','\u1F0F':'\u1F07','\u1F18':'\u1F10','\u1F19':'\u1F11','\u1F1A':'\u1F12','\u1F1B':'\u1F13','\u1F1C':'\u1F14','\u1F1D':'\u1F15','\u1F28':'\u1F20','\u1F29':'\u1F21','\u1F2A':'\u1F22','\u1F2B':'\u1F23','\u1F2C':'\u1F24','\u1F2D':'\u1F25','\u1F2E':'\u1F26','\u1F2F':'\u1F27','\u1F38':'\u1F30','\u1F39':'\u1F31','\u1F3A':'\u1F32','\u1F3B':'\u1F33','\u1F3C':'\u1F34','\u1F3D':'\u1F35','\u1F3E':'\u1F36','\u1F3F':'\u1F37','\u1F48':'\u1F40','\u1F49':'\u1F41','\u1F4A':'\u1F42','\u1F4B':'\u1F43','\u1F4C':'\u1F44','\u1F4D':'\u1F45','\u1F59':'\u1F51','\u1F5B':'\u1F53','\u1F5D':'\u1F55','\u1F5F':'\u1F57','\u1F68':'\u1F60','\u1F69':'\u1F61','\u1F6A':'\u1F62','\u1F6B':'\u1F63','\u1F6C':'\u1F64','\u1F6D':'\u1F65','\u1F6E':'\u1F66','\u1F6F':'\u1F67','\u1FB8':'\u1FB0','\u1FB9':'\u1FB1','\u1FBA':'\u1F70','\u1FBB':'\u1F71','\u1FBE':'\u03B9','\u1FC8':'\u1F72','\u1FC9':'\u1F73','\u1FCA':'\u1F74','\u1FCB':'\u1F75','\u1FD8':'\u1FD0','\u1FD9':'\u1FD1','\u1FDA':'\u1F76','\u1FDB':'\u1F77','\u1FE8':'\u1FE0','\u1FE9':'\u1FE1','\u1FEA':'\u1F7A','\u1FEB':'\u1F7B','\u1FEC':'\u1FE5','\u1FF8':'\u1F78','\u1FF9':'\u1F79','\u1FFA':'\u1F7C','\u1FFB':'\u1F7D','\u2126':'\u03C9','\u212A':'k','\u212B':'\xE5','\u2132':'\u214E','\u2160':'\u2170','\u2161':'\u2171','\u2162':'\u2172','\u2163':'\u2173','\u2164':'\u2174','\u2165':'\u2175','\u2166':'\u2176','\u2167':'\u2177','\u2168':'\u2178','\u2169':'\u2179','\u216A':'\u217A','\u216B':'\u217B','\u216C':'\u217C','\u216D':'\u217D','\u216E':'\u217E','\u216F':'\u217F','\u2183':'\u2184','\u24B6':'\u24D0','\u24B7':'\u24D1','\u24B8':'\u24D2','\u24B9':'\u24D3','\u24BA':'\u24D4','\u24BB':'\u24D5','\u24BC':'\u24D6','\u24BD':'\u24D7','\u24BE':'\u24D8','\u24BF':'\u24D9','\u24C0':'\u24DA','\u24C1':'\u24DB','\u24C2':'\u24DC','\u24C3':'\u24DD','\u24C4':'\u24DE','\u24C5':'\u24DF','\u24C6':'\u24E0','\u24C7':'\u24E1','\u24C8':'\u24E2','\u24C9':'\u24E3','\u24CA':'\u24E4','\u24CB':'\u24E5','\u24CC':'\u24E6','\u24CD':'\u24E7','\u24CE':'\u24E8','\u24CF':'\u24E9','\u2C00':'\u2C30','\u2C01':'\u2C31','\u2C02':'\u2C32','\u2C03':'\u2C33','\u2C04':'\u2C34','\u2C05':'\u2C35','\u2C06':'\u2C36','\u2C07':'\u2C37','\u2C08':'\u2C38','\u2C09':'\u2C39','\u2C0A':'\u2C3A','\u2C0B':'\u2C3B','\u2C0C':'\u2C3C','\u2C0D':'\u2C3D','\u2C0E':'\u2C3E','\u2C0F':'\u2C3F','\u2C10':'\u2C40','\u2C11':'\u2C41','\u2C12':'\u2C42','\u2C13':'\u2C43','\u2C14':'\u2C44','\u2C15':'\u2C45','\u2C16':'\u2C46','\u2C17':'\u2C47','\u2C18':'\u2C48','\u2C19':'\u2C49','\u2C1A':'\u2C4A','\u2C1B':'\u2C4B','\u2C1C':'\u2C4C','\u2C1D':'\u2C4D','\u2C1E':'\u2C4E','\u2C1F':'\u2C4F','\u2C20':'\u2C50','\u2C21':'\u2C51','\u2C22':'\u2C52','\u2C23':'\u2C53','\u2C24':'\u2C54','\u2C25':'\u2C55','\u2C26':'\u2C56','\u2C27':'\u2C57','\u2C28':'\u2C58','\u2C29':'\u2C59','\u2C2A':'\u2C5A','\u2C2B':'\u2C5B','\u2C2C':'\u2C5C','\u2C2D':'\u2C5D','\u2C2E':'\u2C5E','\u2C60':'\u2C61','\u2C62':'\u026B','\u2C63':'\u1D7D','\u2C64':'\u027D','\u2C67':'\u2C68','\u2C69':'\u2C6A','\u2C6B':'\u2C6C','\u2C6D':'\u0251','\u2C6E':'\u0271','\u2C6F':'\u0250','\u2C70':'\u0252','\u2C72':'\u2C73','\u2C75':'\u2C76','\u2C7E':'\u023F','\u2C7F':'\u0240','\u2C80':'\u2C81','\u2C82':'\u2C83','\u2C84':'\u2C85','\u2C86':'\u2C87','\u2C88':'\u2C89','\u2C8A':'\u2C8B','\u2C8C':'\u2C8D','\u2C8E':'\u2C8F','\u2C90':'\u2C91','\u2C92':'\u2C93','\u2C94':'\u2C95','\u2C96':'\u2C97','\u2C98':'\u2C99','\u2C9A':'\u2C9B','\u2C9C':'\u2C9D','\u2C9E':'\u2C9F','\u2CA0':'\u2CA1','\u2CA2':'\u2CA3','\u2CA4':'\u2CA5','\u2CA6':'\u2CA7','\u2CA8':'\u2CA9','\u2CAA':'\u2CAB','\u2CAC':'\u2CAD','\u2CAE':'\u2CAF','\u2CB0':'\u2CB1','\u2CB2':'\u2CB3','\u2CB4':'\u2CB5','\u2CB6':'\u2CB7','\u2CB8':'\u2CB9','\u2CBA':'\u2CBB','\u2CBC':'\u2CBD','\u2CBE':'\u2CBF','\u2CC0':'\u2CC1','\u2CC2':'\u2CC3','\u2CC4':'\u2CC5','\u2CC6':'\u2CC7','\u2CC8':'\u2CC9','\u2CCA':'\u2CCB','\u2CCC':'\u2CCD','\u2CCE':'\u2CCF','\u2CD0':'\u2CD1','\u2CD2':'\u2CD3','\u2CD4':'\u2CD5','\u2CD6':'\u2CD7','\u2CD8':'\u2CD9','\u2CDA':'\u2CDB','\u2CDC':'\u2CDD','\u2CDE':'\u2CDF','\u2CE0':'\u2CE1','\u2CE2':'\u2CE3','\u2CEB':'\u2CEC','\u2CED':'\u2CEE','\u2CF2':'\u2CF3','\uA640':'\uA641','\uA642':'\uA643','\uA644':'\uA645','\uA646':'\uA647','\uA648':'\uA649','\uA64A':'\uA64B','\uA64C':'\uA64D','\uA64E':'\uA64F','\uA650':'\uA651','\uA652':'\uA653','\uA654':'\uA655','\uA656':'\uA657','\uA658':'\uA659','\uA65A':'\uA65B','\uA65C':'\uA65D','\uA65E':'\uA65F','\uA660':'\uA661','\uA662':'\uA663','\uA664':'\uA665','\uA666':'\uA667','\uA668':'\uA669','\uA66A':'\uA66B','\uA66C':'\uA66D','\uA680':'\uA681','\uA682':'\uA683','\uA684':'\uA685','\uA686':'\uA687','\uA688':'\uA689','\uA68A':'\uA68B','\uA68C':'\uA68D','\uA68E':'\uA68F','\uA690':'\uA691','\uA692':'\uA693','\uA694':'\uA695','\uA696':'\uA697','\uA698':'\uA699','\uA69A':'\uA69B','\uA722':'\uA723','\uA724':'\uA725','\uA726':'\uA727','\uA728':'\uA729','\uA72A':'\uA72B','\uA72C':'\uA72D','\uA72E':'\uA72F','\uA732':'\uA733','\uA734':'\uA735','\uA736':'\uA737','\uA738':'\uA739','\uA73A':'\uA73B','\uA73C':'\uA73D','\uA73E':'\uA73F','\uA740':'\uA741','\uA742':'\uA743','\uA744':'\uA745','\uA746':'\uA747','\uA748':'\uA749','\uA74A':'\uA74B','\uA74C':'\uA74D','\uA74E':'\uA74F','\uA750':'\uA751','\uA752':'\uA753','\uA754':'\uA755','\uA756':'\uA757','\uA758':'\uA759','\uA75A':'\uA75B','\uA75C':'\uA75D','\uA75E':'\uA75F','\uA760':'\uA761','\uA762':'\uA763','\uA764':'\uA765','\uA766':'\uA767','\uA768':'\uA769','\uA76A':'\uA76B','\uA76C':'\uA76D','\uA76E':'\uA76F','\uA779':'\uA77A','\uA77B':'\uA77C','\uA77D':'\u1D79','\uA77E':'\uA77F','\uA780':'\uA781','\uA782':'\uA783','\uA784':'\uA785','\uA786':'\uA787','\uA78B':'\uA78C','\uA78D':'\u0265','\uA790':'\uA791','\uA792':'\uA793','\uA796':'\uA797','\uA798':'\uA799','\uA79A':'\uA79B','\uA79C':'\uA79D','\uA79E':'\uA79F','\uA7A0':'\uA7A1','\uA7A2':'\uA7A3','\uA7A4':'\uA7A5','\uA7A6':'\uA7A7','\uA7A8':'\uA7A9','\uA7AA':'\u0266','\uA7AB':'\u025C','\uA7AC':'\u0261','\uA7AD':'\u026C','\uA7B0':'\u029E','\uA7B1':'\u0287','\uFF21':'\uFF41','\uFF22':'\uFF42','\uFF23':'\uFF43','\uFF24':'\uFF44','\uFF25':'\uFF45','\uFF26':'\uFF46','\uFF27':'\uFF47','\uFF28':'\uFF48','\uFF29':'\uFF49','\uFF2A':'\uFF4A','\uFF2B':'\uFF4B','\uFF2C':'\uFF4C','\uFF2D':'\uFF4D','\uFF2E':'\uFF4E','\uFF2F':'\uFF4F','\uFF30':'\uFF50','\uFF31':'\uFF51','\uFF32':'\uFF52','\uFF33':'\uFF53','\uFF34':'\uFF54','\uFF35':'\uFF55','\uFF36':'\uFF56','\uFF37':'\uFF57','\uFF38':'\uFF58','\uFF39':'\uFF59','\uFF3A':'\uFF5A','\uD801\uDC00':'\uD801\uDC28','\uD801\uDC01':'\uD801\uDC29','\uD801\uDC02':'\uD801\uDC2A','\uD801\uDC03':'\uD801\uDC2B','\uD801\uDC04':'\uD801\uDC2C','\uD801\uDC05':'\uD801\uDC2D','\uD801\uDC06':'\uD801\uDC2E','\uD801\uDC07':'\uD801\uDC2F','\uD801\uDC08':'\uD801\uDC30','\uD801\uDC09':'\uD801\uDC31','\uD801\uDC0A':'\uD801\uDC32','\uD801\uDC0B':'\uD801\uDC33','\uD801\uDC0C':'\uD801\uDC34','\uD801\uDC0D':'\uD801\uDC35','\uD801\uDC0E':'\uD801\uDC36','\uD801\uDC0F':'\uD801\uDC37','\uD801\uDC10':'\uD801\uDC38','\uD801\uDC11':'\uD801\uDC39','\uD801\uDC12':'\uD801\uDC3A','\uD801\uDC13':'\uD801\uDC3B','\uD801\uDC14':'\uD801\uDC3C','\uD801\uDC15':'\uD801\uDC3D','\uD801\uDC16':'\uD801\uDC3E','\uD801\uDC17':'\uD801\uDC3F','\uD801\uDC18':'\uD801\uDC40','\uD801\uDC19':'\uD801\uDC41','\uD801\uDC1A':'\uD801\uDC42','\uD801\uDC1B':'\uD801\uDC43','\uD801\uDC1C':'\uD801\uDC44','\uD801\uDC1D':'\uD801\uDC45','\uD801\uDC1E':'\uD801\uDC46','\uD801\uDC1F':'\uD801\uDC47','\uD801\uDC20':'\uD801\uDC48','\uD801\uDC21':'\uD801\uDC49','\uD801\uDC22':'\uD801\uDC4A','\uD801\uDC23':'\uD801\uDC4B','\uD801\uDC24':'\uD801\uDC4C','\uD801\uDC25':'\uD801\uDC4D','\uD801\uDC26':'\uD801\uDC4E','\uD801\uDC27':'\uD801\uDC4F','\uD806\uDCA0':'\uD806\uDCC0','\uD806\uDCA1':'\uD806\uDCC1','\uD806\uDCA2':'\uD806\uDCC2','\uD806\uDCA3':'\uD806\uDCC3','\uD806\uDCA4':'\uD806\uDCC4','\uD806\uDCA5':'\uD806\uDCC5','\uD806\uDCA6':'\uD806\uDCC6','\uD806\uDCA7':'\uD806\uDCC7','\uD806\uDCA8':'\uD806\uDCC8','\uD806\uDCA9':'\uD806\uDCC9','\uD806\uDCAA':'\uD806\uDCCA','\uD806\uDCAB':'\uD806\uDCCB','\uD806\uDCAC':'\uD806\uDCCC','\uD806\uDCAD':'\uD806\uDCCD','\uD806\uDCAE':'\uD806\uDCCE','\uD806\uDCAF':'\uD806\uDCCF','\uD806\uDCB0':'\uD806\uDCD0','\uD806\uDCB1':'\uD806\uDCD1','\uD806\uDCB2':'\uD806\uDCD2','\uD806\uDCB3':'\uD806\uDCD3','\uD806\uDCB4':'\uD806\uDCD4','\uD806\uDCB5':'\uD806\uDCD5','\uD806\uDCB6':'\uD806\uDCD6','\uD806\uDCB7':'\uD806\uDCD7','\uD806\uDCB8':'\uD806\uDCD8','\uD806\uDCB9':'\uD806\uDCD9','\uD806\uDCBA':'\uD806\uDCDA','\uD806\uDCBB':'\uD806\uDCDB','\uD806\uDCBC':'\uD806\uDCDC','\uD806\uDCBD':'\uD806\uDCDD','\uD806\uDCBE':'\uD806\uDCDE','\uD806\uDCBF':'\uD806\uDCDF','\xDF':'ss','\u0130':'i\u0307','\u0149':'\u02BCn','\u01F0':'j\u030C','\u0390':'\u03B9\u0308\u0301','\u03B0':'\u03C5\u0308\u0301','\u0587':'\u0565\u0582','\u1E96':'h\u0331','\u1E97':'t\u0308','\u1E98':'w\u030A','\u1E99':'y\u030A','\u1E9A':'a\u02BE','\u1E9E':'ss','\u1F50':'\u03C5\u0313','\u1F52':'\u03C5\u0313\u0300','\u1F54':'\u03C5\u0313\u0301','\u1F56':'\u03C5\u0313\u0342','\u1F80':'\u1F00\u03B9','\u1F81':'\u1F01\u03B9','\u1F82':'\u1F02\u03B9','\u1F83':'\u1F03\u03B9','\u1F84':'\u1F04\u03B9','\u1F85':'\u1F05\u03B9','\u1F86':'\u1F06\u03B9','\u1F87':'\u1F07\u03B9','\u1F88':'\u1F00\u03B9','\u1F89':'\u1F01\u03B9','\u1F8A':'\u1F02\u03B9','\u1F8B':'\u1F03\u03B9','\u1F8C':'\u1F04\u03B9','\u1F8D':'\u1F05\u03B9','\u1F8E':'\u1F06\u03B9','\u1F8F':'\u1F07\u03B9','\u1F90':'\u1F20\u03B9','\u1F91':'\u1F21\u03B9','\u1F92':'\u1F22\u03B9','\u1F93':'\u1F23\u03B9','\u1F94':'\u1F24\u03B9','\u1F95':'\u1F25\u03B9','\u1F96':'\u1F26\u03B9','\u1F97':'\u1F27\u03B9','\u1F98':'\u1F20\u03B9','\u1F99':'\u1F21\u03B9','\u1F9A':'\u1F22\u03B9','\u1F9B':'\u1F23\u03B9','\u1F9C':'\u1F24\u03B9','\u1F9D':'\u1F25\u03B9','\u1F9E':'\u1F26\u03B9','\u1F9F':'\u1F27\u03B9','\u1FA0':'\u1F60\u03B9','\u1FA1':'\u1F61\u03B9','\u1FA2':'\u1F62\u03B9','\u1FA3':'\u1F63\u03B9','\u1FA4':'\u1F64\u03B9','\u1FA5':'\u1F65\u03B9','\u1FA6':'\u1F66\u03B9','\u1FA7':'\u1F67\u03B9','\u1FA8':'\u1F60\u03B9','\u1FA9':'\u1F61\u03B9','\u1FAA':'\u1F62\u03B9','\u1FAB':'\u1F63\u03B9','\u1FAC':'\u1F64\u03B9','\u1FAD':'\u1F65\u03B9','\u1FAE':'\u1F66\u03B9','\u1FAF':'\u1F67\u03B9','\u1FB2':'\u1F70\u03B9','\u1FB3':'\u03B1\u03B9','\u1FB4':'\u03AC\u03B9','\u1FB6':'\u03B1\u0342','\u1FB7':'\u03B1\u0342\u03B9','\u1FBC':'\u03B1\u03B9','\u1FC2':'\u1F74\u03B9','\u1FC3':'\u03B7\u03B9','\u1FC4':'\u03AE\u03B9','\u1FC6':'\u03B7\u0342','\u1FC7':'\u03B7\u0342\u03B9','\u1FCC':'\u03B7\u03B9','\u1FD2':'\u03B9\u0308\u0300','\u1FD3':'\u03B9\u0308\u0301','\u1FD6':'\u03B9\u0342','\u1FD7':'\u03B9\u0308\u0342','\u1FE2':'\u03C5\u0308\u0300','\u1FE3':'\u03C5\u0308\u0301','\u1FE4':'\u03C1\u0313','\u1FE6':'\u03C5\u0342','\u1FE7':'\u03C5\u0308\u0342','\u1FF2':'\u1F7C\u03B9','\u1FF3':'\u03C9\u03B9','\u1FF4':'\u03CE\u03B9','\u1FF6':'\u03C9\u0342','\u1FF7':'\u03C9\u0342\u03B9','\u1FFC':'\u03C9\u03B9','\uFB00':'ff','\uFB01':'fi','\uFB02':'fl','\uFB03':'ffi','\uFB04':'ffl','\uFB05':'st','\uFB06':'st','\uFB13':'\u0574\u0576','\uFB14':'\u0574\u0565','\uFB15':'\u0574\u056B','\uFB16':'\u057E\u0576','\uFB17':'\u0574\u056D'};
	
	// Normalize reference label: collapse internal whitespace
	// to single space, remove leading/trailing whitespace, case fold.
	module.exports = function(string) {
	    return string.slice(1, string.length - 1).trim().replace(regex, function($0) {
	        // Note: there is no need to check `hasOwnProperty($0)` here.
	        // If character not found in lookup table, it must be whitespace.
	        return map[$0] || ' ';
	    });
	};


/***/ },
/* 455 */
/*!*********************************************!*\
  !*** ./~/commonmark/lib/from-code-point.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";
	
	// derived from https://github.com/mathiasbynens/String.fromCodePoint
	/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
	if (String.fromCodePoint) {
	    module.exports = function (_) {
	        try {
	            return String.fromCodePoint(_);
	        } catch (e) {
	            if (e instanceof RangeError) {
	                return String.fromCharCode(0xFFFD);
	            }
	            throw e;
	        }
	    };
	
	} else {
	
	  var stringFromCharCode = String.fromCharCode;
	  var floor = Math.floor;
	  var fromCodePoint = function() {
	      var MAX_SIZE = 0x4000;
	      var codeUnits = [];
	      var highSurrogate;
	      var lowSurrogate;
	      var index = -1;
	      var length = arguments.length;
	      if (!length) {
	          return '';
	      }
	      var result = '';
	      while (++index < length) {
	          var codePoint = Number(arguments[index]);
	          if (
	              !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	                  codePoint < 0 || // not a valid Unicode code point
	                  codePoint > 0x10FFFF || // not a valid Unicode code point
	                  floor(codePoint) !== codePoint // not an integer
	          ) {
	              return String.fromCharCode(0xFFFD);
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	              codeUnits.push(codePoint);
	          } else { // Astral code point; split in surrogate halves
	              // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	              codePoint -= 0x10000;
	              highSurrogate = (codePoint >> 10) + 0xD800;
	              lowSurrogate = (codePoint % 0x400) + 0xDC00;
	              codeUnits.push(highSurrogate, lowSurrogate);
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	              result += stringFromCharCode.apply(null, codeUnits);
	              codeUnits.length = 0;
	          }
	      }
	      return result;
	  };
	  module.exports = fromCodePoint;
	}


/***/ },
/* 456 */
/*!*********************************************!*\
  !*** ./~/string.prototype.repeat/repeat.js ***!
  \*********************************************/
/***/ function(module, exports) {

	/*! http://mths.be/repeat v0.2.0 by @mathias */
	if (!String.prototype.repeat) {
		(function() {
			'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
			var defineProperty = (function() {
				// IE 8 only supports `Object.defineProperty` on DOM elements
				try {
					var object = {};
					var $defineProperty = Object.defineProperty;
					var result = $defineProperty(object, object, object) && $defineProperty;
				} catch(error) {}
				return result;
			}());
			var repeat = function(count) {
				if (this == null) {
					throw TypeError();
				}
				var string = String(this);
				// `ToInteger`
				var n = count ? Number(count) : 0;
				if (n != n) { // better `isNaN`
					n = 0;
				}
				// Account for out-of-bounds indices
				if (n < 0 || n == Infinity) {
					throw RangeError();
				}
				var result = '';
				while (n) {
					if (n % 2 == 1) {
						result += string;
					}
					if (n > 1) {
						string += string;
					}
					n >>= 1;
				}
				return result;
			};
			if (defineProperty) {
				defineProperty(String.prototype, 'repeat', {
					'value': repeat,
					'configurable': true,
					'writable': true
				});
			} else {
				String.prototype.repeat = repeat;
			}
		}());
	}


/***/ },
/* 457 */
/*!*****************************************!*\
  !*** ./~/commonmark/lib/render/html.js ***!
  \*****************************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var Renderer = __webpack_require__(/*! ./renderer */ 458);
	
	var esc = __webpack_require__(/*! ../common */ 442).escapeXml;
	
	var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
	var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;
	
	var potentiallyUnsafe = function(url) {
	    return reUnsafeProtocol.test(url) &&
	        !reSafeDataProtocol.test(url);
	};
	
	// Helper function to produce an HTML tag.
	function tag(name, attrs, selfclosing) {
	    if (this.disableTags > 0) {
	        return;
	    }
	    this.buffer += ('<' + name);
	    if (attrs && attrs.length > 0) {
	        var i = 0;
	        var attrib;
	        while ((attrib = attrs[i]) !== undefined) {
	            this.buffer += (' ' + attrib[0] + '="' + attrib[1] + '"');
	            i++;
	        }
	    }
	    if (selfclosing) {
	        this.buffer += ' /';
	    }
	    this.buffer += '>';
	    this.lastOut = '>';
	}
	
	
	function HtmlRenderer(options) {
	  options = options || {};
	  // by default, soft breaks are rendered as newlines in HTML
	  options.softbreak = options.softbreak || '\n';
	  // set to "<br />" to make them hard breaks
	  // set to " " if you want to ignore line wrapping in source
	
	  this.disableTags = 0;
	  this.lastOut = "\n";
	  this.options = options;
	}
	
	/* Node methods */
	
	function text(node) {
	  this.out(node.literal);
	}
	
	function softbreak() {
	  this.lit(this.options.softbreak);
	}
	
	function linebreak() {
	  this.tag('br', [], true);
	  this.cr();
	}
	
	function link(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      if (!(this.options.safe && potentiallyUnsafe(node.destination))) {
	          attrs.push(['href', esc(node.destination, true)]);
	      }
	      if (node.title) {
	          attrs.push(['title', esc(node.title, true)]);
	      }
	      this.tag('a', attrs);
	  } else {
	      this.tag('/a');
	  }
	}
	
	function image(node, entering) {
	  if (entering) {
	      if (this.disableTags === 0) {
	          if (this.options.safe &&
	               potentiallyUnsafe(node.destination)) {
	              this.lit('<img src="" alt="');
	          } else {
	              this.lit('<img src="' + esc(node.destination, true) +
	                  '" alt="');
	          }
	      }
	      this.disableTags += 1;
	  } else {
	      this.disableTags -= 1;
	      if (this.disableTags === 0) {
	          if (node.title) {
	              this.lit('" title="' + esc(node.title, true));
	          }
	          this.lit('" />');
	      }
	  }
	}
	
	function emph(node, entering) {
	  this.tag(entering ? 'em' : '/em');
	}
	
	function strong(node, entering) {
	  this.tag(entering ? 'strong' : '/strong');
	}
	
	function paragraph(node, entering) {
	  var grandparent = node.parent.parent
	    , attrs = this.attrs(node);
	  if (grandparent !== null &&
	      grandparent.type === 'list') {
	      if (grandparent.listTight) {
	          return;
	      }
	  }
	  if (entering) {
	      this.cr();
	      this.tag('p', attrs);
	  } else {
	      this.tag('/p');
	      this.cr();
	  }
	}
	
	function heading(node, entering) {
	  var tagname = 'h' + node.level
	    , attrs = this.attrs(node);
	  if (entering) {
	      this.cr();
	      this.tag(tagname, attrs);
	  } else {
	      this.tag('/' + tagname);
	      this.cr();
	  }
	}
	
	function code(node) {
	  this.tag('code');
	  this.out(node.literal);
	  this.tag('/code');
	}
	
	function code_block(node) {
	  var info_words = node.info ? node.info.split(/\s+/) : []
	    , attrs = this.attrs(node);
	  if (info_words.length > 0 && info_words[0].length > 0) {
	      attrs.push(['class', 'language-' + esc(info_words[0], true)]);
	  }
	  this.cr();
	  this.tag('pre');
	  this.tag('code', attrs);
	  this.out(node.literal);
	  this.tag('/code');
	  this.tag('/pre');
	  this.cr();
	}
	
	function thematic_break(node) {
	  var attrs = this.attrs(node);
	  this.cr();
	  this.tag('hr', attrs, true);
	  this.cr();
	}
	
	function block_quote(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      this.cr();
	      this.tag('blockquote', attrs);
	      this.cr();
	  } else {
	      this.cr();
	      this.tag('/blockquote');
	      this.cr();
	  }
	}
	
	function list(node, entering) {
	  var tagname = node.listType === 'bullet' ? 'ul' : 'ol'
	    , attrs = this.attrs(node);
	
	  if (entering) {
	      var start = node.listStart;
	      if (start !== null && start !== 1) {
	          attrs.push(['start', start.toString()]);
	      }
	      this.cr();
	      this.tag(tagname, attrs);
	      this.cr();
	  } else {
	      this.cr();
	      this.tag('/' + tagname);
	      this.cr();
	  }
	}
	
	function item(node, entering) {
	  var attrs = this.attrs(node);
	  if (entering) {
	      this.tag('li', attrs);
	  } else {
	      this.tag('/li');
	      this.cr();
	  }
	}
	
	function html_inline(node) {
	  if (this.options.safe) {
	      this.lit('<!-- raw HTML omitted -->');
	  } else {
	      this.lit(node.literal);
	  }
	}
	
	function html_block(node) {
	  this.cr();
	  if (this.options.safe) {
	      this.lit('<!-- raw HTML omitted -->');
	  } else {
	      this.lit(node.literal);
	  }
	  this.cr();
	}
	
	function custom_inline(node, entering) {
	  if (entering && node.onEnter) {
	      this.lit(node.onEnter);
	  } else if (!entering && node.onExit) {
	      this.lit(node.onExit);
	  }
	}
	
	function custom_block(node, entering) {
	  this.cr();
	  if (entering && node.onEnter) {
	      this.lit(node.onEnter);
	  } else if (!entering && node.onExit) {
	      this.lit(node.onExit);
	  }
	  this.cr();
	}
	
	/* Helper methods */
	
	function out(s) {
	  this.lit(esc(s, false));
	}
	
	function attrs (node) {
	  var att = [];
	  if (this.options.sourcepos) {
	      var pos = node.sourcepos;
	      if (pos) {
	          att.push(['data-sourcepos', String(pos[0][0]) + ':' +
	                      String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
	                      String(pos[1][1])]);
	      }
	  }
	  return att;
	}
	
	// quick browser-compatible inheritance
	HtmlRenderer.prototype = Object.create(Renderer.prototype);
	
	HtmlRenderer.prototype.text = text;
	HtmlRenderer.prototype.html_inline = html_inline;
	HtmlRenderer.prototype.html_block = html_block;
	HtmlRenderer.prototype.softbreak = softbreak;
	HtmlRenderer.prototype.linebreak = linebreak;
	HtmlRenderer.prototype.link = link;
	HtmlRenderer.prototype.image = image;
	HtmlRenderer.prototype.emph = emph;
	HtmlRenderer.prototype.strong = strong;
	HtmlRenderer.prototype.paragraph = paragraph;
	HtmlRenderer.prototype.heading = heading;
	HtmlRenderer.prototype.code = code;
	HtmlRenderer.prototype.code_block = code_block;
	HtmlRenderer.prototype.thematic_break = thematic_break;
	HtmlRenderer.prototype.block_quote = block_quote;
	HtmlRenderer.prototype.list = list;
	HtmlRenderer.prototype.item = item;
	HtmlRenderer.prototype.custom_inline = custom_inline;
	HtmlRenderer.prototype.custom_block = custom_block;
	
	HtmlRenderer.prototype.out = out;
	HtmlRenderer.prototype.tag = tag;
	HtmlRenderer.prototype.attrs = attrs;
	
	module.exports = HtmlRenderer;


/***/ },
/* 458 */
/*!*********************************************!*\
  !*** ./~/commonmark/lib/render/renderer.js ***!
  \*********************************************/
/***/ function(module, exports) {

	"use strict";
	
	function Renderer() {}
	
	/**
	 *  Walks the AST and calls member methods for each Node type.
	 *
	 *  @param ast {Node} The root of the abstract syntax tree.
	 */
	function render(ast) {
	  var walker = ast.walker()
	    , event
	    , type;
	
	  this.buffer = '';
	  this.lastOut = '\n';
	
	  while((event = walker.next())) {
	    type = event.node.type;
	    if (this[type]) {
	      this[type](event.node, event.entering);
	    }
	  }
	  return this.buffer;
	}
	
	/**
	 *  Concatenate a literal string to the buffer.
	 *
	 *  @param str {String} The string to concatenate.
	 */
	function lit(str) {
	  this.buffer += str;
	  this.lastOut = str;
	}
	
	function cr() {
	    if (this.lastOut !== '\n') {
	        this.lit('\n');
	    }
	}
	
	/**
	 *  Concatenate a string to the buffer possibly escaping the content.
	 *
	 *  Concrete renderer implementations should override this method.
	 *
	 *  @param str {String} The string to concatenate.
	 */
	function out(str) {
	  this.lit(str);
	}
	
	Renderer.prototype.render = render;
	Renderer.prototype.out = out;
	Renderer.prototype.lit = lit;
	Renderer.prototype.cr  = cr;
	
	module.exports = Renderer;


/***/ },
/* 459 */
/*!*********************************!*\
  !*** ./~/commonmark/lib/xml.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	var escapeXml = __webpack_require__(/*! ./common */ 442).escapeXml;
	
	// Helper function to produce an XML tag.
	var tag = function(name, attrs, selfclosing) {
	    var result = '<' + name;
	    if (attrs && attrs.length > 0) {
	        var i = 0;
	        var attrib;
	        while ((attrib = attrs[i]) !== undefined) {
	            result += ' ' + attrib[0] + '="' + escapeXml(attrib[1]) + '"';
	            i++;
	        }
	    }
	    if (selfclosing) {
	        result += ' /';
	    }
	
	    result += '>';
	    return result;
	};
	
	var reXMLTag = /\<[^>]*\>/;
	
	var toTagName = function(s) {
	    return s.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
	};
	
	var renderNodes = function(block) {
	
	    var attrs;
	    var tagname;
	    var walker = block.walker();
	    var event, node, entering;
	    var buffer = "";
	    var lastOut = "\n";
	    var disableTags = 0;
	    var indentLevel = 0;
	    var indent = '  ';
	    var container;
	    var selfClosing;
	    var nodetype;
	
	    var out = function(s) {
	        if (disableTags > 0) {
	            buffer += s.replace(reXMLTag, '');
	        } else {
	            buffer += s;
	        }
	        lastOut = s;
	    };
	    var esc = this.escape;
	    var cr = function() {
	        if (lastOut !== '\n') {
	            buffer += '\n';
	            lastOut = '\n';
	            for (var i = indentLevel; i > 0; i--) {
	                buffer += indent;
	            }
	        }
	    };
	
	    var options = this.options;
	
	    if (options.time) { console.time("rendering"); }
	
	    buffer += '<?xml version="1.0" encoding="UTF-8"?>\n';
	    buffer += '<!DOCTYPE CommonMark SYSTEM "CommonMark.dtd">\n';
	
	    while ((event = walker.next())) {
	        entering = event.entering;
	        node = event.node;
	        nodetype = node.type;
	
	        container = node.isContainer;
	        selfClosing = nodetype === 'thematic_break' || nodetype === 'linebreak' ||
	            nodetype === 'softbreak';
	        tagname = toTagName(nodetype);
	
	        if (entering) {
	
	            attrs = [];
	
	            switch (nodetype) {
	            case 'document':
	                attrs.push(['xmlns', 'http://commonmark.org/xml/1.0']);
	                break;
	            case 'list':
	                if (node.listType !== null) {
	                    attrs.push(['type', node.listType.toLowerCase()]);
	                }
	                if (node.listStart !== null) {
	                    attrs.push(['start', String(node.listStart)]);
	                }
	                if (node.listTight !== null) {
	                    attrs.push(['tight', (node.listTight ? 'true' : 'false')]);
	                }
	                var delim = node.listDelimiter;
	                if (delim !== null) {
	                    var delimword = '';
	                    if (delim === '.') {
	                        delimword = 'period';
	                    } else {
	                        delimword = 'paren';
	                    }
	                    attrs.push(['delimiter', delimword]);
	                }
	                break;
	            case 'code_block':
	                if (node.info) {
	                    attrs.push(['info', node.info]);
	                }
	                break;
	            case 'heading':
	                attrs.push(['level', String(node.level)]);
	                break;
	            case 'link':
	            case 'image':
	                attrs.push(['destination', node.destination]);
	                attrs.push(['title', node.title]);
	                break;
	            case 'custom_inline':
	            case 'custom_block':
	                attrs.push(['on_enter', node.onEnter]);
	                attrs.push(['on_exit', node.onExit]);
	                break;
	            default:
	                break;
	            }
	            if (options.sourcepos) {
	                var pos = node.sourcepos;
	                if (pos) {
	                    attrs.push(['sourcepos', String(pos[0][0]) + ':' +
	                                String(pos[0][1]) + '-' + String(pos[1][0]) + ':' +
	                                String(pos[1][1])]);
	                }
	            }
	
	            cr();
	            out(tag(tagname, attrs, selfClosing));
	            if (container) {
	                indentLevel += 1;
	            } else if (!container && !selfClosing) {
	                var lit = node.literal;
	                if (lit) {
	                    out(esc(lit));
	                }
	                out(tag('/' + tagname));
	            }
	        } else {
	            indentLevel -= 1;
	            cr();
	            out(tag('/' + tagname));
	        }
	
	
	    }
	    if (options.time) { console.timeEnd("rendering"); }
	    buffer += '\n';
	    return buffer;
	};
	
	// The XmlRenderer object.
	function XmlRenderer(options){
	    return {
	        // default options:
	        softbreak: '\n', // by default, soft breaks are rendered as newlines in HTML
	        // set to "<br />" to make them hard breaks
	        // set to " " if you want to ignore line wrapping in source
	        escape: escapeXml,
	        options: options || {},
	        render: renderNodes
	    };
	}
	
	module.exports = XmlRenderer;


/***/ },
/* 460 */
/*!*******************************************!*\
  !*** ./beeline/templates/termsModal.html ***!
  \*******************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">\n      Terms and Conditions of Service\n    </h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"termsModal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content has-bouncing=\"false\">\n    <div ng-bind-html=\"company.termsHTML\" class=\"item item-text-wrap legal\">\n    </div>\n  </ion-content>\n\n</ion-modal-view>\n";

/***/ },
/* 461 */
/*!***********************************************!*\
  !*** ./beeline/services/SuggestionService.js ***!
  \***********************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($http, UserService) {
	  var suggestions = [];
	  var selectedSuggestion = null;
	  var similarSuggestions = [];
	
	  return {
	    get: function get() {
	      return UserService.beeline({
	        method: 'GET',
	        url: "/suggestions"
	      });
	    },
	    getSuggestions: function getSuggestions() {
	      return suggestions;
	    },
	    getSuggestionById: function getSuggestionById(id) {
	      for (var i = 0; i < suggestions.length; i++) {
	        if (suggestions[i].id == id) {
	          console.log("found suggestion");
	          return suggestions[i];
	        }
	      }
	      return null;
	    },
	    getSimilar: function getSimilar() {
	      return UserService.beeline({
	        method: 'GET',
	        url: "/suggestions/10126/similar"
	      }).then(function (response) {
	        similarSuggestions = response.data;
	        return similarSuggestions;
	      });
	    },
	    getSimilarSuggestions: function getSimilarSuggestions() {
	      return [];
	    },
	
	    setSelectedSuggestion: function setSelectedSuggestion(suggestionId) {
	      console.log("setselectedsuggestion");
	      console.log(suggestionId);
	      for (var i = 0; i < suggestions.length; i++) {
	        if (suggestions[i].id === suggestionId) {
	          selectedSuggestion = suggestions[i];
	        }
	      }
	      console.log("-------------------");
	      console.log("setselectedticket");
	      console.log(selectedSuggestion);
	    },
	    getSelectedSuggestion: function getSelectedSuggestion() {
	      // need to handle if null
	      return selectedSuggestion;
	    }
	  };
	};

/***/ },
/* 462 */
/*!*******************************************!*\
  !*** ./beeline/services/RoutesService.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.default = RoutesService;
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// Adapter function to convert what we get from the server into what we want
	// Ideally shouldn't need this if the server stays up to date
	// Transforms the data in place rather than making a new array
	// This is to save time since its a deep copy
	// and you wont need the original array anyway
	function transformRouteData(data) {
	  (0, _lodash2.default)(data).each(function (route) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = route.trips[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var trip = _step.value;
	
	        _assert2.default.equal(_typeof(trip.date), 'string');
	        trip.date = new Date(trip.date);
	
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = trip.tripStops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var tripStop = _step2.value;
	
	            _assert2.default.equal(_typeof(tripStop.time), 'string');
	            tripStop.time = new Date(tripStop.time);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    var firstTripStops = route.trips[0].tripStops;
	    route.startTime = firstTripStops[0].time;
	    route.startRoad = firstTripStops[0].stop.description;
	    route.endTime = firstTripStops[firstTripStops.length - 1].time;
	    route.endRoad = firstTripStops[firstTripStops.length - 1].stop.description;
	    route.tripsByDate = _lodash2.default.keyBy(route.trips, function (trip) {
	      return trip.date.getTime();
	    });
	  });
	  return data;
	}
	
	function RoutesService($http, UserService, uiGmapGoogleMapApi, $q, p) {
	  // For all routes
	  var routesCache;
	  var activeRoutes;
	  var recentRoutesCache;
	  var recentRoutes;
	
	  // For single routes
	  var lastRouteId = null;
	  var lastPromise = null;
	
	  // For Route Credits
	  var routeCreditsCache;
	  var tagToCreditsMap;
	  var routePassCache;
	  var routeToRidesRemainingMap;
	  var routesWithRoutePassPromise;
	  var routesWithRoutePass;
	  var activatedKickstarterRoutes;
	  var routeToCreditTagsPromise = null;
	  var routeToCreditTags = null;
	
	  UserService.userEvents.on('userChanged', function () {
	    instance.fetchRecentRoutes(true);
	    instance.fetchRouteCredits(true);
	    instance.fetchRoutesWithRoutePass();
	    instance.fetchRecentRoutes(true);
	    instance.fetchRouteCreditTags(true);
	  });
	
	  var instance = {
	
	    // Retrive the data on a single route, but pulls a lot more data
	    // Pulls all the trips plus the route path
	    // getRoute() will return the heavier stuff (all trips, availability, path)
	    getRoute: function getRoute(routeId, ignoreCache, options) {
	      _assert2.default.equal(typeof routeId === 'undefined' ? 'undefined' : _typeof(routeId), 'number');
	
	      if (!ignoreCache && !options && lastRouteId === routeId) {
	        return lastPromise;
	      }
	
	      var startDate = new Date();
	      startDate.setHours(3, 0, 0, 0, 0);
	
	      var finalOptions = _lodash2.default.assign({
	        start_date: startDate.getTime(),
	        include_trips: true,
	        include_availability: true
	      }, options);
	
	      lastRouteId = routeId;
	      return lastPromise = UserService.beeline({
	        method: 'GET',
	        url: '/routes/' + routeId + '?' + _querystring2.default.stringify(finalOptions)
	      }).then(function (response) {
	        transformRouteData([response.data]);
	        return response.data;
	      }).catch(function (err) {
	        console.error(err);
	      });
	    },
	
	    // Returns list of all routes
	    getRoutes: function getRoutes() {
	      return activeRoutes;
	    },
	
	    // Retrive the data on all the routes
	    // But limits the amount of data retrieved
	    // getRoutes() now returns a list of routes, but with very limited
	    // trip data (limited to 5 trips, no path)
	    // Return promise with all routes
	    fetchRoutes: function fetchRoutes(ignoreCache, options) {
	      if (routesCache && !ignoreCache && !options) return routesCache;
	
	      var url = '/routes?';
	
	      // Start at midnight to avoid cut trips in the middle
	      // FIXME: use date-based search instead
	      var startDate = new Date();
	      startDate.setHours(3, 0, 0, 0, 0);
	
	      var finalOptions = _lodash2.default.assign({
	        start_date: startDate.getTime(),
	        include_trips: true,
	        limit_trips: 5,
	        include_path: false,
	        tags: JSON.stringify(['public'])
	      }, options, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {});
	
	      url += _querystring2.default.stringify(finalOptions);
	
	      var routesPromise = UserService.beeline({
	        method: 'GET',
	        url: url
	      }).then(function (response) {
	        // Checking that we have trips, so that users of it don't choke
	        // on trips[0]
	        var routes = response.data.filter(function (r) {
	          return r.trips && r.trips.length;
	        });
	        transformRouteData(routes);
	        activeRoutes = routes;
	        return routes;
	      });
	
	      // Cache the promise -- prevents two requests from being
	      // in flight together
	      if (!options) routesCache = routesPromise;
	
	      return routesPromise;
	    },
	
	    /**
	    @param {Object} search - search parameters:
	    @param {number} search.startLat Starting point latitude
	    @param {number} search.startLng Starting point longitude
	    @param {number} search.endLat Ending point latitude
	    @param {number} search.endLng Ending point longitude
	    @param {Date} search.arrivalTime a Date object where the number of seconds
	                  since midnight is the desired arrival time at the destination
	    @param {Date} search.startTime A Date object.
	                Restricts search results to routes with trips
	                after this time
	    @param {Date} search.endTime a Date object.
	                Restrict search results to routes with trips
	                before this time
	    @return {Promise}
	    **/
	    searchRoutes: function searchRoutes(search) {
	      // return Promise object
	      return UserService.beeline({
	        method: 'GET',
	        url: '/routes/search_by_latlon?' + _querystring2.default.stringify({
	          startLat: search.startLat,
	          startLng: search.startLng,
	          endLat: search.endLat,
	          endLng: search.endLng,
	          arrivalTime: search.arrivalTime,
	          startTime: search.startTime,
	          endTime: search.endTime,
	          tags: JSON.stringify(['public'])
	        })
	      }).then(function (response) {
	        return transformRouteData(response.data);
	      });
	    },
	
	    // Retrieves the recent routes for a user
	    // If not logged in then just returns an empty array
	    fetchRecentRoutes: function fetchRecentRoutes(ignoreCache) {
	      if (UserService.getUser()) {
	        if (recentRoutesCache && !ignoreCache) return recentRoutesCache;
	        return recentRoutesCache = UserService.beeline({
	          method: 'GET',
	          url: '/routes/recent?limit=10'
	        }).then(function (response) {
	          recentRoutes = response.data;
	          return recentRoutes;
	        });
	      } else {
	        //if user not logged in clear recentRoutes
	        recentRoutes = [];
	        return $q.resolve([]);
	      }
	    },
	
	    getRecentRoutes: function getRecentRoutes() {
	      return recentRoutes;
	    },
	
	    // TODO: make a directive, otherwise literoute need to inject this routeservice
	    decodeRoutePath: function decodeRoutePath(path) {
	      _assert2.default.strictEqual(typeof path === 'undefined' ? 'undefined' : _typeof(path), 'string');
	      return uiGmapGoogleMapApi.then(function (googleMaps) {
	        // Array of LatLng objects
	        return googleMaps.geometry.encoding.decodePath(path);
	      });
	    },
	
	    getRouteFeatures: function getRouteFeatures(routeId) {
	      return UserService.beeline({
	        method: 'GET',
	        url: '/routes/' + routeId + '/features'
	      }).then(function (response) {
	        return response.data;
	      }).catch(function (err) {
	        console.error(err);
	      });
	    },
	
	    // Return an array of regions covered by a given array of routes
	    getUniqueRegionsFromRoutes: function getUniqueRegionsFromRoutes(routes) {
	      return (0, _lodash2.default)(routes).map(function (route) {
	        return route.regions;
	      }).flatten().uniqBy('id').sortBy('name').value();
	    },
	
	    // get all routeCredits associated with the user
	    // performs db query where necessary or specified
	    // input:
	    // - ignoreCache - boolean
	    // output:
	    // - Promise containing all routeCredits associated with user
	    fetchRouteCredits: function fetchRouteCredits(ignoreCache) {
	      if (!ignoreCache && routeCreditsCache) {
	        return routeCreditsCache;
	      }
	      // Destroy the cache for dependent calls
	      // This is a hack
	      routesWithRoutePassPromise = null;
	      routePassCache = null;
	
	      var user = UserService.getUser();
	      if (!user) {
	        return routeCreditsCache = Promise.resolve(tagToCreditsMap = null);
	      } else {
	        return routeCreditsCache = UserService.beeline({
	          method: 'GET',
	          url: '/routeCredits'
	        }).then(function (response) {
	          return tagToCreditsMap = response.data;
	        });
	      }
	    },
	
	    // Retrieve routeCredits information from cache
	    // input:
	    // - tag - String: tag associated with route. optional
	    // output:
	    // - Object containing all routeCredits associated with user
	    // - [tag provided] amount of credits specific to the tag
	    getRouteCredits: function getRouteCredits(tag) {
	      if (tag && tagToCreditsMap) {
	        return tagToCreditsMap[tag];
	      } else {
	        return tagToCreditsMap;
	      }
	    },
	
	    // Retrieve the amount of rides remaining for a specific route
	    // input:
	    // - routeId - number: id of route
	    // - creditTag - string: tag associated with route
	    // output:
	    // - promise containing number of rides remaining on the route pass for specified route
	    getRoutePassCount: function getRoutePassCount() {
	      return routeToRidesRemainingMap;
	    },
	
	    // Retrieve the amount of rides remaining for a specific route
	    // input:
	    // - ignoreCache - boolean to determine if cache should be ignored
	    // output:
	    // - promise containing a map of routeId to Rides Remaining
	    fetchRoutePassCount: function fetchRoutePassCount(ignoreCache) {
	      if (ignoreCache || !routePassCache) {
	        var allRoutesPromise = this.fetchRoutes(ignoreCache);
	        var allRouteCreditsPromise = this.fetchRouteCredits(ignoreCache);
	
	        routePassCache = $q.all([allRoutesPromise, allRouteCreditsPromise]).then(function (values) {
	          var allRoutes = values[0];
	          var allRouteCredits = values[1];
	          var allRouteCreditTags = _lodash2.default.keys(allRouteCredits);
	          routeToRidesRemainingMap = {};
	
	          allRoutes.forEach(function (route) {
	            var notableTags = _lodash2.default.intersection(route.tags, allRouteCreditTags);
	            if (notableTags.length < 1) return; //not a kickstarter route
	            if (notableTags.length > 1) {
	              console.log("Error: Route has more than one kickstarter tag");
	              return; // something is wrong..
	            }
	
	            // calculate the rides left in the route pass
	            var creditTag = notableTags[0];
	            var price = route.trips[0].priceF;
	            if (price <= 0) return;
	            var creditsAvailable = parseFloat(allRouteCredits[creditTag]);
	            routeToRidesRemainingMap[route.id] = Math.floor(creditsAvailable / price);
	          });
	
	          return routeToRidesRemainingMap;
	        });
	      }
	
	      return routePassCache;
	    },
	
	    // Generates a list of all routes, modifying those with route
	    // credits remaining with a "ridesRemaining" property
	    // input:
	    // - ignoreCache: boolean determining if cache should be ignored.
	    // carries over to dependencies fetchRoutes and fetchRoutePassCount
	    // output:
	    // - promise containing all routes, modified with ridesRemaining property
	    // side effect:
	    // - updates activatedKickstarterRoutes: array containing only those routes with
	    // ridesRemaining property
	    // - updates routesWithRoutePass: array containing all avaialable routes,
	    // modifying those with route credits remaining with a ridesRemaining property
	    fetchRoutesWithRoutePass: function fetchRoutesWithRoutePass(ignoreCache) {
	      if (ignoreCache || !routesWithRoutePassPromise) {
	        return routesWithRoutePassPromise = $q.all([this.fetchRoutes(ignoreCache), this.fetchRoutePassCount(ignoreCache)]).then(function (_ref) {
	          var _ref2 = _slicedToArray(_ref, 2),
	              allRoutes = _ref2[0],
	              routeToRidesRemainingMap = _ref2[1];
	
	          if (routeToRidesRemainingMap) {
	            routesWithRoutePass = allRoutes.map(function (route) {
	              var clone = _lodash2.default.clone(route);
	              clone.ridesRemaining = route.id in routeToRidesRemainingMap ? routeToRidesRemainingMap[route.id] : null;
	              return clone;
	            });
	            activatedKickstarterRoutes = routesWithRoutePass.filter(function (route) {
	              return route.id in routeToRidesRemainingMap;
	            });
	
	            return routesWithRoutePass;
	          } else {
	            return routesWithRoutePass = allRoutes;
	          }
	        });
	      }
	
	      return routesWithRoutePassPromise;
	    },
	
	    // Returns array containing all avaialable routes,
	    // modifying those with route credits remaining with a ridesRemaining property
	    // Updated by: fetchRoutesWithRoutePass
	    getRoutesWithRoutePass: function getRoutesWithRoutePass() {
	      return routesWithRoutePass;
	    },
	
	    // Returns array containing only those routes with
	    // ridesRemaining property
	    // Updated by: fetchRoutesWithRoutePass
	    getActivatedKickstarterRoutes: function getActivatedKickstarterRoutes() {
	      return activatedKickstarterRoutes;
	    },
	
	    // Returns promise containing a map of all routeId to their corresponding tags
	    // based on the routeCredits available to a user
	    fetchRouteCreditTags: function fetchRouteCreditTags(ignoreCache) {
	      if (!ignoreCache && routeToCreditTagsPromise) {
	        return routeToCreditTagsPromise;
	      }
	
	      var routesPromise = this.fetchRoutesWithRoutePass();
	      var routeCreditsPromise = this.fetchRouteCredits();
	
	      return routeToCreditTagsPromise = $q.all([routesPromise, routeCreditsPromise]).then(function (_ref3) {
	        var _ref4 = _slicedToArray(_ref3, 2),
	            routes = _ref4[0],
	            routeCredits = _ref4[1];
	
	        if (routeCredits) {
	          routeToCreditTags = {};
	          routes.forEach(function (route) {
	            var routeCreditTags = _lodash2.default.keys(routeCredits);
	            var notableTags = _lodash2.default.intersection(route.tags, routeCreditTags);
	
	            if (notableTags.length === 1) {
	              routeToCreditTags[route.id] = notableTags[0];
	            } else if (notableTags.length > 1) {
	              console.log("Error: Route has incorrect number of tags. Total: ", notableTags.length);
	            } else {
	              routeToCreditTags[route.id] = null;
	            }
	          });
	
	          return routeToCreditTags;
	        } else {
	          return routeToCreditTags = null;
	        }
	      });
	    },
	
	    // Returns the credit tag matched to a route if routeId is given 
	    // Otherwise, returns a map of all routeId to their corresponding tags
	    // based on the routeCredits available to a user
	    getRouteCreditTags: function getRouteCreditTags(routeId) {
	      if (routeId && routeToCreditTags) {
	        return routeToCreditTags[routeId];
	      } else {
	        return routeToCreditTags;
	      }
	    }
	
	  };
	  return instance;
	}

/***/ },
/* 463 */
/*!********************************************!*\
  !*** ./beeline/services/CreditsService.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = CreditsService;
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function CreditsService($http, UserService, $q) {
	  // General credits
	  var userCreditsCache;
	  var userCredits;
	
	  // Referral credits
	  var referralCreditsCache;
	  var referralCredits;
	
	  UserService.userEvents.on('userChanged', function () {
	    instance.fetchUserCredits(true);
	    instance.fetchReferralCredits(true);
	  });
	
	  var instance = {
	    getUserCredits: function getUserCredits() {
	      return userCredits;
	    },
	
	    // get general credits associated with user
	    // input:
	    // - ignoreCache - boolean
	    // output: 
	    // - Promise containing amount of general credits associated with user
	    fetchUserCredits: function fetchUserCredits(ignoreCache) {
	      if (!ignoreCache && userCreditsCache) {
	        return userCreditsCache;
	      }
	
	      var user = UserService.getUser();
	
	      if (!user) {
	        return userCreditsCache = Promise.resolve(userCredits = null);
	      } else {
	        return userCreditsCache = UserService.beeline({
	          method: 'GET',
	          url: '/credits'
	        }).then(function (response) {
	          return userCredits = response.data;
	        });
	      }
	    },
	
	    getReferralCredits: function getReferralCredits() {
	      return referralCredits;
	    },
	
	    // get referral credits associated with user
	    // input:
	    // - ignoreCache - boolean
	    // output: 
	    // - Promise containing amount of referral credits associated with user
	    fetchReferralCredits: function fetchReferralCredits(ignoreCache) {
	      if (!ignoreCache && referralCreditsCache) {
	        return referralCreditsCache;
	      }
	
	      var user = UserService.getUser();
	
	      if (!user) {
	        return referralCreditsCache = Promise.resolve(referralCredits = null);
	      } else {
	        return referralCreditsCache = UserService.beeline({
	          method: 'GET',
	          url: '/user/referralCredits'
	        }).then(function (response) {
	          return referralCredits = response.data;
	        });
	      }
	    }
	
	  };
	
	  return instance;
	}

/***/ },
/* 464 */
/*!***********************************************!*\
  !*** ./beeline/services/LiteRoutesService.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; // get lite routes
	// format lite routes with starting time, ending time, no. of timings/trips per day
	// retrieve lists of trips running for certain lite route on certain date
	// driver pings for list of trips running for this route
	// subscriptions for certain lite route ( this may go to tickets service)
	
	
	exports.default = LiteRoutesService;
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function LiteRoutesService($http, UserService, $q, LiteRouteSubscriptionService, p) {
	
	  var liteRoutesCache;
	  var liteRoutesPromise;
	
	  // For single lite route
	  var lastLiteRouteLabel = null;
	  var lastLiteRoutePromise = null;
	
	  var shouldRefreshLiteTickets = false;
	
	  function transformTime(liteRoutesByLabel) {
	    for (var label in liteRoutesByLabel) {
	      var liteRoute = liteRoutesByLabel[label];
	      //no starting time and ending time
	      if (!liteRoute.trips) {
	        liteRoute.startTime = null;
	        liteRoute.endTime = null;
	        return;
	      }
	      var allTripStops = _lodash2.default.flatten(liteRoute.trips.map(function (trip) {
	        return trip.tripStops;
	      }));
	      var allStopTimes = allTripStops.map(function (stop) {
	        return stop.time;
	      }).sort();
	      liteRoute.startTime = allStopTimes[0];
	      liteRoute.endTime = allStopTimes[allStopTimes.length - 1];
	    }
	  }
	
	  // TODO the same label lite route all data fileds should be the same except trips
	  //otherwise reduce make no sense
	  function transformLiteRouteData(data) {
	    var liteRoutesByLabel = _lodash2.default.reduce(data, function (result, value, key) {
	      var label = value.label;
	      if (result[label] && (result[label].trips || value.trips)) {
	        result[label].trips = result[label].trips.concat(value.trips);
	      } else {
	        result[label] = value;
	        //mark isSubscribed as false
	        result[label].isSubscribed = false;
	      }
	      return result;
	    }, {});
	    transformTime(liteRoutesByLabel);
	    //ignor the startingTime and endTime for now
	    return liteRoutesByLabel;
	  }
	
	  var instance = {
	    // Retrive the data on all lite routes
	    // But limits the amount of data retrieved
	    // getRoutes() now returns a list of routes, but with very limited
	    // trip data (limited to 5 trips, no path)
	    getLiteRoutes: function getLiteRoutes(ignoreCache, options) {
	      if (liteRoutesCache && !ignoreCache && !options) return liteRoutesCache;
	
	      var url = '/routes?';
	
	      // Start at midnight to avoid cut trips in the middle
	      // FIXME: use date-based search instead
	      var startDate = new Date();
	      startDate.setHours(3, 0, 0, 0, 0);
	
	      var finalOptions = _lodash2.default.assign({
	        start_date: startDate.getTime(),
	        include_path: false,
	        include_trips: true,
	        limit_trips: 5,
	        tags: JSON.stringify(['lite'])
	      }, options, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {});
	
	      url += _querystring2.default.stringify(finalOptions);
	
	      var liteRoutesPromise = UserService.beeline({
	        method: 'GET',
	        url: url
	      }).then(function (response) {
	        // Checking that we have trips, so that users of it don't choke
	        // on trips[0]
	        var liteRoutes = response.data.filter(function (r) {
	          return r.trips && r.trips.length;
	        });
	        liteRoutes = transformLiteRouteData(liteRoutes);
	        return liteRoutes;
	      });
	
	      // Cache the promise -- prevents two requests from being
	      // in flight together
	      if (!options) liteRoutesCache = liteRoutesPromise;
	      return liteRoutesPromise;
	    },
	
	    getLiteRoute: function getLiteRoute(liteRouteLabel, ignoreCache, options) {
	      _assert2.default.equal(typeof liteRouteLabel === 'undefined' ? 'undefined' : _typeof(liteRouteLabel), 'string');
	
	      if (!ignoreCache && !options && lastLiteRouteLabel === liteRouteLabel) {
	        return lastLiteRoutePromise;
	      }
	
	      var startDate = new Date();
	      startDate.setHours(3, 0, 0, 0, 0);
	
	      var finalOptions = _lodash2.default.assign({
	        start_date: startDate.getTime(),
	        include_trips: true,
	        tags: JSON.stringify(['lite']),
	        label: liteRouteLabel,
	        include_path: true
	      }, options, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {});
	
	      var url = '/routes?';
	      url += _querystring2.default.stringify(finalOptions);
	
	      lastLiteRouteLabel = liteRouteLabel;
	      return lastLiteRoutePromise = UserService.beeline({
	        method: 'GET',
	        url: url
	      }).then(function (response) {
	        var liteRouteData = transformLiteRouteData(response.data);
	        return liteRouteData;
	      }).catch(function (err) {
	        console.error(err);
	      });
	    },
	
	    subscribeLiteRoute: function subscribeLiteRoute(liteRouteLabel) {
	      var subscribePromise = UserService.beeline({
	        method: 'POST',
	        url: '/liteRoutes/subscriptions',
	        data: {
	          routeLabel: liteRouteLabel
	        }
	      }).then(function (response) {
	        shouldRefreshLiteTickets = true;
	        if (response.data) {
	          LiteRouteSubscriptionService.getSubscriptionSummary().push(liteRouteLabel);
	          return true;
	        } else {
	          return false;
	        }
	      });
	      return subscribePromise;
	    },
	
	    unsubscribeLiteRoute: function unsubscribeLiteRoute(liteRouteLabel) {
	
	      var unsubscribePromise = UserService.beeline({
	        method: 'DELETE',
	        url: '/liteRoutes/subscriptions/' + liteRouteLabel
	      }).then(function (response) {
	        shouldRefreshLiteTickets = true;
	        if (response.data) {
	          var index = LiteRouteSubscriptionService.getSubscriptionSummary().indexOf(liteRouteLabel);
	          LiteRouteSubscriptionService.getSubscriptionSummary().splice(index, 1);
	          return true;
	        } else {
	          return false;
	        }
	      });
	      return unsubscribePromise;
	    },
	
	    //consolidate tripstops for lite route
	    //aggregate stop time for stops
	    computeLiteStops: function computeLiteStops(trips) {
	      var tripStops = _lodash2.default.map(trips, function (trip) {
	        return trip.tripStops;
	      });
	      var allTripStops = _lodash2.default.flatten(tripStops);
	
	      var boardStops = _lodash2.default.groupBy(allTripStops, function (tripStop) {
	        return tripStop.stop.id;
	      });
	      var newStops = [];
	      for (var stopId in boardStops) {
	        var stop = boardStops[stopId][0].stop;
	        stop.canBoard = boardStops[stopId][0].canBoard;
	        var timeArray = _lodash2.default.map(boardStops[stopId], function (stop) {
	          return stop.time;
	        });
	        var sortedTime = (0, _lodash2.default)(timeArray).uniq().sort().value();
	        newStops.push(_lodash2.default.extend({ "time": sortedTime }, stop));
	      }
	      return newStops;
	    },
	
	    getShouldRefreshLiteTickets: function getShouldRefreshLiteTickets() {
	      return shouldRefreshLiteTickets;
	    },
	
	    clearShouldRefreshLiteTickets: function clearShouldRefreshLiteTickets() {
	      shouldRefreshLiteTickets = false;
	    },
	    transformLiteRouteData: transformLiteRouteData
	  };
	
	  return instance;
	}

/***/ },
/* 465 */
/*!********************************************!*\
  !*** ./beeline/services/BookingService.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (UserService, CompanyService, RoutesService, $http) {
	  this.prepareTrips = function (booking) {
	    // create a list of trips
	    var trips = [];
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = booking.selectedDates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var dt = _step.value;
	
	        trips.push({
	          tripId: booking.route.tripsByDate[dt].id,
	          boardStopId: booking.route.tripsByDate[dt].tripStops.filter(function (ts) {
	            return booking.boardStopId == ts.stop.id;
	          })[0].id,
	          alightStopId: booking.route.tripsByDate[dt].tripStops.filter(function (ts) {
	            return booking.alightStopId == ts.stop.id;
	          })[0].id
	        });
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    return trips;
	  };
	
	  /* If a booking has selectedDates array, then it
	    checks the prices.
	  */
	  this.computePriceInfo = function (booking) {
	    var _this = this;
	
	    if (!booking.selectedDates || booking.selectedDates.length == 0) {
	      return Promise.resolve({
	        total: 0
	      });
	    } else {
	      var trips = this.prepareTrips(booking);
	
	      var rv = UserService.beeline({
	        method: 'POST',
	        url: '/transactions/ticket_sale',
	        data: {
	          creditTag: booking.applyRouteCredits ? booking.creditTag : null,
	          trips: trips,
	          dryRun: true,
	          promoCode: booking.promoCode ? {
	            code: booking.promoCode
	          } : null,
	          applyCredits: booking.applyCredits,
	          applyReferralCredits: booking.applyReferralCredits
	        }
	      }).then(function (resp) {
	        // Find the 'payment' entry in the list of transaction itemss
	        var txItems = _lodash2.default.groupBy(resp.data.transactionItems, 'itemType');
	        var totalBeforeDiscount = _lodash2.default.reduce(txItems.ticketSale, function (sum, n) {
	          return sum + parseFloat(n.credit);
	        }, 0);
	
	        // FIXME: include discounts, vouchers
	        return {
	          totalDue: txItems.payment[0].debit,
	          tripCount: trips.length,
	          pricesPerTrip: _this.summarizePrices(booking),
	          routeCredits: txItems['routeCredits'],
	          referralCredits: txItems['referralCredits'],
	          credits: txItems['userCredit'],
	          discounts: txItems.discount,
	          totalBeforeDiscount: totalBeforeDiscount
	        };
	      }).then(null, function (err) {
	        console.log(err.stack);
	        throw err;
	      });
	
	      return rv;
	    }
	  };
	
	  this.summarizePrices = function (booking) {
	    if (!booking.selectedDates) {
	      return [];
	    }
	
	    var dates = _lodash2.default.sortBy(booking.selectedDates);
	
	    if (dates.length == 0) return [];
	
	    var current = {};
	    var rv = [];
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = dates[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var dt = _step2.value;
	
	        current = {
	          startDate: dt,
	          price: booking.route.tripsByDate[dt].price,
	          bookingInfo: booking.route.tripsByDate[dt].bookingInfo
	        };
	        rv.push(current);
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	
	    return rv;
	  };
	
	  this.computeChanges = function (route) {
	    // convert dates (should be in ISO format therefore sortable)
	    route.trips = _lodash2.default.sortBy(route.trips, function (trip) {
	      return trip.date;
	    });
	
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	      for (var _iterator3 = route.trips[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	        var trip = _step3.value;
	
	        trip.date = new Date(trip.date);
	        var _iteratorNormalCompletion10 = true;
	        var _didIteratorError10 = false;
	        var _iteratorError10 = undefined;
	
	        try {
	          for (var _iterator10 = trip.tripStops[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
	            var tripStop = _step10.value;
	
	            tripStop.time = new Date(tripStop.time);
	          }
	        } catch (err) {
	          _didIteratorError10 = true;
	          _iteratorError10 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion10 && _iterator10.return) {
	              _iterator10.return();
	            }
	          } finally {
	            if (_didIteratorError10) {
	              throw _iteratorError10;
	            }
	          }
	        }
	      }
	
	      // summarize trips by date
	    } catch (err) {
	      _didIteratorError3 = true;
	      _iteratorError3 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion3 && _iterator3.return) {
	          _iterator3.return();
	        }
	      } finally {
	        if (_didIteratorError3) {
	          throw _iteratorError3;
	        }
	      }
	    }
	
	    route.tripsByDate = _lodash2.default.keyBy(route.trips, function (t) {
	      return t.date.getTime();
	    });
	
	    var changes = {
	      timeChanges: [],
	      priceChanges: [],
	      stopChanges: []
	    };
	
	    /**
	      Produce an array of changes.
	       @param trips
	      @param comparable : function (trip : Trip) : T, where T can be compared for changes
	      @param humanReadable : function (before : Trip, after : Trip) : string,
	          A human-readable message telling the user what has changed
	       @returns An array, Each entry consists of an object with
	      the following properties:
	        startDate : Date,
	        endDate: Date,
	        comparable: Result of comparable(trip),
	        humanReadable: Result of humanReadable(before, after)
	     */
	    function summarizeChanges(trips, comparable, humanReadable) {
	      var changes = [];
	      // var current = {};
	      var lastComparable = undefined;
	      var lastTrip = undefined;
	
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;
	
	      try {
	        for (var _iterator4 = trips[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var trip = _step4.value;
	
	          // if (current.startDate == undefined) {
	          //   current.startDate = trip.date;
	          //   current.endDate = trip.date;
	          // }
	
	          var valueComparable = comparable(trip);
	          if (lastComparable == undefined) lastComparable = valueComparable;
	
	          if (lastComparable != valueComparable) {
	            var hr = humanReadable(lastTrip, trip);
	
	            changes.push({
	              startDate: trip.date,
	              humanReadable: hr,
	              comparable: valueComparable
	            });
	            // current = {
	            //   startDate: trip.date,
	            //   endDate: trip.date,
	            // };
	          }
	
	          // current.endDate = trip.date;
	          lastTrip = trip;
	          lastComparable = valueComparable;
	        }
	        // if (changes.length != 0) {
	        //   changes.push(current);
	        // }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }
	
	      return changes;
	    }
	
	    var _iteratorNormalCompletion5 = true;
	    var _didIteratorError5 = false;
	    var _iteratorError5 = undefined;
	
	    try {
	      for (var _iterator5 = route.trips[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	        var _trip = _step5.value;
	
	        _trip.tripStops = _lodash2.default.sortBy(_trip.tripStops, function (ts) {
	          return ts.time;
	        });
	      }
	
	      // summarize price/stop/time
	    } catch (err) {
	      _didIteratorError5 = true;
	      _iteratorError5 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion5 && _iterator5.return) {
	          _iterator5.return();
	        }
	      } finally {
	        if (_didIteratorError5) {
	          throw _iteratorError5;
	        }
	      }
	    }
	
	    changes.priceChanges = summarizeChanges(route.trips, function (trip) {
	      return trip.price;
	    }, function (bef, aft) {
	      return ['Ticket price changed from $' + bef.price + ' to $' + aft.price];
	    });
	
	    changes.stopChanges = summarizeChanges(route.trips, function (trip) {
	      return trip.tripStops.map(function (ts) {
	        return ts.stop.id;
	      }).join(',');
	    }, function (bef, aft) {
	      var stopInfo = {};
	
	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;
	
	      try {
	        for (var _iterator6 = bef.tripStops[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var ts = _step6.value;
	
	          stopInfo[ts.stop.id] = ts.stop;
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }
	
	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;
	
	      try {
	        for (var _iterator7 = aft.tripStops[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var _ts = _step7.value;
	
	          stopInfo[_ts.stop.id] = _ts.stop;
	        }
	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }
	
	      var beforeStops = bef.tripStops.map(function (ts) {
	        return ts.stop.id;
	      });
	      var afterStops = aft.tripStops.map(function (ts) {
	        return ts.stop.id;
	      });
	
	      var droppedStops = _lodash2.default.subtract(beforeStops, afterStops);
	      var newStops = _lodash2.default.subtract(afterStops, beforeStops);
	
	      var messages = [];
	      if (droppedStops.length > 0) {
	        messages.push('Stops ' + droppedStops.map(function (sid) {
	          return stopInfo[sid].description;
	        }).join(', ') + ' no longer serviced');
	      }
	      if (newStops.length > 0) {
	        messages.push('New stops ' + newStops.map(function (sid) {
	          return stopInfo[sid].description;
	        }).join(', ') + ' added to route');
	      }
	      return messages;
	    });
	
	    console.log(route.trips.map(function (t) {
	      return t.date;
	    }).join('\n'));
	    console.log(route.trips.map(function (trip) {
	      return trip.tripStops.map(function (ts) {
	        return ts.time.getTime() % (24 * 60 * 60 * 1000) + ':' + ts.stop.id;
	      }).sort().join(',');
	    }).join('\n'));
	    changes.timeChanges = summarizeChanges(route.trips, function (trip) {
	      return trip.tripStops.map(function (ts) {
	        return ts.time.getTime() % (24 * 60 * 60 * 1000) + ':' + ts.stop.id;
	      }).sort().join(',');
	    }, function (bef, aft) {
	      var messages = [];
	
	      var befStopInfo = {};
	      var aftStopInfo = {};
	
	      var _iteratorNormalCompletion8 = true;
	      var _didIteratorError8 = false;
	      var _iteratorError8 = undefined;
	
	      try {
	        for (var _iterator8 = aft.tripStops[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	          var ts = _step8.value;
	
	          aftStopInfo[ts.stop.id] = ts;
	        }
	      } catch (err) {
	        _didIteratorError8 = true;
	        _iteratorError8 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion8 && _iterator8.return) {
	            _iterator8.return();
	          }
	        } finally {
	          if (_didIteratorError8) {
	            throw _iteratorError8;
	          }
	        }
	      }
	
	      var _iteratorNormalCompletion9 = true;
	      var _didIteratorError9 = false;
	      var _iteratorError9 = undefined;
	
	      try {
	        for (var _iterator9 = bef.tripStops[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	          var _ts2 = _step9.value;
	
	          if (!(_ts2.stop.id in aftStopInfo)) {
	            continue; /* if stop was added, then it would have been handled by
	                      stop change messages */
	          }
	          var befTime = (0, _format.formatTime)(new Date(_ts2.time));
	          var aftTime = (0, _format.formatTime)(new Date(aftStopInfo[_ts2.stop.id].time));
	
	          messages.push('Arrival time at stop ' + _ts2.stop.description + ' changed from ' + befTime + ' to ' + aftTime);
	        }
	      } catch (err) {
	        _didIteratorError9 = true;
	        _iteratorError9 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion9 && _iterator9.return) {
	            _iterator9.return();
	          }
	        } finally {
	          if (_didIteratorError9) {
	            throw _iteratorError9;
	          }
	        }
	      }
	
	      return messages;
	    });
	    return changes;
	  };
	
	  this.computeStops = function (trips) {
	    var tripStops = _lodash2.default.flatten(trips.map(function (trip) {
	      return trip.tripStops;
	    }));
	    var uniqueStops = _lodash2.default.uniqBy(tripStops, function (ts) {
	      return ts.stop.id;
	    });
	    var stopData = _lodash2.default.keyBy(uniqueStops, function (ts) {
	      return ts.stop.id;
	    });
	
	    var boardStops = (0, _lodash2.default)(uniqueStops).filter(function (ts) {
	      return ts.canBoard;
	    }).map(function (ts) {
	      return _lodash2.default.extend({ canBoard: true, time: ts.time, timeSinceMidnight: (0, _format.timeSinceMidnight)(ts.time) }, ts.stop);
	    }).orderBy(function (s) {
	      return s.timeSinceMidnight;
	    }).value();
	    var alightStops = (0, _lodash2.default)(uniqueStops).filter(function (ts) {
	      return ts.canAlight;
	    }).map(function (ts) {
	      return _lodash2.default.extend({ canBoard: false, time: ts.time, timeSinceMidnight: (0, _format.timeSinceMidnight)(ts.time) }, ts.stop);
	    }).orderBy(function (s) {
	      return s.timeSinceMidnight;
	    }).value();
	    return [boardStops, alightStops];
	  };
	
	  // Sets up booking sessions
	  var session = Date.now();
	  this.newSession = function () {
	    return ++session;
	  };
	  this.getSession = function () {
	    return session;
	  };
	};
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 466 */
/*!**********************************!*\
  !*** ./beeline/shared/errors.js ***!
  \**********************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var NetworkError = exports.NetworkError = function (_Error) {
	  _inherits(NetworkError, _Error);
	
	  function NetworkError(str) {
	    _classCallCheck(this, NetworkError);
	
	    return _possibleConstructorReturn(this, (NetworkError.__proto__ || Object.getPrototypeOf(NetworkError)).call(this, str));
	  }
	
	  return NetworkError;
	}(Error);

/***/ },
/* 467 */
/*!*******************************************!*\
  !*** ./beeline/services/OneMapService.js ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($http) {
	  var tokenRequest;
	  return {
	    token: function token() {
	      if (tokenRequest) return tokenRequest;else {
	        return tokenRequest = $http.get('http://www.onemap.sg/API/services.svc/getToken?accessKEY=qo/s2TnSUmfLz+32CvLC4RMVkzEFYjxqyti1KhByvEacEdMWBpCuSSQ+IFRT84QjGPBCuz/cBom8PfSm3GjEsGc8PkdEEOEr').then(function (response) {
	          console.log(response);
	          return response.data.GetToken[0].NewToken;
	        });
	      }
	    }
	  };
	};
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);

/***/ },
/* 468 */
/*!*****************************************!*\
  !*** ./beeline/services/DateService.js ***!
  \*****************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return { date: new Date() };
	};

/***/ },
/* 469 */
/*!*******************************************!*\
  !*** ./beeline/services/StripeService.js ***!
  \*******************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = initStripe;
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	function initStripe(UserService, $ionicPopup, $ionicPlatform, $rootScope) {
	  var tokenFromCardIO = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(description, amount, isAddPayment) {
	      var cardDetails, tokenPromise;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return new Promise(function (resolve, reject) {
	                return CardIO.scan({
	                  "expiry": true,
	                  "cvv": true,
	                  "zip": false,
	                  "suppressManual": false,
	                  "suppressConfirm": false,
	                  "hideLogo": true
	                }, resolve, function () {
	                  return resolve(null);
	                });
	              });
	
	            case 2:
	              cardDetails = _context.sent;
	
	              if (!(cardDetails == null)) {
	                _context.next = 5;
	                break;
	              }
	
	              return _context.abrupt('return');
	
	            case 5:
	              tokenPromise = new Promise(function (resolve, reject) {
	                return Stripe.createToken({
	                  number: cardDetails["card_number"],
	                  cvc: cardDetails["cvv"],
	                  exp_month: cardDetails["expiry_month"],
	                  exp_year: cardDetails["expiry_year"]
	                });
	              }, function (statusCode, response) {
	                if (response.error) reject(new Error(response.error.message));else resolve(response);
	              });
	              return _context.abrupt('return', tokenPromise);
	
	            case 7:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this);
	    }));
	
	    return function tokenFromCardIO(_x, _x2, _x3) {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  var stripeKeyPromise = UserService.beeline({
	    url: '/stripe-key',
	    method: 'GET'
	  }).then(function (response) {
	    Stripe.setPublishableKey(response.data.publicKey);
	    return response.data.publicKey;
	  });
	
	  function tokenFromStripeCheckout(description, amount, isAddPayment) {
	    return stripeKeyPromise.then(function (stripeKey) {
	      return new Promise(function (resolve, reject) {
	        var deregister;
	        var handler = StripeCheckout.configure({
	          key: stripeKey,
	          locale: 'auto',
	          // allowRememberMe: false,
	          token: function token(_token) {
	            deregister();
	            resolve(_token);
	          },
	          closed: function closed() {
	            deregister();
	            resolve(null);
	          }
	        });
	
	        deregister = $ionicPlatform.registerBackButtonAction(function () {
	          handler.close();
	        }, 401);
	
	        var handlerOptions = {
	          name: $rootScope.o.APP.NAME,
	          description: description,
	          amount: Math.round(amount),
	          allowRememberMe: false,
	          currency: 'SGD',
	          email: UserService.getUser().email
	        };
	
	        if (isAddPayment) {
	          handlerOptions = {
	            name: 'Add Card Details',
	            description: description,
	            panelLabel: "Add Card",
	            allowRememberMe: false,
	            email: UserService.getUser().email
	          };
	        }
	
	        handler.open(handlerOptions);
	      });
	    });
	  };
	
	  ;
	
	  return {
	    promptForToken: function promptForToken(description, amount, isAddPayment) {
	      var _this = this;
	
	      return _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	        var tokenPromise;
	        return regeneratorRuntime.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	
	                if (window.CardIO) {
	                  tokenPromise = tokenFromCardIO(description, amount, isAddPayment);
	                } else if (StripeCheckout) {
	                  tokenPromise = tokenFromStripeCheckout(description, amount, isAddPayment);
	                }
	
	                tokenPromise.catch(function (err) {
	                  $ionicPopup.alert('There was an error contacting Stripe. ' + (err && err.message));
	                });
	
	                return _context2.abrupt('return', tokenPromise);
	
	              case 3:
	              case 'end':
	                return _context2.stop();
	            }
	          }
	        }, _callee2, _this);
	      }))();
	    },
	
	    loaded: typeof StripeCheckout !== 'undefined' ? true : false
	  };
	}

/***/ },
/* 470 */
/*!********************************************!*\
  !*** ./beeline/services/LoadingSpinner.js ***!
  \********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	/**
	
	loadingSpinner(promise1);
	loadingSpinner(promise2);
	
	Equivalent to: loadingSpinner(Promise.all([promise1, promise2]))
	
	loadingSpinner(promise)
	
	Almost equivalent to (but subject to the above):
	try {
	  $ionicLoading.show(...);
	  await promise;
	} finally {
	  $ionicLoading.hide();
	}
	
	**/
	
	
	exports.default = function ($ionicLoading) {
	  /* Number of promises being watched by loading spinner */
	  var count = 0;
	
	  function hide() {
	    count = Math.max(0, count - 1);
	    if (count === 0) {
	      $ionicLoading.hide();
	    }
	  }
	  function show() {
	    if (count === 0) {
	      $ionicLoading.show({ template: _loading2.default });
	    }
	    count = count + 1;
	  }
	
	  return function (p) {
	    _assert2.default.strictEqual(_typeof(p.then), 'function');
	    show();
	
	    p.then(hide, function (err) {
	      hide();
	      throw err;
	    });
	    return p;
	  };
	};
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 471 */
/*!****************************************!*\
  !*** ./beeline/templates/loading.html ***!
  \****************************************/
/***/ function(module, exports) {

	module.exports = "<div>Loading...</div>\n<br>\n<ion-spinner icon='ios'></ion-spinner>\n";

/***/ },
/* 472 */
/*!*********************************************!*\
  !*** ./beeline/services/GoogleAnalytics.js ***!
  \*********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return function () {
	    window.ga.apply(window, arguments);
	  };
	};
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	(function (i, s, o, g, r, a, m) {
	  i['GoogleAnalyticsObject'] = r;i[r] = i[r] || function () {
	    (i[r].q = i[r].q || []).push(arguments);
	  }, i[r].l = 1 * new Date();a = s.createElement(o), m = s.getElementsByTagName(o)[0];a.async = 1;a.src = g;m.parentNode.insertBefore(a, m);
	})(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');
	
	var devicePromise = new Promise(function (resolve, reject) {
	  if (window.cordova) {
	    document.addEventListener('deviceready', resolve, false);
	  } else {
	    console.log('No cordova detected');
	    resolve();
	  }
	});
	
	angular.module('beeline').run(['$rootScope', function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee($rootScope) {
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return devicePromise;
	
	          case 2:
	
	            if (window.cordova) {
	              (function () {
	                var GA_LOCAL_STORAGE_KEY = 'ga:clientId';
	                // Set up cordova to use localstorage over cookies (file:/// doesn't
	                // support cookies)
	                ga('create', 'UA-79537959-1', {
	                  storage: 'none',
	                  clientId: localStorage.getItem(GA_LOCAL_STORAGE_KEY)
	                });
	                ga(function (tracker) {
	                  localStorage.setItem(GA_LOCAL_STORAGE_KEY, tracker.get('clientId'));
	                });
	
	                // We have a file:/// URL, but tell GA to ignore it
	                ga('set', 'checkProtocolTask', null);
	              })();
	            } else {
	              ga('create', 'UA-79537959-1', 'auto');
	            }
	            // The first page view
	            ga('send', 'pageview', {
	              page: window.location.hash.substr(1)
	            });
	
	            $rootScope.$on('$stateChangeSuccess', function (evt, state) {
	              ga('send', 'pageview', {
	                page: window.location.hash.substr(1)
	              });
	            });
	
	            if (window.cordova) {
	              window.cordova.getAppVersion.getVersionNumber().then(function (version) {
	                ga('set', 'appVersion', version);
	              });
	              window.cordova.getAppVersion.getAppName().then(function (appName) {
	                ga('set', 'appName', appName);
	              });
	            } else {
	              ga('set', 'appVersion', window.location.origin);
	              ga('set', 'appName', 'Beeline Web');
	            }
	
	          case 6:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	
	  return function (_x) {
	    return _ref.apply(this, arguments);
	  };
	}()]);

/***/ },
/* 473 */
/*!*******************************************!*\
  !*** ./beeline/services/SearchService.js ***!
  \*******************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = SearchService;
	function SearchService() {
	  return {
	
	    // Returns a new array with routes matching the given regionId
	    // If regionId is undefined then returns a new array with all the same routes
	    filterRoutesByRegionId: function filterRoutesByRegionId(routes, regionId) {
	      return _.filter(routes, function (route) {
	        if (regionId) return _.some(route.regions, { 'id': regionId });else return true;
	      });
	    },
	
	    filterRoutesByText: function filterRoutesByText(routes, string) {
	      var _this = this;
	
	      return routes.filter(function (route) {
	        return _this.routeContainsString(route, string);
	      });
	    },
	
	    filterRoutes: function filterRoutes(routes, regionId, string) {
	      return this.filterRoutesByText(this.filterRoutesByRegionId(routes, regionId), string);
	    },
	
	    // Input: a Route and a string
	    // Output: True if route metatdata contains the string
	    routeContainsString: function routeContainsString(route, string) {
	      if (!string) return true;
	
	      function containsIgnoreCase(s, t) {
	        if (typeof s == 'string') {
	          return s.toUpperCase().includes(t.toUpperCase());
	        } else {
	          return false;
	        }
	      }
	      return containsIgnoreCase(route.name, string) || containsIgnoreCase(route.notes && route.notes.description, string) || containsIgnoreCase(route.schedule, string) || containsIgnoreCase(route.label, string) || route.trips[0] && (route.trips[0].tripStops.some(function (ts) {
	        return containsIgnoreCase(ts.stop.description, string);
	      }) || route.trips[0].tripStops.some(function (ts) {
	        return containsIgnoreCase(ts.stop.road, string);
	      })) || route.regions.some(function (region) {
	        return containsIgnoreCase(region.name, string);
	      });
	    }
	
	  };
	}

/***/ },
/* 474 */
/*!****************************************!*\
  !*** ./beeline/services/MapOptions.js ***!
  \****************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var googleMaps;
	
	exports.default = ['uiGmapGoogleMapApi', '$cordovaGeolocation', function (uiGmapGoogleMapApi, $cordovaGeolocation) {
	  var markerOptionsPromise = uiGmapGoogleMapApi.then(function (googleMaps) {
	    return {
	      markerOptions: {
	        boardMarker: {
	          icon: {
	            url: 'img/map/MapRoutePickupStop@2x.png',
	            scaledSize: new googleMaps.Size(26, 25),
	            anchor: new googleMaps.Point(13, 13)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 1
	        },
	        alightMarker: {
	          icon: {
	            url: 'img/map/MapRouteDropoffStop@2x.png',
	            scaledSize: new googleMaps.Size(26, 25),
	            anchor: new googleMaps.Point(13, 13)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 1
	        },
	        startMarker: {
	          icon: {
	            url: 'img/map/SelectedPinStart@2x.png',
	            scaledSize: new googleMaps.Size(34, 46),
	            anchor: new googleMaps.Point(17, 41)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 2
	        },
	        endMarker: {
	          icon: {
	            url: 'img/map/SelectedPinStop@2x.png',
	            scaledSize: new googleMaps.Size(34, 46),
	            anchor: new googleMaps.Point(17, 41)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 2
	        }
	      },
	      pathOptions: {
	        routePath: {
	          color: '#4b3863',
	          weight: 3.0,
	          opacity: 0.7
	        },
	        actualPath: {
	          color: '#000000',
	          weight: 3.0,
	          opacity: 1.0
	        }
	      },
	      bounds: {
	        Singapore: {
	          north: 1.516329,
	          east: 104.08,
	          south: 1.1954,
	          west: 103.5814
	        }
	      }
	    };
	  });
	
	  this.defaultMapOptions = function (options) {
	    var mapOptions = _.assign({
	      center: { latitude: 1.370244, longitude: 103.823315 },
	      zoom: 11,
	      bounds: { // so that autocomplete will mainly search within Singapore
	        northeast: {
	          latitude: 1.485152,
	          longitude: 104.091837
	        },
	        southwest: {
	          latitude: 1.205764,
	          longitude: 103.589899
	        }
	      },
	      control: {},
	      options: {
	        disableDefaultUI: true,
	        styles: [{
	          featureType: "poi",
	          stylers: [{
	            visibility: "off"
	          }]
	        }],
	        draggable: true,
	        gestureHandling: 'greedy'
	      },
	      markerOptions: {
	        alightMarker: {},
	        boardMarker: {},
	        startMarker: {},
	        endMarker: {}
	      },
	      events: {},
	      markers: [],
	      lines: []
	    }, options || {});
	
	    markerOptionsPromise.then(function (options) {
	      _.assign(mapOptions, options);
	    });
	
	    return mapOptions;
	  };
	
	  this.locateMe = function (mapControl) {
	    var options = {
	      timeout: 5000,
	      enableHighAccuracy: true
	    };
	
	    // promise
	    // FIXME: use navigator.geoLocation
	    $cordovaGeolocation.getCurrentPosition({ timeout: 5000, enableHighAccuracy: true }).then(function (userpos) {
	      if (!mapControl.getGMap) return;
	
	      var gmap = mapControl.getGMap();
	
	      gmap.panTo(new google.maps.LatLng(userpos.coords.latitude, userpos.coords.longitude));
	      setTimeout(function () {
	        gmap.setZoom(17);
	      }, 300);
	    }, function (err) {
	      console.log('ERROR - ' + err);
	    });
	  };
	
	  this.disableMapLinks = function () {
	    setTimeout(function () {
	      var anchorElems = document.querySelectorAll('ui-gmap-google-map a[href]');
	
	      for (var i = 0; i < anchorElems.length; i++) {
	        var anchorElem = anchorElems[i];
	        if (!anchorElem.dataset['clickDisabled']) {
	          anchorElem.addEventListener('click', function (e) {
	            return e.preventDefault();
	          });
	          anchorElem.dataset['clickDisabled'] = true;
	        }
	      }
	    }, 300);
	  };
	
	  this.resizePreserveCenter = function (map) {
	    var oldCenter = map.getCenter();
	    google.maps.event.trigger(map, 'resize');
	    map.setCenter(oldCenter);
	  };
	}];

/***/ },
/* 475 */
/*!***************************************************!*\
  !*** ./beeline/services/busStopSelectorDialog.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($rootScope, $ionicModal, MapOptions, uiGmapGoogleMapApi, $ionicScrollDelegate) {
	  var scope = $rootScope.$new();
	
	  initializeScope(scope);
	  scope.selectionModal = $ionicModal.fromTemplate(_busStopSelectorList2.default, {
	    scope: scope,
	    animation: 'slide-in-up'
	  });
	
	  this.show = function (options) {
	    _lodash2.default.assign(scope, _lodash2.default.pick(options, ['busStops', 'markerOptions', 'title', 'button', 'pinOptions']));
	    scope.data.selectedStop = options.selectedStop;
	
	    return new Promise(function (resolve, reject) {
	      // Initialize the selected stop
	      scope.selectionModal.show().then(function () {
	        scope.fitMap();
	
	        // I have no idea why $getByHandle doesn't work in Ionic 1.3.1
	        // var scrollDelegate = $ionicScrollDelegate.$getByHandle('stopsListScroll');
	        var scrollDelegate = $ionicScrollDelegate._instances.find(function (inst) {
	          return inst.$$delegateHandle === 'stopsListScroll';
	        });
	        scrollDelegate.resize();
	        scrollDelegate.scrollTop();
	      });
	      scope.resolve = resolve;
	    });
	  };
	
	  /**
	    Initializes properties and methods on scope
	     @prop map
	    @method fitMap
	    @method selectStop -- fired when tapping on a stop in the list
	    @method close -- closes the modal
	  **/
	  function initializeScope(scope) {
	    var _this = this;
	
	    scope.data = {};
	    scope.map = MapOptions.defaultMapOptions();
	
	    scope.fitMap = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	      var bounds, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, bs;
	
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              _context.next = 2;
	              return uiGmapGoogleMapApi;
	
	            case 2:
	              MapOptions.disableMapLinks();
	
	              if (!(!scope.map.control || !scope.busStops || scope.busStops.length == 0)) {
	                _context.next = 5;
	                break;
	              }
	
	              return _context.abrupt('return');
	
	            case 5:
	              // Pan to the bus stops
	              bounds = new google.maps.LatLngBounds();
	              _iteratorNormalCompletion = true;
	              _didIteratorError = false;
	              _iteratorError = undefined;
	              _context.prev = 9;
	
	              for (_iterator = scope.busStops[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                bs = _step.value;
	
	                bounds.extend(new google.maps.LatLng(bs.coordinates.coordinates[1], bs.coordinates.coordinates[0]));
	              }
	              _context.next = 17;
	              break;
	
	            case 13:
	              _context.prev = 13;
	              _context.t0 = _context['catch'](9);
	              _didIteratorError = true;
	              _iteratorError = _context.t0;
	
	            case 17:
	              _context.prev = 17;
	              _context.prev = 18;
	
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	
	            case 20:
	              _context.prev = 20;
	
	              if (!_didIteratorError) {
	                _context.next = 23;
	                break;
	              }
	
	              throw _iteratorError;
	
	            case 23:
	              return _context.finish(20);
	
	            case 24:
	              return _context.finish(17);
	
	            case 25:
	              scope.map.control.getGMap().fitBounds(bounds);
	              if (scope.map.control.getGMap().getZoom() > 17) {
	                scope.map.control.getGMap().setZoom(17);
	              }
	
	            case 27:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this, [[9, 13, 17, 25], [18,, 20, 24]]);
	    }));
	
	    scope.close = function () {
	      scope.selectionModal.hide();
	      scope.resolve(scope.data.selectedStop);
	    };
	
	    function panToStop(stop) {
	      if (!stop) {
	        return;
	      }
	      if (scope.map.control.getGMap) {
	        scope.map.control.getGMap().panTo({
	          lat: stop.coordinates.coordinates[1],
	          lng: stop.coordinates.coordinates[0]
	        });
	      }
	    }
	
	    // BECAUSE ANGULAR SCOPES ARE STUPID
	    scope.$watch('data.selectedStop', function (stop) {
	      panToStop(stop);
	    });
	  }
	};
	
	var _busStopSelectorList = __webpack_require__(/*! ../templates/busStopSelectorList.html */ 476);
	
	var _busStopSelectorList2 = _interopRequireDefault(_busStopSelectorList);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/***/ },
/* 476 */
/*!****************************************************!*\
  !*** ./beeline/templates/busStopSelectorList.html ***!
  \****************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view class=\"stop-selector\">\n  <ion-header-bar class=\"bar bar-royal\">\n    <h1 class=\"title\">\n      {{title}}\n    </h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\"\n        ng-click=\"close()\">\n   </button>\n  </ion-header-bar>\n\n  <ion-content class=\"stops-list-main\" scroll=\"false\">\n    <div class=\"map-area\">\n      <ui-gmap-google-map center=\"map.center\"\n                          zoom=\"map.zoom\"\n                          bounds=\"map.bounds\"\n                          control=\"map.control\"\n                          options=\"map.options\"\n                          data-tap-disabled=\"true\">\n        <my-location></my-location>\n        <ui-gmap-marker ng-repeat=\"stop in busStops\"\n                        idkey=\"stop.id\"\n                        coords=\"stop.coordinates\"\n                        options=\"markerOptions\"\n                        ng-click=\"selectStop($event, stop)\">\n        </ui-gmap-marker>\n\n        <ui-gmap-marker ng-if=\"data.selectedStop\"\n                        idkey=\"'selectedStopPin'\"\n                        coords=\"data.selectedStop.coordinates\"\n                        options=\"pinOptions\">\n        </ui-gmap-marker>\n      </ui-gmap-google-map>\n    </div>\n\n    <div class=\"item item-divider num-stops\">{{busStops.length}} stops available</div>\n\n    <ion-content class=\"stops-list\" delegate-handle=\"stopsListScroll\">\n      <ion-list>\n        <ion-radio  ng-repeat=\"stop in busStops\"\n                    ng-model=\"data.selectedStop\"\n                    ng-value=\"stop\"\n                    class=\"item-text-wrap item-icon-left\"\n                    icon=\"icon ion-ios-checkmark\">\n          <i class=\"icon ion-ios-circle-outline not-selected\" ng-show=\"data.selectedStop !== stop\"></i>\n          <div class=\"fullStopDetails\">\n            <div class=\"time\">{{stop.time | formatTime}}</div>\n            <div class=\"details\">\n              <div class=\"description\">{{stop.description}}</div>\n              <div class=\"road\">{{stop.road}}</div>\n            </div>\n          </div>\n        </ion-radio>\n      </ion-list>\n    </ion-content>\n\n    <div class=\"item select-button\">\n      <button class=\"button primary-button button-item\"\n              ng-disabled=\"!data.selectedStop\"\n              ng-click=\"close()\">\n        {{title}}\n      </button>\n    </div>\n\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 477 */
/*!**************************************!*\
  !*** ./beeline/services/legalese.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($rootScope, $ionicModal) {
	  var privacyPolicyModalTemplate = __webpack_require__(/*! ../templates */ 478)("./" + $rootScope.o.APP.PREFIX + 'privacy-policy-modal.html');
	  var termsOfUseModalTemplate = __webpack_require__(/*! ../templates */ 481)("./" + $rootScope.o.APP.PREFIX + 'terms-of-use-modal.html');
	
	  function showModal(template) {
	    var scope = $rootScope.$new();
	    var modal = $ionicModal.fromTemplate(template, { scope: scope });
	    modal.show();
	
	    scope.modal = modal;
	    scope.$on('modal.hidden', function () {
	      return modal.remove();
	    });
	  }
	
	  this.showPrivacyPolicy = function () {
	    return showModal(privacyPolicyModalTemplate);
	  };
	  this.showTermsOfUse = function () {
	    return showModal(termsOfUseModalTemplate);
	  };
	};

/***/ },
/* 478 */
/*!****************************************************************!*\
  !*** ./beeline/templates ^\.\/.*privacy\-policy\-modal\.html$ ***!
  \****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./grab-privacy-policy-modal.html": 479,
		"./privacy-policy-modal.html": 480
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 478;


/***/ },
/* 479 */
/*!**********************************************************!*\
  !*** ./beeline/templates/grab-privacy-policy-modal.html ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">Privacy Policy</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"modal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content class=\"main\">\n    <div class=\"item item-text-wrap legal\">\n      <h1>Grab Privacy Statement</h1>\n      <p>This Privacy Notice (Notice) describes how GrabTaxi Holdings Pte Ltd and its respective subsidiaries, associate companies and jointly controlled entities (GrabTaxi Group) use your Personal Data.</p>\n      <h2>Collection of Personal Data</h2>\n      <p>\n        Personal Data means information about you, from which you are identifiable, including but not limited to your name, identification card number, birth certificate number, passport number, nationality, address, telephone number, fax number, bank details, credit card details, race, gender, date of birth, marital status, resident status, education background, financial background, personal interests, email address, your occupation, your designation in your GrabTaxi Group, your GrabTaxi Group details, the industry in which you work in, any information about you which you have provided to GrabTaxi Group in registration forms, application forms or any other similar forms and/or any information about you that has been or may be collected, stored, used and processed by GrabTaxi Group from time to time and includes sensitive personal data such as data relating to health, religious or other similar beliefs.\n      </p>\n      <p>\n        The provision of your Personal Data is voluntary. However if you do not provide GrabTaxi Group your Personal Data, GrabTaxi Group will not be able to process your Personal Data for the Purposes and Additional Purposes outlined below.\n      </p>\n      <p>\n        If you are an agent, vendor, supplier or service provider, provision of your Personal Data is mandatory and failure to provide your Personal Data, may be a breach of laws or regulatory requirements, and may cause GrabTaxi Group to be unable to engage you to provide services or products or issue payments to you for products or services provided.\n      </p>\n      <ul>\n        In addition to the Personal Data you provide to GrabTaxi Group directly, GrabTaxi Group may collect your Personal Data from a variety of sources such as:\n        <li>Fill up application or registration forms or other similar forms;</li>\n        <li>From publicly available sources such as directories,</li>\n        <li>From GrabTaxi Groups social media pages, if you follow, like or are a fan of such pages;</li>\n        <li>From credit reporting agencies;</li>\n        <li>When you interact and communicate with GrabTaxi Group at any events or activities;</li>\n        <li>When you enter contests organized by GrabTaxi Group,</li>\n        <li>From various entities or divisions under GrabTaxi Group; or</li>\n        <li>By using GrabTaxi Group websites, which includes all websites operated by GrabTaxi Group and under the names of its respective brands (Websites). Your personal data may also be collected from cookies used on the Websites.</li>\n      </ul>\n      <h2>Purposes of Processing</h2>\n      <p>\n        GrabTaxi Group may use and process your Personal Data for business and activities of GrabTaxi Group which shall include, without limitation the following (Purpose):\n      </p>\n      <ul>\n        Where you are a customer of the services provided by GrabTaxi Group:\n        <li>To perform the GrabTaxi Groups obligations in respect of any contract entered into with you;</li>\n        <li>To provide you with any service you have requested;</li>\n        <li>To process your subscriptions and to deliver the services to you;</li>\n        <li>Where you have requested to download and use the GrabTaxi, MyTeksi or GrabShuttle App (App), to process your request, to deliver the App to you and to provide you a license for the use of the App;</li>\n        <li>To process your participation in any events, activities, focus groups, research studies, contests, promotions, polls, surveys or any productions;</li>\n        <li>To process, manage or verify your application for subscription with the GrabTaxi Group and to provide you the benefits offered to subscribers;</li>\n        <li>To validate your bookings and process payments relating to any products or services you have requested;</li>\n        <li>To understand and analyses our sales as well as your needs and preferences;</li>\n        <li>To develop, enhance and provide products and services to meet your needs;</li>\n        <li>To process exchanges or product returns;</li>\n      </ul>\n      <ul>\n        Where you are an agent, vendor, supplier, partner, contractor or service provider:\n        <li>For the purposes of engaging you to provide services or products;</li>\n        <li>To facilitate or enable any checks as may be required by GrabTaxi Group in order to engage you;</li>\n        <li>To process payments relating to any products or services you have provided;</li>\n        <li>To contact you or your GrabTaxi Group;</li>\n      </ul>\n      <ul>\n        General:\n        <li>To respond to questions, comments and feedback from you;</li>\n        <li>To communicate with you for any of the purposes listed in this Notice;</li>\n        <li>For internal administrative purposes, such as auditing, data analysis, database records;</li>\n        <li>For purposes of detection, prevention and prosecution of crime;</li>\n        <li>For GrabTaxi Group to comply with its obligations under law;</li>\n        <li>And you agree and consent to GrabTaxi Group using and processing your Personal Data for the Purposes and in the manner as identified in this Notice.</li>\n      </ul>\n      <ul>\n        Marketing and promotional purposes<br />GrabTaxi Group may also use and process your data for other purposes such as (Additional Purposes):\n        <li>To send you alerts, newsletters, updates, mailers, promotional materials, special privileges, festive greetings from GrabTaxi Group, its partners, sponsors or advertisers;</li>\n        <li>To notify and invite you to events or activities organized by GrabTaxi Group, its partners, sponsors or advertisers;</li>\n        <li>To process your registration to participate in or attend an event or activity and to communicate with you regarding your attendance at the event or activity;</li>\n        <li>To share your Personal Data amongst its subsidiaries, associate companies and jointly controlled entities as well as with its agent, vendor, supplier, partner, contractor or service provider who may communicate with you to market their products, services, events or promotions.</li>\n        <li>by way of post, telephone call, short message service (SMS), by hand and/or by email.</li>\n      </ul>\n      <h2>Unsubscribe and Revocation of Consent</h2>\n      <p>\n        If you wish to unsubscribe to the processing of your Personal Data for Additional Purposes by GrabTaxi Group, please click on the link Unsubscribe which is embedded in the relevant email in order not to receive any email in the future.\n      </p>\n      <p>\n        If you wish to revoke the consent that GrabTaxi Group has obtained from you for the Purposes stipulated herein, please notify GrabTaxi Group using the contact details stated below.\n      </p>\n      <h2>Transfer of Personal Data</h2>\n      <p>\n        Your Personal Data may be transferred to, stored, used and processed in a jurisdiction other than your home nation or otherwise in the country, state and city in which you are present while using any services provided by GrabTaxi Group (Alternate Country), to companies under GrabTaxi Group which are located outside of your home nation or Alternate Country and/or where GrabTaxi Groups servers are located outside of your home nation or Alternate Country. You understand and consent to the transfer of your Personal Data out of your home nation or Alternate Country as described herein.\n      </p>\n      <h2>Disclosure to Third Parties</h2>\n      <ul>\n        Your personal data may be transferred, accessed or disclosed to third parties for the Purposes and Additional Purposes. Further, GrabTaxi Group may engage other companies, service providers or individuals to perform functions on its behalf, and consequently may provide access or disclose to your Personal Data to such service providers or third parties. The third parties include, without limitation:\n        <li>\n          GrabTaxi Group partners, which include parties with whom GrabTaxi Group collaborates with for certain events, programs and activities;\n        </li>\n        <li>\n          Event management companies and event sponsors;\n        </li>\n        <li>\n          Marketing research companies;\n        </li>\n        <li>Service providers, including, information technology (IT) service providers for infrastructure, software and development work;</li>\n        <li>Professional advisors and external auditors, including legal advisors, financial advisors and consultants;</li>\n        <li>Other entities within GrabTaxi Group; and</li>\n        <li>Governmental authorities to comply with statutory, regulatory and governmental requirements.</li>\n      </ul>\n      <p>\n        Your Personal Data may also be shared in connection with a corporate transaction, such as a sale of a subsidiary or a division, merger, consolidation, or asset sale, or in the unlikely event of winding-up.\n      </p>\n      <h2>Access &amp; Correction Requests and Inquiries, Limiting the Processing of Personal Data</h2>\n      <p>\n        Subject to any exceptions under applicable laws of your home nation or Alternate Country, you may request for access to and/or request correction of your Personal Data, request to limit the processing of your Personal Data for the Additional Purposes and/or make any inquiries regarding your Personal Data by contacting:\n      </p>\n      <p>\n        GrabTaxi Holdings Pte Ltdc/o Group Legal &amp; Corporate Compliance <br />\n        6 Shenton Way, <br />\n        #32-01 OUE Downtown, <br />\n        Singapore 068809 <br />\n        Email: dataprotection@grabtaxi.com\n      </p>\n      <p>\n        Subject to any laws of your home nation or Alternate Country, GrabTaxi Group reserves the right to impose a fee for access of your Personal Data in the amounts as permitted therein.\n      </p>\n      <p>\n        In respect of your right to access and/or correct your Personal Data, GrabTaxi Group has the right to refuse the your requests to access and/or make any correction to your Personal Data for the reasons permitted under law, such as where the expense of providing access to you is disproportionate to the risks to your or another persons privacy.\n      </p>\n      <p>\n        If you do not wish for your Personal Data to be collected via cookies on the Websites, you may deactivate cookies by adjusting your internet browser settings to disable, block or deactivate cookies, by deleting your browsing history and clearing the cache from your internet browser.\n      </p>\n      <h2>Links to Third-Party Websites</h2>\n      <p>\n        The Websites may contain links to third parties websites. Please note that GrabTaxi Group is not responsible for the collection, use, maintenance, sharing, or disclosure of data and information by such third parties. If you provide information directly to such sites, the privacy policy and terms of service on those sites are applicable and GrabTaxi Group is not responsible for the information processing practices or privacy policies of such sites.\n      </p>\n      <h2>Personal Information from Minors and Other Individuals</h2>\n      <p>\n        As a parent or legal guardian, please do not allow the minor (individuals under 18 (eighteen) years of age) under your care to submit Personal Data to GrabTaxi Group. In the event that such Personal Data is provided to GrabTaxi Group, you hereby consent to the processing of the minors Personal Data and personally accept and agree to be bound by this Notice and take responsibility for his or her actions.\n      </p>\n      <p>\n        In some circumstances you may have provided personal data relating to other individuals (such as your spouse, family members or friends) and in such circumstances you represent and warrant that you are authorized to provide their personal data to GrabTaxi Group and you have obtained their consent for their personal data be processed and used in the manner as set forth in this Notice.\n      </p>\n      <h2>Acknowledgement and Consent</h2>\n      <p>\n        By communicating with GrabTaxi Group, using GrabTaxi Groups services, purchasing products from GrabTaxi Group or by virtue of your engagement with GrabTaxi Group, you acknowledge that you have read and understood this Notice and agree and consent to the use, processing and transfer of your Personal Data by GrabTaxi Group as described in this Notice.\n      </p>\n      <p>\n        GrabTaxi Group shall have the right to modify, update or amend the terms of this Notice at any time by placing the updated Notice on the Websites. By continuing to communicate with GrabTaxi Group, by continuing to use GrabTaxi Groups services, purchasing products from GrabTaxi Group or by your continued engagement with GrabTaxi Group following the modifications, updates or amendments to this Notice, such actions shall signify your acceptance of such modifications, updates or amendments.\n      </p>\n      <p>\n        In the event of any conflict between the English and other language versions, the English version shall prevail.\n      </p>\n      </div>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 480 */
/*!*****************************************************!*\
  !*** ./beeline/templates/privacy-policy-modal.html ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">Privacy Policy</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"modal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content class=\"main\">\n    <div  class=\"item item-text-wrap legal\">\n      <h2>Government Agency<br />Privacy Statement</h2>\n      <ol>\n        <li>This is a Government Agency website.</li>\n        <li> We may use \"cookies\", where a small data file is sent to your device to store and track information about you when you enter our websites. The cookie is used to track information such as the number of users and their frequency of use, profiles\n          of users and their preferred sites. While this cookie can tell us when you enter our sites and which pages you visit, it cannot read data off your hard disk.</li>\n        <li>You can choose to accept or decline cookies. Most devices automatically accept cookies, but you can usually modify your device settings to decline cookies if you prefer. This may prevent you from taking full advantage of the website.</li>\n        <li>If you provide us with personally identifiable data\n          <ol>\n            <li>We may share necessary personal data with other Government agencies, so as to serve you in the most efficient and effective way and with transport service providers for the purposes of providing you with transportation services and keeping you\n              informed about the new service offerings unless such sharing is prohibited by law.</li>\n            <li>Except as specified above, we will NOT share your personal data with non-Government entities, except where such entities have been authorised to carry out specific Government services.</li>\n            <li>For your convenience, we may also display to you data you had previously supplied us or other Government Agencies. This will speed up the transaction and save you the trouble of repeating previous submissions. Should the data be out-of-date,\n              please supply us the latest data.</li>\n          </ol>\n        </li>\n        <li>To safeguard your personal data, all electronic storage and transmission of personal data is secured with appropriate security technologies.</li>\n        <li>This site may contain links to non-Government sites whose data protection and privacy practices may differ from ours. We are not responsible for the content and privacy practices of these other websites and encourage you to consult the privacy\n          notices of those sites.</li>\n        <li>Please contact 1800 211 0777 (qsm@tech.gov.sg) if you:\n          <ol>\n            <li>have any enquires or feedback on our data protection policies and procedures,</li>\n            <li>need more information on or access to data which you have provided to us in the past.</li>\n          </ol>\n        </li>\n      </ol>\n    </div>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 481 */
/*!***************************************************************!*\
  !*** ./beeline/templates ^\.\/.*terms\-of\-use\-modal\.html$ ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./grab-terms-of-use-modal.html": 482,
		"./terms-of-use-modal.html": 483
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 481;


/***/ },
/* 482 */
/*!********************************************************!*\
  !*** ./beeline/templates/grab-terms-of-use-modal.html ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n    <ion-header-bar class=\"bar-royal bar bar-header\">\n      <h1 class=\"title\">Terms of Use</h1>\n      <button class=\"button button-clear icon ion-ios-close-outline\"\n            ng-click=\"modal.hide()\">\n      </button>\n    </ion-header-bar>\n    <ion-content>\n        <ion-item class=\"item item-text-wrap legal\">\n            <h1>Grab Terms of Use</h1>\n            <p>Important  please read these terms carefully. By using the Service (as defined below), you agree that you have read, understood, accepted and agreed with the Terms of Use. You further agree to the representations made by yourself below. If you do not agree to or fall within the Terms of Use of the Service and wish to discontinue using the Service, please do not continue using the Application (as defined below) or the Service. </p>\n            <p>The Terms of Use stated herein (collectively, the Terms of Use or this Agreement) constitute a legal agreement between you and GrabCar Pte. Ltd. (Company No. 201427085E) (the Company). In order to use the Service you must agree to the Terms of Use that are set out below. By using the mobile application supplied to you by the Company (the Application), and downloading, installing or using any associated software supplied by the Company (the Software) which overall purpose is to enable persons seeking transportation services to certain destinations to be matched with third party transportation providers, drivers and vehicle operators (collectively, the Service), you hereby expressly acknowledge and agree to be bound by the Terms of Use, and any future amendments and additions to the Terms of Use as published from time to time at <ext-a href=\"http://www.grab.com\" target=\"_system\">http://www.grab.com</ext-a> or through the Application. </p>\n            <p>The Company reserves the right to modify, vary and change the Terms of Use or its policies relating to the Service at any time as it deems fit. Such modifications, variations and or changes to the Terms of Use or its policies relating to the Service shall be effective upon the posting of an updated version at <ext-a href=\"http://www.grab.com\" target=\"_system\">http://www.grab.com</ext-a>. You agree that it shall be your responsibility to review the Terms of Use regularly and also the Terms of Use applicable to any country where you use the Service which may differ from the country where you registered for the Application (the Alternate Country) whereupon the continued use of the Service after any such changes, whether or not reviewed by you, shall constitute your consent and acceptance to such changes. You further agree that usage of the Service in the Alternate Country shall be subject to the Terms of Use prevailing for the Alternate Country which can be found at <ext-a href=\"http://www.grab.com\" target=\"_system\">http://www.grab.com</ext-a>. </p>\n            <p>THE COMPANY IS A TECHNOLOGY COMPANY THAT DOES NOT PROVIDE TRANSPORTATION SERVICES AND THE COMPANY IS NOT A TRANSPORTATION PROVIDER. IT IS UP TO THE THIRD PARTY TRANSPORTATION PROVIDERS TO OFFER TRANSPORTATION SERVICES TO YOU AND IT IS UP TO YOU TO ACCEPT SUCH TRANSPORTATION SERVICES. THE SERVICE OF THE COMPANY IS TO LINK YOU WITH SUCH THIRD PARTY TRANSPORTATION PROVIDERS, BUT DOES NOT NOR IS IT INTENDED TO PROVIDE TRANSPORTATION SERVICE OR ANY ACT THAT CAN BE CONSTRUED IN ANY WAY AS AN ACT OF A TRANSPORTATION PROVIDER. THE COMPANY IS NOT RESPONSIBLE NOR LIABLE FOR THE ACTS AND/OR OMISSIONS OF ANY THIRD PARTY TRANSPORTATION PROVIDER AND/OR ANY TRANSPORTATION SERVICES PROVIDED TO YOU.</p>\n\n            <h2>Representations and Warranties</h2>\n            <p>By using the Service, you expressly represent and warrant that you are legally entitled to accept and agree to the Terms of Use and that you are at least eighteen (18) years old. Without limiting the generality of the foregoing, the Service is not available to persons under the age of eighteen (18) or such persons that are forbidden for any reason whatsoever to enter into a contractual relationship. By using the Service, you further represent and warrant that you have the right, authority and capacity to use the Service and to abide by the Terms of Use. You further confirm that all the information which you provide shall be true and accurate. Your use of the Service is for your own sole, personal use. You undertake not to authorize others to use your identity or user status, and you may not assign or otherwise transfer your user account to any other person or entity. When using the Service, you agree to comply with all applicable laws whether in your home nation or otherwise in the country, state and city in which you are present while using the Service.</p>\n            <p>\n            You may only access the Service using authorized means. It is your responsibility to check and ensure that you have downloaded the correct Software for your device. The Company is not liable if you do not have a compatible device or if you have downloaded the wrong version of the Software to your device.The Company reserves the right not to permit you to use the Service should you use the Application and/or the Software with an incompatible or unauthorized device or for purposes other than which the Software and/or the Application is intended to be used.</p>\n            <ul>\n              By using the Software or the Application, you agree that:\n              <li>You will only use the Service for lawful purposes; </li>\n              <li>You will only use the Service for the purpose for which it is intended to be used; </li>\n              <li>You will not use the Application for sending or storing any unlawful material or for fraudulent purposes; </li>\n              <li>You will not use the Application and/or the Software to cause nuisance, annoyance, inconvenience or make fake bookings; </li>\n              <li>You will not use the Service, the Application and/or the Software for purposes other than obtaining the Service; </li>\n              <li>You shall not contact the third party transportation provider for purposes other than the Service; </li>\n              <li>You will not impair the proper operation of the network; </li>\n              <li>You shall not intentionally or unintentionally cause or attempt to cause damage to the third party transportation provider; </li>\n              <li>You will not try to harm the Service, the Application and/or the Software in any way whatsoever; </li>\n              <li>You will not copy, or distribute the Software or other content without written permission from the Company; </li>\n              <li>You will only use the Software and/or the Application for your own use and will not resell it to a third party; </li>\n              <li>You will keep secure and confidential your account password or any identification we provide you which allows access to the Service;</li>\n              <li>You will provide the Company with proof of identity as it may reasonably request or require;</li>\n              <li>You agree to provide accurate, current and complete information as required for the Service and undertake the responsibility to maintain and update your information in a timely manner to keep it accurate, current and complete at all times during the term of this Agreement. You agree that the Company may rely on your information as accurate, current and complete. You acknowledge that if your information is untrue, inaccurate, not current or incomplete in any respect, the Company has the right but not the obligation to terminate this Agreement and your use of the Service at any time with or without notice; </li>\n              <li>You will only use an access point or data account which you are authorized to use; </li>\n              <li>You shall not employ any means to defraud the Company or enrich yourself, through any means, whether fraudulent or otherwise, through any event, promotion or campaign launched by the Company to encourage new subscription or usage of the Service by new or existing passengers; </li>\n              <li> You are aware that when requesting transportation services by SMS or use of the Service, standard telecommunication charges will apply; </li>\n              <li>You shall not cause a nuisance or behave in an inappropriate or disrespectful manner towards the Company or the third party transportation provider regardless of any misgivings that you may have against the Company or the third party transportation provider; </li>\n              <li>You shall not impair or circumvent the proper operation of the network which the Service operates on; </li>\n              <li>You agree that the Service is provided on a reasonable effort basis; and </li>\n              <li>You agree that your use of the Service will be subject to the Companys Privacy Policy as may be amended from time to time. </li>\n              <p>You agree to assume full responsibility and liability for all loss or damage suffered by yourself, the third party service provider, the Company or any third party as a result of any breach of the Terms of Use.</p>\n            </ul>\n            <h2>Taxes</h2>\n            <p>\n              You agree that this Agreement shall be subject to all prevailing statutory taxes, duties, fees, charges and/or costs, however denominated, as may be in force and in connection with any future taxes that may be introduced at any point of time. You further agree to use your best efforts to do everything necessary and required by the relevant laws to enable, assist and/or defend the Company to claim or verify any input tax credit, set off, rebate or refund in respect of any taxes paid or payable in connection with the Services supplied under this Agreement.\n            </p>\n            <h2>License Grant &amp; Restrictions </h2>\n            <p>\n              The Company and its licensors, where applicable, hereby grants you a revocable, non-exclusive, non-transferable, non-assignable, personal, limited license to use the Application and/or the Software, solely for your own personal and non-commercial purposes, subject to the Terms of Use herein. All rights not expressly granted to you are reserved by the Company and its licensors.\n            </p>\n            <p>\n              You shall not (i) license, sublicense, sell, resell, transfer, assign, distribute or otherwise commercially exploit or make available to any third party the Application and/or the Software in any way; (ii) modify or make derivative works based on the Application and/or the Software; (iii) create internet links to the Application or frame or mirror the Software on any other server or wireless or internet-based device; (iv) reverse engineer or access the Software in order to (a) build a competitive product or service, (b) build a product using similar ideas, features, functions or graphics of the Application and/or the Software, or (c) copy any ideas, features, functions or graphics of the Application and/or the Software, (v) launch an automated program or script, including, but not limited to, web spiders, web crawlers, web robots, web ants, web indexers, bots, viruses or worms, or any program which may make multiple server requests per second, or unduly burdens or hinders the operation and/or performance of the Application and/or the Software, (vi) use any robot, spider, site search/retrieval application, or other manual or automatic device or process to retrieve, index, data mine, or in any way reproduce or circumvent the navigational structure or presentation of the Service or its contents; (vii) post, distribute or reproduce in any way any copyrighted material, trademarks, or other proprietary information without obtaining the prior consent of the owner of such proprietary rights, (viii) remove any copyright, trademark or other proprietary rights notices contained in the Service. You may use the Software and/or the Application only for your personal, non-commercial purposes and shall not use the Software and/or the Application to: (i) send spam or otherwise duplicative or unsolicited messages; (ii) send or store infringing, obscene, threatening, libellous, or otherwise unlawful or tortious material, including but not limited to materials harmful to children or violative of third party privacy rights; (iii) send material containing software viruses, worms, trojan horses or other harmful computer code, files, scripts, agents or programs; (iv) interfere with or disrupt the integrity or performance of the Software and/or the Application or the data contained therein; (v) attempt to gain unauthorized access to the Software and/or the Application or its related systems or networks; or (vi) Impersonate any person or entity or otherwise misrepresent your affiliation with a person or entity (vii) to abstain from any conduct that could possibly damage the Companys reputation or amount to being disreputable.\n            </p>\n            <p>\n              You may use the Software and/or the Application only for your personal, non-commercial purposes and shall not use the Software and/or the Application to: (i) send spam or otherwise duplicative or unsolicited messages; (ii) send or store infringing, obscene, threatening, libellous, or otherwise unlawful or tortious material, including but not limited to materials harmful to children or violative of third party privacy rights; (iii) send material containing software viruses, worms, trojan horses or other harmful computer code, files, scripts, agents or programs; (iv) interfere with or disrupt the integrity or performance of the Software and/or the Application or the data contained therein; (v) attempt to gain unauthorized access to the Software and/or the Application or its related systems or networks; or (vi) Impersonate any person or entity or otherwise misrepresent your affiliation with a person or entity (vii) to abstain from any conduct that could possibly damage the Companys reputation or amount to being disreputable.\n            </p>\n            <h2>Intellectual Property Ownership</h2>\n            <p>\n              The Company and its licensors, where applicable, shall own all right, title and interest, including all related intellectual property rights, in and to the Software and/or the Application and by extension, the Service and any suggestions, ideas, enhancement requests, feedback, recommendations or other information provided by you or any other party relating to the Service. The Terms of Use do not constitute a sale agreement and do not convey to you any rights of ownership in or related to the Service, the Software and/or the Application, or any intellectual property rights owned by the Company and/or its licensors. The Companys name, the Companys logo, the Service, the Software and/or the Application and the third party transportation providers logos and the product names associated with the Software and/or the Application are trademarks of the Company or third parties, and no right or license is granted to use them. For the avoidance of doubt, the term the Software and the Application herein shall include its respective components, processes and design in its entirety.\n            </p>\n            <h2>Confidentiality</h2>\n            <p>\n              You shall maintain in confidence all information and data relating to the Company, its services, products, business affairs, marketing and promotion plans or other operations and its associated companies which are disclosed to you by or on behalf of the Company (whether orally or in writing and whether before, on or after the date of this Agreement) or which are otherwise directly or indirectly acquired by you from the Company, or any of its affiliated companies, or created in the course of this Agreement.\n            </p>\n            <p>\n              You shall further ensure that it, its officers, employees and agents only use such confidential information in order to perform the Service, and shall not without the Companys prior written consent, disclose such information to any third-party nor use it for any other purpose. You shall only disclose such information to such officers, employees and agents as need to know it to fulfil its obligations under this Agreement.\n            </p>\n            <ul>\n              The above obligations of confidentiality shall not apply to the extent that you can show that the relevant information:\n              <li>was at the time of receipt already in your possession; </li>\n              <li>is, or becomes in the future, public knowledge through no fault or omission of you;</li>\n              <li>was received from a third-party having the right to disclose it; or </li>\n              <li>is required to be disclosed by law.</li>\n            </ul>\n            <h2>Personal Data Protection</h2>\n            <p>\n              You agree and consent to the Company using and processing your Personal Data for the Purposes and in the manner as identified hereunder.\n            </p>\n            <p>\n              For the purposes of this Agreement, Personal Data means information about you, from which you are identifiable, including but not limited to your name, identification card number, birth certificate number, passport number, nationality, address, telephone number, credit or debit card details, race, gender, date of birth, email address, any information about you which you have provided to the Company in registration forms, application forms or any other similar forms and/or any information about you that has been or may be collected, stored, used and processed by the Company from time to time and includes sensitive personal data such as data relating to health, religious or other similar beliefs.\n            </p>\n            <p>\n              The provision of your Personal Data is voluntary. However, if you do not provide the Company your Personal Data, your request for the Application may be incomplete and the Company will not be able to process your Personal Data for the Purposes outlined below and may cause the Company to be unable to allow you to use the Service.\n            </p>\n            <ul>\n              The Company may use and process your Personal Data for business and activities of the Company which shall include, without limitation the following (the Purpose):\n              <li>To perform the Companys obligations in respect of any contract entered with you; </li>\n              <li>To provide you with any services pursuant to the Terms of Use herein; </li>\n              <li>To process your participation in any events, promotions, activities, focus groups, research studies, contests, promotions, polls, surveys or any productions and to communicate with you regarding your attendance thereto;</li>\n              <li>Process, manage or verify your application for the Service pursuant to the Terms of Use herein; </li>\n              <li>To validate and/or process payments pursuant to the Terms of Use herein; </li>\n              <li>To develop, enhance and provide what is required pursuant to the Terms of Use herein to meet your needs; </li>\n              <li>To process any refunds, rebates and or charges pursuant to the Terms of Use herein; </li>\n              <li>To facilitate or enable any checks as may be required pursuant to the Terms of Use herein;</li>\n              <li>To respond to questions, comments and feedback from you; </li>\n              <li>To communicate with you for any of the purposes listed herein; </li>\n              <li>For internal administrative purposes, such as auditing, data analysis, database records; </li>\n              <li>For purposes of detection, prevention and prosecution of crime;</li>\n              <li>For the Company to comply with its obligations under law;</li>\n              <li>To send you alerts, newsletters, updates, mailers, promotional materials, special privileges, festive greetings from the Company, its partners, advertisers and or sponsors; </li>\n              <li>To notify and invite you to events or activities organised by the Company, its partners, advertisers, and or sponsors; and/or </li>\n              <li>To share your Personal Data amongst the companies within the Companys group of companies comprising the subsidiaries, associate companies and or jointly controlled entities of the holding company of the group (the Group) and with the Companys and Groups agents, third party providers, developers, advertisers, partners, event companies or sponsors who may communicate with you for any reasons whatsoever. </li>\n              <p>\n                If you do not consent to the Company processing your Personal Data for any of the Purposes, please notify the Company using the support contact details as provided in the Application.\n              </p>\n              <p>\n                If any of the Personal Data that you have provided to us changes, for example, if you change your e-mail address, telephone number, payment details or if you wish to cancel your account, please update your details by sending your request to the support contact details as provided in the Application.\n              </p>\n              <p>\n                The Company will, to the best of its abilities, effect such changes as requested within fourteen (14) working days of receipt of such notice of change.\n              </p>\n              <p>\n                By submitting your information to the Company, you consent to the use of that information as set out in the form of submission and in the Terms of Use.\n              </p>\n            </ul>\n            <h2>Third Party Interactions</h2>\n            <p>\n              During use of the Service, you may enter into correspondence with, purchase of goods and/or services from, or participate in promotions of third party providers, advertisers or sponsors showing their goods and/or services through the Service, the Software and/or the Application. Any such activity, and any terms, conditions, warranties or representations associated with such activity, is solely between you and the applicable third-party. The Company and its licensors shall have no liability, obligation or responsibility for any such correspondence, purchase, transaction or promotion between you and any such third-party. The Group does not endorse any applications or sites on the Internet that are linked through the Service, the Application and/or the Software, and in no event, shall the Company, its licensors or the Group be responsible for any content, products, services or other materials on or available from such sites or third party providers. The Company provides the Service to you pursuant to the Terms of Use. You recognize, however, that certain third party providers of transportation, goods and/or services may require your agreement to additional or different terms and conditions prior to your use of or access to such goods or services, and the Company is not a party to and disclaims any and all responsibility and/or liability arising from such agreements between you and the third party providers.\n            </p>\n            <p>\n              The Company may rely on third party advertising and marketing supplied through the Service and other mechanisms to subsidize the Service and/or to earn additional revenue. By agreeing to the Terms of Use you agree to receive such advertising and marketing. If you do not want to receive such advertising, you should notify us in writing or in accordance with the procedure determined by the Company. The Company reserves the right to charge you a higher fee for or deny you use of the Service should you choose not to receive these advertising services. This higher fee, if applicable, will be posted on the Companys website located at <ext-a href=\"http://www.grab.com\" target=\"_system\">http://www.grab.com</ext-a>. You agree and allow the Company to compile and release information regarding you and your use of the Service on an anonymous basis as part of a customer profile or similar report or analysis. You agree that it is your responsibility to take all precautions in all actions and interactions with any Service Providers, other third party providers, advertisers and/or sponsors you interact with through the Service and/or advertising or marketing material supplied through the Service.\n            </p>\n            <h2>Repair or Cleaning Fees</h2>\n            <p>\n              You shall be responsible for the cost of repair for any damage to or necessary cleaning of the third party service providers vehicle as a result of your misuse of the Service or in breach of the Terms of Use herein. The Company reserves the right to facilitate payment for reasonable cost of such repair or cleaning on behalf of the third party service provider via your designated payment method or demand from you in cash, in the event a request for repair or cleaning request by the third party service provider has been verified by the Company.\n            </p>\n            <h2>Indemnification</h2>\n            <p>\n              By agreeing to the Terms of Use upon using the Service, you agree that you shall defend, indemnify and hold the Company, its licensors and each such partys parent organizations, subsidiaries, affiliates, officers, directors, members, employees, attorneys and agents harmless from and against any and all claims, costs, damages, losses, liabilities and expenses (including attorneys fees and costs and/or regulatory action) arising out of or in connection with: (a) your use of the Service, the Software and/or the Application in your dealings with the third party transportation providers, third party providers, partners, advertisers and/or sponsors, or (b) your violation or breach of any of the Terms of Use or any applicable law or regulation, whether or not referenced herein, or (c) your violation of any rights of any third party, including the third party transportation providers arranged via the Service, or (d) your use or misuse of the Service, the Software and/or the Application.\n            </p>\n            <h2>Disclaimer of Warranties </h2>\n            <p>\n              THE COMPANY MAKES NO REPRESENTATION, WARRANTY, OR GUARANTEE AS TO THE RELIABILITY, TIMELINESS, QUALITY, SUITABILITY, AVAILABILITY, ACCURACY OR COMPLETENESS OF THE SERVICES INCLUDING BUT NOT LIMITED TO THE THIRD PARTY TRANSPORTATION SERVICES OBTAINED BY OR FROM THIRD PARTIES THROUGH THE APPLICATION AND/OR THE SOFTWARE. THE COMPANY DOES NOT REPRESENT OR WARRANT THAT (A) THE USE OF THE SERVICE, THE APPLICATION AND/OR THE SOFTWARE WILL BE SECURE, TIMELY, UNINTERRUPTED OR ERROR-FREE OR OPERATE IN COMBINATION WITH ANY OTHER HARDWARE, SOFTWARE, SYSTEM OR DATA, (B) THE SERVICE WILL MEET YOUR REQUIREMENTS OR EXPECTATIONS, (C) ANY STORED DATA WILL BE ACCURATE OR RELIABLE, (D) THE QUALITY OF ANY PRODUCTS, SERVICES, INFORMATION, OR OTHER MATERIALS PURCHASED OR OBTAINED BY YOU THROUGH THE APPLICATION WILL MEET YOUR REQUIREMENTS OR EXPECTATIONS, (E) ERRORS OR DEFECTS IN THE APPLICATION AND/OR THE SOFTWARE WILL BE CORRECTED, OR (F) THE APPLICATION OR THE SERVER(S) THAT MAKE THE APPLICATION AVAILABLE ARE FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS, OR (G) THE APPLICATION AND/OR THE SOFTWARE TRACKS YOU OR THE VEHICLE USED BY THE THIRD PARTY TRANSPORTATION PROVIDER. THE SERVICE IS PROVIDED TO YOU STRICTLY ON AN AS IS BASIS. ALL CONDITIONS, REPRESENTATIONS AND WARRANTIES, WHETHE EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING, WITHOUT LIMITATION, ANY IMPLIED WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT OF THIRD PARTY RIGHTS, ARE HEREBY EXCLUDED AND DISCLAIMED TO THE HIGHEST AND MAXIMUM EXTENT. <br />\n             We disclaim all liabilities to you or any third party for any damage or loss of any kind whatsoever and howsoever caused, including but not limited to any direct, indirect, special or consequential damages, loss of income, revenue or profits, lost or damaged data, or damage to any property, whether arising directly or indirectly from your use of the App\n            </p>\n            <h2>Internet Delays</h2>\n            <p>\n              THE SERVICE, THE APPLICATION AND/OR THE SOFTWARE MAY BE SUBJECT TO LIMITATIONS, DELAYS, AND OTHER PROBLEMS INHERENT IN THE USE OF THE INTERNET AND ELECTRONIC COMMUNICATIONS INCLUDING THE DEVICE USED BY YOU OR THE THIRD PARTY TRANSPORTATION PROVIDER BEING FAULTY, NOT CONNECTED, OUT OF RANGE, SWITCHED OFF OR NOT FUNCTIONING. THE COMPANY IS NOT RESPONSIBLE FOR ANY DELAYS, DELIVERY FAILURES, DAMAGES OR LOSSES RESULTING FROM SUCH PROBLEMS.\n            </p>\n            <h2>Limitation of Liability</h2>\n            <p>\n              ANY CLAIMS AGAINST THE COMPANY BY YOU SHALL IN ANY EVENT BE LIMITED TO THE AGGREGATE AMOUNT OF ALL AMOUNTS ACTUALLY PAID BY AND/OR DUE FROM YOU IN UTILISING THE SERVICE DURING THE EVENT GIVING RISE TO SUCH CLAIMS. IN NO EVENT SHALL THE COMPANY AND/OR ITS LICENSORS BE LIABLE TO YOU OR ANYONE FOR ANY DIRECT, INDIRECT, PUNITIVE, ECONOMIC, FUTURE SPECIAL, EXEMPLARY, INCIDENTAL, CONSEQUENTIAL OR OTHER DAMAGES OR LOSSES OF ANY TYPE OR KIND (INCLUDING PERSONAL INJURY, EMOTIONAL DISTRESS AND LOSS OF DATA, GOODS, REVENUE, PROFITS, USE OR OTHER ECONOMIC ADVANTAGE). THE COMPANY AND/OR ITS LICENSORS SHALL NOT BE LIABLE FOR ANY LOSS, DAMAGE OR INJURY WHICH MAY BE INCURRED BY OR CAUSED TO YOU OR TO ANY PERSON FOR WHOM YOU HAVE BOOKED THE SERVICE FOR, INCLUDING BUT NOT LIMITED TO LOSS, DAMAGE OR INJURY ARISING OUT OF, OR IN ANY WAY CONNECTED WITH THE SERVICE, THE APPLICATION AND/OR THE SOFTWARE, INCLUDING BUT NOT LIMITED TO THE USE OR INABILITY TO USE THE SERVICE, THE APPLICATION AND/OR THE SOFTWARE, ANY RELIANCE PLACED BY YOU ON THE COMPLETENESS, ACCURACY OR EXISTENCE OF ANY ADVERTISING, OR AS A RESULT OF ANY RELATIONSHIP OR TRANSACTION BETWEEN YOU AND ANY THIRD PARTY PROVIDER, ADVERTISER OR SPONSOR WHOSE ADVERTISING APPEARS ON THE WEBSITE OR IS REFERRED TO BY THE SERVICE, THE APPLICATION AND/OR THE SOFTWARE, EVEN IF THE COMPANY AND/OR ITS LICENSORS HAVE BEEN PREVIOUSLY ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.\n            </p>\n            <p>\n              THE COMPANY DOES NOT AND WILL NOT ASSESS NOR MONITOR THE SUITABILITY, LEGALITY, ABILITY, MOVEMENT OR LOCATION OF ANY THIRD PARTY PROVIDERS INCLUDING THIRD PARTY TRANSPORTATION PROVIDERS, ADVERTISERS AND/OR SPONSORS AND YOU EXPRESSLY WAIVE AND RELEASE THE COMPANY FROM ANY AND ALL LIABILITY, CLAIMS OR DAMAGES ARISING FROM OR IN ANY WAY RELATED TO THE THIRD PARTY PROVIDERS INCLUDING THIRD PARTY TRANSPORTATION PROVIDERS, ADVERTISERS AND/OR SPONSORS.\n            </p>\n            <p>\n              THE COMPANY WILL NOT BE A PARTY TO DISPUTES, NEGOTIATIONS OF DISPUTES BETWEEN YOU AND SUCH THIRD PARTY PROVIDERS INCLUDING THIRD PARTY TRANSPORTATION PROVIDERS, ADVERTISERS AND/OR SPONSORS. UNLESS YOU ARE A CORPORATE CUSTOMER WITH A CURRENT CORPORATE ACCOUNT WITH THE COMPANY, THE COMPANY CANNOT AND WILL NOT PLAY ANY ROLE IN MANAGING PAYMENTS BETWEEN YOU AND THE THIRD PARTY PROVIDERS, INCLUDING THE THIRD PARTY TRANSPORATION PROVIDER, ADVERTISERS AND/OR SPONSORS. RESPONSIBILITY FOR THE DECISIONS YOU MAKE REGARDING SERVICES AND PRODUCTS OFFERED VIA THE SERVICE, THE SOFTWARE AND/OR THE APPLICATION (WITH ALL ITS IMPLICATIONS) RESTS SOLELY WITH AND ON YOU. YOU EXPRESSLY WAIVE AND RELEASE THE COMPANY FROM ANY AND ALL LIABILITY, CLAIMS, CAUSES OF ACTION, OR DAMAGES ARISING FROM YOUR USE OF THE SERVICE, THE SOFTWARE AND/OR THE APPLICATION, OR IN ANY WAY RELATED TO THE THIRD PARTIES INCLUDING THIRD PARTY TRANSPORTATION PROVIDERS, ADVERTISERS AND/OR SPONSORS INTRODUCED TO YOU BY THE SERVICE, THE SOFTWARE AND/OR THE APPLICATION.\n            </p>\n            <p>\n              THE QUALITY OF THE THIRD PARTY TRANSPORTATION SERVICES SCHEDULED THROUGH THE USE OF THE SERVICE IS ENTIRELY THE RESPONSIBILITY OF THE THIRD PARTY TRANSPORTATION PROVIDER WHO ULTIMATELY PROVIDES SUCH TRANSPORTATION SERVICES TO YOU. YOU UNDERSTAND, THEREFORE, THAT BY USING THE SERVICE, YOU MAY BE EXPOSED TO TRANSPORATION THAT IS POTENTIALLY DANGEROUS, OFFENSIVE, HARMFUL TO MINORS, UNSAFE OR OTHERWISE OBJECTIONABLE, AND THAT YOU USE THE SERVICE AT YOUR OWN RISK.\n            </p>\n            <h2>Notice</h2>\n            <p>\n              The Company may give notice by means of a general notice on the Application, electronic mail to your email address in the records of the Company, or by written communication sent by registered mail or pre-paid post to your address in the record of the Company. Such notice shall be deemed to have been given upon the expiration of 48 hours after mailing or posting (if sent by registered mail or pre-paid post) or 1 hour after sending (if sent by email). You may give notice to the Company (such notice shall be deemed given when received by the Company) by letter sent by courier or registered mail to the Company using the contact details as provided in the Application.\n            </p>\n            <h2>Assignment</h2>\n            <p>\n              This Agreement as constituted by the Terms of Use as modified from time to time may not be assigned by you without the prior written approval of the Company but may be assigned without your consent by the Company. Any purported assignment by you in violation of this section shall be void.\n            </p>\n            <h2>General</h2>\n            <p>\n              This Agreement shall be governed by Singapore law, without regard to the choice or conflicts of law provisions of any jurisdiction, and any disputes, actions, claims or causes of action arising out of or in connection with the Terms of Use or the Service shall be subject to the exclusive jurisdiction of the courts of Singapore to which you hereby agree to submit to.\n            </p>\n            <p>\n              In the event that the law in an Alternate Country does not allow jurisdiction to be that of the courts of Singapore or where judgment of a Singapore court is unenforceable in the Alternate Country, unresolved disputes shall be referred to the Singapore International Arbitration Centre (SIAC), in accordance with the Rules of the SIAC as modified or amended from time to time (the Rules) by a sole arbitrator appointed by the mutual agreement of the parties (the Arbitrator). If parties are unable to agree on an arbitrator, the Arbitrator shall be appointed by the President of SIAC in accordance with the Rules.\n            </p>\n            <p>\n              The seat and venue of the arbitration shall be Singapore, in the English language and the fees of the Arbitrator shall be borne equally by the parties, provided that the Arbitrator may require that such fees be borne in such other manner as the Arbitrator determines is required in order for this arbitration clause to be enforceable under applicable law.\n            </p>\n            <p>\n              No joint venture, partnership, employment, or agency relationship exists between you, the Company or any third party provider as a result of the Terms of Use or use of the Service.\n            </p>\n            <p>\n              If any provision of the Terms of Use is held to be invalid or unenforceable, such provision shall be struck and the remaining provisions shall be enforced to the fullest extent under law. This shall, without limitation, also apply to the applicable law and jurisdiction as stipulated above.\n            </p>\n            <p>\n              The failure of the Company to enforce any right or provision in the Terms of Use shall not constitute a waiver of such right or provision unless acknowledged and agreed to by the Company in writing. The Terms of Use comprises the entire agreement between you and the Company and supersedes all prior or contemporaneous negotiations or discussions, whether written or oral (if any) between the parties regarding the subject matter contained herein.\n            </p>\n            <p>\n              You hereby agree that the Company is entitled to terminate this Agreement immediately if it finds in its absolute discretion that you are in breach of any of the terms stipulated in this Agreement. For the avoidance of doubt, the termination of this Agreement shall not require the Company to compensate, reimburse or cover any cost incurred by you in the course of you acquiring Services from the third party transportation provider under this Agreement.\n            </p>\n        </ion-item>\n    </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 483 */
/*!***************************************************!*\
  !*** ./beeline/templates/terms-of-use-modal.html ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n    <ion-header-bar class=\"bar-royal bar bar-header\">\n        <h1 class=\"title\">Terms of Use</h1>\n        <button class=\"button button-clear icon ion-ios-close-outline\"\n              ng-click=\"modal.hide()\">\n        </button>\n    </ion-header-bar>\n    <ion-content>\n        <ion-item class=\"item item-text-wrap legal\">\n\n            <h2>General</h2>\n            <ol>\n                <li>These Terms of Use govern your access to and use of our services, including this website, the application contained in this website, email notifications and Application Programme Interface (API) (collectively, the Beeline Service or\n                    this \"Service). This Service is owned and operated by the Government Technology Agency (\"GovTech\").</li>\n\n                <li>By accessing or using any part of this Service, you unconditionally agree and accept to be legally bound by these Terms of Use. If you do not agree to these Terms of Use, please do not use this Service or any part of this Service.</li>\n\n                <li>In case of any violation of these Terms of Use, GovTech reserves the right to seek all remedies available under the law and in equity for such violations. These Terms of Use apply to access and use of this Service or any part of this Service,\n                    both now and in the future.</li>\n\n                <li>GovTech reserves the right to change these Terms of Use from time to time at its sole discretion. All changes will be posted on this page, and your use of this Service or any part of this Service after such changes have been posted will constitute\n                    your agreement to the modified Terms of Use and all of the changes. You should therefore read this page carefully each time you access or use any part of this Service.</li>\n            </ol>\n            <h2>Nature of this Service</h2>\n            <ol start=\"5\">\n                <li>This Service facilitates crowd-sourcing road transport routes and the booking of transport services along those routes. GovTech DOES NOT provide, own or operate any transport services. When making a booking through this Service, you are entering\n                    into a contract with your selected transport service provider. GovTech is NOT responsible for the fulfilment and quality of transport services available through this Service.</li>\n\n                <li>Transport services, including provision of transport, booking amendments, cancellation and payment disputes, will be provided by your selected transport service provider in accordance with the Booking Policy of your selected transport\n                    service provider. The Booking Policy of your selected transport service provider is presented at the point of booking and in the email notification confirming your booking.</li>\n            </ol>\n            <h2>Proprietary Rights</h2>\n            <ol start=\"7\">\n                <li>The materials available on or through the Service, including any software, text and images (the Contents\"), are protected by copyright, trademark and other forms of proprietary rights. All rights, title and interest in the Contents are\n                    owned by, licensed to, or controlled by GovTech.</li>\n            </ol>\n\n            <h2>Content</h2>\n            <ol start=\"8\">\n\n                <li>Unless otherwise provided, the Contents shall not be reproduced, republished, uploaded, posted, transmitted or otherwise distributed in any way, without the prior written permission of GovTech.</li>\n\n                <li>You may use, hyperlink, copy and distribute the Contents found on this website solely for personal, internal, non-commercial, informational purposes only. You may download one copy of any information provided in this website onto a single\n                    computer for your own personal non-commercial use provided that you keep intact all accompanying copyright and other proprietary notices. You may not display, distribute or otherwise use any of the Content found on this website for\n                    any commercial purpose unless you receive specific prior written consent from GovTech.</li>\n\n                <li>Modification of any of the Contents or use of the Contents for any other purpose will be a violation of GovTech's copyright and other intellectual property rights. Graphics and images on this website are protected by copyright and may not\n                    be reproduced or appropriated in any manner without the prior written permission of their respective copyright owners.</li>\n\n                <li>The design and layout of the Contents are protected by intellectual property and other laws and may not be copied or imitated in whole or in part. No logo, graphic, sound, image or search engine from this website may be copied or transmitted\n                    unless with the prior express permission of GovTech. </li>\n            </ol>\n            <h2>Disclaimer of Warranties and Liability</h2>\n\n            <ol start=\"12\">\n                <li>\n                    This Service is provided on an \"as is\" and as available basis without warranties of any kind. To the fullest extent permitted by law, GovTech does not make any representations or warranties of any kind whatsoever in relation to the Service and hereby disclaims\n                    all express, implied and/or statutory warranties of any kind to you or any third party, whether arising from usage or custom or trade or by operation of law or otherwise, including but not limited to any representations or warranties:</li>\n\n                <ol style=\"list-style-type: lower-alpha;\">\n                    <li>\n                        as to the accuracy, completeness, correctness, currency, timeliness, reliability, availability, security, non-infringement, title, merchantability, quality or fitness for any particular purpose of the Service; and\n                    </li>\n                    <li>\n                        that the Contents available through this website or any functions associated therewith will be uninterrupted or error-free, or that defects will be corrected or that this website and the server is and will be free of all viruses and/or other malicious,\n                        destructive or corrupting code, programme or macro.\n                    </li>\n                </ol>\n\n\n\n                <li>GovTech shall also not be liable to you or any third party for any damage or loss of any kind whatsoever and howsoever caused, including but not limited to any direct or indirect, special or consequential damages, loss of income, revenue or\n                    profits, lost or damaged data, or damage to your computer, software or any other property, whether arising directly or indirectly from  </li>\n                <ol style=\"list-style-type: lower-alpha;\">\n                    <li>\n                        your access to or use of this Service or any part of this Service;\n                    </li>\n                    <li>\n                        any loss of access to our use of this Service or any part of this Service, howsoever caused;\n                    </li>\n                    <li>\n                        any inaccuracy or incompleteness in, or errors or omissions in the transmission of, the Contents;\n                    </li>\n                    <li>\n                        any delay or interruption in the transmission of the Contents, whether caused by delay or interruption in transmission over the internet or otherwise; or\n                    </li>\n                    <li>\n                        any decision made or action taken by you or any third party in reliance upon the Service,\n                    </li>\n                </ol>\n\n                <li>\n                    regardless of whether GovTech has been advised of the possibility of such damage or loss.\n                </li>\n                <li>\n                    For the avoidance of doubt, GovTech DOES NOT provide, own or operate any transport services, and makes no representation or warranty of any kind whatsoever in relation to any transport services provided by the transport service provider you select through\n                    this Service (including but not limited to any representations or warranties as to the timeliness, reliability, availability, quality or fitness for any particular purpose of the transport services provided by the transport service\n                    provider you select through this Service).\n                </li>\n                <li>\n                    For the avoidance of doubt, GovTech hereby disclaims all liability to you or any third party for any damage or loss of any kind whatsoever and howsoever caused, including but not limited to any direct, indirect, special or consequential damages, loss of income,\n                    revenue or profits, lost or damaged data, or damage to any property, whether arising directly or indirectly from your use of the transport services provided by the transport service provider you select through this Service.\n                </li>\n            </ol>\n\n            <h2>No Representations</h2>\n\n            <ol start=\"14\">\n\n                <li>Without prejudice to the generality of the disclaimers stated above, you agree that the Contents as provided by this Service, including but not limited to any information relating to  </li>\n                <ol style=\"list-style-type: lower-alpha;\">\n                    <li>\n                        GovTechs statutory duties, functions and powers; and\n                    </li>\n                    <li>\n                        GovTechs policies, frameworks, projects, initiatives, plans, schemes, objectives and instruments,\n                    </li>\n                </ol>\n\n                <li>\n                    shall not be construed as constituting any promise or representation by GovTech to you or any third party that GovTech will or will not adopt any particular course of action or confer any particular benefit upon you or any third party. The Contents shall not\n                    preclude, limit or constrain GovTechs exercise of its rights, powers and discretion in any way nor compel, require or oblige GovTech to exercise its rights, powers and discretion in any particular manner or to achieve any particular outcome.\n                </li>\n\n                <li>You further agree that you shall not rely on any of the Contents to claim or assert any form of legitimate expectation against GovTech, whether procedural or substantive in nature, in respect of any action that GovTech may or may not take in the\n                    exercise of its discretion as a public authority. </li>\n\n                <li>GovTech reserves the right to change, modify, add to, derogate from or vary its position in respect of any regulatory policies, frameworks, projects, initiatives, plans, schemes, objectives and instruments referred to on this website at any\n                    time in GovTechs sole and absolute discretion without prior notice to you. </li>\n\n                <li>You shall obtain your own professional and/or legal advice and conduct all necessary due diligence, including but not limited to making such other investigations or seeking clarifications as may be appropriate, as regards any decision\n                    or action that you intend to take in relation to any matter concerning the Contents.</li>\n            </ol>\n\n            <h2>Right of Access</h2>\n            <ol start=\"18\">\n                <li>GovTech reserves the right to update or modify this Service from time to time. GovTech further reserves all rights to deny or restrict access to this Service to any particular person, or to block access from a particular Internet address to this\n                    Service, at any time, without ascribing any reasons whatsoever.</li>\n                <li>You agree that you will not:</li>\n                <ol style=\"list-style-type: lower-alpha;\">\n                    <li>\n                        use any device, software or routine to interfere or attempt to interfere with the proper working of this Service; and\n                    </li>\n                    <li>\n                        take any action that imposes an unreasonable or disproportionately large load on GovTech's servers\n                    </li>\n                </ol>\n            </ol>\n            <h2>Hyperlinks to Third Party Sites</h2>\n\n            <ol start=\"20\">\n\n                <li>The Contents contain hyperlinks to websites which are not maintained nor controlled by GovTech. GovTech shall not be responsible for the content of any hyperlinked website or any hyperlink contained in a hyperlinked web site, and shall not be\n                    liable for any damages or loss arising from access to those websites. Use of the hyperlinks and access to such hyperlinked websites are entirely at your own risk. </li>\n\n                <li>All hyperlinks to other websites are provided as a convenience to you as a user of this Service. The inclusion of any hyperlink does not imply endorsement by GovTech of such websites. In no circumstances shall GovTech be considered to be associated\n                    or affiliated in whatever manner with any trade or service marks, logos, insignia or other devices used or appearing on websites to which the Contents are hyperlinked. </li>\n            </ol>\n\n            <h2>Hyperlinks to the Contents from Third Party Websites</h2>\n            <ol start=\"22\">\n                <li>Except as set forth below, caching and hyperlinks to, and the framing of any of the Contents are prohibited.</li>\n                <li>You may hyperlink to the Home Page of websites provided by the Service, upon prior notification to GovTech in writing. You must make a specific request for, and secure permission from GovTech prior to hyperlinking to, or framing, any of the Contents,\n                    or engaging in similar activities. GovTech reserves the right to impose conditions when permitting any hyperlinking to, or framing of or any of the Contents. </li>\n\n                <li>Your hyperlinking to, or your framing of any of the Contents constitute acceptance of these Terms of Use. This is deemed to be the case even after the posting of any changes or modifications to these Terms of Use. If you do not accept\n                    these Terms of Use, you must discontinue linking to, or framing of any of the Contents. </li>\n\n                <li>In no circumstances shall GovTech be considered to be associated or affiliated in any manner with any trade or service marks, logos, insignia or other devices used or appearing on websites that link to any of the Contents.</li>\n\n                <li>GovTech reserves all rights to disable any links to, or frames of any site containing inappropriate, profane, defamatory, infringing, obscene, indecent or unlawful topics, names, material or information, or material or information that violates\n                    any written law, any applicable intellectual property, proprietary, privacy or publicity rights. </li>\n\n                <li>GovTech reserves the right to disable any unauthorised links or frames and disclaims any responsibility for the content available on any other site reached by links to or from any of the Contents. </li>\n            </ol>\n\n            <h2>Governing Law</h2>\n            <ol start=\"28\">\n                <li>\n                    These Terms of Use shall be governed and construed in accordance with laws of Singapore.</li>\n            </ol>\n\n        </ion-item>\n    </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 484 */
/*!***********************************!*\
  !*** ./beeline/services/login.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($rootScope, $ionicModal, Legalese) {
	  this.show = function () {
	    var scope = $rootScope.$new();
	    var loginModal = $ionicModal.fromTemplate(_loginModal2.default, { scope: scope });
	
	    scope.modal = loginModal;
	    scope.phonePattern = VALID_PHONE_REGEX;
	    scope.showPrivacyPolicy = function () {
	      return Legalese.showPrivacyPolicy();
	    };
	    scope.showTermsOfUse = function () {
	      return Legalese.showTermsOfUse();
	    };
	
	    scope.data = {};
	    scope.form = {};
	
	    function cleanup() {
	      loginModal.remove();
	    }
	
	    var loginPromise = new Promise(function (resolve, reject) {
	      scope.$on('modal.hidden', function () {
	        if (scope.reject) scope.reject(null);
	        scope.accept = scope.reject = null;
	      });
	
	      scope.reject = resolve;
	
	      scope.accept = function () {
	        scope.accept = scope.reject = null;
	        loginModal.hide();
	        // returns [ telephone-number, want-telephone-verification ]
	        resolve([scope.data.telephone, true]);
	      };
	
	      scope.bypass = function () {
	        scope.accept = scope.reject = null;
	        loginModal.hide();
	        // returns [ telephone-number, want-telephone-verification ]
	        resolve([scope.data.telephone, false]);
	      };
	
	      loginModal.show();
	    });
	
	    loginPromise.then(cleanup, cleanup);
	
	    return loginPromise;
	  };
	};
	
	var _loginModal = __webpack_require__(/*! ../templates/login-modal.html */ 485);
	
	var _loginModal2 = _interopRequireDefault(_loginModal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var VALID_PHONE_REGEX = /^[8-9]{1}[0-9]{7}$|^########$/;

/***/ },
/* 485 */
/*!********************************************!*\
  !*** ./beeline/templates/login-modal.html ***!
  \********************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">Login</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"modal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content ng-form=\"form.validation\" scroll=\"false\">\n    <div class=\"item item-text-wrap loginContent\">\n      <div class=\"list list-inset\">\n        <p>\n          Please enter your telephone number.\n        </p>\n        <label class=\"item item-input loginTel\">\n          <i class=\"icon ion-ios-telephone placeholder-icon\"></i><span class=\"telPrefix\">+65</span>\n          <input ng-model=\"data.telephone\" name=\"telephone\" ng-required=\"true\" ng-pattern=\"phonePattern\" placeholder=\"91234567\" type=\"tel\">\n        </label>\n        <div class=\"has-error\" ng-show=\"form.validation.telephone.$invalid\n                  && form.validation.telephone.$dirty\">\n          The phone no. you provide does not appear to be in the correct format. Please provide a valid 8-digit phone no. starting with the number 8 or 9.\n        </div>\n        <div class=\"checkTerms\">\n            Please read {{o.APP.NAME}}'s <a ng-click=\"showPrivacyPolicy()\">Privacy Policy</a> and <a ng-click=\"showTermsOfUse()\">Terms of Use</a>.\n          <ion-checkbox ng-model=\"acceptPolicy\" ng-required=\"true\">I read and agree to the above terms and would like to proceed using {{o.APP.NAME}}.\n          </ion-checkbox>\n        </div>\n\n        <div class=\"buttons\">\n          <button class=\"primary-button button\" ng-click=\"accept()\" ng-disabled=\"form.validation.$invalid\">\n            Log in\n          </button>\n\n          <button class=\"button button-clear button-royal\" ng-click=\"bypass()\" ng-disabled=\"form.validation.$invalid\">\n            I already have a PIN\n          </button>\n        </div>\n\n      </div>\n    </div>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 486 */
/*!************************************************!*\
  !*** ./beeline/services/KickstarterService.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = KickstarterService;
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _SafeInterval = __webpack_require__(/*! ../SafeInterval */ 487);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var transformKickstarterData = function transformKickstarterData(kickstarterRoutes) {
	  if (!kickstarterRoutes) return null;
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;
	
	  try {
	    for (var _iterator = kickstarterRoutes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var kickstarter = _step.value;
	
	      kickstarter.isActived = false;
	      if (kickstarter.bids && kickstarter.bids.length > 0) {
	        var bidsByTier = _lodash2.default.groupBy(kickstarter.bids, function (x) {
	          return x.userOptions.price;
	        });
	        kickstarter.notes.tier.map(function (tier) {
	          var countCommitted = bidsByTier[tier.price] ? bidsByTier[tier.price].length : 0;
	          _lodash2.default.assign(tier, { count: countCommitted,
	            moreNeeded: Math.max(tier.pax - countCommitted, 0) });
	        });
	      } else {
	        kickstarter.notes.tier.map(function (tier) {
	          _lodash2.default.assign(tier, { count: 0, moreNeeded: tier.pax });
	        });
	      }
	      //order tiers in price desc order
	      kickstarter.notes.tier = _lodash2.default.orderBy(kickstarter.notes.tier, function (x) {
	        return x.price;
	      }, "desc");
	      //if sb. commit $8, also commit $5
	      // kickstarter.notes.tier[1].count += kickstarter.notes.tier[0].count;
	      kickstarter.isActived = kickstarter.notes.tier[0].moreNeeded == 0;
	
	      kickstarter.isExpired = false;
	      kickstarter.is7DaysOld = false;
	
	      var now = new Date().getTime();
	      if (kickstarter.notes && kickstarter.notes.lelongExpiry) {
	        var expiryTime = new Date(kickstarter.notes.lelongExpiry).getTime();
	        if (now >= expiryTime) {
	          kickstarter.isExpired = true;
	          if (now - expiryTime >= 7 * 1000 * 60 * 60 * 24) {
	            kickstarter.is7DaysOld = true;
	          }
	        } else {
	          var day = 1000 * 60 * 60 * 24;
	          kickstarter.daysLeft = Math.ceil((expiryTime - now) / day);
	        }
	      }
	
	      // isSuccess / isFailure
	      kickstarter.isFailed = kickstarter.tags.indexOf('failed') != -1;
	      kickstarter.isSuccess = kickstarter.tags.indexOf('success') != -1;
	      kickstarter.isConverted = kickstarter.isFailed || kickstarter.isSuccess;
	
	      //filter only isRunning trips
	      //sort trips date in ascending order
	      kickstarter.trips = (0, _lodash2.default)(kickstarter.trips).filter(function (x) {
	        return x.isRunning;
	      }).orderBy(function (x) {
	        return x.date;
	      }).value();
	      //sort tripStops time in ascending order
	      _lodash2.default.forEach(kickstarter.trips, function (trip) {
	        trip.tripStops = _lodash2.default.orderBy(trip.tripStops, function (stop) {
	          return stop.time;
	        });
	      });
	
	      //calculate the pass expiry date
	      kickstarter.passExpired = false;
	      var firstTripDate = new Date(kickstarter.trips[0].date);
	      var passExpiryTime = new Date(firstTripDate.getFullYear(), firstTripDate.getMonth() + 1, firstTripDate.getDate()).getTime();
	      kickstarter.passExpired = now >= passExpiryTime;
	      updateStatus(kickstarter);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	
	  return kickstarterRoutes;
	};
	
	var updateStatus = function updateStatus(route) {
	  //status of kickstarter
	  route.status = "";
	  if (route.notes.tier[0].moreNeeded == 0) {
	    route.status = "Yay! Route is activated at $" + route.notes.tier[0].price.toFixed(2) + " per trip.";
	  } else if (!route.isExpired) {
	    route.status = route.notes.tier[0].moreNeeded + " more pax to activate the route at $" + route.notes.tier[0].price.toFixed(2) + " per trip.";
	  } else if (route.isSuccess) {
	    route.status = "Campaign was successful! Check out the running routes for more info";
	  } else {
	    route.status = "Campaign has expired and the route is not activated.";
	  }
	};
	
	var updateAfterBid = function updateAfterBid(route, price) {
	  route.notes.tier[0].count = route.notes.tier[0].count + 1;
	  route.notes.tier[0].moreNeeded = Math.max(route.notes.tier[0].moreNeeded - 1, 0);
	  route.isActived = route.notes.tier[0].moreNeeded == 0;
	  updateStatus(route);
	};
	
	function KickstarterService($http, UserService, $q, $rootScope, RoutesService, p, DevicePromise) {
	  var fetchNearbyKickstarterIds = function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	      var locationOrNull, coords, nearbyPromise, nearbyReversePromise;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              locationOrNull = null;
	              _context.prev = 1;
	              _context.next = 4;
	              return DevicePromise;
	
	            case 4:
	              _context.next = 6;
	              return getLocationPromise(false);
	
	            case 6:
	              locationOrNull = _context.sent;
	              _context.next = 13;
	              break;
	
	            case 9:
	              _context.prev = 9;
	              _context.t0 = _context['catch'](1);
	
	              // Location not found -- suppress error
	              nearbyKickstarterRoutesById = nearbyKickstarterRoutesById || null;
	              return _context.abrupt('return', new Promise(function (resolve, reject) {
	                resolve(nearbyKickstarterRoutesById);
	              }));
	
	            case 13:
	              coords = {
	                latitude: locationOrNull.coords.latitude,
	                longitude: locationOrNull.coords.longitude
	              };
	              nearbyPromise = UserService.beeline({
	                method: 'GET',
	                url: '/routes/search_by_latlon?' + _querystring2.default.stringify(_lodash2.default.assign({ maxDistance: 2000,
	                  startTime: Date.now(),
	                  tags: JSON.stringify(['lelong']),
	                  startLat: coords.latitude,
	                  startLng: coords.longitude
	                }, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {}))
	              });
	              nearbyReversePromise = UserService.beeline({
	                method: 'GET',
	                url: '/routes/search_by_latlon?' + _querystring2.default.stringify(_lodash2.default.assign({ maxDistance: 2000,
	                  startTime: Date.now(),
	                  tags: JSON.stringify(['lelong']),
	                  endLat: coords.latitude,
	                  endLng: coords.longitude
	                }, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {}))
	              });
	              return _context.abrupt('return', Promise.all([nearbyPromise, nearbyReversePromise]).then(function (values) {
	                var _values = _slicedToArray(values, 2),
	                    np = _values[0],
	                    nvp = _values[1];
	
	                return nearbyKickstarterRoutesById = (0, _lodash2.default)(np.data.concat(nvp.data)).map(function (r) {
	                  return r.id;
	                }).uniq().value();
	              }));
	
	            case 17:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, this, [[1, 9]]);
	    }));
	
	    return function fetchNearbyKickstarterIds() {
	      return _ref.apply(this, arguments);
	    };
	  }();
	
	  var kickstarterRoutesCache;
	  var bidsCache;
	  var kickstarterSummary = null,
	      bidsById = null;
	  var kickstarterRoutesList = null,
	      kickstarterRoutesById = null;
	  var nearbyKickstarterRoutesById = null;
	
	  UserService.userEvents.on('userChanged', function () {
	    _fetchBids(true);
	    //to load route credits
	    RoutesService.fetchRoutePassCount(true);
	  });
	
	  //first load
	  // every 1 hour should reload kickstarter information
	  var timeout = new _SafeInterval.SafeInterval(refresh, 1000 * 60 * 60, 1000 * 60);
	
	  function refresh() {
	    return Promise.all([fetchKickstarterRoutes(true), _fetchBids(true), fetchNearbyKickstarterIds()]);
	  }
	
	  timeout.start();
	
	  function _fetchBids(ignoreCache) {
	    if (UserService.getUser()) {
	      if (bidsCache && !ignoreCache) return bidsCache;
	      return bidsCache = UserService.beeline({
	        method: 'GET',
	        url: '/custom/lelong/bids'
	      }).then(function (response) {
	        // kickstarterSummary = response.data;
	        kickstarterSummary = response.data.map(function (bid) {
	          return { routeId: bid.id,
	            boardStopId: bid.bid.tickets[0].boardStop.stopId,
	            alightStopId: bid.bid.tickets[0].alightStop.stopId,
	            bidPrice: bid.bid.userOptions.price,
	            ticketStatus: bid.bid.tickets[0].status };
	        });
	        bidsById = _lodash2.default.keyBy(kickstarterSummary, function (r) {
	          return r.routeId;
	        });
	        return kickstarterSummary;
	      });
	    } else {
	      kickstarterSummary = [];
	      return $q.resolve(kickstarterSummary);
	    }
	  }
	
	  function fetchKickstarterRoutes(ignoreCache) {
	    if (kickstarterRoutesCache && !ignoreCache) return kickstarterRoutesCache;
	    var url = '/custom/lelong/status';
	    if (p.transportCompanyId) {
	      url += '?' + _querystring2.default.stringify({ transportCompanyId: p.transportCompanyId });
	    }
	    return kickstarterRoutesCache = UserService.beeline({
	      method: 'GET',
	      url: url
	    }).then(function (response) {
	      //return expired kickstarter too
	      kickstarterRoutesList = transformKickstarterData(response.data);
	      kickstarterRoutesById = _lodash2.default.keyBy(kickstarterRoutesList, 'id');
	      return kickstarterRoutesList;
	    });
	  }
	
	  function getLocationPromise() {
	    var enableHighAccuracy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
	
	    return new Promise(function (resolve, reject) {
	      navigator.geolocation.getCurrentPosition(function (success) {
	        return resolve(success);
	      }, function (error) {
	        return reject(error);
	      }, { enableHighAccuracy: enableHighAccuracy });
	    });
	  }
	
	  return {
	    //all lelong routes
	    getLelong: function getLelong() {
	      return kickstarterRoutesList;
	    },
	    fetchLelong: function fetchLelong(ignoreCache) {
	      return fetchKickstarterRoutes(ignoreCache);
	    },
	
	    getLelongById: function getLelongById(routeId) {
	      return kickstarterRoutesById ? kickstarterRoutesById[routeId] : null;
	    },
	
	    //user personal bid information
	    getBids: function getBids() {
	      return kickstarterSummary;
	    },
	    fetchBids: function fetchBids(ignoreCache) {
	      return _fetchBids(ignoreCache);
	    },
	
	    isBid: function isBid(routeId) {
	      return bidsById && bidsById[routeId] ? true : false;
	    },
	
	    getBidInfo: function getBidInfo(routeId) {
	      return kickstarterSummary ? kickstarterSummary.find(function (x) {
	        return x.routeId == routeId;
	      }) : null;
	    },
	
	    //need to return a promise
	    hasBids: function hasBids() {
	      return bidsCache.then(function () {
	        return kickstarterSummary && kickstarterSummary.length > 0 && kickstarterSummary.find(function (x) {
	          return x.ticketStatus === 'bidded';
	        });
	      });
	    },
	
	    createBid: function createBid(route, boardStopId, alightStopId, bidPrice) {
	      return UserService.beeline({
	        method: 'POST',
	        url: '/custom/lelong/bid',
	        data: {
	          trips: route.trips.map(function (trip) {
	            return {
	              tripId: trip.id,
	              boardStopId: boardStopId,
	              alightStopId: alightStopId
	            };
	          }),
	          promoCode: {
	            code: 'LELONG',
	            options: { price: bidPrice }
	          }
	        }
	      }).then(function (response) {
	        updateAfterBid(kickstarterRoutesById[route.id], bidPrice);
	        kickstarterSummary = kickstarterSummary.concat([{
	          routeId: route.id,
	          boardStopId: boardStopId,
	          alightStopId: alightStopId,
	          bidPrice: bidPrice,
	          ticketStatus: 'bidded'
	        }]);
	        return response.data;
	      });
	    },
	
	    getNearbyKickstarterIds: function getNearbyKickstarterIds() {
	      return nearbyKickstarterRoutesById;
	    },
	
	    fetchNearbyKickstarterIds: fetchNearbyKickstarterIds
	  };
	}

/***/ },
/* 487 */
/*!*********************************!*\
  !*** ./beeline/SafeInterval.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SafeInterval = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SafeInterval = exports.SafeInterval = function () {
	  function SafeInterval(fn, interval, retryTimeout) {
	    _classCallCheck(this, SafeInterval);
	
	    this.isRunning = false;
	    this.timeout = null;
	
	    retryTimeout = retryTimeout || interval;
	
	    //fn returns a Promise
	    this.loop = function () {
	      var _this = this;
	
	      this.timeout = null;
	
	      var promise = this.currentPromise = fn();
	
	      this.currentPromise.then(function () {
	        if (promise == _this.currentPromise && _this.isRunning) {
	          _this.timeout = setTimeout(_this.loop, interval);
	        }
	      }).catch(function () {
	        if (promise == _this.currentPromise && _this.isRunning) {
	          _this.timeout = setTimeout(_this.loop, retryTimeout);
	        }
	      });
	    }.bind(this);
	  }
	
	  _createClass(SafeInterval, [{
	    key: 'stop',
	    value: function stop() {
	      this.isRunning = false;
	      if (this.timeout !== null) {
	        clearTimeout(this.timeout);
	      }
	    }
	  }, {
	    key: 'start',
	    value: function start() {
	      if (this.isRunning) return;
	      this.isRunning = true;
	      this.loop();
	    }
	  }]);

	  return SafeInterval;
	}();

/***/ },
/* 488 */
/*!******************************************************!*\
  !*** ./beeline/controllers/IntroSlidesController.js ***!
  \******************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($scope) {
	  $scope.options = {
	    loop: false,
	    effect: 'slide',
	    speed: 500
	  };
	
	  $scope.data = {
	    slider: null,
	    buttonLabel: 'SKIP',
	    showHome: undefined
	  };
	
	  //if has cordova no need to show first 2 slides in intro
	  $scope.data.showHome = !window.cordova || false;
	
	  $scope.$on("$ionicSlides.sliderInitialized", function (event, data) {
	    //only has 1 slide
	    if (data.slider.isBeginning && data.slider.isEnd) {
	      $scope.data.buttonLabel = 'DONE';
	      $scope.$digest();
	    }
	  });
	
	  $scope.$on("$ionicSlides.slideChangeEnd", function (event, data) {
	    // note: the indexes are 0-based
	    if (!data.slider.isEnd) {
	      $scope.data.buttonLabel = 'SKIP';
	    } else {
	      $scope.data.buttonLabel = 'DONE';
	    }
	    $scope.$digest();
	  });
	};

/***/ },
/* 489 */
/*!*****************************************************!*\
  !*** ./beeline/controllers/RoutesListController.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = function ($scope, $state, UserService, RoutesService, $q, BookingService, $ionicScrollDelegate, LiteRoutesService, $ionicPopup, LiteRouteSubscriptionService, $timeout, SearchService, $ionicModal, $cordovaSocialSharing) {
	
	  // https://github.com/angular/angular.js/wiki/Understanding-Scopes
	  $scope.data = {
	    regions: [],
	    routes: [],
	    recentRoutes: [],
	    selectedRegionId: undefined,
	    filterText: '',
	    stagingFilterText: '',
	    filteredActiveRoutes: [],
	    filteredRecentRoutes: [],
	    nextSessionId: null,
	    liteRoutes: [],
	    filteredLiteRoutes: []
	  };
	
	  // Modal for sharing referral
	  $scope.hasCordova = !!window.cordova || false;
	  $scope.shareReferralModal = $ionicModal.fromTemplate(_shareReferralModal2.default, { scope: $scope });
	  $scope.cordovaShare = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            $cordovaSocialSharing.share($scope.shareMsg, "Try out Beeline!");
	
	          case 1:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	
	  $scope.$on('$ionicView.beforeEnter', function () {
	    $scope.data.nextSessionId = BookingService.newSession();
	  });
	
	  $scope.$watch(function () {
	    return RoutesService.getActivatedKickstarterRoutes();
	  }, function (rpRoutes) {
	    $scope.data.activatedKickstarterRoutes = rpRoutes;
	  });
	
	  $scope.$watch(function () {
	    return UserService.getUser();
	  }, function (newUser) {
	    $scope.user = newUser;
	
	    if (newUser) {
	      $scope.shareMsg = UserService.getReferralMsg();
	    } else {
	      $scope.shareMsg = null;
	    }
	
	    // Referral Sharing - hidden for now
	    // if(!JSON.parse(window.localStorage.showedReferralModal) && newUser){
	    //   window.localStorage.showedReferralModal = true
	    //   $scope.shareReferralModal.show()
	    // }
	  });
	
	  RoutesService.fetchRoutesWithRoutePass();
	
	  // $scope.$watch('data.liteRoutes', updateSubscriptionStatus)
	  // $scope.$watch(() => Svc.getSubscriptionSummary(), updateSubscriptionStatus)
	  var allLiteRoutesPromise;
	
	  $scope.refreshRoutes = function (ignoreCache) {
	    RoutesService.fetchRouteCredits(ignoreCache);
	    RoutesService.fetchRoutes(ignoreCache);
	    var routesPromise = RoutesService.fetchRoutesWithRoutePass();
	    var recentRoutesPromise = RoutesService.fetchRecentRoutes(ignoreCache);
	
	    // Lite Routes
	    allLiteRoutesPromise = LiteRoutesService.getLiteRoutes(ignoreCache);
	    var liteRouteSubscriptionsPromise = LiteRouteSubscriptionService.getSubscriptions(ignoreCache);
	    // allLiteRoutesPromise.then(function(allLiteRoutes){
	    //   $scope.data.liteRoutes = allLiteRoutes;
	    // })
	    $q.all([allLiteRoutesPromise, liteRouteSubscriptionsPromise]).then(function (response) {
	      var allLiteRoutes, liteRouteSubscriptions;
	
	      var _response = _slicedToArray(response, 2);
	
	      allLiteRoutes = _response[0];
	      liteRouteSubscriptions = _response[1];
	
	      $scope.data.liteRoutes = _lodash2.default.sortBy(allLiteRoutes, 'label');
	    });
	
	    $q.all([routesPromise, recentRoutesPromise, allLiteRoutesPromise, liteRouteSubscriptionsPromise]).then(function () {
	      $scope.error = null;
	    }).catch(function () {
	      $scope.error = true;
	    }).then(function () {
	      $scope.$broadcast('scroll.refreshComplete');
	    });
	  };
	
	  $scope.$watch(function () {
	    return RoutesService.getRoutesWithRoutePass();
	  }, function (allRoutes) {
	
	    $scope.data.routes = _lodash2.default.sortBy(allRoutes, 'label', function (route) {
	      var firstTripStop = _lodash2.default.get(route, 'trips[0].tripStops[0]');
	      var midnightOfTrip = new Date(firstTripStop.time.getTime());
	
	      midnightOfTrip.setHours(0, 0, 0, 0);
	      return firstTripStop.time.getTime() - midnightOfTrip.getTime();
	    });
	  });
	
	  $scope.$watchCollection(function () {
	    return [RoutesService.getRecentRoutes(), RoutesService.getRoutesWithRoutePass()];
	  }, function (_ref2) {
	    var _ref3 = _slicedToArray(_ref2, 2),
	        recentRoutes = _ref3[0],
	        allRoutes = _ref3[1];
	
	    if (recentRoutes && allRoutes) {
	      (function () {
	        var allRoutesById = _lodash2.default.keyBy(allRoutes, 'id');
	
	        $scope.data.recentRoutes = recentRoutes.map(function (r) {
	          return _lodash2.default.assign({
	            alightStopStopId: r.alightStopStopId,
	            boardStopStopId: r.boardStopStopId
	          }, allRoutesById[r.id]);
	        }).filter(function (r) {
	          return r.id !== undefined;
	        });
	      })();
	    }
	  });
	
	  // Filter the displayed routes by selected region
	  $scope.$watchGroup(['data.routes', 'data.liteRoutes', 'data.activatedKickstarterRoutes', 'data.selectedRegionId', 'data.filterText'], function (_ref4) {
	    var _ref5 = _slicedToArray(_ref4, 5),
	        routes = _ref5[0],
	        liteRoutes = _ref5[1],
	        activatedKickstarterRoutes = _ref5[2],
	        selectedRegionId = _ref5[3],
	        filterText = _ref5[4];
	
	    var normalAndLiteRoutes = routes.concat(_lodash2.default.values(liteRoutes));
	    $scope.data.regions = RoutesService.getUniqueRegionsFromRoutes(normalAndLiteRoutes);
	    $scope.data.filteredActiveRoutes = SearchService.filterRoutes(routes, +selectedRegionId, filterText);
	    $scope.data.filteredLiteRoutes = SearchService.filterRoutes(liteRoutes, +selectedRegionId, filterText);
	    $scope.data.filteredActivatedKickstarterRoutes = SearchService.filterRoutes(activatedKickstarterRoutes, +selectedRegionId, filterText);
	  });
	
	  // Throttle the actual updating of filter text
	  $scope.updateFilter = _lodash2.default.throttle(function (value) {
	    // Some times this function is called synchronously, some times it isn't
	    // Use timeout to ensure that we are always inside a digest cycle.
	    setTimeout(function () {
	      $scope.data.filterText = $scope.data.stagingFilterText;
	      $scope.$digest();
	    }, 0);
	  }, 400, { trailing: true });
	
	  // Filter the recent routes display whenever the active routes is changed
	  // This cascades the region filter from the previous block
	  $scope.$watchGroup(['data.filteredActiveRoutes', 'data.recentRoutes', 'data.filteredActivatedKickstarterRoutes'], function (_ref6) {
	    var _ref7 = _slicedToArray(_ref6, 3),
	        newActiveRoutes = _ref7[0],
	        recentRoutes = _ref7[1],
	        newKickstarterRoutes = _ref7[2];
	
	    if (!recentRoutes) return;
	
	    $scope.data.recentRoutesById = _lodash2.default.keyBy(recentRoutes, function (r) {
	      return r.id;
	    });
	    $scope.data.filteredRecentRoutes = recentRoutes.map(function (recent) {
	      return newActiveRoutes.find(function (route) {
	        return route.id === recent.id;
	      });
	    }).filter(function (x) {
	      return x;
	    }); // Exclude null values (e.g. expired routes)
	
	    // filter out duplicate ones in recently booked to prevent displaying it too many times
	    $scope.data.filteredRecentRoutes = _lodash2.default.difference($scope.data.filteredRecentRoutes, newKickstarterRoutes);
	  });
	
	  $scope.$watchGroup(['data.filteredRecentRoutes', 'data.filteredActiveRoutes', 'data.filteredLiteRoutes', 'data.filteredActivatedKickstarterRoutes'], function () {
	    $ionicScrollDelegate.resize();
	  });
	
	  $scope.$watchCollection(function () {
	    return [].concat(LiteRouteSubscriptionService.getSubscriptionSummary()).concat([$scope.data.liteRoutes]);
	  }, function () {
	    var subscribedRoutes = LiteRouteSubscriptionService.getSubscriptionSummary();
	    _lodash2.default.forEach($scope.data.liteRoutes, function (liteRoute) {
	      if (subscribedRoutes.includes(liteRoute.label)) {
	        liteRoute.isSubscribed = true;
	      } else {
	        liteRoute.isSubscribed = false;
	      }
	    });
	  });
	
	  // Don't override the caching in main.js
	  $scope.refreshRoutes();
	};
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _shareReferralModal = __webpack_require__(/*! ../templates/share-referral-modal.html */ 490);
	
	var _shareReferralModal2 = _interopRequireDefault(_shareReferralModal);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	// Parse out the available regions from the routes
	// Filter what is displayed by the region filter
	// Split the routes into those the user has recently booked and the rest

/***/ },
/* 490 */
/*!*****************************************************!*\
  !*** ./beeline/templates/share-referral-modal.html ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">Invite friends</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"shareReferralModal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content id=\"share-rides\">\n    <div class=\"item item-text-wrap\">\n      <div class=\"referral-code\">\n        {{user.referralCode.code}}\n      </div>\n      <p>Share this to your friend so that they receive $10 off Beeline rides.  You'll automatically get $10 ride credits, once they claim their first ride.</p>\n      <div class=\"share-box\">\n        <textarea rows=\"4\" id=\"shareMsg\" ng-model=\"shareMsg\"></textarea>\n\n        <div class=\"text-right\">\n          <button ng-if=\"!hasCordova\" class=\"button button-outline button-royal small-button\" ngclipboard data-clipboard-text=\"{{ shareMsg }}\">Copy</button>\n          <button ng-if=\"hasCordova\" class=\"button button-outline button-royal small-button\" ng-click=\"cordovaShare()\">Share</button>\n        </div>\n      </div>\n    </div>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 491 */
/*!*******************************************************!*\
  !*** ./beeline/controllers/BookingStopsController.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	exports.default = ['$rootScope', '$scope', '$interpolate', '$state', '$stateParams', '$ionicModal', '$http', '$cordovaGeolocation', 'BookingService', 'RoutesService', 'UserService', 'uiGmapGoogleMapApi', 'MapOptions', 'loadingSpinner', '$q', function ($rootScope, $scope, $interpolate, $state, $stateParams, $ionicModal, $http, $cordovaGeolocation, BookingService, RoutesService, UserService, uiGmapGoogleMapApi, MapOptions, loadingSpinner, $q) {
	  // Gmap default settings
	  $scope.map = MapOptions.defaultMapOptions();
	  $scope.routePath = [];
	
	  // Booking session logic
	  $scope.session = {
	    sessionId: null
	  };
	  // Default settings for various info used in the page
	  $scope.book = {
	    routeId: null,
	    route: null,
	    boardStops: [], // all board stops for this route
	    alightStops: [], // all alight stops for this route
	    boardStop: null,
	    alightStop: null,
	    changes: {}
	  };
	  $scope.disp = {
	    popupStop: null,
	    popupStopType: null,
	    parentScope: $scope
	  };
	
	  // Resolved when the map is initialized
	  var gmapIsReady = new Promise(function (resolve, reject) {
	    var resolved = false;
	    $scope.$watch('map.control.getGMap', function () {
	      if ($scope.map.control.getGMap) {
	        if (!resolved) {
	          resolved = true;
	          resolve();
	        }
	      }
	    });
	  });
	
	  $scope.session.sessionId = +$stateParams.sessionId;
	  $scope.book.routeId = +$stateParams.routeId;
	
	  var routePromise = RoutesService.getRoute($scope.book.routeId);
	
	  var stopOptions = {
	    initialBoardStopId: $stateParams.boardStop ? parseInt($stateParams.boardStop) : undefined,
	    initialAlightStopId: $stateParams.alightStop ? parseInt($stateParams.alightStop) : undefined
	  };
	
	  var routePostProcessingPromise = routePromise.then(function (route) {
	    $scope.book.route = route;
	    computeStops(stopOptions);
	  });
	
	  var ridesRemainingPromise = RoutesService.fetchRoutePassCount();
	
	  $q.all([routePromise, ridesRemainingPromise]).then(function (values) {
	    var ridesRemainingMap = values[1];
	    if (ridesRemainingMap) {
	      $scope.book.route.ridesRemaining = ridesRemainingMap[$scope.book.routeId];
	    } else {
	      $scope.book.route.ridesRemaining = null;
	    }
	  });
	
	  $scope.$on('$ionicView.afterEnter', function () {
	    loadingSpinner(Promise.all([gmapIsReady, routePromise]).then(function () {
	      var gmap = $scope.map.control.getGMap();
	      google.maps.event.trigger(gmap, 'resize');
	      panToStops();
	    }));
	  });
	
	  gmapIsReady.then(function () {
	    MapOptions.disableMapLinks();
	  });
	
	  $scope.$watch('book.route.path', function (path) {
	    if (!path) {
	      $scope.routePath = [];
	    } else {
	      RoutesService.decodeRoutePath(path).then(function (decodedPath) {
	        return $scope.routePath = decodedPath;
	      }).catch(function () {
	        return $scope.routePath = [];
	      });
	    }
	  });
	
	  $scope.applyTapBoard = function (stop) {
	    $scope.disp.popupStopType = "pickup";
	    $scope.disp.popupStop = stop;
	    $scope.$digest();
	  };
	  $scope.applyTapAlight = function (stop) {
	    $scope.disp.popupStopType = "dropoff";
	    $scope.disp.popupStop = stop;
	    $scope.$digest();
	  };
	  $scope.setStop = function (stop, type) {
	    if (type === 'pickup') {
	      $scope.book.boardStop = stop;
	    } else {
	      $scope.book.alightStop = stop;
	    }
	    $scope.disp.popupStop = null;
	  };
	  $scope.closeWindow = function () {
	    $scope.disp.popupStop = null;
	  };
	
	  /* Pans to the stops on the screen */
	  function panToStops() {
	    var stops = [];
	    stops = $scope.book.boardStops.concat($scope.book.alightStops);
	
	    if (stops.length == 0) {
	      return;
	    }
	    var bounds = new google.maps.LatLngBounds();
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = stops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var s = _step.value;
	
	        bounds.extend(new google.maps.LatLng(s.coordinates.coordinates[1], s.coordinates.coordinates[0]));
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    $scope.map.control.getGMap().fitBounds(bounds);
	  }
	
	  /** Summarizes the stops from trips by comparing their stop location and time */
	  function computeStops(_ref) {
	    var initialBoardStopId = _ref.initialBoardStopId,
	        initialAlightStopId = _ref.initialAlightStopId;
	
	    var trips = $scope.book.route.trips;
	
	    var _BookingService$compu = BookingService.computeStops(trips),
	        _BookingService$compu2 = _slicedToArray(_BookingService$compu, 2),
	        boardStops = _BookingService$compu2[0],
	        alightStops = _BookingService$compu2[1];
	
	    $scope.book.boardStops = boardStops;
	    $scope.book.alightStops = alightStops;
	
	    // Check that the boardStopIds are still valid
	    if (typeof initialBoardStopId === 'number') {
	      $scope.book.boardStop = boardStops.find(function (ts) {
	        return ts.id === initialBoardStopId;
	      });
	    }
	    // Check that the boardStopIds are still valid
	    if (typeof initialAlightStopId === 'number') {
	      $scope.book.alightStop = alightStops.find(function (ts) {
	        return ts.id === initialAlightStopId;
	      });
	    }
	  }
	}];

/***/ },
/* 492 */
/*!*******************************************************!*\
  !*** ./beeline/controllers/BookingDatesController.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var moment = __webpack_require__(/*! moment */ 311);
	exports.default = ['$scope', '$state', '$http', 'BookingService', 'UserService', 'RoutesService', '$stateParams', 'TicketService', 'loadingSpinner', '$q', '$ionicScrollDelegate', function ($scope, $state, $http, BookingService, UserService, RoutesService, $stateParams, TicketService, loadingSpinner, $q, $ionicScrollDelegate) {
	  var now = new Date();
	
	  // Booking session logic.
	  // Defines the set of variables that, when changed, all user inputs
	  // on this page should be cleared.
	  $scope.session = {
	    sessionId: $stateParams.sessionId,
	    userId: null
	  };
	  // Data logic;
	  $scope.book = {
	    routeId: +$stateParams.routeId,
	    route: null,
	    boardStopId: parseInt($stateParams.boardStop),
	    alightStopId: parseInt($stateParams.alightStop),
	    priceInfo: {},
	    selectedDates: [],
	    invalidStopDates: [],
	    applyRouteCredits: false,
	    applyReferralCredits: false,
	    applyCredits: false,
	    creditTag: null
	  };
	  // Display Logic;
	  $scope.disp = {
	    month: moment(),
	    validDates: [],
	    soldOutDates: [],
	    bookedDates: [],
	    today: moment(),
	    availabilityDays: undefined,
	    previouslyBookedDays: undefined,
	    highlightDays: [],
	    daysAllowed: [],
	    selectedDatesMoments: []
	  };
	
	  var routePromise = loadRoutes();
	
	  var ridesRemainingPromise = RoutesService.fetchRoutePassCount();
	  $q.all([routePromise, ridesRemainingPromise]).then(function (values) {
	    var ridesRemainingMap = values[1];
	    $scope.book.route.ridesRemaining = ridesRemainingMap[$scope.book.routeId];
	  });
	
	  RoutesService.fetchRouteCreditTags();
	  $scope.$watch(function () {
	    return RoutesService.getRouteCreditTags();
	  }, function (routeToCreditTags) {
	    var creditTag = routeToCreditTags ? routeToCreditTags[$scope.book.routeId] : null;
	    $scope.book.applyRouteCredits = !!creditTag;
	    $scope.book.creditTag = creditTag;
	  });
	
	  $scope.$watch(function () {
	    return UserService.getUser();
	  }, function (user) {
	    loadTickets();
	    $scope.book.applyReferralCredits = !!user;
	    $scope.book.applyCredits = !!user;
	  });
	
	  $scope.$watch(
	  /* Don't watch the entire moment objects, just their value */
	  function () {
	    return $scope.disp.selectedDatesMoments.map(function (m) {
	      return m.valueOf();
	    });
	  }, function () {
	    // multiple-date-picker gives us the
	    // date in midnight local time
	    // Need to convert to UTC
	    $scope.book.selectedDates = $scope.disp.selectedDatesMoments.map(function (m) {
	      return m.valueOf();
	    });
	  }, true);
	
	  $scope.$watchGroup(['disp.availabilityDays', 'disp.previouslyBookedDays'], function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        availabilityDays = _ref2[0],
	        previouslyBookedDays = _ref2[1];
	
	    $scope.disp.highlightDays = [];
	    $scope.disp.daysAllowed = [];
	
	    if (!availabilityDays || !previouslyBookedDays) {
	      return;
	    }
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = Object.keys($scope.disp.availabilityDays)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var time = _step.value;
	
	        time = parseInt(time);
	        var timeMoment = moment(time).utcOffset(0);
	        if (time in $scope.disp.previouslyBookedDays) {
	          $scope.disp.highlightDays.push({
	            date: timeMoment,
	            css: 'previously-booked',
	            selectable: false,
	            annotation: $scope.book.route.tripsByDate[time].bookingInfo && $scope.book.route.tripsByDate[time].bookingInfo.notes && ' '
	          });
	        } else if ($scope.disp.availabilityDays[time] <= 0) {
	          $scope.disp.highlightDays.push({
	            date: timeMoment,
	            css: 'sold-out',
	            selectable: false,
	            annotation: $scope.book.route.tripsByDate[time].bookingInfo && $scope.book.route.tripsByDate[time].bookingInfo.notes && ' '
	          });
	        } else {
	          $scope.disp.highlightDays.push({
	            date: timeMoment,
	            css: '',
	            selectable: true,
	            annotation: $scope.book.route.tripsByDate[time].bookingInfo && $scope.book.route.tripsByDate[time].bookingInfo.notes && ' '
	          });
	          $scope.disp.daysAllowed.push(timeMoment);
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    $scope.disp.selectedDatesMoments = _lodash2.default.intersectionBy($scope.disp.selectedDatesMoments, $scope.disp.daysAllowed, function (m) {
	      return m.valueOf();
	    });
	  });
	
	  $scope.$on('priceCalculator.done', function () {
	    $ionicScrollDelegate.resize();
	  });
	
	  function loadTickets() {
	    var ticketsPromise = TicketService.getPreviouslyBookedDaysByRouteId($scope.book.routeId, true).catch(function (err) {
	      return null;
	    });
	
	    loadingSpinner($q.all([ticketsPromise]).then(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 1),
	          tickets = _ref4[0];
	
	      $scope.disp.previouslyBookedDays = tickets || {};
	    }));
	  }
	  function loadRoutes() {
	    var routePromise = RoutesService.getRoute($scope.book.routeId, true);
	    return loadingSpinner(routePromise.then(function (route) {
	      // Route
	      $scope.book.route = route;
	      updateCalendar(); // updates availabilityDays
	      return route;
	    }));
	  }
	  function updateCalendar() {
	    // ensure cancelled trips are not shown
	    // var runningTrips = $scope.book.route.trips.filter(tr => tr.status !== 'cancelled');
	    var runningTrips = $scope.book.route.trips.filter(function (tr) {
	      return tr.isRunning;
	    });
	
	    // discover which month to show. Use UTC timezone
	    $scope.disp.month = moment(_lodash2.default.min(runningTrips.map(function (t) {
	      return t.date;
	    }))).utcOffset(0);
	
	    // reset
	    $scope.disp.availabilityDays = {};
	
	    // booking window restriction
	    var now = Date.now();
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	      for (var _iterator2 = runningTrips[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var trip = _step2.value;
	
	        // FIXME: disable today if past the booking window
	
	        // Make it available, only if the stop is valid for this trip
	        var stopIds = trip.tripStops.filter(function (t) {
	          return t.time.getTime() > now;
	        }).map(function (ts) {
	          return ts.stop.id;
	        });
	        if (stopIds.indexOf($scope.book.boardStopId) === -1 || stopIds.indexOf($scope.book.alightStopId) === -1) {
	          continue;
	        }
	
	        $scope.disp.availabilityDays[trip.date.getTime()] = trip.availability.seatsAvailable;
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }
	  }
	}];

/***/ },
/* 493 */
/*!*********************************************************!*\
  !*** ./beeline/controllers/BookingSummaryController.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _processingPayments = __webpack_require__(/*! ../templates/processing-payments.html */ 494);
	
	var _processingPayments2 = _interopRequireDefault(_processingPayments);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$scope', '$state', '$http', '$ionicPopup', 'BookingService', 'UserService', '$ionicLoading', 'StripeService', '$stateParams', 'RoutesService', '$ionicScrollDelegate', 'TicketService', 'loadingSpinner', 'CreditsService', '$ionicPosition', function ($scope, $state, $http, $ionicPopup, BookingService, UserService, $ionicLoading, StripeService, $stateParams, RoutesService, $ionicScrollDelegate, TicketService, loadingSpinner, CreditsService, $ionicPosition) {
	  var _this = this;
	
	  /** After you have settled the payment mode **/
	  var completePayment = function () {
	    var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7(paymentOptions) {
	      var result;
	      return regeneratorRuntime.wrap(function _callee7$(_context7) {
	        while (1) {
	          switch (_context7.prev = _context7.next) {
	            case 0:
	              _context7.prev = 0;
	
	              $ionicLoading.show({
	                template: _processingPayments2.default
	              });
	
	              _context7.next = 4;
	              return UserService.beeline({
	                method: 'POST',
	                url: '/transactions/payment_ticket_sale',
	                data: _lodash2.default.defaults(paymentOptions, {
	                  trips: BookingService.prepareTrips($scope.book),
	                  promoCode: $scope.book.promoCode ? { code: $scope.book.promoCode } : null,
	                  creditTag: $scope.book.creditTag,
	                  applyCredits: $scope.book.applyCredits,
	                  applyReferralCredits: $scope.book.applyReferralCredits
	                })
	              });
	
	            case 4:
	              result = _context7.sent;
	
	
	              (0, _assert2.default)(result.status == 200);
	
	              $ionicLoading.hide();
	
	              TicketService.setShouldRefreshTickets();
	              $state.go('tabs.booking-confirmation');
	
	              _context7.next = 16;
	              break;
	
	            case 11:
	              _context7.prev = 11;
	              _context7.t0 = _context7['catch'](0);
	
	              $ionicLoading.hide();
	              _context7.next = 16;
	              return $ionicPopup.alert({
	                title: 'Error processing payment',
	                template: _context7.t0.data.message
	              });
	
	            case 16:
	              _context7.prev = 16;
	
	              RoutesService.fetchRouteCredits(true);
	              RoutesService.fetchRoutePassCount();
	              RoutesService.fetchRoutesWithRoutePass();
	
	              CreditsService.fetchReferralCredits(true);
	              CreditsService.fetchUserCredits(true);
	              return _context7.finish(16);
	
	            case 23:
	            case 'end':
	              return _context7.stop();
	          }
	        }
	      }, _callee7, this, [[0, 11, 16, 23]]);
	    }));
	
	    return function completePayment(_x2) {
	      return _ref7.apply(this, arguments);
	    };
	  }();
	
	  // Booking session logic
	  $scope.session = {
	    sessionId: +$stateParams.sessionId
	  };
	  $scope.book = {
	    routeId: +$stateParams.routeId,
	    route: null,
	    qty: 1,
	    selectedDates: [],
	    boardStopId: parseInt($stateParams.boardStop),
	    alightStopId: parseInt($stateParams.alightStop),
	    boardStop: undefined,
	    alightStop: undefined,
	    price: undefined,
	    hasInvalidDate: false,
	    features: null,
	    applyRouteCredits: false,
	    applyReferralCredits: false,
	    applyCredits: false,
	    creditTag: null,
	    promoCode: null,
	    promoCodeEntered: null,
	    feedback: null,
	    promoCodeIsValid: null,
	    isVerifying: null,
	    // if 2 requests sent to verify promo code, only the latter triggered matters
	    // always need to have this if using debounce with promise
	    lastestVerifyPromoCodePromise: null
	  };
	  $scope.disp = {
	    zeroDollarPurchase: false
	  };
	
	  $scope.isPaymentProcessing = false;
	
	  if (!Array.prototype.isPrototypeOf($stateParams.selectedDates)) {
	    $stateParams.selectedDates = [$stateParams.selectedDates];
	  }
	  $scope.book.selectedDates = $stateParams.selectedDates.map(function (item) {
	    return parseInt(item);
	  });
	
	  RoutesService.getRoute(parseInt($scope.book.routeId)).then(function (route) {
	    $scope.book.route = route;
	    $scope.book.boardStop = route.tripsByDate[$scope.book.selectedDates[0]].tripStops.filter(function (ts) {
	      return $scope.book.boardStopId == ts.stop.id;
	    })[0];
	    $scope.book.alightStop = route.tripsByDate[$scope.book.selectedDates[0]].tripStops.filter(function (ts) {
	      return $scope.book.alightStopId == ts.stop.id;
	    })[0];
	  });
	
	  RoutesService.getRouteFeatures(parseInt($scope.book.routeId)).then(function (features) {
	    $scope.book.features = features;
	  });
	
	  $scope.$watch(function () {
	    return RoutesService.getRouteCreditTags();
	  }, function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(routeToCreditTags) {
	      var creditTag;
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              creditTag = routeToCreditTags ? routeToCreditTags[$scope.book.routeId] : null;
	
	              $scope.book.applyRouteCredits = !!creditTag;
	              $scope.book.creditTag = creditTag;
	
	            case 3:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this);
	    }));
	
	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  }());
	
	  $scope.$watch(function () {
	    return UserService.getUser();
	  }, function (user) {
	    $scope.isLoggedIn = user ? true : false;
	    $scope.user = user;
	    $scope.hasSavedPaymentInfo = _lodash2.default.get($scope.user, 'savedPaymentInfo.sources.data.length', 0) > 0;
	    $scope.book.applyReferralCredits = !!user;
	    $scope.book.applyCredits = !!user;
	    if ($scope.isLoggedIn) {
	      loadingSpinner(Promise.all([$scope.checkValidDate(), RoutesService.fetchRouteCreditTags()]));
	    }
	  });
	
	  $scope.login = function () {
	    $scope.isPreviewCalculating = true;
	    UserService.promptLogIn();
	    $scope.scrollToPriceCalculator();
	  };
	
	  $scope.$on('priceCalculator.done', function () {
	    $ionicScrollDelegate.resize();
	    $scope.isPreviewCalculating = false;
	  });
	  $scope.$on('companyTnc.done', function () {
	    $ionicScrollDelegate.resize();
	  });
	  $scope.$watch('book.price', function (price) {
	    if (parseFloat(price) === 0) {
	      $scope.disp.zeroDollarPurchase = true;
	    } else {
	      $scope.disp.zeroDollarPurchase = false;
	    }
	  });
	
	  $scope.checkValidDate = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	    var previouslyBookedDays, selectedAndInvalid;
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return TicketService.getPreviouslyBookedDaysByRouteId($scope.book.routeId, true);
	
	          case 2:
	            previouslyBookedDays = _context2.sent;
	            selectedAndInvalid = _lodash2.default.intersection($scope.book.selectedDates, // list of integers
	            Object.keys(previouslyBookedDays).map(function (s) {
	              return parseInt(s);
	            }));
	
	            $scope.book.hasInvalidDate = selectedAndInvalid.length > 0;
	
	          case 5:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this);
	  }));
	
	  $scope.payHandler = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	    return regeneratorRuntime.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if ($scope.disp.payZeroDollar) {
	              $scope.payZeroDollar();
	            } else if ($scope.disp.savePaymentChecked) {
	              $scope.payWithSavedInfo();
	            } else {
	              $scope.payWithoutSavingCard();
	            }
	
	          case 1:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this);
	  }));
	
	  $scope.payZeroDollar = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	    return regeneratorRuntime.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.next = 2;
	            return $ionicPopup.confirm({
	              title: 'Complete Purchase',
	              template: 'Are you sure you want to complete the purchase?'
	            });
	
	          case 2:
	            if (!_context4.sent) {
	              _context4.next = 10;
	              break;
	            }
	
	            _context4.prev = 3;
	
	            $scope.isPaymentProcessing = true;
	
	            _context4.next = 7;
	            return completePayment({
	              stripeToken: 'this-will-not-be-used'
	            });
	
	          case 7:
	            _context4.prev = 7;
	
	            $scope.$apply(function () {
	              $scope.isPaymentProcessing = false;
	            });
	            return _context4.finish(7);
	
	          case 10:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this, [[3,, 7, 10]]);
	  }));
	
	  // Prompts for card and processes payment with one time stripe token.
	  $scope.payWithoutSavingCard = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	    var stripeToken;
	    return regeneratorRuntime.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            _context5.prev = 0;
	
	            // disable the button
	            $scope.isPaymentProcessing = true;
	
	            _context5.next = 4;
	            return StripeService.promptForToken(null, isFinite($scope.book.price) ? $scope.book.price * 100 : '', null);
	
	          case 4:
	            stripeToken = _context5.sent;
	
	            if (stripeToken) {
	              _context5.next = 7;
	              break;
	            }
	
	            return _context5.abrupt('return');
	
	          case 7:
	            _context5.next = 9;
	            return completePayment({
	              stripeToken: stripeToken.id
	            });
	
	          case 9:
	            _context5.next = 15;
	            break;
	
	          case 11:
	            _context5.prev = 11;
	            _context5.t0 = _context5['catch'](0);
	            _context5.next = 15;
	            return $ionicPopup.alert({
	              title: 'Error contacting the payment gateway',
	              template: _context5.t0.data.message
	            });
	
	          case 15:
	            _context5.prev = 15;
	
	            $scope.$apply(function () {
	              $scope.isPaymentProcessing = false;
	            });
	            return _context5.finish(15);
	
	          case 18:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this, [[0, 11, 15, 18]]);
	  }));
	
	  // Processes payment with customer object. If customer object does not exist,
	  // prompts for card, creates customer object, and proceeds as usual.
	  $scope.payWithSavedInfo = _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
	    var stripeToken;
	    return regeneratorRuntime.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            _context6.prev = 0;
	
	            // disable the button
	            $scope.isPaymentProcessing = true;
	
	            if ($scope.hasSavedPaymentInfo) {
	              _context6.next = 9;
	              break;
	            }
	
	            _context6.next = 5;
	            return StripeService.promptForToken(null, isFinite($scope.book.price) ? $scope.book.price * 100 : '', null);
	
	          case 5:
	            stripeToken = _context6.sent;
	
	            if (stripeToken) {
	              _context6.next = 9;
	              break;
	            }
	
	            $scope.isPaymentProcessing = false; // re-enable button
	            return _context6.abrupt('return');
	
	          case 9:
	            if ($scope.hasSavedPaymentInfo) {
	              _context6.next = 12;
	              break;
	            }
	
	            _context6.next = 12;
	            return loadingSpinner(UserService.savePaymentInfo(stripeToken.id));
	
	          case 12:
	            _context6.next = 14;
	            return completePayment({
	              customerId: $scope.user.savedPaymentInfo.id,
	              sourceId: _lodash2.default.head($scope.user.savedPaymentInfo.sources.data).id
	            });
	
	          case 14:
	            _context6.next = 21;
	            break;
	
	          case 16:
	            _context6.prev = 16;
	            _context6.t0 = _context6['catch'](0);
	
	            $scope.isPaymentProcessing = false; // re-enable button
	            _context6.next = 21;
	            return $ionicPopup.alert({
	              title: 'Error saving payment method',
	              template: _context6.t0.data.message
	            });
	
	          case 21:
	            _context6.prev = 21;
	
	            $scope.$apply(function () {
	              $scope.isPaymentProcessing = false;
	            });
	            return _context6.finish(21);
	
	          case 24:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this, [[0, 16, 21, 24]]);
	  }));
	
	  $scope.scrollToPriceCalculator = function () {
	    var priceCalculatorPosition = $ionicPosition.position(angular.element(document.getElementById('priceCalc')));
	    $ionicScrollDelegate.scrollTo(priceCalculatorPosition.left, priceCalculatorPosition.top, true);
	  };
	
	  function verifyPromoCode() {
	    if ($scope.book.promoCodeEntered === null || !$scope.book.promoCodeEntered) {
	      $scope.book.feedback = $scope.book.promoCodeEntered = $scope.book.promoCodeIsValid = null;
	      $scope.$digest();
	      return;
	    };
	    var bookClone = _lodash2.default.cloneDeep($scope.book);
	    var book = _lodash2.default.assign(bookClone, { 'promoCode': $scope.book.promoCodeEntered.toUpperCase() });
	    $scope.book.isVerifying = true;
	    var currentVerifyPromoCodePromise = $scope.book.lastestVerifyPromoCodePromise = BookingService.computePriceInfo(book).then(function (priceInfo) {
	      if (currentVerifyPromoCodePromise === $scope.book.lastestVerifyPromoCodePromise) {
	        $scope.book.feedback = 'Valid';
	        $scope.book.promoCodeIsValid = true;
	      }
	    }).catch(function (error) {
	      //still need this check as the latter promise may come back earlier than the 1st one
	      if (currentVerifyPromoCodePromise === $scope.book.lastestVerifyPromoCodePromise) {
	        if (error.data && error.data.source === 'promoCode') {
	          $scope.book.feedback = error.data.message || 'Invalid';
	          $scope.book.promoCodeIsValid = null;
	        } else {
	          $scope.book.feedback = 'Valid';
	          $scope.book.promoCodeIsValid = true;
	        }
	      }
	    }).finally(function () {
	      if (currentVerifyPromoCodePromise === $scope.book.lastestVerifyPromoCodePromise) {
	        $scope.book.isVerifying = null;
	      }
	    });
	  }
	
	  $scope.$watch('book.promoCodeEntered', _lodash2.default.debounce(verifyPromoCode, 800, { leading: false, trailing: true }));
	
	  $scope.promptPromoCode = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
	    return regeneratorRuntime.wrap(function _callee8$(_context8) {
	      while (1) {
	        switch (_context8.prev = _context8.next) {
	          case 0:
	            if ($scope.isLoggedIn) {
	              _context8.next = 6;
	              break;
	            }
	
	            _context8.next = 3;
	            return $ionicPopup.alert({
	              title: 'You need to log in before enter any promo code'
	            });
	
	          case 3:
	            $scope.login();
	            _context8.next = 7;
	            break;
	
	          case 6:
	            $scope.enterPromoCodePopup = $ionicPopup.show({
	              scope: $scope,
	              template: '\n            <label>\n              <input type="text" style="text-transform: uppercase" placeholder="PROMOCODE" ng-model="book.promoCodeEntered">\n              </input>\n            </label>\n            <div class="text-center"><ion-spinner ng-show="book.isVerifying"></ion-spinner></div>\n            <div class="text-center"> {{book.feedback}}</div>\n          ',
	              title: 'Enter Promo Code',
	              buttons: [{ text: 'Close',
	                onTap: function onTap(e) {
	                  $scope.book.feedback = null;
	                  $scope.book.promoCodeEntered = null;
	                }
	              }, {
	                text: 'Apply',
	                type: 'button-positive',
	                onTap: function onTap(e) {
	                  e.preventDefault();
	                  if ($scope.book.promoCodeIsValid) {
	                    $scope.book.promoCode = $scope.book.promoCodeEntered.toUpperCase();
	                    $scope.book.feedback = $scope.book.promoCodeEntered = null;
	                    $scope.enterPromoCodePopup.close();
	                  }
	                }
	              }]
	            });
	
	          case 7:
	          case 'end':
	            return _context8.stop();
	        }
	      }
	    }, _callee8, this);
	  }));
	}];

/***/ },
/* 494 */
/*!****************************************************!*\
  !*** ./beeline/templates/processing-payments.html ***!
  \****************************************************/
/***/ function(module, exports) {

	module.exports = "Please wait while we process the payment...\n<br/>\n<ion-spinner icon=\"ios\"></ion-spinner>\n";

/***/ },
/* 495 */
/*!**************************************************************!*\
  !*** ./beeline/controllers/BookingConfirmationController.js ***!
  \**************************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ['$scope', '$state', '$http', 'BookingService', '$ionicHistory', '$ionicPlatform', function ($scope, $state, $http, BookingService, $ionicHistory, $ionicPlatform) {
	  $scope.$on('$ionicView.afterEnter', function () {
	    $ionicHistory.clearHistory();
	
	    // Back button goes back to routes list
	    var deregister = $ionicPlatform.registerBackButtonAction(function () {
	      $state.go('tabs.routes');
	    }, 101);
	    $scope.$on('$ionicView.beforeLeave', deregister);
	  });
	}];

/***/ },
/* 496 */
/*!**************************************************!*\
  !*** ./beeline/controllers/SuggestController.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = ['$scope', '$state', '$stateParams', '$http', 'SuggestionService', 'UserService', '$ionicModal', '$ionicPopup', function ($scope, $state, $stateParams, $http, SuggestionService, UserService, $ionicModal, $ionicPopup) {
	  $scope.user = null;
	
	  $scope.newSuggestion = {
	    time: '',
	    startPoint: {},
	    endPoint: {},
	    control: {}
	  };
	  $scope.newSuggestionModal = $ionicModal.fromTemplate(__webpack_require__(/*! ./newSuggestion.html */ 497), {
	    scope: $scope,
	    animation: 'slide-in-up'
	  });
	
	  $scope.$on('destroy', function () {
	    $scope.newSuggestionModal.destroy();
	  });
	
	  $scope.$on('$ionicView.afterEnter', function (event) {
	
	    // if we had anonymous suggestions before, convert them to suggestions
	    // associated with this user
	    $scope.$watch(function () {
	      return UserService.getUser();
	    }, function (newUser) {
	      if (newUser) {
	        UserService.beeline({
	          method: 'POST',
	          url: '/suggestions/deanonymize'
	        }).then(function (response) {
	          if (response.data > 0) queryData();
	        });
	      }
	    });
	
	    /* Entered from the route search */
	    if ($state.params.action == 'submit' && Search.data.startLat && Search.data.startLng) {
	      $state.params.action = '';
	
	      var arrivalTime = new Date(Search.data.arrivalTime);
	      var secondsSinceMidnight = arrivalTime.getHours() * 60 * 60 + arrivalTime.getMinutes() * 60 + arrivalTime.getSeconds();
	
	      UserService.beeline({
	        method: 'POST',
	        url: '/suggestions',
	        data: {
	          boardLat: Search.data.startLat,
	          boardLon: Search.data.startLng,
	          alightLat: Search.data.endLat,
	          alightLon: Search.data.endLng,
	          time: secondsSinceMidnight
	        }
	      }).then(function () {
	        queryData();
	      }).catch(function (err) {
	        console.log(err);
	        alert('You must be logged in to make a suggestion');
	        $state.go('tabs.suggest', { action: '' });
	      });
	    } else if ($state.params.action == 'new') {
	      $scope.promptNewSuggestion();
	      queryData();
	    } else {
	      queryData();
	    }
	  });
	
	  // populate
	  function queryData() {
	    var suggestions;
	
	    UserService.beeline({
	      url: '/suggestions',
	      method: 'GET'
	    }).then(function (response) {
	      suggestions = response.data;
	
	      var countSimilar = suggestions.map(function (suggestion) {
	        return UserService.beeline({
	          url: '/suggestions/' + suggestion.id + '/similar',
	          method: 'GET'
	        });
	      });
	
	      return Promise.all(countSimilar);
	    }).then(function (similars) {
	      for (var i = 0; i < suggestions.length; i++) {
	        suggestions[i].numSimilar = similars[i].data.length;
	      }
	      return suggestions;
	    }).then(function (suggestions) {
	      /* Need to map the old suggestions to the new suggestions so
	      that we don't lose the geocoding */
	      // var oldSuggestions = _.keyBy(
	      //   $scope.suggestions,
	      //   sugg => sugg.id);
	
	      // for (let suggestion of suggestions) {
	      //   if (oldSuggestions[sugg.id] &&
	      //       oldSuggestion[sugg.id].updatedAt == suggestion.updatedAt) {
	      //     _.assign(suggestion, oldSuggestions[sugg.id])
	      //   }
	      // }
	      $scope.suggestions = suggestions;
	    });
	
	    SuggestionService.getSimilar().then(function () {
	      $scope.similarSuggestions = SuggestionService.getSimilarSuggestions();
	    });
	
	    $scope.getSuggestionById = function (tid) {
	      SuggestionService.getSuggestionById(tid);
	      $scope.suggestion = SuggestionService.getSelectedSuggestion();
	      console.log("selected suggestion is " + $scope.suggestion.id);
	    };
	  }
	
	  $scope.toggleSelected = function (item) {
	    if ($scope.selectedItem == item) {
	      $scope.selectedItem = null;
	    } else {
	      $scope.selectedItem = item;
	    }
	  };
	
	  $scope.selectItem = function (item) {
	    // Show a modal
	    $scope.newSuggestion.title = 'Your Suggestion';
	    $scope.newSuggestion.id = item.id;
	    $scope.newSuggestion.startPoint.coordinates = {
	      latitude: item.board.coordinates[1],
	      longitude: item.board.coordinates[0]
	    };
	    $scope.newSuggestion.startPoint.text = item.board.description1;
	    $scope.newSuggestion.endPoint.coordinates = {
	      latitude: item.alight.coordinates[1],
	      longitude: item.alight.coordinates[0]
	    };
	    $scope.newSuggestion.endPoint.text = item.alight.description1;
	    $scope.newSuggestion.disabled = true;
	    $scope.newSuggestion.setPoint = null;
	    $scope.newSuggestionModal.show().then(function () {
	      $scope.newSuggestion.control.fitToPoints();
	    });
	  };
	
	  $scope.deleteSuggestion = function (event, id) {
	    event.stopPropagation();
	    $ionicPopup.confirm({
	      title: 'Delete suggestion',
	      template: 'Are you sure you want to delete this suggestion?'
	    }).then(function (result) {
	      if (result) {
	        UserService.beeline({
	          method: 'DELETE',
	          url: '/suggestions/' + id
	        }).then(queryData);
	      }
	    });
	  };
	  $scope.promptNewSuggestion = function () {
	    $scope.newSuggestion.title = 'New Suggestion';
	    $scope.newSuggestion.time = '';
	    $scope.newSuggestion.id = false;
	    $scope.newSuggestion.startPoint.coordinates = null;
	    $scope.newSuggestion.startPoint.text = '';
	    $scope.newSuggestion.endPoint.coordinates = null;
	    $scope.newSuggestion.endPoint.text = '';
	    $scope.newSuggestion.setPoint = 'start';
	    $scope.newSuggestion.disabled = false;
	    $scope.newSuggestionModal.show().then(function () {
	      $scope.newSuggestion.control.fitToPoints();
	    });
	  };
	  $scope.submitSuggestion = function (suggestion) {
	    var arrivalTime = new (Date.bind.apply(Date, [{}, 2015, 1, 1].concat(suggestion.time.split(':'))))();
	    var secondsSinceMidnight = arrivalTime.getHours() * 60 * 60 + arrivalTime.getMinutes() * 60 + arrivalTime.getSeconds();
	
	    return UserService.beeline({
	      method: 'POST',
	      url: '/suggestions',
	      data: {
	        boardLat: suggestion.startPoint.coordinates.latitude,
	        boardLon: suggestion.startPoint.coordinates.longitude,
	        alightLat: suggestion.endPoint.coordinates.latitude,
	        alightLon: suggestion.endPoint.coordinates.longitude,
	        time: secondsSinceMidnight
	      }
	    }).catch(function () {
	      return alert('Your suggestion could not be submitted');
	    }).then(function () {
	      queryData();
	      $scope.newSuggestionModal.hide();
	    });
	  };
	  $scope.cancel = function (suggestion) {
	    $scope.newSuggestionModal.hide();
	  };
	}];

/***/ },
/* 497 */
/*!************************************************!*\
  !*** ./beeline/controllers/newSuggestion.html ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"new_suggestion modal\" data-tap-disabled=true>\n  <ion-header-bar class=\"bar-stable\">\n    <h1 class=\"title\">{{newSuggestion.title}}</h1>\n    <button class=\"button button-clear icon ion-android-close\"\n        ng-click=\"cancel()\">\n   </button>\n  </ion-header-bar>\n  <ion-content>\n    <div class=\"button-controls\" ng-if=\"newSuggestion.id\">\n      <button ng-click=\"deleteSuggestion($event, newSuggestion.id)\">Delete Suggestion</button>\n    </div>\n    <start-end-picker\n          is-valid=\"newSuggestion.time != ''\"\n          start-point=\"newSuggestion.startPoint\"\n          end-point=\"newSuggestion.endPoint\"\n          prompt=\"Make Suggestion!\"\n          set-point=\"newSuggestion.setPoint\"\n          disabled=\"newSuggestion.disabled\"\n          control=\"newSuggestion.control\"\n          onsubmit=\"submitSuggestion(newSuggestion)\">\n      <!-- FIXME: duplicate code here -->\n      <label class=\"item item-select\">\n        <i class=\"icon ion-clock\"></i>\n        Time at Destination:\n        <select ng-model=\"newSuggestion.time\">\n          <option value=\"\"></option>\n          <option value=\"00:00\">00:00 - 02:00</option>\n          <option value=\"02:00\">02:00 - 04:00</option>\n          <option value=\"04:00\">04:00 - 06:00</option>\n          <option value=\"06:00\">06:00 - 08:00</option>\n          <option value=\"08:00\">08:00 - 10:00</option>\n          <option value=\"10:00\">10:00 - 12:00</option>\n          <option value=\"12:00\">12:00 - 14:00</option>\n          <option value=\"14:00\">14:00 - 16:00</option>\n          <option value=\"16:00\">16:00 - 18:00</option>\n          <option value=\"18:00\">18:00 - 20:00</option>\n          <option value=\"20:00\">20:00 - 22:00</option>\n        </select>\n      </label>\n    </start-end-picker>\n  </ion-content>\n</div>\n";

/***/ },
/* 498 */
/*!***************************************************!*\
  !*** ./beeline/controllers/SettingsController.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _faqModal = __webpack_require__(/*! ../templates/faq-modal.html */ 499);
	
	var _faqModal2 = _interopRequireDefault(_faqModal);
	
	var _contactUsModal = __webpack_require__(/*! ../templates/contact-us-modal.html */ 500);
	
	var _contactUsModal2 = _interopRequireDefault(_contactUsModal);
	
	var _shareReferralModal = __webpack_require__(/*! ../templates/share-referral-modal.html */ 490);
	
	var _shareReferralModal2 = _interopRequireDefault(_shareReferralModal);
	
	var _commonmark = __webpack_require__(/*! commonmark */ 439);
	
	var _commonmark2 = _interopRequireDefault(_commonmark);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var reader = new _commonmark2.default.Parser({ safe: true });
	var writer = new _commonmark2.default.HtmlRenderer({ safe: true });
	
	exports.default = ['$scope', 'UserService', 'StripeService', 'KickstarterService', '$ionicModal', '$ionicPopup', 'Legalese', 'loadingSpinner', '$ionicLoading', '$state', '$cordovaSocialSharing', 'replace', 'DevicePromise', function ($scope, UserService, StripeService, KickstarterService, $ionicModal, $ionicPopup, Legalese, loadingSpinner, $ionicLoading, $state, $cordovaSocialSharing, replace, DevicePromise) {
	  var checkIfOnKickstarter = function () {
	    var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	      var response;
	      return regeneratorRuntime.wrap(function _callee4$(_context4) {
	        while (1) {
	          switch (_context4.prev = _context4.next) {
	            case 0:
	              _context4.next = 2;
	              return KickstarterService.hasBids();
	
	            case 2:
	              response = _context4.sent;
	              return _context4.abrupt('return', response);
	
	            case 4:
	            case 'end':
	              return _context4.stop();
	          }
	        }
	      }, _callee4, this);
	    }));
	
	    return function checkIfOnKickstarter() {
	      return _ref4.apply(this, arguments);
	    };
	  }();
	
	  $scope.data = {};
	  $scope.hasCordova = !!window.cordova || false;
	  $scope.isOnKickstarter = false;
	
	  DevicePromise.then(function () {
	    if ($scope.hasCordova) {
	      chcp.getVersionInfo(function (error, data) {
	        $scope.data.currentVersion = data.currentWebVersion || null;
	      });
	    }
	  });
	
	  var isPressed = false;
	
	  // Track the login state of the user service
	  $scope.$watch(function () {
	    return UserService.getUser();
	  }, function (newUser) {
	    $scope.user = newUser;
	
	    if (newUser) {
	      $scope.shareMsg = UserService.getReferralMsg();
	    } else {
	      $scope.shareMsg = null;
	    }
	  });
	
	  // Function that allows user to share an invitation with a referral code to other apps on the phone
	  $scope.cordovaShare = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            $cordovaSocialSharing.share($scope.shareMsg, "Try out Beeline!");
	
	          case 1:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this);
	  }));
	
	  // Map in the login items
	  $scope.logIn = UserService.promptLogIn;
	  $scope.logOut = UserService.promptLogOut;
	
	  // Generic event handler to allow user to update their
	  // name, email
	  // FIXME: Get Yixin to review the user info update flow.
	  $scope.updateUserInfo = function (field) {
	    return UserService.promptUpdateUserInfo(field);
	  };
	
	  // Update telephone is distinct from the update user due to verification
	  $scope.updateTelephone = UserService.promptUpdatePhone;
	
	  // Configure modals
	
	  // Load the pages only when requested.
	  function assetScope(assetName) {
	    var newScope = $scope.$new();
	    newScope.error = newScope.html = null;
	    newScope.$on('modal.shown', function () {
	      UserService.beeline({
	        method: 'GET',
	        url: replace('/assets/' + assetName)
	      }).then(function (response) {
	        newScope.html = writer.render(reader.parse(response.data.data));
	        newScope.error = false;
	      }).catch(function (error) {
	        console.log(error);
	        newScope.html = "";
	        newScope.error = error;
	      });
	    });
	    return newScope;
	  };
	
	  $scope.shareReferralModal = $ionicModal.fromTemplate(_shareReferralModal2.default, { scope: $scope });
	
	  $scope.faqModal = $ionicModal.fromTemplate(_faqModal2.default, { scope: assetScope('FAQ') });
	  $scope.showPrivacyPolicy = function () {
	    return Legalese.showPrivacyPolicy();
	  };
	  $scope.showTermsOfUse = function () {
	    return Legalese.showTermsOfUse();
	  };
	  $scope.contactUsModal = $ionicModal.fromTemplate(_contactUsModal2.default, { scope: $scope });
	  $scope.$on('$destroy', function () {
	    $scope.faqModal.destroy();
	    $scope.contactUsModal.destroy();
	    $scope.shareReferralModal.destroy();
	  });
	
	  $scope.hasPaymentInfo = function () {
	    return _lodash2.default.get($scope.user, 'savedPaymentInfo.sources.data.length', 0) > 0;
	  };
	
	  $scope.promptChangeOrRemoveCard = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if (!isPressed) {
	              _context2.next = 2;
	              break;
	            }
	
	            return _context2.abrupt('return');
	
	          case 2:
	            _context2.prev = 2;
	
	            isPressed = true;
	            _context2.next = 6;
	            return checkIfOnKickstarter();
	
	          case 6:
	            $scope.isOnKickstarter = _context2.sent;
	            _context2.next = 15;
	            break;
	
	          case 9:
	            _context2.prev = 9;
	            _context2.t0 = _context2['catch'](2);
	
	            console.log(_context2.t0);
	            _context2.next = 14;
	            return $ionicLoading.show({
	              template: '\n          <div> Network error. ' + (_context2.t0 && _context2.t0.data && _context2.t0.data.message) + ' Please try again later.</div>\n          ',
	              duration: 3500
	            });
	
	          case 14:
	            return _context2.abrupt('return');
	
	          case 15:
	            _context2.prev = 15;
	
	            isPressed = false;
	            return _context2.finish(15);
	
	          case 18:
	
	            $scope.cardDetailPopup = $ionicPopup.show({
	              title: 'Payment Method',
	              scope: $scope,
	              template: '\n          <div class="item item-text-wrap text-center">\n            <div>\n              <b>{{user.savedPaymentInfo.sources.data[0].brand}}</b> ending in <b> {{user.savedPaymentInfo.sources.data[0].last4}} </b>\n            </div>\n            <div>\n              <button class="button button-outline button-royal small-button"\n                ng-click="changeCard()">\n                Change\n              </button>\n            </div>\n          </div>\n          <div class="item item-text-wrap text-center" ng-if="isOnKickstarter">\n            You cannot remove this card unless the Crowdstart route you back expires.\n          </div>\n        ',
	              buttons: [{ text: 'Cancel' }, {
	                text: 'Remove',
	                type: $scope.isOnKickstarter ? 'button-disabled' : 'button-positive',
	                onTap: function onTap(e) {
	                  if ($scope.isOnKickstarter) {
	                    e.preventDefault();
	                  } else {
	                    removeCard();
	                  }
	                }
	              }]
	            });
	
	          case 19:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this, [[2, 9, 15, 18]]);
	  }));
	
	  var removeCard = function () {
	    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	      var response;
	      return regeneratorRuntime.wrap(function _callee3$(_context3) {
	        while (1) {
	          switch (_context3.prev = _context3.next) {
	            case 0:
	              _context3.next = 2;
	              return $ionicPopup.confirm({
	                title: 'Remove Payment Method',
	                scope: $scope,
	                template: '\n        <div class="item item-text-wrap text-center">\n            Are you sure you want to delete this payment method?\n        </div>\n        <div class="item item-text-wrap text-center">\n            <b>{{user.savedPaymentInfo.sources.data[0].brand}}</b> ending in <b> {{user.savedPaymentInfo.sources.data[0].last4}} </b>\n        </div>\n        '
	              });
	
	            case 2:
	              response = _context3.sent;
	
	              if (response) {
	                _context3.next = 5;
	                break;
	              }
	
	              return _context3.abrupt('return');
	
	            case 5:
	              _context3.prev = 5;
	              _context3.next = 8;
	              return loadingSpinner(UserService.removePaymentInfo());
	
	            case 8:
	              _context3.next = 10;
	              return $ionicLoading.show({
	                template: '\n          <div>Payment method has been deleted!</div>\n          ',
	                duration: 1500
	              });
	
	            case 10:
	              _context3.next = 17;
	              break;
	
	            case 12:
	              _context3.prev = 12;
	              _context3.t0 = _context3['catch'](5);
	
	              console.log(_context3.t0);
	              _context3.next = 17;
	              return $ionicLoading.show({
	                template: '\n          <div> Failed to delete payment method. ' + (_context3.t0 && _context3.t0.data && _context3.t0.data.message) + ' Please try again later.</div>\n          ',
	                duration: 3500
	              });
	
	            case 17:
	              _context3.prev = 17;
	
	              $scope.$digest();
	              return _context3.finish(17);
	
	            case 20:
	            case 'end':
	              return _context3.stop();
	          }
	        }
	      }, _callee3, this, [[5, 12, 17, 20]]);
	    }));
	
	    return function removeCard() {
	      return _ref3.apply(this, arguments);
	    };
	  }();
	
	  ;
	
	  $scope.addCard = _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
	    var stripeToken;
	    return regeneratorRuntime.wrap(function _callee5$(_context5) {
	      while (1) {
	        switch (_context5.prev = _context5.next) {
	          case 0:
	            if (!isPressed) {
	              _context5.next = 2;
	              break;
	            }
	
	            return _context5.abrupt('return');
	
	          case 2:
	            _context5.prev = 2;
	
	            isPressed = true;
	            _context5.next = 6;
	            return StripeService.promptForToken(null, null, true);
	
	          case 6:
	            stripeToken = _context5.sent;
	
	            if (stripeToken) {
	              _context5.next = 9;
	              break;
	            }
	
	            return _context5.abrupt('return');
	
	          case 9:
	            _context5.next = 11;
	            return loadingSpinner(UserService.savePaymentInfo(stripeToken.id));
	
	          case 11:
	            _context5.next = 17;
	            break;
	
	          case 13:
	            _context5.prev = 13;
	            _context5.t0 = _context5['catch'](2);
	
	            console.log(_context5.t0);
	            throw new Error('Error saving credit card details. ' + _lodash2.default.get(_context5.t0, 'data.message'));
	
	          case 17:
	            _context5.prev = 17;
	
	            isPressed = false;
	            $scope.$digest();
	            return _context5.finish(17);
	
	          case 21:
	          case 'end':
	            return _context5.stop();
	        }
	      }
	    }, _callee5, this, [[2, 13, 17, 21]]);
	  }));
	
	  $scope.changeCard = _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
	    var stripeToken;
	    return regeneratorRuntime.wrap(function _callee6$(_context6) {
	      while (1) {
	        switch (_context6.prev = _context6.next) {
	          case 0:
	            if (!isPressed) {
	              _context6.next = 2;
	              break;
	            }
	
	            return _context6.abrupt('return');
	
	          case 2:
	            _context6.prev = 2;
	
	            isPressed = true;
	            $scope.cardDetailPopup.close();
	            _context6.next = 7;
	            return StripeService.promptForToken(null, null, true);
	
	          case 7:
	            stripeToken = _context6.sent;
	
	            if (stripeToken) {
	              _context6.next = 10;
	              break;
	            }
	
	            return _context6.abrupt('return');
	
	          case 10:
	            _context6.next = 12;
	            return loadingSpinner(UserService.updatePaymentInfo(stripeToken.id));
	
	          case 12:
	            _context6.next = 18;
	            break;
	
	          case 14:
	            _context6.prev = 14;
	            _context6.t0 = _context6['catch'](2);
	
	            console.log(_context6.t0);
	            throw new Error('Error saving credit card details. ' + _lodash2.default.get(_context6.t0, 'data.message'));
	
	          case 18:
	            _context6.prev = 18;
	
	            isPressed = false;
	            $scope.$digest();
	            return _context6.finish(18);
	
	          case 22:
	          case 'end':
	            return _context6.stop();
	        }
	      }
	    }, _callee6, this, [[2, 14, 18, 22]]);
	  }));
	}];

/***/ },
/* 499 */
/*!******************************************!*\
  !*** ./beeline/templates/faq-modal.html ***!
  \******************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">FAQ</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"faqModal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content>\n      <div class=\"item item-text-wrap text-center\" ng-if=\"!error && !html\">\n        <p class=\"padding-bottom\">\n          FAQ is loading...\n        </p>\n        <ion-spinner icon=\"ios\"></ion-spinner>\n      </div>\n    <div class=\"item item-text-wrap\" ng-if=\"error\">\n      <i class=\"icon ion-alert-circled\"></i> There was a problem loading the FAQ. Please check your Internet connection.\n    </div>\n    <div class=\"faq\" ng-bind-html=\"html\">\n    </div>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 500 */
/*!*************************************************!*\
  !*** ./beeline/templates/contact-us-modal.html ***!
  \*************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view>\n  <ion-header-bar class=\"bar-royal bar bar-header\">\n    <h1 class=\"title\">Contact Us</h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\" ng-click=\"contactUsModal.hide()\">\n    </button>\n  </ion-header-bar>\n  <ion-content>\n    <ion-item class=\"item item-text-wrap\">\n      <div class=\"settings-modal\">\n        <p>\n          If you face any issues with the app or have suggestions that can help us improve {{o.APP.NAME}}, please contact us at:\n        </p>\n        <p class=\"text-center\">\n          <div ng-show=\"o.CONTACTS.PHONE\">{{o.CONTACTS.PHONE}}</div>\n          {{o.CONTACTS.EMAIL || \"feedback@beeline.sg\"}}\n        </p>\n      </div>\n    </ion-item>\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 501 */
/*!**************************************************!*\
  !*** ./beeline/controllers/TicketsController.js ***!
  \**************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$scope', 'TicketService', 'UserService', 'LiteRouteSubscriptionService', 'LiteRoutesService', 'loadingSpinner', function ($scope, TicketService, UserService, LiteRouteSubscriptionService, LiteRoutesService, loadingSpinner) {
	  var normalRoutesPromise = Promise.resolve(null);;
	  var liteRoutesPromise = Promise.resolve(null);
	
	  // Track the login state of the user service
	  $scope.logIn = function () {
	    UserService.promptLogIn();
	  };
	
	  $scope.$watch(function () {
	    return UserService.getUser() && UserService.getUser().id;
	  }, function () {
	    $scope.user = UserService.getUser();
	    if ($scope.user) {
	      refreshTickets(true);
	    } else {
	      refreshTickets();
	    }
	  });
	
	  // Grab the tickets
	  $scope.tickets = {};
	
	  $scope.$on('$ionicView.afterEnter', function () {
	    loadingSpinner(Promise.all([normalRoutesPromise, liteRoutesPromise]));
	  });
	
	  $scope.$watch(function () {
	    return TicketService.getShouldRefreshTickets();
	  }, function (value) {
	    if (!value) return;
	    normalRoutesPromise = refreshNormalTickets(true);
	  });
	  $scope.$watch(function () {
	    return LiteRoutesService.getShouldRefreshLiteTickets();
	  }, function (value) {
	    if (!value) return;
	    liteRoutesPromise = refreshLiteTickets(true);
	  });
	
	  function refreshTickets(ignoreCache) {
	    normalRoutesPromise = refreshNormalTickets(ignoreCache);
	    liteRoutesPromise = refreshLiteTickets(ignoreCache);
	  }
	
	  function refreshNormalTickets(ignoreCache) {
	    return TicketService.getCategorizedTickets(ignoreCache).then(function (categorizedTickets) {
	      $scope.tickets.today = categorizedTickets.today;
	      $scope.tickets.soon = categorizedTickets.afterToday;
	      $scope.error = false;
	    }).catch(function (error) {
	      $scope.error = true;
	    }).finally(function () {
	      $scope.$broadcast('scroll.refreshComplete');
	    });
	  }
	
	  function refreshLiteTickets(ignoreCache) {
	    var _this = this;
	
	    LiteRoutesService.clearShouldRefreshLiteTickets();
	    return LiteRouteSubscriptionService.getSubscriptions(ignoreCache).then(function () {
	      var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(liteRouteSubscriptions) {
	        var allLiteRoutes;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return LiteRoutesService.getLiteRoutes(ignoreCache);
	
	              case 2:
	                allLiteRoutes = _context.sent;
	
	                $scope.liteRouteSubscriptions = liteRouteSubscriptions.map(function (subscribedLiteLabel) {
	                  return { "label": subscribedLiteLabel, "liteRoute": allLiteRoutes[subscribedLiteLabel] };
	                }).filter(function (subscription) {
	                  return subscription.liteRoute;
	                });
	                $scope.error = false;
	
	              case 5:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, _this);
	      }));
	
	      return function (_x) {
	        return _ref.apply(this, arguments);
	      };
	    }()).catch(function (error) {
	      $scope.error = true;
	    }).finally(function () {
	      $scope.$broadcast('scroll.refreshComplete');
	    });
	  }
	  $scope.refreshTickets = refreshTickets;
	}];

/***/ },
/* 502 */
/*!*******************************************************!*\
  !*** ./beeline/controllers/TicketDetailController.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = ['$scope', '$rootScope', '$stateParams', '$timeout', 'uiGmapGoogleMapApi', 'TicketService', 'CompanyService', 'TripService', 'UserService', 'MapOptions', 'RoutesService', function ($scope, $rootScope, $stateParams, $timeout, uiGmapGoogleMapApi, TicketService, CompanyService, TripService, UserService, MapOptions, RoutesService) {
	
	  // Initialize the necessary basic data data
	  $scope.user = UserService.getUser();
	  $scope.map = MapOptions.defaultMapOptions({
	    lines: {
	      route: { path: [] },
	      actualPath: { path: [] }
	    },
	    busLocation: {
	      coordinates: null,
	      icon: null
	    },
	    markers: {
	      boardStop: {},
	      alightStop: {}
	    }
	  });
	
	  $scope.showTerms = function (companyId) {
	    CompanyService.showTerms(companyId);
	  };
	
	  var ticketPromise = TicketService.getTicketById(+$stateParams.ticketId);
	  var tripPromise = ticketPromise.then(function (ticket) {
	    return TripService.getTripData(+ticket.alightStop.tripId);
	  });
	  var routePromise = tripPromise.then(function (trip) {
	    return RoutesService.getRoute(+trip.routeId);
	  });
	  var companyPromise = tripPromise.then(function (trip) {
	    return CompanyService.getCompany(+trip.transportCompanyId);
	  });
	  ticketPromise.then(function (ticket) {
	    $scope.ticket = ticket;
	  });
	  tripPromise.then(function (trip) {
	    $scope.trip = trip;
	  });
	  routePromise.then(function (route) {
	    $scope.route = route;
	  });
	  companyPromise.then(function (company) {
	    $scope.company = company;
	  });
	
	  // Loop to get pings from the server every 15s between responses
	  // Using a recursive timeout instead of an interval to avoid backlog
	  // when the server is slow to respond
	  var pingTimer;
	  function pingLoop() {
	    TripService.DriverPings($scope.trip.id).then(function (info) {
	      $scope.info = info;
	
	      /* Only show pings from the last two hours */
	      var now = Date.now();
	      $scope.recentPings = _lodash2.default.filter(info.pings, function (ping) {
	        return now - ping.time.getTime() < 2 * 60 * 60 * 1000;
	      });
	    }).then(null, function () {}) // catch all errors
	    .then(function () {
	      //TODO: need to add variable to make sure it's still running
	      pingTimer = $timeout(pingLoop, 15000);
	    });
	  };
	  tripPromise.then(pingLoop);
	  $scope.$on('$destroy', function () {
	    $timeout.cancel(pingTimer);
	  });
	
	  // Draw the bus stops on the map
	  Promise.all([ticketPromise]).then(function (values) {
	    var ticket = values[0];
	    $scope.map.markers.boardStop = ticket.boardStop;
	    $scope.map.markers.alightStop = ticket.alightStop;
	  });
	
	  // Draw the planned route
	  routePromise.then(function (route) {
	    RoutesService.decodeRoutePath(route.path).then(function (path) {
	      return $scope.map.lines.route.path = path;
	    }).catch(function (err) {
	      console.error(err);
	    });
	  });
	
	  uiGmapGoogleMapApi.then(function (googleMaps) {
	    $scope.map.busLocation.icon = {
	      url: 'img/busMarker.svg',
	      scaledSize: new googleMaps.Size(68, 86),
	      anchor: new googleMaps.Point(34, 78)
	    };
	  });
	
	  // Draw the icon for latest bus location
	  $scope.$watch('recentPings', function (recentPings) {
	    if (recentPings && recentPings.length > 0) {
	      $scope.map.busLocation.coordinates = recentPings[0].coordinates;
	      $scope.map.lines.actualPath.path = recentPings.map(function (ping) {
	        return {
	          latitude: ping.coordinates.coordinates[1],
	          longitude: ping.coordinates.coordinates[0]
	        };
	      });
	    }
	  });
	
	  //
	  $scope.$watch('map.markerOptions.boardMarker.icon', function (icon) {
	    if (!icon) return;
	    tripPromise.then(function (trip) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = trip.tripStops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var ts = _step.value;
	
	          ts._markerOptions = ts.canBoard ? $scope.map.markerOptions.boardMarker : $scope.map.markerOptions.alightMarker;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    });
	  });
	
	  // Pan and zoom to the bus location when the map is ready
	  // Single ping request for updating the map initially
	  // Duplicates a bit with the update loop but is much cleaner this way
	  // If the load ever gets too much can easily integrate into the
	  // main update loop
	  var updatePromise = tripPromise.then(function (trip) {
	    return TripService.DriverPings(trip.id);
	  });
	  var mapPromise = new Promise(function (resolve) {
	    $scope.$watch('map.control.getGMap', function (getGMap) {
	      if (getGMap) resolve($scope.map.control.getGMap());
	    });
	  });
	  Promise.all([updatePromise, mapPromise, ticketPromise, uiGmapGoogleMapApi]).then(function (values) {
	    var _values = _slicedToArray(values, 4),
	        info = _values[0],
	        map = _values[1],
	        ticket = _values[2],
	        googleMaps = _values[3];
	
	    if (info.pings.length > 0) {
	      var bounds = new googleMaps.LatLngBounds();
	      bounds.extend(new google.maps.LatLng(ticket.boardStop.stop.coordinates.coordinates[1], ticket.boardStop.stop.coordinates.coordinates[0]));
	      bounds.extend(new google.maps.LatLng(info.pings[0].coordinates.coordinates[1], info.pings[0].coordinates.coordinates[0]));
	      map.fitBounds(bounds);
	    } else {
	      // Just show the boarding stops
	      var bounds = new googleMaps.LatLngBounds();
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;
	
	      try {
	        for (var _iterator2 = $scope.trip.tripStops[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var tripStop = _step2.value;
	
	          if (!tripStop.canBoard) continue;
	          bounds.extend(new google.maps.LatLng(tripStop.stop.coordinates.coordinates[1], tripStop.stop.coordinates.coordinates[0]));
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	
	      map.fitBounds(bounds);
	    }
	  });
	
	  // ////////////////////////////////////////////////////////////////////////
	  // Hack to fix map resizing due to ionic view cacheing
	  // Need to use the rootscope since ionic view enter stuff doesnt seem
	  // to propagate down to child views and scopes
	  // ////////////////////////////////////////////////////////////////////////
	  Promise.all([mapPromise, uiGmapGoogleMapApi]).then(function (values) {
	    var _values2 = _slicedToArray(values, 2),
	        map = _values2[0],
	        googleMaps = _values2[1];
	
	    MapOptions.disableMapLinks();
	    $scope.$on("$ionicView.afterEnter", function (event, data) {
	      googleMaps.event.trigger(map, 'resize');
	    });
	  });
	}];

/***/ },
/* 503 */
/*!***********************************************************!*\
  !*** ./beeline/controllers/LiteRouteTrackerController.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$scope', '$rootScope', '$state', '$stateParams', 'uiGmapGoogleMapApi', 'CompanyService', 'TripService', 'UserService', 'MapOptions', 'RoutesService', 'LiteRoutesService', '$ionicPopup', '$ionicLoading', 'loadingSpinner', function ($scope, $rootScope, $state, $stateParams, uiGmapGoogleMapApi, CompanyService, TripService, UserService, MapOptions, RoutesService, LiteRoutesService, $ionicPopup, $ionicLoading, loadingSpinner) {
	  // Initialize the necessary basic data data
	  $scope.user = UserService.getUser();
	  $scope.map = MapOptions.defaultMapOptions({
	    lines: {
	      route: { path: [] }
	    }
	  });
	
	  $scope.disp = {};
	
	  $scope.hasTrips = true;
	
	  $scope.data = {
	    todayTrips: null,
	    hasTrackingData: true,
	    inServiceWindow: false,
	    nextTrips: null
	  };
	
	  $scope.liteRouteLabel = $stateParams.liteRouteLabel;
	
	  var routePromise = LiteRoutesService.getLiteRoute($scope.liteRouteLabel);
	
	  var availableTripsPromise = routePromise.then(function (route) {
	    $scope.liteRoute = route[$scope.liteRouteLabel];
	    //get route features
	    RoutesService.getRouteFeatures($scope.liteRoute.id).then(function (data) {
	      $scope.disp.features = data;
	    });
	    $scope.data.nextTrips = $scope.liteRoute.trips.filter(function (trip) {
	      return trip.date === $scope.liteRoute.trips[0].date;
	    });
	  });
	
	  /* Updated by the view using <daily-trips></daily-trips> (yes, I know, it's ugly) */
	  $scope.$watch('data.todayTrips', function (trips) {
	    if (!trips) return;
	    $scope.hasTrips = trips.length > 0;
	  });
	
	  var mapPromise = new Promise(function (resolve) {
	    $scope.$watch('map.control.getGMap', function (getGMap) {
	      if (getGMap) resolve($scope.map.control.getGMap());
	    });
	  });
	
	  $scope.$on('$ionicView.afterEnter', function () {
	    $scope.$broadcast('startPingLoop');
	    loadingSpinner(Promise.all([mapPromise, routePromise]).then(function () {
	      var gmap = $scope.map.control.getGMap();
	      google.maps.event.trigger(gmap, 'resize');
	    }));
	  });
	
	  $scope.$on('$ionicView.beforeLeave', function () {
	    $scope.$broadcast('killPingLoop');
	  });
	
	  Promise.all([mapPromise, routePromise]).then(function (values) {
	    var _values = _slicedToArray(values, 2),
	        map = _values[0],
	        route = _values[1];
	
	    RoutesService.decodeRoutePath(route[$scope.liteRouteLabel].path).then(function (path) {
	      return $scope.map.lines.route.path = path;
	    }).catch(function (err) {});
	  });
	
	  Promise.all([mapPromise, uiGmapGoogleMapApi]).then(function (values) {
	    var _values2 = _slicedToArray(values, 2),
	        map = _values2[0],
	        googleMaps = _values2[1];
	
	    MapOptions.disableMapLinks();
	    $scope.$on("$ionicView.afterEnter", function (event, data) {
	      googleMaps.event.trigger(map, 'resize');
	    });
	  });
	
	  // TODO: Move bulk of promptUntrack code into service or directive as both
	  // LiteSummaryController and LiteRouteTrackerController uses it
	  $scope.promptUntrack = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	    var response, unsubscribeResult;
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.next = 2;
	            return $ionicPopup.confirm({
	              title: 'Are you sure you want to untrack this route?',
	              subTitle: "This tracking-only route will be removed from your list of trips."
	            });
	
	          case 2:
	            response = _context.sent;
	
	            if (response) {
	              _context.next = 5;
	              break;
	            }
	
	            return _context.abrupt('return');
	
	          case 5:
	            _context.prev = 5;
	            _context.next = 8;
	            return loadingSpinner(LiteRoutesService.unsubscribeLiteRoute($scope.liteRouteLabel));
	
	          case 8:
	            unsubscribeResult = _context.sent;
	
	            if (!unsubscribeResult) {
	              _context.next = 13;
	              break;
	            }
	
	            _context.next = 12;
	            return $ionicLoading.show({
	              template: '\n            <div>Done!</div>\n            ',
	              duration: 1000
	            });
	
	          case 12:
	            $state.transitionTo("tabs.tickets");
	
	          case 13:
	            _context.next = 19;
	            break;
	
	          case 15:
	            _context.prev = 15;
	            _context.t0 = _context['catch'](5);
	            _context.next = 19;
	            return $ionicLoading.show({
	              template: '\n          <div> There was an error unsubscribing. ' + (_context.t0 && _context.t0.data && _context.t0.data.message) + ' Please try again later.</div>\n          ',
	              duration: 1000
	            });
	
	          case 19:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[5, 15]]);
	  }));
	
	  $scope.disp.showTerms = function () {
	    if (!$scope.liteRoute.transportCompanyId) return;
	    CompanyService.showTerms($scope.liteRoute.transportCompanyId);
	  };
	
	  $scope.locateMe = function () {
	    mapPromise.then(function () {
	      MapOptions.locateMe($scope.map.control);
	    });
	  };
	}];

/***/ },
/* 504 */
/*!*********************************************************!*\
  !*** ./beeline/controllers/BookingHistoryController.js ***!
  \*********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($scope, UserService, RoutesService) {
	  var routesPromise;
	  $scope.routesById = {};
	
	  $scope.$on('$ionicView.beforeEnter', function () {
	    reset();
	    $scope.loadMore();
	  });
	
	  function reset() {
	    _lodash2.default.assign($scope, {
	      hasMoreData: true,
	      page: 1,
	      perPage: 20,
	      transactions: null
	    });
	
	    routesPromise = RoutesService.fetchRoutes(true, {
	      end_date: Date.now() + 14 * 24 * 60 * 60 * 1000,
	      start_date: Date.now() - 365 * 24 * 60 * 60 * 1000,
	      tags: '[]'
	    }).then(function (routes) {
	      $scope.routesById = _lodash2.default.keyBy(routes, function (r) {
	        return r.id;
	      });
	    });
	  }
	
	  var inFlight = false;
	
	  $scope.loadMore = function () {
	    if (inFlight) {
	      return;
	    }
	
	    inFlight = true;
	    UserService.beeline({
	      method: 'GET',
	      url: '/transactions/userHistory?' + _querystring2.default.stringify({
	        page: $scope.page,
	        perPage: $scope.perPage
	      })
	    }).then(function (response) {
	      inFlight = false;
	      var newTransactions = response.data.transactions;
	
	      if (newTransactions.length != $scope.perPage) {
	        $scope.hasMoreData = false;
	      } else {
	        $scope.page++;
	      }
	
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;
	
	      try {
	        for (var _iterator = newTransactions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var t = _step.value;
	
	          t.itemsByType = _lodash2.default.groupBy(t.transactionItems, function (ti) {
	            return ti.itemType;
	          });
	        }
	
	        // add route information to ticket sale items and route credit items
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	
	      routesPromise.then(function () {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = newTransactions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var t = _step2.value;
	            var _iteratorNormalCompletion3 = true;
	            var _didIteratorError3 = false;
	            var _iteratorError3 = undefined;
	
	            try {
	              for (var _iterator3 = (t.itemsByType.ticketSale || [])[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var ticketSaleItem = _step3.value;
	
	                ticketSaleItem.route = $scope.routesById[ticketSaleItem.ticketSale.boardStop.trip.routeId];
	              }
	            } catch (err) {
	              _didIteratorError3 = true;
	              _iteratorError3 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                  _iterator3.return();
	                }
	              } finally {
	                if (_didIteratorError3) {
	                  throw _iteratorError3;
	                }
	              }
	            }
	
	            var _iteratorNormalCompletion4 = true;
	            var _didIteratorError4 = false;
	            var _iteratorError4 = undefined;
	
	            try {
	              for (var _iterator4 = (t.itemsByType.ticketRefund || [])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                var ticketRefundItem = _step4.value;
	
	                ticketRefundItem.route = $scope.routesById[ticketRefundItem.ticketRefund.boardStop.trip.routeId];
	              }
	            } catch (err) {
	              _didIteratorError4 = true;
	              _iteratorError4 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                  _iterator4.return();
	                }
	              } finally {
	                if (_didIteratorError4) {
	                  throw _iteratorError4;
	                }
	              }
	            }
	
	            var _iteratorNormalCompletion5 = true;
	            var _didIteratorError5 = false;
	            var _iteratorError5 = undefined;
	
	            try {
	              for (var _iterator5 = (t.itemsByType.ticketExpense || [])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	                var ticketExpenseItem = _step5.value;
	
	                ticketExpenseItem.route = $scope.routesById[ticketExpenseItem.ticketExpense.boardStop.trip.routeId];
	              }
	            } catch (err) {
	              _didIteratorError5 = true;
	              _iteratorError5 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion5 && _iterator5.return) {
	                  _iterator5.return();
	                }
	              } finally {
	                if (_didIteratorError5) {
	                  throw _iteratorError5;
	                }
	              }
	            }
	
	            var _iteratorNormalCompletion6 = true;
	            var _didIteratorError6 = false;
	            var _iteratorError6 = undefined;
	
	            try {
	              for (var _iterator6 = (t.itemsByType.routeCredits || [])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	                var routeCreditItem = _step6.value;
	
	                routeCreditItem.route = $scope.routesById[routeCreditItem.routeCredits.tag.substring(routeCreditItem.routeCredits.tag.indexOf("-") + 1)];
	              }
	            } catch (err) {
	              _didIteratorError6 = true;
	              _iteratorError6 = err;
	            } finally {
	              try {
	                if (!_iteratorNormalCompletion6 && _iterator6.return) {
	                  _iterator6.return();
	                }
	              } finally {
	                if (_didIteratorError6) {
	                  throw _iteratorError6;
	                }
	              }
	            }
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      });
	
	      $scope.transactions = $scope.transactions || [];
	      $scope.transactions = $scope.transactions.concat(newTransactions);
	      $scope.$broadcast('scroll.infiniteScrollComplete');
	    }).then(null, function (error) {
	      inFlight = false;
	    });
	  };
	};
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 505 */
/*!******************************************************!*\
  !*** ./beeline/controllers/LiteSummaryController.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$rootScope', '$scope', '$interpolate', '$state', '$stateParams', '$ionicModal', '$http', '$cordovaGeolocation', '$ionicPopup', '$ionicLoading', 'RoutesService', 'LiteRoutesService', 'LiteRouteSubscriptionService', 'UserService', 'CompanyService', 'uiGmapGoogleMapApi', 'MapOptions', 'loadingSpinner', function ($rootScope, $scope, $interpolate, $state, $stateParams, $ionicModal, $http, $cordovaGeolocation, $ionicPopup, $ionicLoading, RoutesService, LiteRoutesService, LiteRouteSubscriptionService, UserService, CompanyService, uiGmapGoogleMapApi, MapOptions, loadingSpinner) {
	  var _this = this;
	
	  // Gmap default settings
	  $scope.map = MapOptions.defaultMapOptions({
	    lines: {
	      route: { path: [] }
	    }
	  });
	
	  $scope.disp = {
	    companyInfo: {},
	    showTooltip: true
	  };
	
	  // Default settings for various info used in the page
	  $scope.book = {
	    label: null,
	    route: null,
	    boardStops: [], // all board stops for this route
	    alightStops: [], // all alight stops for this route
	    waitingForSubscriptionResult: false,
	    isSubscribed: false
	  };
	
	  $scope.data = {
	    todayTrips: [],
	    nextTrips: null
	  };
	
	  var routePromise, subscriptionPromise;
	
	  $scope.book.label = $stateParams.label;
	
	  routePromise = LiteRoutesService.getLiteRoute($scope.book.label);
	  subscriptionPromise = LiteRouteSubscriptionService.isSubscribed($scope.book.label);
	
	  subscriptionPromise.then(function (response) {
	    $scope.book.isSubscribed = response;
	  });
	
	  var availableTripsPromise = routePromise.then(function (route) {
	    $scope.book.route = route[$scope.book.label];
	    //get route features
	    RoutesService.getRouteFeatures($scope.book.route.id).then(function (data) {
	      $scope.disp.features = data;
	    });
	    $scope.data.nextTrips = $scope.book.route.trips.filter(function (trip) {
	      return trip.date === $scope.book.route.trips[0].date;
	    });
	  });
	
	  var mapPromise = new Promise(function (resolve) {
	    $scope.$watch('map.control.getGMap', function (getGMap) {
	      if (getGMap) resolve($scope.map.control.getGMap());
	    });
	  });
	
	  $scope.$on('$ionicView.afterEnter', function () {
	    $scope.$broadcast('startPingLoop');
	    loadingSpinner(Promise.all([mapPromise, routePromise, subscriptionPromise]).then(function () {
	      var gmap = $scope.map.control.getGMap();
	      google.maps.event.trigger(gmap, 'resize');
	    }));
	  });
	
	  $scope.$on('$ionicView.beforeLeave', function () {
	    $scope.$broadcast('killPingLoop');
	  });
	
	  Promise.all([mapPromise, routePromise]).then(function (values) {
	    var _values = _slicedToArray(values, 2),
	        map = _values[0],
	        route = _values[1];
	
	    RoutesService.decodeRoutePath(route[$scope.book.label].path).then(function (path) {
	      return $scope.map.lines.route.path = path;
	    }).catch(function (err) {
	      console.error(err);
	    });
	  });
	
	  Promise.all([mapPromise, uiGmapGoogleMapApi]).then(function (values) {
	    var _values2 = _slicedToArray(values, 2),
	        map = _values2[0],
	        googleMaps = _values2[1];
	
	    MapOptions.disableMapLinks();
	    $scope.$on("$ionicView.afterEnter", function (event, data) {
	      googleMaps.event.trigger(map, 'resize');
	    });
	  });
	
	  $scope.$watch(function () {
	    return UserService.getUser() && UserService.getUser().id;
	  }, function (userId) {
	    $scope.isLoggedIn = userId ? true : false;
	  });
	
	  $scope.$watchCollection(function () {
	    return [].concat(LiteRouteSubscriptionService.getSubscriptionSummary());
	  }, function (newValue) {
	    LiteRouteSubscriptionService.isSubscribed($scope.book.label).then(function (response) {
	      if (response) {
	        $scope.book.isSubscribed = true;
	      } else {
	        $scope.book.isSubscribed = false;
	      }
	    });
	  });
	
	  $scope.login = function () {
	    UserService.promptLogIn();
	  };
	
	  $scope.showConfirmationPopup = function () {
	    return $scope.confirmationPopup = $ionicPopup.show({
	      scope: $scope,
	      template: '\n        <div class="item item-text-wrap">\n          <div>\n              Please read {{disp.companyInfo.name}}\'s <a ng-click="disp.showTerms()">Terms and Conditions of Service</a>.\n          </div>\n          <ion-checkbox ng-model="disp.termsChecked">\n            Yes, I have read and agree to the above Terms and Conditions and would like to proceed.\n          </ion-checkbox>\n        </div>\n        ',
	      cssClass: "popup-no-head",
	      buttons: [{
	        text: "Cancel",
	        type: "button-default",
	        onTap: function onTap() {
	          return false;
	        }
	      }, {
	        text: "OK",
	        type: "button-positive",
	        onTap: function onTap(e) {
	          if (!$scope.disp.termsChecked) {
	            e.preventDefault();
	          } else {
	            $scope.followRoute();
	          }
	        }
	      }]
	    });
	  };
	
	  $scope.followRoute = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	    var subscribeResult;
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            _context.prev = 0;
	
	            $scope.book.waitingForSubscriptionResult = true;
	
	            _context.next = 4;
	            return loadingSpinner(LiteRoutesService.subscribeLiteRoute($scope.book.label));
	
	          case 4:
	            subscribeResult = _context.sent;
	
	
	            if (subscribeResult) {
	              $scope.book.isSubscribed = true;
	              $ionicPopup.alert({
	                title: 'Success',
	                template: '\n            <div class="item item-text-wrap text-center ">\n              <div>\n                <img src="img/lite_success.svg">\n              </div>\n              <p>You bookmarked this route.<br>\n              Track your bus on the day of the trip.\n              </p>\n            </div>\n            '
	              }).then(function () {
	                $state.transitionTo("tabs.tickets");
	              });
	            }
	            _context.next = 12;
	            break;
	
	          case 8:
	            _context.prev = 8;
	            _context.t0 = _context['catch'](0);
	            _context.next = 12;
	            return $ionicLoading.show({
	              template: '\n          <div>Error, please try again later.</div>\n          ',
	              duration: 1000
	            });
	
	          case 12:
	            _context.prev = 12;
	
	            $scope.book.waitingForSubscriptionResult = false;
	            return _context.finish(12);
	
	          case 15:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, this, [[0, 8, 12, 15]]);
	  }));
	
	  // TODO: Move bulk of promptUntrack code into service or directive as both
	  // LiteSummaryController and LiteRouteTrackerController uses it
	  $scope.promptUntrack = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	    var response, unsubscribeResult;
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            _context2.next = 2;
	            return $ionicPopup.confirm({
	              title: 'Are you sure you want to unbookmark this route?',
	              subTitle: "This tracking-only route will be removed from your trips list."
	            });
	
	          case 2:
	            response = _context2.sent;
	
	            if (response) {
	              _context2.next = 5;
	              break;
	            }
	
	            return _context2.abrupt('return');
	
	          case 5:
	            _context2.prev = 5;
	
	            $scope.book.waitingForSubscriptionResult = true;
	
	            _context2.next = 9;
	            return loadingSpinner(LiteRoutesService.unsubscribeLiteRoute($scope.book.label));
	
	          case 9:
	            unsubscribeResult = _context2.sent;
	
	
	            if (unsubscribeResult) {
	              $scope.book.isSubscribed = false;
	            }
	
	            if ($scope.book.isSubscribed) {
	              _context2.next = 15;
	              break;
	            }
	
	            _context2.next = 14;
	            return $ionicLoading.show({
	              template: '\n            <div>Done!</div>\n            ',
	              duration: 1000
	            });
	
	          case 14:
	            $state.transitionTo("tabs.routes");
	
	          case 15:
	            _context2.next = 21;
	            break;
	
	          case 17:
	            _context2.prev = 17;
	            _context2.t0 = _context2['catch'](5);
	            _context2.next = 21;
	            return $ionicLoading.show({
	              template: '\n          <div>Error, please try again later.</div>\n          ',
	              duration: 1000
	            });
	
	          case 21:
	            _context2.prev = 21;
	
	            $scope.book.waitingForSubscriptionResult = false;
	            return _context2.finish(21);
	
	          case 24:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this, [[5, 17, 21, 24]]);
	  }));
	
	  $scope.disp.showTerms = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	    return regeneratorRuntime.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            if ($scope.book.route.transportCompanyId) {
	              _context3.next = 2;
	              break;
	            }
	
	            return _context3.abrupt('return');
	
	          case 2:
	
	            $scope.confirmationPopup.close();
	
	            _context3.next = 5;
	            return CompanyService.showTerms($scope.book.route.transportCompanyId);
	
	          case 5:
	
	            $scope.showConfirmationPopup();
	
	          case 6:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, _this);
	  }));
	
	  $scope.hideTooltip = function () {
	    if ($scope.disp.showTooltip) {
	      $scope.disp.showTooltip = false;
	    }
	  };
	}];

/***/ },
/* 506 */
/*!*******************************************************!*\
  !*** ./beeline/controllers/LiteMoreInfoController.js ***!
  \*******************************************************/
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($scope, $state, $stateParams, LiteRoutesService, RoutesService) {
	
	  // https://github.com/angular/angular.js/wiki/Understanding-Scopes
	  $scope.data = {
	    companyId: null,
	    label: null
	  };
	
	  $scope.data.companyId = $stateParams.companyId;
	  $scope.data.label = $stateParams.label;
	  LiteRoutesService.getLiteRoute($scope.data.label).then(function (liteRoute) {
	    $scope.data.liteRoute = liteRoute[$scope.data.label];
	    RoutesService.getRouteFeatures($scope.data.liteRoute.id).then(function (data) {
	      $scope.data.features = data;
	    });
	  });
	};

/***/ },
/* 507 */
/*!**************************************************!*\
  !*** ./beeline/controllers/WelcomeController.js ***!
  \**************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var queryString = __webpack_require__(/*! querystring */ 425);
	
	exports.default = ['$scope', '$state', '$stateParams', '$ionicPopup', '$ionicLoading', 'UserService', 'LoginDialog', function () {
	  var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2($scope, $state, $stateParams, $ionicPopup, $ionicLoading, UserService, LoginDialog) {
	    var query, refCodeOwner;
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	
	            // Verify if refCode is provided
	            $scope.isLoaded = false;
	            $ionicLoading.show();
	
	            $scope.refCode = $stateParams.refCode;
	
	            if (!$scope.refCode) {
	              _context2.next = 15;
	              break;
	            }
	
	            query = queryString.stringify({ code: $scope.refCode });
	            _context2.prev = 5;
	            _context2.next = 8;
	            return UserService.beeline({
	              method: 'GET',
	              url: '/promotions/refCodeOwner?' + query
	            });
	
	          case 8:
	            refCodeOwner = _context2.sent;
	
	
	            if (refCodeOwner) {
	              $scope.refCodeOwner = refCodeOwner.data;
	            }
	
	            _context2.next = 15;
	            break;
	
	          case 12:
	            _context2.prev = 12;
	            _context2.t0 = _context2['catch'](5);
	
	            $ionicPopup.alert({
	              title: _context2.t0.data.message,
	              subTitle: _context2.t0.statusText
	            });
	
	          case 15:
	
	            $ionicLoading.hide();
	            $scope.isLoaded = true;
	
	            $scope.data = {};
	
	            $scope.register = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	              return regeneratorRuntime.wrap(function _callee$(_context) {
	                while (1) {
	                  switch (_context.prev = _context.next) {
	                    case 0:
	                      _context.next = 2;
	                      return UserService.registerViaReferralWelcome($scope.data.telephone, $scope.refCode, $scope.refCodeOwner);
	
	                    case 2:
	
	                      $state.go('tabs.routes');
	
	                      _context.next = 5;
	                      return $ionicPopup.alert({
	                        title: 'Welcome to Beeline',
	                        subTitle: 'Success! You can now use your $10 ride credits when you make bookings.'
	                      });
	
	                    case 5:
	                    case 'end':
	                      return _context.stop();
	                  }
	                }
	              }, _callee, this);
	            }));
	
	          case 19:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, this, [[5, 12]]);
	  }));
	
	  return function (_x, _x2, _x3, _x4, _x5, _x6, _x7) {
	    return _ref.apply(this, arguments);
	  };
	}()];

/***/ },
/* 508 */
/*!******************************************************!*\
  !*** ./beeline/controllers/KickstarterController.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	// Parse out the available regions from the routes
	// Filter what is displayed by the region filter
	// Split the routes into those the user has recently booked and the rest
	
	
	exports.default = function ($scope, $state, UserService, RoutesService, $q, $ionicScrollDelegate, $ionicPopup, KickstarterService, $ionicLoading, SearchService, $timeout, loadingSpinner) {
	
	  // https://github.com/angular/angular.js/wiki/Understanding-Scopes
	  $scope.data = {
	    error: null,
	    kickstarter: null,
	    backedKickstarter: null,
	    regions: [],
	    filterText: '',
	    stagingFilterText: '',
	    nearbyKickstarterRoutes: null
	  };
	
	  $scope.disp = {
	    showNearbyKickstarter: true,
	    showAvailableKickstarter: true
	  };
	
	  $scope.refreshRoutes = function () {
	    $q.all([KickstarterService.fetchLelong(true), KickstarterService.fetchBids(true), KickstarterService.fetchNearbyKickstarterIds()]).then(function () {
	      $scope.data.error = null;
	    }).catch(function () {
	      $scope.data.error = true;
	    }).then(function () {
	      $scope.$broadcast('scroll.refreshComplete');
	    });
	  };
	
	  var timeoutProise = function timeoutProise(promise, ms) {
	    return Promise.race([promise, new Promise(function (resolve, reject) {
	      $timeout(function () {
	        return reject();
	      }, ms);
	    })]);
	  };
	
	  //show loading spinner for the 1st time
	  loadingSpinner(timeoutProise(KickstarterService.fetchLelong(), 10 * 6000).then(function () {
	    $scope.data.error = null;
	  }).catch(function () {
	    $scope.data.error = true;
	  }).then(function () {
	    if (!window.localStorage['showCrowdstart']) {
	      window.localStorage['showCrowdstart'] = true;
	      $scope.showHelpPopup();
	    }
	  }));
	
	  $scope.$watchGroup([function () {
	    return KickstarterService.getLelong();
	  }, function () {
	    return KickstarterService.getNearbyKickstarterIds();
	  }, function () {
	    return KickstarterService.getBids();
	  }, 'data.selectedRegionId', 'data.filterText'], function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 5),
	        lelongRoutes = _ref2[0],
	        nearByLelongIds = _ref2[1],
	        userBids = _ref2[2],
	        selectedRegionId = _ref2[3],
	        filterText = _ref2[4];
	
	    if (!lelongRoutes) return;
	    //sort by numeric part of label (to fix c100 appears before c99)
	    $scope.data.kickstarter = _lodash2.default.sortBy(lelongRoutes, function (x) {
	      return parseInt(x.label.slice(1));
	    });
	    $scope.userBids = userBids;
	    $scope.recentBidsById = _lodash2.default.keyBy($scope.userBids, function (r) {
	      return r.routeId;
	    });
	    var recentAndAvailable = _lodash2.default.partition($scope.data.kickstarter, function (x) {
	      return _lodash2.default.includes(_lodash2.default.keys($scope.recentBidsById), x.id.toString());
	    });
	    // don't display it in backed list if the pass expires after 1 month of 1st trip
	    //and don't display it if it's 7 days after expired and not actived
	    $scope.data.backedKickstarter = recentAndAvailable[0].filter(function (route) {
	      return !route.passExpired && route.isActived || !route.isExpired || !route.is7DaysOld;
	    });
	    //don't display it in kickstarter if it's expired
	    $scope.data.kickstarter = recentAndAvailable[1].filter(function (route) {
	      return !route.isExpired;
	    });
	    //regions from list of backed and not expired available
	    $scope.data.regions = RoutesService.getUniqueRegionsFromRoutes($scope.data.backedKickstarter.concat($scope.data.kickstarter));
	    //nearby Lelong routes and the rest
	    if (nearByLelongIds) {
	      var _$partition = _lodash2.default.partition($scope.data.kickstarter, function (r) {
	        return nearByLelongIds.indexOf(r.id) != -1;
	      });
	
	      var _$partition2 = _slicedToArray(_$partition, 2);
	
	      $scope.data.nearbyKickstarterRoutes = _$partition2[0];
	      $scope.data.kickstarter = _$partition2[1];
	
	      $scope.data.filteredNearbyKickstarter = SearchService.filterRoutes($scope.data.nearbyKickstarterRoutes, +selectedRegionId, filterText);
	    }
	    $scope.data.filteredKickstarter = SearchService.filterRoutes($scope.data.kickstarter, +selectedRegionId, filterText);
	    $scope.data.filteredbackedKickstarter = SearchService.filterRoutes($scope.data.backedKickstarter, +selectedRegionId, filterText);
	  });
	
	  // Throttle the actual updating of filter text
	  $scope.updateFilter = _lodash2.default.throttle(function (value) {
	    // Some times this function is called synchronously, some times it isn't
	    // Use timeout to ensure that we are always inside a digest cycle.
	    setTimeout(function () {
	      $scope.data.filterText = $scope.data.stagingFilterText;
	      $scope.$digest();
	    }, 0);
	  }, 400, { trailing: true });
	
	  $scope.showHelpPopup = function () {
	    $scope.kickstartHelpPopup = $ionicPopup.show({
	      template: _kickstartPopup2.default,
	      title: 'Crowdstart Routes',
	      buttons: [{
	        text: 'OK',
	        type: 'button-positive',
	        onTap: function onTap(e) {
	          $scope.closePopup();
	        }
	      }]
	    });
	  };
	
	  $scope.closePopup = function () {
	    $scope.kickstartHelpPopup.close();
	  };
	};
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _kickstartPopup = __webpack_require__(/*! ../templates/kickstart-popup.html */ 509);
	
	var _kickstartPopup2 = _interopRequireDefault(_kickstartPopup);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 509 */
/*!************************************************!*\
  !*** ./beeline/templates/kickstart-popup.html ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = "\n  <div  class=\"kickstart-help\">\n    <img src=\"img/introKickstart.svg\">\n    <p>\n      Crowdstart routes are routes that are not in operation yet. Activate these routes by pre-ordering route passes. If enough people do so, the route will be activated.\n    </p>\n  </div>\n";

/***/ },
/* 510 */
/*!************************************************************!*\
  !*** ./beeline/controllers/KickstarterDetailController.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	var _processingPayments = __webpack_require__(/*! ../templates/processing-payments.html */ 494);
	
	var _processingPayments2 = _interopRequireDefault(_processingPayments);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _busStopList = __webpack_require__(/*! ../templates/bus-stop-list.html */ 511);
	
	var _busStopList2 = _interopRequireDefault(_busStopList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = ['$rootScope', '$scope', '$interpolate', '$state', '$stateParams', '$ionicModal', '$http', '$cordovaGeolocation', 'BookingService', 'RoutesService', 'uiGmapGoogleMapApi', 'MapOptions', 'loadingSpinner', 'UserService', 'StripeService', '$ionicLoading', '$ionicPopup', 'KickstarterService', function ($rootScope, $scope, $interpolate, $state, $stateParams, $ionicModal, $http, $cordovaGeolocation, BookingService, RoutesService, uiGmapGoogleMapApi, MapOptions, loadingSpinner, UserService, StripeService, $ionicLoading, $ionicPopup, KickstarterService) {
	  // Gmap default settings
	  $scope.map = MapOptions.defaultMapOptions();
	  $scope.modalMap = MapOptions.defaultMapOptions();
	
	  $scope.routePath = [];
	
	  // Default settings for various info used in the page
	  $scope.book = {
	    routeId: null,
	    route: null,
	    bid: null,
	    calculatedAmount: '',
	    bidPrice: null
	  };
	  $scope.disp = {
	    popupStop: null,
	    popupStopType: null,
	    parentScope: $scope
	  };
	
	  // Resolved when the map is initialized
	  var gmapIsReady = new Promise(function (resolve, reject) {
	    var resolved = false;
	    $scope.$watch('map.control.getGMap', function () {
	      if ($scope.map.control.getGMap) {
	        if (!resolved) {
	          resolved = true;
	          resolve();
	        }
	      }
	    });
	  });
	
	  var routePromise;
	
	  $scope.book.routeId = +$stateParams.routeId;
	
	  $scope.$watch(function () {
	    return KickstarterService.getLelongById($scope.book.routeId);
	  }, function (route) {
	    if (!route) return;
	    $scope.book.route = route;
	    $scope.book.bidOptions = route.notes.tier;
	
	    var _BookingService$compu = BookingService.computeStops($scope.book.route.trips);
	
	    var _BookingService$compu2 = _slicedToArray(_BookingService$compu, 2);
	
	    $scope.book.boardStops = _BookingService$compu2[0];
	    $scope.book.alightStops = _BookingService$compu2[1];
	
	    $scope.busStops = $scope.book.boardStops.concat($scope.book.alightStops);
	    $scope.panToStops($scope.map.control.getGMap(), $scope.busStops);
	  });
	
	  $scope.$on('$ionicView.afterEnter', function () {
	    loadingSpinner(Promise.all([gmapIsReady]).then(function () {
	      var gmap = $scope.map.control.getGMap();
	      google.maps.event.trigger(gmap, 'resize');
	    }));
	  });
	
	  gmapIsReady.then(function () {
	    MapOptions.disableMapLinks();
	  });
	
	  $scope.$watch('book.route.path', function (path) {
	    if (!path) {
	      $scope.routePath = [];
	    } else {
	      RoutesService.decodeRoutePath(path).then(function (decodedPath) {
	        return $scope.routePath = decodedPath;
	      }).catch(function () {
	        return $scope.routePath = [];
	      });
	    }
	  });
	
	  $scope.applyTapBoard = function (stop) {
	    $scope.disp.popupStopType = "pickup";
	    $scope.disp.popupStop = stop;
	    $scope.$digest();
	  };
	  $scope.applyTapAlight = function (stop) {
	    $scope.disp.popupStopType = "dropoff";
	    $scope.disp.popupStop = stop;
	    $scope.$digest();
	  };
	
	  $scope.closeWindow = function () {
	    $scope.disp.popupStop = null;
	  };
	
	  $scope.modal = $ionicModal.fromTemplate(_busStopList2.default, {
	    scope: $scope,
	    animation: 'slide-in-up'
	  });
	
	  $scope.showStops = function () {
	    $scope.modal.show();
	
	    $scope.$watch(function () {
	      return $scope.modalMap.control.getGMap();
	    }, function (modalMap) {
	      if (modalMap) {
	        google.maps.event.trigger(modalMap, 'resize');
	        //set modalMap bound
	        $scope.panToStops(modalMap, $scope.busStops);
	      }
	    });
	  };
	  $scope.close = function () {
	    $scope.modal.hide();
	  };
	  // Cleanup the modal when we're done with it!
	  $scope.$on('$destroy', function () {
	    $scope.modal.remove();
	  });
	
	  /* Pans to the stops on the screen */
	  $scope.panToStops = function (gmap, stops) {
	    if (stops.length == 0) {
	      return;
	    }
	    var bounds = new google.maps.LatLngBounds();
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = stops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var s = _step.value;
	
	        bounds.extend(new google.maps.LatLng(s.coordinates.coordinates[1], s.coordinates.coordinates[0]));
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    gmap.fitBounds(bounds);
	  };
	
	  // pans to single stop
	  $scope.panToStop = function (gmap, stop) {
	    if (!stop) return;
	    $scope.book.chosenStop = stop;
	    gmap.panTo({
	      lat: stop.coordinates.coordinates[1],
	      lng: stop.coordinates.coordinates[0]
	    });
	    gmap.setZoom(17);
	  };
	
	  $scope.updateSelection = function (position, tiers, price) {
	    _.forEach(tiers, function (tier, index) {
	      if (position == index) {
	        $scope.book.bidPrice = $scope.book.bidPrice == price ? null : price;
	      }
	    });
	  };
	}];
	//

/***/ },
/* 511 */
/*!**********************************************!*\
  !*** ./beeline/templates/bus-stop-list.html ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = "<ion-modal-view class=\"stop-selector\">\n  <ion-header-bar class=\"bar bar-royal\">\n    <h1 class=\"title\">\n      Crowdstart Route Stops\n    </h1>\n    <button class=\"button button-clear icon ion-ios-close-outline\"\n        ng-click=\"close()\">\n   </button>\n  </ion-header-bar>\n\n  <ion-content class=\"stops-list-main\" scroll=\"false\">\n    <div class=\"map-area\">\n      <ui-gmap-google-map center=\"modalMap.center\"\n                          zoom=\"modalMap.zoom\"\n                          bounds=\"modalMap.bounds\"\n                          control=\"modalMap.control\"\n                          options=\"modalMap.options\"\n                          data-tap-disabled=\"true\">\n        <my-location></my-location>\n        <ui-gmap-marker\n          ng-repeat=\"stop in book.boardStops\"\n          idKey=\"stop.id\"\n          coords=\"stop.coordinates\"\n          options=\"modalMap.markerOptions.boardMarker\"\n        ></ui-gmap-marker>\n        <ui-gmap-marker\n          ng-repeat=\"stop in book.alightStops\"\n          idKey=\"stop.id\"\n          coords=\"stop.coordinates\"\n          options=\"modalMap.markerOptions.alightMarker\"\n        ></ui-gmap-marker>\n\n        <ui-gmap-marker ng-if=\"book.chosenStop\"\n                        idkey=\"'selectedStopPin'\"\n                        coords=\"book.chosenStop.coordinates\"\n                        options=\"book.chosenStop.canBoard ? modalMap.markerOptions.startMarker : modalMap.markerOptions.endMarker\">\n        </ui-gmap-marker>\n      </ui-gmap-google-map>\n    </div>\n\n    <div class=\"item item-divider num-stops\">{{busStops.length}} stops available</div>\n\n    <ion-content class=\"stops-list\" delegate-handle=\"stopsListScroll\">\n      <div class=\"item item-divider\"> Boarding Stops </div>\n      <ion-list>\n        <ion-item ng-repeat=\"stop in book.boardStops\"\n                  class=\"item-text-wrap item-icon-left\"\n                  icon=\"icon ion-ios-checkmark\"\n                  ng-click=\"panToStop(modalMap.control.getGMap(), stop)\">\n          <div class=\"fullStopDetails\">\n            <div class=\"time\">{{stop.time | formatTime}}</div>\n            <div class=\"details\">\n              <div class=\"description\">{{stop.description}}</div>\n              <div class=\"road\">{{stop.road}}</div>\n            </div>\n          </div>\n          <i class=\"icon stop-icon board\"></i>\n        </ion-item>\n      </ion-list>\n      <div class=\"item item-divider\"> Alighting Stops </div>\n      <ion-list>\n        <ion-item  ng-repeat=\"stop in book.alightStops\"\n                    class=\"item-text-wrap item-icon-left\"\n                    icon=\"icon ion-ios-checkmark\"\n                    ng-click=\"panToStop(modalMap.control.getGMap(), stop)\">\n          <div class=\"fullStopDetails\">\n            <div class=\"time\">{{stop.time | formatTime}}</div>\n            <div class=\"details\">\n              <div class=\"description\">{{stop.description}}</div>\n              <div class=\"road\">{{stop.road}}</div>\n            </div>\n          </div>\n          <i class=\"icon stop-icon alight\"></i>\n        </ion-item>\n      </ion-list>\n    </ion-content>\n\n    <div class=\"item select-button\">\n      <button class=\"button primary-button button-item\"\n              ng-click=\"close()\">\n        close\n      </button>\n    </div>\n\n  </ion-content>\n</ion-modal-view>\n";

/***/ },
/* 512 */
/*!*************************************************************!*\
  !*** ./beeline/controllers/KickstarterSummaryController.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$rootScope', '$scope', '$interpolate', '$state', '$stateParams', '$ionicModal', '$http', 'BookingService', 'RoutesService', 'loadingSpinner', 'UserService', '$ionicPopup', 'KickstarterService', 'CompanyService', 'StripeService', function ($rootScope, $scope, $interpolate, $state, $stateParams, $ionicModal, $http, BookingService, RoutesService, loadingSpinner, UserService, $ionicPopup, KickstarterService, CompanyService, StripeService) {
	  var _this = this;
	
	  // Default settings for various info used in the page
	  $scope.book = {
	    routeId: null,
	    boardStopId: null,
	    alightStopId: null,
	    route: null,
	    notExpired: true,
	    isBid: null
	  };
	  $scope.priceInfo = {
	    tripCount: null,
	    bidPrice: null,
	    totalDue: null
	  };
	  $scope.data = {
	    hasCreditInfo: false,
	    brand: null,
	    last4Digtis: null
	  };
	
	  $scope.book.routeId = +$stateParams.routeId;
	  $scope.priceInfo.bidPrice = +$stateParams.bidPrice;
	
	  $scope.$watch(function () {
	    return KickstarterService.getLelongById($scope.book.routeId);
	  }, function (route) {
	    if (!route) return;
	    $scope.book.route = route;
	    //give 1st and last stop as board and alight stop for fake ticket
	    $scope.book.boardStopId = _.first(route.trips[0].tripStops).id;
	    $scope.book.alightStopId = _.last(route.trips[0].tripStops).id;
	    $scope.priceInfo.tripCount = $scope.book.route.notes.noPasses || 0;
	    $scope.priceInfo.totalDue = $scope.priceInfo.bidPrice * $scope.priceInfo.tripCount;
	    $scope.$watch('priceInfo.bidPrice', function (price) {
	      $scope.priceInfo.tripCount = $scope.book.route.notes.noPasses || 0;
	      $scope.priceInfo.totalDue = price * $scope.priceInfo.tripCount;
	    });
	  });
	
	  $scope.$watch(function () {
	    return UserService.getUser();
	  }, function () {
	    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(user) {
	      return regeneratorRuntime.wrap(function _callee$(_context) {
	        while (1) {
	          switch (_context.prev = _context.next) {
	            case 0:
	              $scope.isLoggedIn = user ? true : false;
	              $scope.user = user;
	              if ($scope.isLoggedIn) {
	                $scope.$watch(function () {
	                  return UserService.getUser().savedPaymentInfo;
	                }, function (paymentInfo) {
	                  $scope.data.hasCreditInfo = $scope.user && $scope.user.savedPaymentInfo && $scope.user.savedPaymentInfo.sources.data.length > 0;
	                  if ($scope.data.hasCreditInfo) {
	                    $scope.data.brand = paymentInfo.sources.data[0].brand;
	                    $scope.data.last4Digtis = paymentInfo.sources.data[0].last4;
	                  }
	                });
	              }
	
	            case 3:
	            case 'end':
	              return _context.stop();
	          }
	        }
	      }, _callee, _this);
	    }));
	
	    return function (_x) {
	      return _ref.apply(this, arguments);
	    };
	  }());
	
	  $scope.showTerms = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
	      while (1) {
	        switch (_context2.prev = _context2.next) {
	          case 0:
	            if ($scope.book.route.transportCompanyId) {
	              _context2.next = 2;
	              break;
	            }
	
	            return _context2.abrupt('return');
	
	          case 2:
	            _context2.next = 4;
	            return CompanyService.showTerms($scope.book.route.transportCompanyId);
	
	          case 4:
	          case 'end':
	            return _context2.stop();
	        }
	      }
	    }, _callee2, _this);
	  }));
	
	  $scope.login = function () {
	    UserService.promptLogIn();
	  };
	
	  $scope.createBid = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
	    var bidPrice, stripeToken, bidResult;
	    return regeneratorRuntime.wrap(function _callee3$(_context3) {
	      while (1) {
	        switch (_context3.prev = _context3.next) {
	          case 0:
	            _context3.prev = 0;
	            bidPrice = $scope.priceInfo.bidPrice;
	            // disable the button
	
	            $scope.waitingForPaymentResult = true;
	
	            if ($scope.data.hasCreditInfo) {
	              _context3.next = 11;
	              break;
	            }
	
	            _context3.next = 6;
	            return StripeService.promptForToken(null, null, true);
	
	          case 6:
	            stripeToken = _context3.sent;
	
	            if (stripeToken) {
	              _context3.next = 9;
	              break;
	            }
	
	            return _context3.abrupt('return');
	
	          case 9:
	            _context3.next = 11;
	            return loadingSpinner(UserService.savePaymentInfo(stripeToken.id));
	
	          case 11:
	            _context3.next = 17;
	            break;
	
	          case 13:
	            _context3.prev = 13;
	            _context3.t0 = _context3['catch'](0);
	
	            console.log(_context3.t0);
	            throw new Error('Error saving credit card details. ' + _.get(_context3.t0, 'data.message'));
	
	          case 17:
	            _context3.prev = 17;
	
	            $scope.waitingForPaymentResult = false;
	            //to make $digest not throw errors
	            _context3.next = 21;
	            return new Promise(function (resolve) {
	              return setTimeout(resolve, 0);
	            });
	
	          case 21:
	            $scope.$digest();
	            return _context3.finish(17);
	
	          case 23:
	            _context3.prev = 23;
	            _context3.next = 26;
	            return loadingSpinner(KickstarterService.createBid($scope.book.route, $scope.book.boardStopId, $scope.book.alightStopId, bidPrice));
	
	          case 26:
	            bidResult = _context3.sent;
	            _context3.next = 29;
	            return $ionicPopup.alert({
	              title: 'Success'
	            });
	
	          case 29:
	            $scope.$apply(function () {
	              $scope.book.isBid = true;
	            });
	            $state.go('tabs.crowdstart-commit', { routeId: $scope.book.routeId });
	            _context3.next = 38;
	            break;
	
	          case 33:
	            _context3.prev = 33;
	            _context3.t1 = _context3['catch'](23);
	            _context3.next = 37;
	            return $ionicPopup.alert({
	              title: 'Error processing bid',
	              template: '\n          <div> There was an error creating the bid. ' + (_context3.t1 && _context3.t1.data && _context3.t1.data.message) + ' Please try again later.</div>\n          '
	            });
	
	          case 37:
	            $state.go('tabs.crowdstart');
	
	          case 38:
	            _context3.prev = 38;
	
	            $scope.waitingForPaymentResult = false;
	            $scope.$digest();
	            return _context3.finish(38);
	
	          case 42:
	          case 'end':
	            return _context3.stop();
	        }
	      }
	    }, _callee3, this, [[0, 13, 17, 23], [23, 33, 38, 42]]);
	  }));
	
	  //update the saving card info then place bid
	  $scope.updateSavingCard = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
	    var stripeToken, user, result;
	    return regeneratorRuntime.wrap(function _callee4$(_context4) {
	      while (1) {
	        switch (_context4.prev = _context4.next) {
	          case 0:
	            _context4.prev = 0;
	            _context4.next = 3;
	            return StripeService.promptForToken(null, null, true);
	
	          case 3:
	            stripeToken = _context4.sent;
	
	            if (stripeToken) {
	              _context4.next = 6;
	              break;
	            }
	
	            return _context4.abrupt('return');
	
	          case 6:
	            user = $scope.user;
	            _context4.next = 9;
	            return loadingSpinner(UserService.updatePaymentInfo(stripeToken.id));
	
	          case 9:
	            result = _context4.sent;
	            _context4.next = 16;
	            break;
	
	          case 12:
	            _context4.prev = 12;
	            _context4.t0 = _context4['catch'](0);
	
	            console.log(err);
	            throw new Error('Error saving credit card details. ' + _.get(err, 'data.message'));
	
	          case 16:
	          case 'end':
	            return _context4.stop();
	        }
	      }
	    }, _callee4, this, [[0, 12]]);
	  }));
	}];
	//

/***/ },
/* 513 */
/*!************************************************************!*\
  !*** ./beeline/controllers/KickstarterCommitController.js ***!
  \************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = ['$rootScope', '$scope', '$state', '$stateParams', '$http', 'RoutesService', 'loadingSpinner', 'UserService', 'KickstarterService', '$cordovaSocialSharing', function ($rootScope, $scope, $state, $stateParams, $http, RoutesService, loadingSpinner, UserService, KickstarterService, $cordovaSocialSharing) {
	  // Default settings for various info used in the page
	  $scope.book = {
	    routeId: null,
	    boardStopId: null,
	    alightStopId: null,
	    route: null,
	    notExpired: true,
	    bidPrice: null
	  };
	
	  $scope.book.routeId = +$stateParams.routeId;
	  $scope.showCopy = !window.cordova || false;
	
	  $scope.$watchGroup([function () {
	    return KickstarterService.getLelongById($scope.book.routeId);
	  }, function () {
	    return KickstarterService.getBidInfo($scope.book.routeId);
	  }], function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        route = _ref2[0],
	        bid = _ref2[1];
	
	    if (!route) return;
	    $scope.book.route = route;
	    if (!bid) return;
	    $scope.book.bidPrice = bid.bidPrice;
	    $scope.book.boardStop = $scope.book.route.trips[0].tripStops.find(function (ts) {
	      return bid.boardStopId == ts.stop.id;
	    });
	    $scope.book.alightStop = $scope.book.route.trips[0].tripStops.find(function (ts) {
	      return bid.alightStopId == ts.stop.id;
	    });
	  });
	}];
	//

/***/ },
/* 514 */
/*!***********************************************************!*\
  !*** ./beeline/controllers/KickstarterRecapController.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	var _errors = __webpack_require__(/*! ../shared/errors */ 466);
	
	var _format = __webpack_require__(/*! ../shared/format */ 299);
	
	var _loading = __webpack_require__(/*! ../templates/loading.html */ 471);
	
	var _loading2 = _interopRequireDefault(_loading);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _busStopList = __webpack_require__(/*! ../templates/bus-stop-list.html */ 511);
	
	var _busStopList2 = _interopRequireDefault(_busStopList);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$rootScope', '$scope', '$interpolate', '$state', '$stateParams', '$ionicModal', '$http', 'BookingService', 'RoutesService', 'loadingSpinner', 'UserService', '$ionicLoading', '$ionicPopup', 'KickstarterService', 'CompanyService', 'MapOptions', function ($rootScope, $scope, $interpolate, $state, $stateParams, $ionicModal, $http, BookingService, RoutesService, loadingSpinner, UserService, $ionicLoading, $ionicPopup, KickstarterService, CompanyService, MapOptions) {
	  var _this = this;
	
	  // Default settings for various info used in the page
	  $scope.book = {
	    routeId: null,
	    boardStopId: null,
	    alightStop: null,
	    route: null,
	    bidPrice: null,
	    boardStops: null,
	    alightStops: null,
	    passAvailable: null,
	    creditTag: null
	  };
	
	  $scope.book.routeId = +$stateParams.routeId;
	
	  $scope.book.creditTag = "crowdstart-" + $scope.book.routeId;
	
	  $scope.modalMap = MapOptions.defaultMapOptions();
	
	  $scope.modal = $ionicModal.fromTemplate(_busStopList2.default, {
	    scope: $scope,
	    animation: 'slide-in-up'
	  });
	
	  $scope.showStops = function () {
	    $scope.modal.show();
	
	    $scope.$watch(function () {
	      return $scope.modalMap.control.getGMap();
	    }, function (modalMap) {
	      if (modalMap) {
	        google.maps.event.trigger(modalMap, 'resize');
	        //set modalMap bound
	        $scope.panToStops(modalMap, $scope.busStops);
	      }
	    });
	  };
	  $scope.close = function () {
	    $scope.modal.hide();
	  };
	  // Cleanup the modal when we're done with it!
	  $scope.$on('$destroy', function () {
	    $scope.modal.remove();
	  });
	
	  $scope.$watchGroup([function () {
	    return KickstarterService.getLelongById($scope.book.routeId);
	  }, function () {
	    return KickstarterService.getBidInfo($scope.book.routeId);
	  }, function () {
	    return RoutesService.getRouteCredits($scope.book.creditTag);
	  }], function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 3),
	        route = _ref2[0],
	        bid = _ref2[1],
	        credit = _ref2[2];
	
	    if (!route) return;
	    $scope.book.route = route;
	    /** Summarizes the stops from trips by comparing their stop location and time */
	
	    var _BookingService$compu = BookingService.computeStops($scope.book.route.trips);
	
	    var _BookingService$compu2 = _slicedToArray(_BookingService$compu, 2);
	
	    $scope.book.boardStops = _BookingService$compu2[0];
	    $scope.book.alightStops = _BookingService$compu2[1];
	
	    $scope.busStops = $scope.book.boardStops.concat($scope.book.alightStops);
	    if (!bid) return;
	    $scope.book.bid = bid;
	    $scope.book.bidPrice = $scope.book.bid.bidPrice;
	    $scope.book.boardStopId = +$scope.book.bid.boardStopId;
	    $scope.book.alightStopId = +$scope.book.bid.alightStopId;
	    $scope.book.boardStop = route.trips[0].tripStops.find(function (ts) {
	      return $scope.book.boardStopId == ts.stop.id;
	    });
	    $scope.book.alightStop = route.trips[0].tripStops.find(function (ts) {
	      return $scope.book.alightStopId == ts.stop.id;
	    });
	    if (!credit) return;
	    $scope.book.passAvailable = credit / $scope.book.bidPrice;
	  });
	
	  $scope.showTerms = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	    return regeneratorRuntime.wrap(function _callee$(_context) {
	      while (1) {
	        switch (_context.prev = _context.next) {
	          case 0:
	            if ($scope.book.route.transportCompanyId) {
	              _context.next = 2;
	              break;
	            }
	
	            return _context.abrupt('return');
	
	          case 2:
	            _context.next = 4;
	            return CompanyService.showTerms($scope.book.route.transportCompanyId);
	
	          case 4:
	          case 'end':
	            return _context.stop();
	        }
	      }
	    }, _callee, _this);
	  }));
	
	  /* Pans to the stops on the screen */
	  $scope.panToStops = function (gmap, stops) {
	    if (stops.length == 0) {
	      return;
	    }
	    var bounds = new google.maps.LatLngBounds();
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	      for (var _iterator = stops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var s = _step.value;
	
	        bounds.extend(new google.maps.LatLng(s.coordinates.coordinates[1], s.coordinates.coordinates[0]));
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	
	    gmap.fitBounds(bounds);
	  };
	
	  // pans to single stop
	  $scope.panToStop = function (gmap, stop) {
	    if (!stop) return;
	    $scope.book.chosenStop = stop;
	    gmap.panTo({
	      lat: stop.coordinates.coordinates[1],
	      lng: stop.coordinates.coordinates[0]
	    });
	    gmap.setZoom(17);
	  };
	}];
	//

/***/ },
/* 515 */
/*!*************************************************!*\
  !*** ./beeline/controllers/SearchController.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($scope, $state, $stateParams, $http, SuggestionService, UserService, $ionicModal, $ionicPopup, MapOptions, uiGmapGoogleMapApi) {
	
	  /* Fix the map not resizing */
	  uiGmapGoogleMapApi.then(function (googleMaps) {
	    MapOptions.disableMapLinks();
	    $scope.$on("$ionicView.afterEnter", function (event, data) {
	      if ($scope.map && $scope.map.control && $scope.map.control.getGMap) {
	        MapOptions.resizePreserveCenter($scope.map.control.getGMap());
	      }
	    });
	  });
	
	  //
	  $scope.goBack = function () {
	    if (!$stateParams.backPage) {
	      $state.go('tabs.routes');
	    } else {
	      $state.go($stateParams.backPage);
	    }
	  };
	
	  $scope.map = MapOptions.defaultMapOptions();
	
	  $scope.disp = { active: null, latestRequest: null };
	
	  $scope.focus = function (which) {
	    return $scope.disp.active = which;
	  };
	  $scope.blur = function (which) {}; //$scope.disp.active = null;
	
	  $scope.map.events.dragend = function () {
	    var a = $scope.disp.active;
	    if (!a) return;
	    $scope.disp.showCrosshair = true;
	  };
	  $scope.useCenter = function () {
	    var a = $scope.disp.active;
	    var center = $scope.map.control.getGMap().getCenter();
	
	    $scope.data[a] = {
	      latitude: center.lat(),
	      longitude: center.lng()
	    };
	
	    $scope.data[a + 'Text'] = center.lat() + ', ' + center.lng();
	    $scope.disp.active = null;
	    $scope.disp.showCrosshair = false;
	
	    var promise = $scope.disp.latestRequest = UserService.beeline({
	      url: '/onemap/revgeocode?' + _querystring2.default.stringify({
	        location: center.lng() + ',' + center.lat()
	      })
	    }).then(function (result) {
	      // A new request has come in, so we don't bother with this
	      if (promise !== $scope.disp.latestRequest) return;
	
	      var r = result.data;
	
	      if (r.GeocodeInfo[0].ErrorMessage) {
	        throw new Error(r.GeocodeInfo[0].ErrorMessage);
	      } else {
	        $scope.data[a + 'Text'] = [r.GeocodeInfo[0].BUILDINGNAME, r.GeocodeInfo[0].ROAD].filter(function (x) {
	          return x;
	        }).join(', ');
	      }
	    }).catch(function (err) {
	      console.error(err);
	    }).finally(function () {
	      if (promise !== $scope.disp.latestRequest) return;
	      $scope.disp.latestRequest = null;
	    });
	  };
	
	  $scope.data = {
	    originText: '',
	    destinationText: '',
	
	    origin: null,
	    destination: null
	  };
	
	  $scope.updatePlace = function (which, place) {
	    var location = _lodash2.default.get(place, 'geometry.location');
	
	    if (!location) {
	      $scope.data[which] = null;
	    } else {
	      $scope.data[which] = {
	        latitude: location.lat(),
	        longitude: location.lng()
	      };
	    }
	  };
	
	  $scope.goSearch = function () {
	    var searchQuery = _lodash2.default.assign({}, $scope.data.origin ? {
	      originLat: $scope.data.origin.latitude,
	      originLng: $scope.data.origin.longitude
	    } : {
	      originLat: null,
	      originLng: null
	    }, $scope.data.destination ? {
	      destinationLat: $scope.data.destination.latitude,
	      destinationLng: $scope.data.destination.longitude
	    } : {
	      destinationLat: null,
	      destinationLng: null
	    });
	    $state.go('tabs.search-results', searchQuery);
	  };
	};
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 516 */
/*!********************************************************!*\
  !*** ./beeline/controllers/SearchResultsController.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = function ($scope, $state, $stateParams, $http, UserService, LiteRoutesService, p, $rootScope, BookingService, KickstarterService) {
	
	  $scope.runningRoutes = null;
	  $scope.crowdstartRoutes = null;
	  $scope.liteRoutes = null;
	
	  $scope.data = {
	    nextSessionId: null
	  };
	
	  $scope.$on('$ionicView.beforeEnter', function () {
	    $scope.data.nextSessionId = BookingService.newSession();
	  });
	
	  $scope.$watchCollection(function () {
	    return [$stateParams.originLat, $stateParams.originLng, $stateParams.destinationLat, $stateParams.destinationLng];
	  }, function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 4),
	        slat = _ref2[0],
	        slng = _ref2[1],
	        elat = _ref2[2],
	        elng = _ref2[3];
	
	    (0, _assert2.default)(slat && slng || elat && elng);
	
	    function search(options, reversed) {
	      var latLngOptions = reversed ? _lodash2.default.assign(elat && elng ? { startLat: elat, startLng: elng } : {}, slat && slng ? { endLat: slat, endLng: slng } : {}) : _lodash2.default.assign(slat && slng ? { startLat: slat, startLng: slng } : {}, elat && elng ? { endLat: elat, endLng: elng } : {});
	
	      return UserService.beeline({
	        url: '/routes/search_by_latlon?' + _querystring2.default.stringify(_lodash2.default.assign({ maxDistance: 2000, startTime: Date.now() }, latLngOptions, p.transportCompanyId ? { transportCompanyId: p.transportCompanyId } : {}, options))
	      });
	    }
	
	    var runningPromise = search({
	      tags: JSON.stringify(['public'])
	    }, false).then(function (result) {
	      $scope.runningRoutes = result.data;
	    });
	
	    var runningReversePromise = search({
	      tags: JSON.stringify(['public'])
	    }, true).then(function (result) {
	      $scope.runningReverseRoutes = result.data;
	    });
	
	    // Crowdstart routes need extra meta data
	    var allLelongRoutes = KickstarterService.fetchLelong();
	
	    var lelongPromise = search({
	      tags: JSON.stringify(['lelong'])
	    }, false);
	
	    var lelongReversePromise = search({
	      tags: JSON.stringify(['lelong'])
	    }, true);
	
	    Promise.all([allLelongRoutes, lelongPromise, lelongReversePromise]).then(function (_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 3),
	          ksRoutes = _ref4[0],
	          fwd = _ref4[1],
	          bwd = _ref4[2];
	
	      var routesByKey = _lodash2.default.keyBy(ksRoutes, 'id');
	
	      $scope.crowdstartRoutes = _lodash2.default.map(fwd.data, function (r) {
	        return routesByKey[r.id];
	      });
	      $scope.crowdstartReverseRoutes = _lodash2.default.map(bwd.data, function (r) {
	        return routesByKey[r.id];
	      });
	
	      $scope.$digest();
	    });
	
	    var litePromise = search({
	      tags: JSON.stringify(['lite'])
	    }, false).then(function (result) {
	      $scope.liteRoutes = LiteRoutesService.transformLiteRouteData(result.data);
	    });
	
	    //not needed in most cases as lite routes are looping services
	    // const liteReversePromise = UserService.beeline({
	    //   url: '/routes/search_by_latlon?' + querystring.stringify(_.assign({
	    //     maxDistance: 2000,
	    //     tags: JSON.stringify(['lite'])
	    //   }, p.transportCompanyId ? {transportCompanyId: p.transportCompanyId}: {},
	    //     (elat && elng) ? {startLat: elat, startLng: elng} : {},
	    //     (slat && slng)? {endLat: slat, endLng: slng} : {}))
	    // })
	    // .then((result) => {
	    //   $scope.liteReverseRoutes = LiteRoutesService.transformLiteRouteData(result.data);
	    // })
	
	  });
	
	  $scope.$watchGroup(['liteRoutes', 'crowdstartRoutes', 'runningRoutes'], function (routes) {
	    //liteRoutes is {'OCC':{}, 'JTC':{}}
	    $scope.routesFoundCount = _lodash2.default.sumBy(routes, function (r) {
	      return r ? r.length || _lodash2.default.keys(r).length : 0;
	    });
	  });
	
	  $scope.submitSuggestion = function () {
	    var href = "https://www.beeline.sg/suggest.html#" + _querystring2.default.stringify({
	      originLat: $stateParams.originLat,
	      originLng: $stateParams.originLng,
	      destinationLat: $stateParams.destinationLat,
	      destinationLng: $stateParams.destinationLng,
	      referrer: $rootScope.o.APP.NAME.replace(/\s/g, '')
	    });
	
	    if (typeof cordova !== 'undefined') {
	      cordova.InAppBrowser.open(href, '_system');
	    } else {
	      window.open(href, '_blank');
	    }
	  };
	};
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	;

/***/ },
/* 517 */
/*!********************************************!*\
  !*** ./beeline/directives/searchButton.js ***!
  \********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    restrict: 'E',
	    replace: true,
	    template: '\n    <div class="search-button item">\n      <i class="ion-map"></i>\n      <span>&nbsp;&nbsp;Search in Map</span>\n    </div>\n    '
	  };
	};

/***/ },
/* 518 */
/*!*****************************************************************!*\
  !*** ./beeline/directives/suggestionViewer/suggestionViewer.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _util = __webpack_require__(/*! ../../shared/util */ 519);
	
	var _suggestionViewer = __webpack_require__(/*! ./suggestionViewer.html */ 520);
	
	var _suggestionViewer2 = _interopRequireDefault(_suggestionViewer);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$state', '$ionicModal', '$http', 'uiGmapGoogleMapApi', 'uiGmapIsReady', function ($state, $ionicModal, $http, uiGmapGoogleMapApi, uiGmapIsReady) {
	  return {
	    restrict: 'E',
	    template: _suggestionViewer2.default,
	    scope: {
	      startLat: '=',
	      startLng: '=',
	      startDescriptionA: '=',
	      startDescriptionB: '=',
	      endLat: '=',
	      endLng: '=',
	      endDescriptionA: '=',
	      endDescriptionB: '='
	    },
	    link: function link(scope, elem, attrs) {
	      scope.map = (0, _util.defaultMapOptions)();
	
	      scope.showStart = scope.showEnd = true;
	
	      scope.$watchGroup(['showStart', 'showEnd'], function () {
	        scope.line = [{ latitude: scope.startLat, longitude: scope.startLng }, { latitude: scope.endLat, longitude: scope.endLng }];
	        scope.icons = (0, _util.dashedLineIcons)();
	      });
	
	      var gmapResolve;
	      var gmapReady = new Promise(function (resolve) {
	        return gmapResolve = resolve;
	      });
	      scope.mapReady = gmapResolve;
	
	      scope.fitMarkers = function () {
	        gmapReady.then(function () {
	          var llBounds = new google.maps.LatLngBounds();
	          llBounds.extend(new google.maps.LatLng({
	            lat: scope.startLat,
	            lng: scope.startLng
	          }));
	          llBounds.extend(new google.maps.LatLng({
	            lat: scope.endLat,
	            lng: scope.endLng
	          }));
	          scope.map.control.getGMap().fitBounds(llBounds);
	        });
	      };
	
	      uiGmapGoogleMapApi.then(function x() {
	        scope.map.boardMarkerOptions = {
	          icon: {
	            url: 'img/board.png',
	            scaledSize: new google.maps.Size(20, 20),
	            anchor: new google.maps.Point(5, 5)
	          }
	        };
	        scope.map.alightMarkerOptions = {
	          icon: {
	            url: 'img/alight.png',
	            scaledSize: new google.maps.Size(20, 20),
	            anchor: new google.maps.Point(5, 5)
	          }
	        };
	        scope.fitMarkers();
	      });
	
	      // FIXME
	      scope.$on('mapRequireResize', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return uiGmapGoogleMapApi;
	
	              case 2:
	                google.maps.event.trigger($scope.map.mapControl.getGMap(), 'resize');
	
	              case 3:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      })));
	    }
	  };
	}];

/***/ },
/* 519 */
/*!********************************!*\
  !*** ./beeline/shared/util.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setupBroadcastViewEnter = setupBroadcastViewEnter;
	exports.dashedLineIcons = dashedLineIcons;
	exports.defaultMapOptions = defaultMapOptions;
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* Update a scope so that the child scopes also
	receive the $ionicView.*Enter events */
	function setupBroadcastViewEnter($scope) {
	  $scope.$on('$ionicView.afterEnter', function (a, b) {
	    // var next = $scope.$$childHead;
	    // while (next) {
	    //     next.$broadcast('$ionicView.afterEnter', a, b);
	    //     next = next.$$nextSibling;
	    // }
	    $scope.$broadcast('mapRequireResize');
	  });
	}
	
	var lineSymbol = {
	  path: 'M 0,-1 0,1',
	  strokeOpacity: 1,
	  scale: 4
	};
	var lineIcons = {
	  path: [{ lat: 22.291, lng: 153.027 }, { lat: 18.291, lng: 153.027 }],
	  strokeOpacity: 0,
	  icons: [{
	    icon: lineSymbol,
	    offset: '0',
	    repeat: '20px'
	  }]
	};
	function dashedLineIcons() {
	  return lineIcons;
	}
	
	function defaultMapOptions(options) {
	  return _lodash2.default.assign({
	    center: { latitude: 1.370244, longitude: 103.823315 },
	    zoom: 11,
	    bounds: { // so that autocomplete will mainly search within Singapore
	      northeast: {
	        latitude: 1.485152,
	        longitude: 104.091837
	      },
	      southwest: {
	        latitude: 1.205764,
	        longitude: 103.589899
	      }
	    },
	    control: {},
	    options: {
	      disableDefaultUI: true,
	      styles: [{
	        featureType: "poi",
	        stylers: [{
	          visibility: "off"
	        }]
	      }],
	      draggable: true
	    },
	    markers: [],
	    lines: []
	  }, options || {});
	}

/***/ },
/* 520 */
/*!*******************************************************************!*\
  !*** ./beeline/directives/suggestionViewer/suggestionViewer.html ***!
  \*******************************************************************/
/***/ function(module, exports) {

	module.exports = "\n<ui-gmap-google-map\n  center=\"map.center\"\n  zoom=\"map.zoom\"\n  bounds=\"map.bounds\"\n  control=\"map.control\"\n  options=\"map.options\"\n  data-tap-disabled=\"true\"\n>\n  <!-- start marker and window -->\n  <ui-gmap-marker\n    idkey=\"0\"\n    coords=\"{\n      latitude: startLat,\n      longitude: startLng,\n    }\"\n    options=\"map.boardMarkerOptions\"\n    click=\"showStart = !showStart\"\n  ></ui-gmap-marker>\n  <ui-gmap-window\n    show=\"showStart\"\n    coords=\"{\n      latitude: startLat,\n      longitude: startLng,\n    }\"\n    >\n    <div>\n      <b>{{startDescriptionA}}</b>\n      <br/>\n      {{startDescriptionB}}\n    </div>\n  </ui-gmap-window>\n\n  <!-- line between -->\n  <ui-gmap-polyline\n    path=\"line\"\n    icons=\"lineIcons\">\n  </ui-gmap-polyline>\n\n  <!-- end marker and window -->\n  <ui-gmap-marker\n    idkey=\"1\"\n    coords=\"{\n      latitude: endLat,\n      longitude: endLng,\n    }\"\n    options=\"map.alightMarkerOptions\"\n    click=\"showEnd = !showEnd\"\n  ></ui-gmap-marker>\n  <ui-gmap-window\n    show=\"showEnd\"\n    coords=\"{\n      latitude: endLat,\n      longitude: endLng,\n    }\"\n    >\n    <div>\n      <b>{{endDescriptionA}}</b>\n      <br/>\n      {{endDescriptionB}}\n    </div>\n  </ui-gmap-window>\n</ui-gmap-google-map>\n";

/***/ },
/* 521 */
/*!*************************************************************!*\
  !*** ./beeline/directives/startEndPicker/startEndPicker.js ***!
  \*************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _util = __webpack_require__(/*! ../../shared/util */ 519);
	
	var _startEndPicker = __webpack_require__(/*! ./startEndPicker.html */ 522);
	
	var _startEndPicker2 = _interopRequireDefault(_startEndPicker);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	exports.default = ['$state', '$ionicModal', '$http', 'uiGmapGoogleMapApi', 'uiGmapIsReady', '$cordovaGeolocation', function ($state, $ionicModal, $http, uiGmapGoogleMapApi, uiGmapIsReady, $cordovaGeolocation) {
	
	  return {
	    restrict: 'E',
	    transclude: true,
	    template: _startEndPicker2.default,
	    scope: {
	      prompt: '@',
	      isValid: '=',
	      startPoint: '=',
	      endPoint: '=',
	      setPoint: '=',
	      control: '=',
	      disabled: '=',
	      mode: '=',
	      onsubmit: '@'
	    },
	    link: function link(scope, elem, attrs) {
	      scope.map = (0, _util.defaultMapOptions)({
	        events: { //empty functions - to be overwritten
	          dragstart: function dragstart(map, e, args) {},
	          zoom_changed: function zoom_changed(map, e, args) {},
	          dragend: function dragend(map, e, args) {},
	          click: function click(map, e, args) {}
	        },
	        boardMarkerOptions: {},
	        alightMarkerOptions: {},
	        lineIcons: {}
	      });
	
	      scope.prompt = scope.prompt || 'Next';
	      console.log(scope.setPoint);
	      scope.setPoint = scope.setPoint === undefined ? 'start' : scope.setPoint;
	      scope.startPoint = _.extend({
	        text: '',
	        coordinates: null
	      }, scope.startPoint || {});
	      scope.endPoint = _.extend({
	        text: '',
	        coordinates: null
	      }, scope.endPoint || {});
	      scope.lineBetween = [];
	
	      scope.$watchGroup(['startPoint.coordinates', 'endPoint.coordinates'], function () {
	        if (scope.startPoint.coordinates && scope.endPoint.coordinates) {
	          scope.lineBetween = [scope.startPoint.coordinates, scope.endPoint.coordinates];
	        } else {
	          scope.lineBetween = [];
	        }
	      });
	
	      var gmapResolve;
	      var gmapReady = new Promise(function (resolve) {
	        return gmapResolve = resolve;
	      });
	      scope.mapReady = gmapResolve;
	      gmapReady.then(function x() {
	        var gmap = scope.map.control.getGMap();
	        scope.map.boardMarkerOptions = {
	          icon: {
	            url: 'img/board.png',
	            scaledSize: new google.maps.Size(20, 20),
	            anchor: new google.maps.Point(5, 5)
	          }
	        };
	        scope.map.alightMarkerOptions = {
	          icon: {
	            url: 'img/alight.png',
	            scaledSize: new google.maps.Size(20, 20),
	            anchor: new google.maps.Point(5, 5)
	          }
	        };
	        scope.map.lineIcons = [{
	          icon: {
	            path: 1,
	            scale: 3,
	            strokeColor: '#333'
	          },
	          offset: '20%',
	          repeat: '50px'
	        }];
	
	        var inputElems = elem[0].querySelectorAll('INPUT');
	        var pickupautocomp = new google.maps.places.Autocomplete(inputElems[0]);
	        var dropoffautocomp = new google.maps.places.Autocomplete(inputElems[1]);
	
	        pickupautocomp.addListener('place_changed', function (event) {
	          var pickupPos = pickupautocomp.getPlace().geometry.location;
	
	          scope.startPoint.coordinates = {
	            lat: pickupPos.lat(),
	            lng: pickupPos.lng()
	          };
	          scope.startPoint.text = pickupautocomp.getPlace().formatted_address;
	
	          inputElems[0].blur();
	          setTimeout(function () {
	            gmap.setZoom(15);
	            gmap.panTo(pickupPos);
	            updateLocationText(gmap);
	          }, 100);
	        });
	
	        dropoffautocomp.addListener('place_changed', function () {
	          var dropoffPos = dropoffautocomp.getPlace().geometry.location;
	
	          scope.endPoint.coordinates = {
	            lat: dropoffPos.lat(),
	            lng: dropoffPos.lng()
	          };
	          scope.endPoint.text = dropoffautocomp.getPlace().formatted_address;
	
	          inputElems[1].blur();
	          setTimeout(function () {
	            gmap.setZoom(15);
	            gmap.panTo(dropoffPos);
	            updateLocationText(gmap);
	          }, 100);
	        });
	
	        scope.map.events = {
	          click: function click() {
	            if (scope.inFocusElement) {
	              scope.inFocusElement.blur();
	            }
	          },
	          dragstart: function dragstart(map, e, args) {},
	          zoom_changed: function zoom_changed(map, e, args) {
	            updateCenter(map);
	            updateLocationText(map, e, args);
	          },
	          dragend: function dragend(map, e, args) {
	            updateCenter(map);
	            updateLocationText(map, e, args);
	          }
	        };
	
	        //drop down list disappears before the clicked item is registered,
	        //this will disable the click event on the lists' containers
	        setTimeout(function () {
	          var contain = document.getElementsByClassName('pac-container');
	          angular.element(contain).attr('data-tap-disabled', 'true');
	        }, 500);
	      });
	
	      function fitToPoints() {
	        var gmap = scope.map.control.getGMap();
	        if (scope.startPoint.coordinates && scope.endPoint.coordinates) {
	
	          var bounds = new google.maps.LatLngBounds();
	
	          bounds.extend(new google.maps.LatLng({
	            lat: scope.startPoint.coordinates.latitude,
	            lng: scope.startPoint.coordinates.longitude
	          }));
	          bounds.extend(new google.maps.LatLng({
	            lat: scope.endPoint.coordinates.latitude,
	            lng: scope.endPoint.coordinates.longitude
	          }));
	
	          gmap.fitBounds(bounds);
	        } else {
	          gmap.setCenter({
	            lat: 1.38,
	            lng: 103.8
	          });
	          gmap.setZoom(11);
	        }
	      }
	      scope.$watch('control', function () {
	        if (scope.control) {
	          scope.control.fitToPoints = fitToPoints;
	        }
	      });
	      scope.nextBtnClick = function () {
	        if (scope.setPoint == 'start') {
	          if (scope.startPoint.coordinates) {
	            if (scope.endPoint.coordinates) {
	              /* End point has been previously set, don't reset it */
	              scope.setPoint = null;
	              fitToPoints();
	            } else {
	              scope.setPoint = 'end';
	            }
	          }
	        } else if (scope.setPoint == 'end') {
	          if (scope.endPoint.coordinates) {
	            scope.setPoint = null;
	            fitToPoints();
	          }
	        } else {
	          // FIXME: optimize this using a $parse
	          scope.$parent.$eval(scope.onsubmit);
	        }
	      };
	      scope.setSetPoint = function (what) {
	        if (scope.disabled) return;
	        scope.setPoint = what;
	
	        if (scope[what + 'Point'].coordinates) {
	          scope.map.control.getGMap().panTo({
	            lat: scope.startPoint.coordinates.latitude,
	            lng: scope.startPoint.coordinates.longitude
	          });
	        }
	      };
	      function updateCenter(map) {
	        if (scope.setPoint == 'start') {
	          scope.startPoint.coordinates = {
	            latitude: map.center.lat(),
	            longitude: map.center.lng()
	          };
	        } else if (scope.setPoint == 'end') {
	          scope.endPoint.coordinates = {
	            latitude: map.center.lat(),
	            longitude: map.center.lng()
	          };
	        }
	      }
	      function updateLocationText(map) {
	        if (!scope.setPoint) return;
	
	        var geocoder = new google.maps.Geocoder();
	        geocoder.geocode({ latLng: map.getCenter() }, function (r, s) {
	          if (!scope.setPoint) return;
	          var center = map.getCenter().toJSON();
	          var point = scope[scope.setPoint + 'Point'];
	          if (s == 'OK') {
	            point.text = r[0].formatted_address;
	          } else {
	            point.text = center.lat + ', ' + center.lng;
	          }
	          point.coordinates = {
	            latitude: center.lat,
	            longitude: center.lng
	          };
	        });
	      }
	      scope.inFocus = 0;
	      scope.inFocusElement = null;
	      scope.inputFocus = function ($event, which) {
	        scope.setPoint = which;
	        var point = scope[which + 'Point'];
	        if (point.coordinates) {
	          scope.map.control.getGMap().panTo({
	            lat: scope[which + 'Point'].coordinates.latitude,
	            lng: scope[which + 'Point'].coordinates.longitude
	          });
	        }
	        scope.inFocusElement = $event.target;
	        scope.inFocus++;
	      };
	      scope.inputBlur = function ($event, which) {
	        scope.inFocus--;
	      };
	      scope.reset = function (which) {
	        scope[which + 'Point'].text = '';
	        scope[which + 'Point'].coordinates = null;
	        elem[0].querySelector('.input-' + which).focus();
	      };
	      scope.nextAllowed = function () {
	        return scope.setPoint && scope[scope.setPoint + 'Point'].coordinates || !scope.setPoint && scope.isValid && scope.startPoint.coordinates && scope.endPoint.coordinates;
	      };
	
	      scope.$on('mapRequireResize', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                _context.next = 2;
	                return uiGmapGoogleMapApi;
	
	              case 2:
	                google.maps.event.trigger($scope.map.mapControl.getGMap(), 'resize');
	
	              case 3:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      })));
	
	      //Click function for User Position Icon
	      scope.getUserLocation = function () {
	        var options = {
	          timeout: 5000,
	          enableHighAccuracy: true
	        };
	
	        //promise
	        $cordovaGeolocation.getCurrentPosition({ timeout: 5000, enableHighAccuracy: true }).then(function (userpos) {
	          var gmap = scope.map.control.getGMap();
	          gmap.panTo(new google.maps.LatLng(userpos.coords.latitude, userpos.coords.longitude));
	          setTimeout(function () {
	            gmap.setZoom(15);
	          }, 300);
	        }, function (err) {
	          console.log('ERROR - ' + err);
	        });
	      };
	    }
	  };
	}];

/***/ },
/* 522 */
/*!***************************************************************!*\
  !*** ./beeline/directives/startEndPicker/startEndPicker.html ***!
  \***************************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"locinputs\">\n  <label class=\"item item-input pickup\"\n    ng-show=\"true || !setPoint || setPoint == 'start'\"\n    >\n    <input class=\"input-start\"\n            type=\"search\"\n            placeholder=\"Enter your pick-up location\"\n            ng-model=\"startPoint.text\"\n            ng-focus=\"inputFocus($event, 'start')\"\n            ng-blur=\"inputBlur($event, 'start')\"\n            ng-disabled=\"disabled\"\n             />\n    <a class=\"item item-icon-right\"\n        ng-click=\"reset('start')\">\n        <i class=\"icon ng-hide ion-ios-close-outline\"\n          ng-hide=\"startPoint.text == ''\"></i>\n    </a>\n  </label>\n\n  <label class=\"item item-input dropoff\"\n        ng-show=\"!setPoint || setPoint == 'end'\">\n    <input class=\"input-end\"\n          type=\"search\"\n          placeholder=\"Enter your drop-off location\"\n          ng-model=\"endPoint.text\"\n          ng-focus=\"inputFocus($event, 'end')\"\n          ng-blur=\"inputBlur($event, 'end')\"\n          ng-disabled=\"disabled\"\n          />\n    <a class=\"item item-icon-right\"\n        ng-click=\"reset('end')\">\n        <i class=\"icon ng-hide ion-ios-close-outline\"\n          ng-hide=\"endPoint.text == ''\"></i>\n    </a>\n  </label>\n  <div ng-show=\"!setPoint\">\n    <ng-transclude></ng-transclude>\n  </div>\n</div>\n\n<div ng-show=\"inFocus == 0\">\n  <div class=\"centmark\" ng-hide=\"setPoint == null\"></div>\n  <div class=\"locateme\" ng-click=\"getUserLocation()\"></div>\n  <button\n    ng-show=\"!disabled\"\n    class=\"btnnext\"\n    ng-click=\"nextBtnClick()\"\n    ng-disabled=\"!nextAllowed()\">\n    {{ setPoint == 'start' ? 'Set pick-up point' :\n       setPoint == 'end' ? 'Set drop-off point' : prompt}}\n  </button>\n</div>\n<ui-gmap-google-map center=\"map.center\"\n                    zoom=\"map.zoom\"\n                    options=\"map.options\"\n                    bounds=\"map.bounds\"\n                    control=\"map.control\"\n                    events=\"map.events\"\n                    ready=\"mapReady()\"\n                    data-tap-disabled=\"true\">\n  <ui-gmap-marker\n  idkey=\"0\"\n  coords=\"startPoint.coordinates\"\n  options=\"map.boardMarkerOptions\"\n  click=\"setSetPoint('start')\"\n  ></ui-gmap-marker>\n\n  <!-- line between -->\n  <ui-gmap-polyline\n    path=\"lineBetween\"\n    icons=\"map.lineIcons\">\n  </ui-gmap-polyline>\n\n  <ui-gmap-marker\n    idkey=\"1\"\n    coords=\"endPoint.coordinates\"\n    options=\"map.alightMarkerOptions\"\n    click=\"setSetPoint('end')\"\n  ></ui-gmap-marker>\n</ui-gmap-google-map>\n";

/***/ },
/* 523 */
/*!***************************************************************!*\
  !*** ./beeline/directives/busStopSelector/busStopSelector.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _busStopSelector = __webpack_require__(/*! ./busStopSelector.html */ 524);
	
	var _busStopSelector2 = _interopRequireDefault(_busStopSelector);
	
	var _format = __webpack_require__(/*! ../../shared/format */ 299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = ['$state', '$ionicModal', '$http', 'uiGmapGoogleMapApi', 'MapOptions', 'busStopSelectorDialog', function ($state, $ionicModal, $http, uiGmapGoogleMapApi, MapOptions, busStopSelectorDialog) {
	
	  return {
	    restrict: 'E',
	    replace: true,
	    template: _busStopSelector2.default,
	    scope: {
	      busStops: '=',
	      ngModel: "=",
	      change: '=',
	      placeholder: '@',
	      title: '@',
	      button: '@',
	      markerOptions: '=',
	      pinOptions: '=',
	      ngRequired: '=',
	      name: '='
	    },
	    link: function link(scope, elem, attrs) {
	      scope.showList = function () {
	        busStopSelectorDialog.show(_.assign({ selectedStop: scope.ngModel }, _.pick(scope, ['busStops', 'markerOptions', 'title', 'button', 'pinOptions']))).then(function (selectedStop) {
	          scope.ngModel = selectedStop;
	        });
	      };
	
	      scope.formatTime = _format.formatTime;
	    }
	  };
	}];

/***/ },
/* 524 */
/*!*****************************************************************!*\
  !*** ./beeline/directives/busStopSelector/busStopSelector.html ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"item item-text-wrap item-icon-left item-icon-right bus-stop-selector\"\n     ng-click=\"showList()\">\n  <select ng-options=\"stop.id as (formatTime(stop.time) + ' - ' + stop.description + ' ' + stop.road) for stop in busStops\"\n          ng-model=\"ngModel\"\n          ng-required=\"ngRequired\"\n          name=\"name\"\n          hidden\n          aria-hidden=\"true\">\n  </select>\n  <span class=\"icon stop-icon\"></span>\n  <span ng-if=\"!ngModel\" class=\"placeholder\">\n    {{placeholder}}\n  </span>\n  <span ng-if=\"ngModel\">\n    {{ngModel.time | formatTime}}&nbsp;&nbsp;{{ngModel.description}}\n  </span>\n  <i class=\"icon ion-ios-arrow-down\"></i>\n</div>\n";

/***/ },
/* 525 */
/*!***************************************************************!*\
  !*** ./beeline/directives/priceCalculator/priceCalculator.js ***!
  \***************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _priceCalculator = __webpack_require__(/*! ./priceCalculator.html */ 526);
	
	var _priceCalculator2 = _interopRequireDefault(_priceCalculator);
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var queryString = __webpack_require__(/*! querystring */ 425);
	
	exports.default = ['BookingService', 'RoutesService', 'UserService', '$ionicPopup', 'CreditsService', function (BookingService, RoutesService, UserService, $ionicPopup, CreditsService) {
	  return {
	    restrict: 'E',
	    template: _priceCalculator2.default,
	    scope: {
	      'booking': '=',
	      'price': '=?',
	      'showPromoField': '<'
	    },
	    controller: function controller($scope) {
	      $scope.isCalculating = 0;
	
	      function stopCalculating() {
	        $scope.isCalculating = Math.max(0, $scope.isCalculating - 1);
	        $scope.$emit('priceCalculator.done');
	      }
	
	      $scope.updatePromoCode = function (promoCode) {
	        $scope.booking.promoCode = promoCode;
	      };
	
	      $scope.$watch(function () {
	        return UserService.getUser();
	      }, function (user) {
	        $scope.isLoggedIn = !!user;
	        CreditsService.fetchUserCredits().then(function (userCredits) {
	          $scope.userCredits = userCredits;
	        });
	
	        CreditsService.fetchReferralCredits().then(function (referralCredits) {
	          $scope.referralCredits = referralCredits;
	        });
	      });
	
	      var latestRequest = null;
	      $scope.$watch(function () {
	        return _.pick($scope.booking, ['selectedDates', 'applyRouteCredits', 'applyCredits', 'applyReferralCredits', 'promoCode' /* , qty */]);
	      }, _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        var routeToRidesRemainingMap, promise;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                (0, _assert2.default)($scope.booking.routeId);
	
	                if ($scope.booking.route) {
	                  _context.next = 9;
	                  break;
	                }
	
	                _context.next = 4;
	                return RoutesService.getRoute($scope.booking.routeId);
	
	              case 4:
	                $scope.booking.route = _context.sent;
	                _context.next = 7;
	                return RoutesService.fetchRoutePassCount();
	
	              case 7:
	                routeToRidesRemainingMap = _context.sent;
	
	                $scope.booking.route.ridesRemaining = routeToRidesRemainingMap[$scope.booking.routeId];
	
	              case 9:
	
	                // Provide a price summary first (don't count total due)
	                // This allows the page to resize earlier, so that when
	                // users scroll down the bounce works ok.
	                $scope.priceInfo = $scope.priceInfo || {};
	                $scope.priceInfo.pricesPerTrip = BookingService.summarizePrices($scope.booking);
	
	                $scope.isCalculating++;
	                promise = BookingService.computePriceInfo($scope.booking).then(function (priceInfo) {
	                  // Check to ensure that the order of
	                  // replies don't affect the result
	                  if (promise != latestRequest) return;
	                  $scope.priceInfo = priceInfo;
	                  $scope.price = priceInfo.totalDue;
	                  $scope.ridesUsed = $scope.booking.applyRouteCredits ? Math.min($scope.booking.route.ridesRemaining, priceInfo.tripCount) : 0;
	                  $scope.errorMessage = null;
	                }).catch(function (error) {
	                  $scope.priceInfo = {};
	                  $scope.price = undefined;
	                  $scope.errorMessage = error.data.message;
	                }).then(stopCalculating);
	
	
	                latestRequest = promise;
	
	              case 14:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      })), true);
	
	      $scope.removePromoCode = function () {
	        $scope.booking.promoCode = null;
	      };
	    }
	  };
	}];

/***/ },
/* 526 */
/*!*****************************************************************!*\
  !*** ./beeline/directives/priceCalculator/priceCalculator.html ***!
  \*****************************************************************/
/***/ function(module, exports) {

	module.exports = "<div id=\"price-calculator\">\n  <div><b>{{booking.selectedDates.length}} day(s)</b> were selected.</div>\n  <div class=\"item-subtitle\">Selected Dates </div>\n  <div ng-show=\"isCalculating\" class=\"spinner-block\">\n    <ion-spinner></ion-spinner>\n    Calculating prices...\n  </div>\n  <table class=\"booking-info prices\">\n    <thead>\n      <tr ng-if=\"booking.selectedDates.length != 0\">\n        <th>Selected Dates</th>\n        <th>\n          Price per trip\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr ng-if=\"booking.selectedDates.length == 0\">\n        <td colspan=\"2\">Please select your trip dates</td>\n      </tr>\n      <tr ng-if=\"errorMessage\">\n        <td colspan=\"2\" class=\"text-left\">\n          <i class=\"icon ion-alert-circled padding-right\"></i> {{errorMessage}}\n        </td>\n      </tr>\n      <tr ng-if=\"booking.selectedDates.length > 0\" ng-repeat=\"pinfo in priceInfo.pricesPerTrip\">\n        <td>\n          {{pinfo.startDate | date:'dd MMM (EEE)' : 'Z'}}\n          <div ng-if=\"pinfo.bookingInfo.notes\" class=\"trd ip-notes\">\n            <i class=\"ionicon ion-information-circled\"></i> {{pinfo.bookingInfo.notes}}\n          </div>\n        </td>\n        <td>${{pinfo.price | number:2}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <table class=\"booking-info prices\" ng-if=\"booking.selectedDates.length > 0\">\n    <tbody>\n      <tr>\n        <th>Total Trips</th>\n        <th>Total Amount</th>\n      </tr>\n      <tr>\n        <td>{{priceInfo.tripCount || 0}}</td>\n        <td>{{(priceInfo.totalBeforeDiscount || 0) | currency}}</td>\n      </tr>\n    </tbody>\n  </table>\n\n  <!-- hide from calculator -->\n  <!-- <div class=\"promoCredits\" ng-if=\"showPromoField && isLoggedIn\">\n    <ul class=\"list\">\n      <li class=\"item item-input-inset\">\n        <label class=\"item-input-wrapper\">\n          <input type=\"text\" placeholder=\"Enter Promo Code\" ng-model=\"currentPromoCode\" ng-blur=\"updatePromoCode(currentPromoCode)\">\n        </label>\n        <button class=\"button button-royal small-button\" ng-click=\"updatePromoCode(currentPromoCode)\">\n          Apply\n        </button>\n      </li>\n    </ul>\n  </div> -->\n  <div class=\"item-subtitle\">Amount to Pay </div>\n  <table class=\"booking-info calculator\" ng-if=\"booking.selectedDates.length > 0\">\n    <tbody>\n      <tr>\n        <td>Total Amount</td>\n        <td class=\"right\">{{(priceInfo.totalBeforeDiscount || 0) | currency}}</td>\n      </tr>\n      <tr ng-if=\"priceInfo.routeCredits && priceInfo.routeCredits.length > 0\" ng-repeat=\"routeCredit in priceInfo.routeCredits\">\n        <td>Route pass - Using {{ ridesUsed }} of {{ booking.route.ridesRemaining}} trips remaining</td>\n        <td class=\"right\">{{(-routeCredit.debit || 0) | currency}}</td>\n      </tr>\n      <tr ng-if=\"priceInfo.discounts && priceInfo.discounts.length > 0\" ng-repeat=\"discount in priceInfo.discounts\">\n        <td>\n          {{discount.discount.description}}: {{discount.discount.code}}  <i class=\"icon ion-close-circled\" ng-click=\"removePromoCode()\"></i>\n        </td>\n        <td class=\"right\">\n          {{(-discount.debit || 0) | currency}}\n        </td>\n      </tr>\n      <tr ng-if=\"priceInfo.referralCredits && priceInfo.referralCredits.length > 0\" ng-repeat=\"referralCredit in priceInfo.referralCredits\">\n        <td>Welcome Credits (use for up to 50% of the remaining transaction)<br />Using {{ referralCredit.debit || 0 | currency }} of {{ referralCredits || 0 | currency }}</td>\n        <td class=\"right\">{{(-referralCredit.debit || 0) | currency}}</td>\n      </tr>\n      <tr ng-if=\"priceInfo.credits && priceInfo.credits.length > 0\" ng-repeat=\"credits in priceInfo.credits\">\n        <td>Credits - Using {{ credits.debit || 0 | currency }} of {{ userCredits || 0 | currency }} </td>\n        <td class=\"right\">{{(-credits.debit || 0) | currency}}</td>\n      </tr>\n      <tr>\n        <td class=\"total-sum\" ><b>Total Amount Due</b></td>\n        <td class=\"total-sum right\"><b>{{ (priceInfo.totalDue || 0) | currency}}</b></td>\n      </tr>\n      <!-- FIXME: include vouchers, discounts here -->\n    </tbody>\n  </table>\n</div>\n";

/***/ },
/* 527 */
/*!*****************************************************!*\
  !*** ./beeline/directives/revGeocode/revGeocode.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);
	
	var _format = __webpack_require__(/*! ../../shared/format */ 299);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; } // <rev-geocode x="longitude" y="latitude"></rev-geocode>
	
	// {{block_number}} {{road}}<br/>
	// {{postcode}}
	
	
	exports.default = ['$http', 'OneMapService', 'UserService', function ($http, OneMapService, UserService) {
	    return {
	        restrict: 'E',
	        transclude: true,
	        scope: {
	            x: '=',
	            y: '=',
	            geocodeW: '=',
	            geocodePromiseW: '=',
	            description1: '=',
	            description2: '='
	        },
	        template: '\n<div ng-if="geocodeW && geocodeW.GeocodeInfo[0].ROAD != null">\n    {{geocodeW.GeocodeInfo[0].BLOCK | titleCase}}\n    {{geocodeW.GeocodeInfo[0].ROAD | titleCase}}\n    {{geocodeW.GeocodeInfo[0].BUILDINGNAME | titleCase}}\n    {{geocodeW.GeocodeInfo[0].POSTALCODE | titleCase}}\n</div>\n<div ng-if="!(geocodeW && geocodeW.GeocodeInfo[0].ROAD != null)">\n    {{y | number:4}}, {{x | number:4}}\n</div>\n        ',
	        link: function () {
	            var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(scope, elem) {
	                var oneMapToken, updateDescription, geocode;
	                return regeneratorRuntime.wrap(function _callee$(_context) {
	                    while (1) {
	                        switch (_context.prev = _context.next) {
	                            case 0:
	                                geocode = function geocode() {
	                                    scope.geocodePromiseW = UserService.beeline({
	                                        method: 'GET',
	                                        url: '/onemap/revgeocode?location=' + scope.x + ',' + scope.y
	                                    }).then(function (response) {
	                                        // console.log(response);
	                                        scope.geocodeW = response.data;
	                                        updateDescription();
	                                    });
	                                };
	
	                                updateDescription = function updateDescription() {
	                                    if (scope.geocodeW && scope.geocodeW.GeocodeInfo && scope.geocodeW.GeocodeInfo[0].ROAD) {
	                                        scope.description1 = (0, _format.titleCase)(scope.geocodeW.GeocodeInfo[0].BLOCK) + ' ' + (0, _format.titleCase)(scope.geocodeW.GeocodeInfo[0].ROAD);
	                                        scope.description2 = (0, _format.titleCase)(scope.geocodeW.GeocodeInfo[0].BUILDINGNAME);
	                                    } else {
	                                        scope.description1 = parseFloat(scope.y).toFixed(4) + ', ' + parseFloat(scope.x).toFixed(4);
	                                        scope.description2 = null;
	                                    }
	                                };
	
	                                scope.geocodeW = {}; //`${scope.y}, ${scope.x}`
	                                _context.next = 5;
	                                return OneMapService.token();
	
	                            case 5:
	                                oneMapToken = _context.sent;
	
	                                scope.$watchGroup(['x', 'y'], geocode);
	                                // Hack to reverse the erasure of the description when suggestion page is reloaded
	                                scope.$watchGroup(['description1', 'description2'], function () {
	                                    if (scope.description1 == undefined || scope.description2 == undefined) {
	                                        updateDescription();
	                                    }
	                                });
	
	                            case 8:
	                            case 'end':
	                                return _context.stop();
	                        }
	                    }
	                }, _callee, this);
	            }));
	
	            function link(_x, _x2) {
	                return _ref.apply(this, arguments);
	            }
	
	            return link;
	        }() };
	}];

/***/ },
/* 528 */
/*!*****************************************************!*\
  !*** ./beeline/directives/fancyPrice/fancyPrice.js ***!
  \*****************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
	
	exports.default = function () {
	
	  function linkFn(scope, elem, attrs) {
	    scope.currency = scope.currency || '$';
	    scope.integer = 0;
	    scope.fraction = 0;
	
	    scope.$watch('value', function () {
	      var floatValue = parseFloat(scope.value);
	      if (!isFinite(floatValue)) {
	        var _ref = ['', ''];
	        scope.integer = _ref[0];
	        scope.fraction = _ref[1];
	      } else {
	        var _parseFloat$toFixed$s = parseFloat(scope.value).toFixed(2).split('.');
	
	        var _parseFloat$toFixed$s2 = _slicedToArray(_parseFloat$toFixed$s, 2);
	
	        scope.integer = _parseFloat$toFixed$s2[0];
	        scope.fraction = _parseFloat$toFixed$s2[1];
	      }
	    });
	  }
	
	  return {
	    link: linkFn,
	    restrict: 'E',
	    transclude: true,
	    scope: {
	      value: '=value',
	      currency: '=?'
	    },
	    template: '\n<span class="currency">{{currency}}</span>\n<span class="integer">{{integer}}</span>\n<span class="fraction">.{{fraction}}</span>\n    '
	  };
	};

/***/ },
/* 529 */
/*!*********************************************************************!*\
  !*** ./beeline/directives/bookingBreadcrumbs/bookingBreadcrumbs.js ***!
  \*********************************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = breadcrumbs;
	function breadcrumbs($rootScope) {
	  return {
	    template: '<div class="item"><img ng-src="{{breadcrumbs_dir}}{{imgNames[step]}}"></div>',
	    scope: {
	      step: '@'
	    },
	    link: function link(scope, elem, attr) {
	      scope.breadcrumbs_dir = 'img/' + $rootScope.o.APP.PREFIX + 'booking-breadcrumbs/';
	      scope.imgNames = ['ProgressBar01_ChooseStops.svg', 'ProgressBar02_ChooseDates.svg', 'ProgressBar03_ReviewBooking.svg', 'ProgressBar04_MakePayment.svg'];
	    }
	  };
	}

/***/ },
/* 530 */
/*!***************************************************!*\
  !*** ./beeline/directives/routeItem/routeItem.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($state, BookingService) {
	  return {
	    replace: false,
	    template: _routeItem2.default,
	    scope: {
	      hideBusLabel: '<?',
	      hideAdditionalInfo: '<?',
	      hideTiming: '<?',
	      hideDescription: '<?'
	    },
	    transclude: {
	      additionalInfo: '?routeItemAdditionalInfo',
	      busNumber: '?routeItemBusNumber',
	      startTime: '?routeItemStartTime',
	      startLocation: '?routeItemStartLocation',
	      endTime: '?routeItemEndTime',
	      endLocation: '?routeItemEndLocation',
	      description: '?routeItemDescription'
	    },
	    link: function link(scope, element, attributes) {}
	  };
	};
	
	var _routeItem = __webpack_require__(/*! ./routeItem.html */ 531);
	
	var _routeItem2 = _interopRequireDefault(_routeItem);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 531 */
/*!*****************************************************!*\
  !*** ./beeline/directives/routeItem/routeItem.html ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"route-overview\">\n  <span class=\"bus-number\" ng-if=\"!hideBusLabel\" ng-transclude=\"busNumber\">\n  </span>\n  <span class=\"mini-info\" ng-if=\"!hideDescription\" ng-transclude=\"description\">\n  </span>\n</div>\n<div class=\"stops\">\n  <div class=\"start\">\n    <span class=\"time\" ng-if=\"!hideTiming\" ng-transclude=\"startTime\"></span>\n    <span class=\"stop-icon\">\n      <span class=\"line\"></span>\n    </span>\n    <span class=\"road\" ng-transclude=\"startLocation\"></span>\n  </div>\n  <div class=\"end\">\n    <span class=\"time\" ng-if=\"!hideTiming\" ng-transclude=\"endTime\"></span>\n    <span class=\"stop-icon\"></span>\n    <span class=\"road\" ng-transclude=\"endLocation\"></span>\n  </div>\n</div>\n<div class=\"additional-info\"\n    ng-if=\"!hideAdditionalInfo\"\n    ng-transclude=\"additionalInfo\">\n</div>\n";

/***/ },
/* 532 */
/*!*****************************************************!*\
  !*** ./beeline/directives/companyTnc/companyTnc.js ***!
  \*****************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = companyTnc;
	
	var _commonmark = __webpack_require__(/*! commonmark */ 439);
	
	var _commonmark2 = _interopRequireDefault(_commonmark);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var reader = new _commonmark2.default.Parser({ safe: true });
	var writer = new _commonmark2.default.HtmlRenderer({ safe: true });
	
	function companyTnc(CompanyService, $q) {
	  return {
	    template: __webpack_require__(/*! ./companyTnc.html */ 533),
	    replace: false,
	    scope: {
	      companyId: '=',
	      features: '=',
	      signageText: '<?'
	    },
	    link: function link(scope, elem, attr) {
	      scope.company = {};
	
	      scope.$watch('companyId', function () {
	        if (!scope.companyId) {
	          scope.company = null;
	          return;
	        }
	
	        var companyPromise = CompanyService.getCompany(scope.companyId).then(function (company) {
	          scope.company = company;
	          scope.$emit('companyTnc.done');
	          return company;
	        });
	      });
	
	      scope.showTerms = function () {
	        if (!scope.company) return;
	
	        CompanyService.showTerms(scope.company.id);
	      };
	    }
	  };
	}

/***/ },
/* 533 */
/*!*******************************************************!*\
  !*** ./beeline/directives/companyTnc/companyTnc.html ***!
  \*******************************************************/
/***/ function(module, exports) {

	module.exports = "<h4 class=\"item item-divider\">Operated By:</h4>\n\n<div class=\"item\">\n  <div class=\"row\">\n    <div class=\"col-20 bus-logo\">\n      <img ng-src=\"{{company.id | companyLogo}}\">\n    </div>\n    <div class=\"col-80 col-center bus-co-info\">\n      <p class=\"name\">{{company.name}}</p>\n      <p class=\"email\">{{company.email}}</p>\n    </div>\n  </div>\n</div>\n\n<h4 class=\"item item-divider\">Important Notes</h4>\n<div class=\"item item-text-wrap features\" beeline-bind-html=\"features\"></div>\n\n<div class=\"item item-text-wrap\">\n  <div>\n    Signage example:\n  </div>\n  <dynamic-signage signage-text=\"signageText\">\n  </dynamic-signage>\n  <div>\n    Please look out for the signage at the front of the bus.\n  </div>\n</div>\n\n<div class=\"item item-icon-right\" ng-click=\"showTerms()\">\n  Terms and Conditions of Service\n  <i class=\"icon ion-ios-arrow-right\"></i>\n</div>\n";

/***/ },
/* 534 */
/*!*************************************************!*\
  !*** ./beeline/directives/tripCode/tripCode.js ***!
  \*************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    template: '\n<span class="ch c0">{{codeStr[0]}}</span><span\n      class="ch c1">{{codeStr[1]}}</span><span\n      class="ch c2">{{codeStr[2]}}</span><span\n      class="ch c3">{{codeStr[3]}}</span>',
	    scope: {
	      code: '='
	    },
	    link: function link(scope, elem, attr) {
	      scope.$watch('code', function (code) {
	        if (code) {
	          scope.codeStr = code.toString();
	        } else {
	          scope.codeStr = '';
	        }
	      });
	
	      var exit = false;
	      function delay(ms) {
	        return new Promise(function (resolve) {
	          return setTimeout(resolve, ms);
	        });
	      }
	      scope.$on('$destroy', function () {
	        return exit = true;
	      });
	
	      _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	        var i, charElem;
	        return regeneratorRuntime.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                if (exit) {
	                  _context.next = 12;
	                  break;
	                }
	
	                i = 0;
	
	              case 2:
	                if (!(i < 4 && !exit)) {
	                  _context.next = 10;
	                  break;
	                }
	
	                charElem = elem[0].querySelector('.c' + i);
	
	
	                if (charElem.classList.contains('shrink')) {
	                  charElem.classList.remove('shrink');
	                } else {
	                  charElem.classList.add('shrink');
	                }
	
	                _context.next = 7;
	                return delay(250);
	
	              case 7:
	                i++;
	                _context.next = 2;
	                break;
	
	              case 10:
	                _context.next = 0;
	                break;
	
	              case 12:
	              case 'end':
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }))().then(null, console.error);
	    }
	  };
	};
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

/***/ },
/* 535 */
/*!******************************************!*\
  !*** ./beeline/directives/myLocation.js ***!
  \******************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (uiGmapGoogleMapApi) {
	
	  return {
	    template: '\n<ui-gmap-circle ng-if="coords" idkey="idkey1" center="coords" radius="radius"\n  stroke="accuracyOptions.stroke" fill="accuracyOptions.fill"\n  options="accuracyOptions.options"></ui-gmap-circle>\n<ui-gmap-marker ng-if="coords" idkey="idkey2" coords="coords" options="markerOptions"></ui-gmap-marker>\n    ',
	
	    scope: true,
	    link: function link(scope, elem, attr) {
	      scope.coords = null; // Null until location is available
	      scope.markerOptions = {
	        zIndex: 2
	      };
	      scope.accuracyOptions = {
	        stroke: {
	          color: '#3E82F7',
	          opacity: 0.4,
	          weight: 1
	        },
	        fill: {
	          color: '#3E82F7',
	          opacity: 0.2
	        },
	        options: {}
	      };
	      scope.radius = 1;
	      scope.idkey1 = 'my-location-' + Date.now() + '-circle';
	      scope.idkey2 = 'my-location-' + Date.now() + '-marker';
	
	      uiGmapGoogleMapApi.then(function (googleMaps) {
	        scope.markerOptions.icon = {
	          url: 'img/userLocation.svg',
	          anchor: new googleMaps.Point(6, 6)
	        };
	
	        var watch = navigator.geolocation.watchPosition(function (success) {
	          scope.coords = {
	            latitude: success.coords.latitude,
	            longitude: success.coords.longitude
	          };
	          scope.radius = success.coords.accuracy;
	          scope.$digest();
	        }, function (error) {
	          scope.coords = null;
	          scope.$digest();
	        }, {
	          enableHighAccuracy: false
	        });
	
	        scope.$on('destroy', function () {
	          navigator.geolocation.clearWatch(watch);
	        });
	      });
	    }
	  };
	};

/***/ },
/* 536 */
/*!*************************************************!*\
  !*** ./beeline/directives/companyInfoBroker.js ***!
  \*************************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (CompanyService) {
	  return {
	    replace: true,
	    template: '',
	    scope: {
	      'companyId': '<',
	      'company': '='
	    },
	    link: function link(scope, element, attributes) {
	      scope.$watch('companyId', function (companyId) {
	        if (!companyId) {
	          scope.company = {};
	          return;
	        }
	
	        var companyPromise = CompanyService.getCompany(+companyId).then(function (company) {
	          scope.company = company;
	        });
	      });
	    }
	  };
	};

/***/ },
/* 537 */
/*!*************************************************!*\
  !*** ./beeline/directives/moreInfo/moreInfo.js ***!
  \*************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    template: __webpack_require__(/*! ./moreInfo.html */ 538),
	    replace: false,
	    scope: {
	      companyId: '<',
	      features: '<',
	      signageText: '<'
	    },
	    link: function link(scope, elem, attr) {}
	  };
	};

/***/ },
/* 538 */
/*!***************************************************!*\
  !*** ./beeline/directives/moreInfo/moreInfo.html ***!
  \***************************************************/
/***/ function(module, exports) {

	module.exports = "<h4 class=\"item item-divider\">Operated By:</h4>\n\n<company-info-broker company-id=\"companyId\"\n                      company=\"companyInfo\">\n</company-info-broker>\n\n<div class=\"item item-text-wrap\">\n  <div class=\"row\">\n    <div class=\"col-20 bus-logo\">\n      <img ng-src=\"{{companyInfo.id | companyLogo}}\">\n    </div>\n    <div class=\"col-80 col-center bus-co-info\">\n      <p class=\"name\">{{companyInfo.name}}</p>\n      <p class=\"email\">{{companyInfo.email}}</p>\n    </div>\n  </div>\n</div>\n\n<h4 class=\"item item-divider\">Important Notes</h4>\n<div class=\"item item-text-wrap features\" beeline-bind-html=\"features\"></div>\n\n<div class=\"item item-text-wrap\">\n  <div>\n    Signage example:\n  </div>\n  <dynamic-signage signage-text=\"signageText\">\n  </dynamic-signage>\n  <div>\n    Please look out for the signage at the front of the bus.\n  </div>\n</div>\n";

/***/ },
/* 539 */
/*!************************************************!*\
  !*** ./beeline/directives/markdownRenderer.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    replace: true,
	    template: '<div ng-bind-html="markdownHTML"></div>',
	    scope: {
	      data: '<'
	    },
	    link: function link(scope, element, attributes) {
	      scope.$watch('data', function (data) {
	        scope.markdownHTML = data && writer.render(reader.parse(data));
	      });
	    }
	  };
	};
	
	var _commonmark = __webpack_require__(/*! commonmark */ 439);
	
	var _commonmark2 = _interopRequireDefault(_commonmark);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var reader = new _commonmark2.default.Parser({ safe: true });
	var writer = new _commonmark2.default.HtmlRenderer({ safe: true });

/***/ },
/* 540 */
/*!********************************************!*\
  !*** ./beeline/directives/mapPolyRoute.js ***!
  \********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    replace: false,
	    template: '\n    <ui-gmap-polyline path="routePath" stroke="strokeOptions"></ui-gmap-polyline>\n    ',
	    scope: {
	      'routePath': '<'
	    },
	    link: function link(scope, element, attributes) {
	      scope.strokeOptions = {
	        color: '#4b3863',
	        weight: 3.0,
	        opacity: 0.7
	      };
	    }
	  };
	};

/***/ },
/* 541 */
/*!***********************************************!*\
  !*** ./beeline/directives/mapBusPolyRoute.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (TripService, uiGmapGoogleMapApi, $timeout) {
	  return {
	    replace: false,
	    restrict: 'E',
	    template: '\n    <ui-gmap-marker ng-repeat="busLocation in map.busLocations"\n                    ng-if="busLocation.coordinates"\n                    idkey="\'bus-location{{index}}\'"\n                    coords="busLocation.coordinates"\n                    icon="busLocation.icon"></ui-gmap-marker>\n    ',
	    scope: {
	      availableTrips: '<',
	      hasTrackingData: '=?',
	      routeMessage: '=?'
	    },
	    link: function link(scope, element, attributes) {
	      var pingLoop = function () {
	        var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
	          return regeneratorRuntime.wrap(function _callee$(_context) {
	            while (1) {
	              switch (_context.prev = _context.next) {
	                case 0:
	                  _context.next = 2;
	                  return availableTripsPromise;
	
	                case 2:
	                  _context.next = 4;
	                  return Promise.all(scope.availableTrips.map(function (trip, index) {
	                    return TripService.DriverPings(trip.id).then(function (info) {
	                      //get status msg
	                      scope.statusMessages[index] = _.get(info, 'statuses[0].message', null);
	                      scope.recentPings = scope.recentPings || [];
	
	                      /* Only show pings from the last 5 minutes */
	                      // max 12 pings
	                      var now = Date.now();
	                      return scope.recentPings[index] = _.filter(info.pings, function (ping) {
	                        return now - ping.time.getTime() < 5 * 60 * 1000;
	                      }).slice(0, 13);
	                    });
	                  }));
	
	                case 4:
	                case 'end':
	                  return _context.stop();
	              }
	            }
	          }, _callee, this);
	        }));
	
	        return function pingLoop() {
	          return _ref.apply(this, arguments);
	        };
	      }();
	
	      // scope.strokeOptions = {
	      //   color: '#4b3863',
	      //   weight: 3.0,
	      //   opacity: 0.7
	      // };
	      //
	      // scope.strokeIcons = [{
	      //     icon: {
	      //       path: google.maps.SymbolPath.BACKWARD_CLOSED_ARROW,
	      //     },
	      //     offset: '10px',
	      //     repeat: '100px'
	      // }];
	
	      scope.map = {
	        // lines: {
	        //   actualPaths: [
	        //     { path: [] }
	        //   ],
	        // },
	        busLocations: [{ coordinates: null,
	          icon: null }]
	      };
	
	      scope.recentPings = null;
	
	      scope.statusMessages = [];
	
	      scope.$watch('availableTrips', function (availableTrips) {
	        if (!availableTrips) return;
	
	        uiGmapGoogleMapApi.then(function (googleMaps) {
	          scope.availableTrips.map(function (trip, index) {
	            scope.map.busLocations[index] = {
	              icon: {
	                url: 'img/busMarker_' + leftPad(index % 10 + 1, 2, '0') + '.svg',
	                scaledSize: new googleMaps.Size(68, 86),
	                anchor: new googleMaps.Point(34, 78)
	              }
	            };
	          });
	        });
	      });
	
	      scope.$watchCollection('statusMessages', function () {
	        scope.routeMessage = scope.statusMessages.join(' ');
	      });
	
	      scope.$watchCollection('recentPings', function (recentPings) {
	        if (recentPings) {
	          scope.hasTrackingData = _.some(recentPings, function (rp) {
	            return rp && rp.length;
	          });
	          if (!scope.hasTrackingData) {
	            //to remove path and bus icon
	            // _.forEach(scope.map.lines.actualPaths,(actualPath)=>{
	            //   actualPath = {
	            //     path: null
	            //   };
	            // });
	            _.forEach(scope.map.busLocations, function (busLocation) {
	              busLocation.coordinates = null;
	            });
	            return;
	          }
	
	          recentPings.forEach(function (pings, index) {
	            if (pings.length > 0) {
	
	              var coordinates = pings[0].coordinates;
	              // var path = pings.map(ping => ({
	              //   latitude: ping.coordinates.coordinates[1],
	              //   longitude: ping.coordinates.coordinates[0]
	              // }));
	              scope.map.busLocations[index].coordinates = coordinates;
	              //
	              // scope.map.lines.actualPaths[index] = {
	              //   path: path
	              // }
	            } else {
	              //to remove bus icon and actual path
	              scope.map.busLocations[index].coordinates = null;
	              // scope.map.lines.actualPaths[index] = {
	              //   path: null
	              // }
	            }
	          });
	        } else {
	          scope.hasTrackingData = null;
	        }
	      });
	
	      //fetch driver pings every 4s 
	      scope.timeout = new _SafeInterval.SafeInterval(pingLoop, 4000, 1000);
	
	      scope.$on("killPingLoop", function () {
	        scope.timeout.stop();
	      });
	
	      scope.$on("startPingLoop", function () {
	        scope.timeout.start();
	      });
	
	      //load icons and path earlier by restart timeout on watching trips
	      var availableTripsPromise = new Promise(function (resolve) {
	        scope.$watchCollection("availableTrips", function () {
	          if (scope.availableTrips) {
	            resolve();
	          }
	          scope.timeout.stop();
	          scope.timeout.start();
	        });
	      });
	    }
	  };
	};
	
	var _SafeInterval = __webpack_require__(/*! ../SafeInterval */ 487);
	
	function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
	
	var leftPad = __webpack_require__(/*! left-pad */ 542);

/***/ },
/* 542 */
/*!*****************************!*\
  !*** ./~/left-pad/index.js ***!
  \*****************************/
/***/ function(module, exports) {

	/* This program is free software. It comes without any warranty, to
	     * the extent permitted by applicable law. You can redistribute it
	     * and/or modify it under the terms of the Do What The Fuck You Want
	     * To Public License, Version 2, as published by Sam Hocevar. See
	     * http://www.wtfpl.net/ for more details. */
	'use strict';
	module.exports = leftPad;
	
	var cache = [
	  '',
	  ' ',
	  '  ',
	  '   ',
	  '    ',
	  '     ',
	  '      ',
	  '       ',
	  '        ',
	  '         '
	];
	
	function leftPad (str, len, ch) {
	  // convert `str` to `string`
	  str = str + '';
	  // `len` is the `pad`'s length now
	  len = len - str.length;
	  // doesn't need to pad
	  if (len <= 0) return str;
	  // `ch` defaults to `' '`
	  if (!ch && ch !== 0) ch = ' ';
	  // convert `ch` to `string`
	  ch = ch + '';
	  // cache common use cases
	  if (ch === ' ' && len < 10) return cache[len] + str;
	  // `pad` starts with an empty string
	  var pad = '';
	  // loop
	  while (true) {
	    // add `ch` to `pad` if `len` is odd
	    if (len & 1) pad += ch;
	    // divide `len` by 2, ditch the remainder
	    len >>= 1;
	    // "double" the `ch` so this operation count grows logarithmically on `len`
	    // each time `ch` is "doubled", the `len` would need to be "doubled" too
	    // similar to finding a value in binary search tree, hence O(log(n))
	    if (len) ch += ch;
	    // `len` is 0, exit the loop
	    else break;
	  }
	  // pad `str`!
	  return pad + str;
	}


/***/ },
/* 543 */
/*!*******************************************!*\
  !*** ./beeline/directives/mapBusStops.js ***!
  \*******************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (uiGmapGoogleMapApi, LiteRoutesService, uiGmapCtrlHandle) {
	  return {
	    replace: false,
	    require: '^uiGmapGoogleMap',
	    template: '\n    <ui-gmap-marker\n      ng-repeat="stop in tripStops"\n      idKey="stop.id"\n      coords="stop.coordinates"\n      options="stop.canBoard ? boardMarker : alightMarker"\n      click="applyTapBoard(stop)"\n    ></ui-gmap-marker>\n    <ui-gmap-window ng-if="disp.popupStop"\n                    coords="disp.popupStop.coordinates"\n                    show="disp.popupStop"\n                    closeClick="closeWindow">\n      <div class="popUpStopSelect">\n        <b ng-if="!isLiteFrequent">{{disp.popupStop.time | formatTimeArray }}<br/></b>\n        {{disp.popupStop.description}}<br/>{{disp.popupStop.road}}<br/>\n      </div>\n    </ui-gmap-window>\n    ',
	    scope: {
	      'availableTrips': '<',
	      'isLiteFrequent': '<?'
	    },
	    link: function link(scope, element, attributes, ctrl) {
	
	      scope.disp = {
	        popupStop: null
	      };
	
	      uiGmapGoogleMapApi.then(function (googleMaps) {
	        scope.googleMaps = googleMaps;
	        scope.boardMarker = {
	          icon: {
	            url: 'img/map/MapRoutePickupStop@2x.png',
	            scaledSize: new googleMaps.Size(26, 25),
	            anchor: new googleMaps.Point(13, 13)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 1
	        };
	        scope.alightMarker = {
	          icon: {
	            url: 'img/map/MapRouteDropoffStop@2x.png',
	            scaledSize: new googleMaps.Size(26, 25),
	            anchor: new googleMaps.Point(13, 13)
	          },
	          zIndex: google.maps.Marker.MAX_ZINDEX + 1
	        };
	      });
	
	      scope.$watch('availableTrips', function (availableTrips) {
	        if (!availableTrips || availableTrips.length == 0) return;
	        scope.tripStops = LiteRoutesService.computeLiteStops(availableTrips);
	        uiGmapCtrlHandle.mapPromise(scope, ctrl).then(panToStops);
	      });
	
	      scope.applyTapBoard = function (stop) {
	        scope.disp.popupStop = stop;
	      };
	
	      scope.closeWindow = function () {
	        scope.disp.popupStop = null;
	      };
	
	      function panToStops(map) {
	        var bounds = new scope.googleMaps.LatLngBounds();
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = scope.tripStops[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var tripStop = _step.value;
	
	            bounds.extend(new google.maps.LatLng(tripStop.coordinates.coordinates[1], tripStop.coordinates.coordinates[0]));
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        google.maps.event.trigger(map, 'resize');
	        map.fitBounds(bounds);
	      }
	    }
	  };
	};

/***/ },
/* 544 */
/*!**********************************************!*\
  !*** ./beeline/directives/dynamicSignage.js ***!
  \**********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    replace: false,
	    template: '\n    <div>{{signageText}}</div>\n    ',
	    scope: {
	      'signageText': '<'
	    },
	    link: function link(scope, element, attributes) {}
	  };
	};

/***/ },
/* 545 */
/*!***********************************************!*\
  !*** ./beeline/directives/beelineBindHtml.js ***!
  \***********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($compile) {
	  return {
	    restrict: 'A',
	    scope: false,
	    link: function link(scope, elem, attrs) {
	      scope.$watch(attrs.beelineBindHtml, function (html) {
	        elem[0].innerHTML = html || '';
	
	        scope.$openOpenLink = function (href) {
	          if (typeof cordova !== 'undefined') {
	            cordova.InAppBrowser.open(href, '_system');
	          } else {
	            window.open(href, '_blank');
	          }
	        };
	
	        angular.forEach(elem.find('a'), function (value, key) {
	          if (!value.href) return;
	
	          value.setAttribute("ng-click", '$openOpenLink(' + JSON.stringify(value.href) + ')');
	
	          $compile(value)(scope);
	        });
	      });
	    }
	  };
	};

/***/ },
/* 546 */
/*!***********************************************************!*\
  !*** ./beeline/directives/kickstartInfo/kickstartInfo.js ***!
  \***********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    template: __webpack_require__(/*! ./kickstartInfo.html */ 547),
	    restrict: 'E',
	    replace: false,
	    scope: {
	      route: '<',
	      passHide: '<?',
	      preorderHide: '<?',
	      contentHide: '<?'
	    }
	  };
	};

/***/ },
/* 547 */
/*!*************************************************************!*\
  !*** ./beeline/directives/kickstartInfo/kickstartInfo.html ***!
  \*************************************************************/
/***/ function(module, exports) {

	module.exports = "\n<div class=\"kickstarter-info\">\n  <div class=\"preorder-pass\" ng-hide=\"passHide\">\n    <div class=\"route-pass-header\">\n      <h3>Route Pass</h3>\n    </div>\n    <div class=\"route-pass-body\">\n      <route-item>\n        <route-item-bus-number>\n          {{route.label }}\n        </route-item-bus-number>\n      </route-item>\n\n        <h1>{{route.notes.noPasses}}</h1>\n        <h4>trips</h4>\n\n      <div class=\"pass-additional\">\n        <table>\n          <tr>\n            <td class=\"label\">\n              Per Trip\n            </td>\n            <td>\n              <strong>$ {{route.notes.tier[0].price | number: 2}}</strong>\n            </td>\n          </tr>\n          <tr>\n            <td class=\"label\">\n            Total Price\n            </td>\n            <td>\n              <strong>$ {{route.notes.noPasses*route.notes.tier[0].price | number: 2}}</strong>\n            </td>\n          </tr>\n        </table>\n      <p class=\"pass-condition\">\n        If activated, Route Pass will be valid\n      </p>\n      <table>\n        <tr>\n          <td class=\"label\">\n            From\n          </td>\n          <td>\n            <strong>{{route.trips[0].date | date:'dd MMM yyyy' : 'Z'}} ({{route.trips[0].date | date:'EEE' : 'Z'}})</strong>\n          </td>\n        </tr>\n      </table>\n        <p>For any {{route.notes.noPasses}} trips happening in the 1st  month of the activated route. Operates Mon-Fri, except Public Holidays. </p>\n      </div>\n    </div>\n  </div>\n  <div class=\"kickstart-info-content\" ng-hide=\"contentHide\">\n    <p>\n     This route will activate when <strong>{{route.notes.tier[0].pax}} people</strong>\n     pre-order this Route Pass by <strong>{{route.notes.lelongExpiry | date:'dd MMM yy' : '+0800'}}</strong>.\n   </p>\n   <p ng-if=\"!route.daysLeft\">This campaign has ended.</p>\n   <p>\n     If route is <strong>activated</strong>,\n     <ul >\n       <li>\n         Beeline will process the payment.\n       </li>\n       <li>\n         You will receive the Route Pass within a week.\n       </li>\n       <li>\n         Use the pass to <strong>book any {{route.notes.noPasses}} trips</strong>\n       </li>\n       <li>\n         Valid for the 1st month of the activated route.\n       </li>\n     </ul>\n   </p>\n   <p>\n     If route is <strong>not activated</strong>,\n   </p>\n   <ul>\n     <li>\n       Payment will not be processed.\n     </li>\n   </ul>\n  </div>\n  <p ng-if=\"route.notes.tier[0].count >= route.notes.tier[0].pax && route.daysLeft\" ng-hide=\"preorderHide\">You can still pre-order even though enough people has pre-ordered to activate this route.</p>\n</div>\n";

/***/ },
/* 548 */
/*!*******************************************************!*\
  !*** ./beeline/directives/progressBar/progressBar.js ***!
  \*******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _progressBar = __webpack_require__(/*! ./progressBar.html */ 549);
	
	var _progressBar2 = _interopRequireDefault(_progressBar);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = [function () {
	  return {
	    restrict: 'E',
	    template: _progressBar2.default,
	    scope: {
	      backer1: '<',
	      pax1: '<',
	      price1: '<',
	      detail: '<',
	      needed: '<'
	    },
	    link: function link(scope, elem, attr) {
	      scope.$watchGroup(['backer1', 'pax1'], function () {
	        scope.percentage = Math.min(scope.backer1 / scope.pax1, 1);
	        // if (!isFinite(scope.moreNeeded))
	        //   scope.moreNeeded = '';
	      });
	    }
	  };
	}];

/***/ },
/* 549 */
/*!*********************************************************!*\
  !*** ./beeline/directives/progressBar/progressBar.html ***!
  \*********************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"progress-bar\">\n  <!-- price label starts -->\n  <div class=\"bar-label-default\" ng-if=\"detail\">\n    <div class=\"bar-100\">\n      <div class=\"price-label\" ng-class=\"{activated: needed==0}\">\n        <div class=\"ride-price\">${{price1| number:2}}</div>\n        <div class=\"per-ride\">per trip</div>\n      </div>\n    </div>\n  </div>\n  <!-- price label ends -->\n\n  <!-- dynamic bar starts -->\n  <div class=\"backer-progress\">\n    <div class=\"backer-high\" ng-style=\"{\n             width: (percentage * 100) + '%',\n             }\">\n    </div>\n  </div>\n  <!-- dynamic bar starts -->\n\n  <!-- default base bar starts -->\n  <div class=\"bar-default\" ng-style=\"{\n              width: (pax1/pax1)*100 + '%'}\">\n    <div class=\"start-marker\" ng-class=\"{started: backer1>0}\"></div>\n    <div class=\"bar-100\">\n      <div class=\"milestone\">\n        <div class=\"milestone-outline\"  ng-class=\"{reached: needed==0}\">\n          <div class=\"milestone-inset\"></div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <!-- default base bar ends -->\n\n  <!-- dynamic join starts here -->\n  <div ng-if=\"detail\" class=\"high-joined\" ng-style=\"{\n            width:\n(backer1/pax1)*200 + '%',\n            }\">\n      <span class=\"line\"></span>\n      <div>{{backer1}} pax<br />pre-ordered</div>\n  </div>\n\n  <!-- dynamic join line ends here -->\n\n  <!-- number needed section start -->\n  <div ng-if=\"detail\" class=\"needed-label-default\">\n    <!-- full mark -->\n    <div class=\"bar-100\">\n        <div class=\"needed-label\">\n        <span class=\"line\"></span>\n        <div>{{needed}} more</div>\n        <div>pax needed</div>\n      </div>\n    </div>\n  <!-- number needed section ends -->\n</div>\n";

/***/ },
/* 550 */
/*!************************************************!*\
  !*** ./beeline/directives/dailyTripsBroker.js ***!
  \************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (LiteRoutesService, $timeout) {
	  return {
	    replace: true,
	    restrict: 'E',
	    template: '',
	    scope: {
	      'tripLabel': '<',
	      'dailyTrips': '='
	    },
	    link: function link(scope, element, attributes) {
	      var timeout;
	
	      scope.dailyTrips = null;
	
	      scope.$watch('tripLabel', function (label) {
	        if (timeout) timeout.stop();
	
	        if (!label) {
	          return;
	        }
	
	        timeout = new _SafeScheduler.SafeScheduler(function () {
	          return grabTrips(label);
	        }, 24, 1, 0);
	
	        timeout.start();
	      });
	
	      scope.$on('$destroy', function () {
	        if (timeout) timeout.stop();
	      });
	
	      function grabTrips(label) {
	        return LiteRoutesService.getLiteRoute(label, true).then(function (response) {
	          var route = response[scope.tripLabel];
	          scope.dailyTrips = route.trips.filter(function (trip) {
	            return trip.isRunning && new Date(trip.date).setHours(0, 0, 0, 0) == new Date().setHours(0, 0, 0, 0);
	          });
	        });
	      }
	    }
	  };
	};
	
	var _SafeScheduler = __webpack_require__(/*! ../SafeScheduler */ 551);

/***/ },
/* 551 */
/*!**********************************!*\
  !*** ./beeline/SafeScheduler.js ***!
  \**********************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.SafeScheduler = undefined;
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _assert = __webpack_require__(/*! assert */ 303);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var SafeScheduler = exports.SafeScheduler = function () {
	  function SafeScheduler(fn, hours) {
	    var minutes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	
	    _classCallCheck(this, SafeScheduler);
	
	    this.isRunning = false;
	    this.timeout = null;
	
	    //fn returns a Promise
	    this.loop = function () {
	      var _this = this;
	
	      this.timeout = null;
	
	      fn().then(function () {
	        if (_this.isRunning) {
	          _this.timeout = setTimeout(_this.loop, new Date().setHours(hours, minutes, seconds) - Date.now());
	        }
	      }).catch(function () {
	        if (_this.isRunning) {
	          _this.timeout = setTimeout(_this.loop, 60000 /* retryTimeout */);
	        }
	      });
	    }.bind(this);
	  }
	
	  _createClass(SafeScheduler, [{
	    key: 'stop',
	    value: function stop() {
	      this.isRunning = false;
	      if (this.timeout !== null) {
	        clearTimeout(this.timeout);
	      }
	    }
	  }, {
	    key: 'start',
	    value: function start() {
	      (0, _assert2.default)(!this.isRunning);
	      this.isRunning = true;
	      this.loop();
	    }
	  }]);

	  return SafeScheduler;
	}();

/***/ },
/* 552 */
/*!***********************************************!*\
  !*** ./beeline/directives/fakeProgressBar.js ***!
  \***********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($timeout) {
	  return {
	    template: '\n      <progress class="fakeProgressBar" max="100" value={{progressValue}}></progress>\n    ',
	    scope: {
	      'interval': '<',
	      'max': '<'
	    },
	    link: function link(scope, elem, attr) {
	      scope.progressValue = 0;
	      var timeout;
	      var makeProgress = function makeProgress() {
	        scope.progressValue = (scope.progressValue + 1) % (scope.max + 1);
	        timeout = $timeout(makeProgress, scope.interval);
	      };
	      makeProgress();
	      scope.$on('$destroy', function () {
	        return $timeout.cancel(timeout);
	      });
	    }
	  };
	};

/***/ },
/* 553 */
/*!***********************************************!*\
  !*** ./beeline/directives/inServiceWindow.js ***!
  \***********************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($timeout) {
	  return {
	    replace: true,
	    restrict: 'E',
	    template: '',
	    scope: {
	      'availableTrips': '<',
	      'inServiceWindow': '='
	    },
	    link: function link(scope, element, attributes) {
	      var allStopsTime;
	      scope.inServiceWindow = null;
	      //check in service window every 1 min, if fails re-try in 1 sec
	      scope.timeout = new _SafeInterval.SafeInterval(function () {
	        return checkServiceWindow(scope.availableTrips);
	      }, 1000 * 60, 1000);
	      scope.timeout.start();
	      scope.$on('$destroy', function () {
	        if (scope.timeout) scope.timeout.stop();
	      });
	      //to restart the loop when available trips become not null
	      scope.$watchCollection('availableTrips', function () {
	        scope.timeout.stop();
	        scope.timeout.start();
	      });
	      function checkServiceWindow(trips) {
	        if (!trips || trips.length == 0) {
	          scope.inServiceWindow = null;
	        } else {
	          var allStopsTime = _lodash2.default.flatten(trips.map(function (trip) {
	            return trip.tripStops;
	          })).map(function (stop) {
	            return stop.time;
	          }).sort();
	          if (allStopsTime) {
	            //15 min before 1st stop time
	            scope.startTime = new Date(allStopsTime[0]).getTime() - 1000 * 60 * 15;
	            scope.endTime = new Date(allStopsTime[allStopsTime.length - 1]).getTime();
	            scope.now = Date.now();
	            if (isFinite(scope.startTime) && isFinite(scope.endTime)) {
	              scope.inServiceWindow = scope.startTime <= scope.now && scope.now <= scope.endTime;
	            } else {
	              scope.inServiceWindow = false;
	            }
	          }
	        }
	        return Promise.resolve();
	      }
	    }
	  };
	};
	
	var _SafeInterval = __webpack_require__(/*! ../SafeInterval */ 487);
	
	var _lodash = __webpack_require__(/*! lodash */ 309);
	
	var _lodash2 = _interopRequireDefault(_lodash);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 554 */
/*!***********************************************!*\
  !*** ./beeline/directives/crowdstartShare.js ***!
  \***********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($cordovaSocialSharing, $rootScope) {
	  return {
	    replace: true,
	    restrict: 'E',
	    template: '<div class="item item-text-wrap">\n                <div class="share-box">\n                  Share this campaign to your friends and colleagues to increase the chance of activating this route!\n                  <div class="text-center">\n                    <textarea rows="4">{{shareLink}}</textarea>\n                  </div>\n                  <div class="text-right">\n                    <button class="button button-outline button-royal small-button" ng-click="shareAnywhere()" ng-if="!showCopy">Share</button>\n                    <button class="button button-outline button-royal small-button" ng-if="showCopy" ngclipboard data-clipboard-text={{shareLink}}>\n                        Copy\n                    </button>\n                  </div>\n                </div>\n              </div>',
	    scope: {
	      'routeId': '<'
	    },
	    link: function link(scope, element, attributes) {
	      scope.showCopy = !window.cordova || false;
	      //if has cordova no need to show shareLink text area
	      // scope.shareLink = "Hey, check out this new Crowdstart route from "+$rootScope.o.APP.NAME +"! "+$rootScope.o.APP.INDEX+"#/tabs/crowdstart/"+scope.routeId+"/detail";
	      scope.shareLink = 'Hey, check out this new Crowdstart route from ' + $rootScope.o.APP.NAME + '! ' + $rootScope.o.APP.INDEX + '#/tabs/crowdstart/' + scope.routeId + '/detail';
	
	      scope.shareAnywhere = function () {
	        $cordovaSocialSharing.share('Hey, check out this new Crowdstart route from ' + $rootScope.o.APP.NAME + '!', 'New ' + $rootScope.o.APP.NAME + ' Crowdstart Route', null, $rootScope.o.APP.INDEX + '#/tabs/crowdstart/' + scope.routeId + '/detail');
	      };
	    }
	  };
	};

/***/ },
/* 555 */
/*!*****************************************************************!*\
  !*** ./beeline/directives/poweredByBeeline/poweredByBeeline.js ***!
  \*****************************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function ($rootScope) {
	  return {
	    template: __webpack_require__(/*! ./poweredByBeeline.html */ 556),
	    restrict: 'E',
	    replace: false,
	    scope: {
	      powerHide: '<?',
	      suggestHide: '<?'
	    },
	    link: function link(scope, elem, attr) {
	      scope.openSuggestionLink = function (event) {
	        event.preventDefault();
	        var appName = $rootScope.o.APP.NAME.replace(/\s/g, '');
	        window.open('https://www.beeline.sg/suggest.html#' + _querystring2.default.stringify({ referrer: appName }), '_system');
	      };
	      scope.powerHide = scope.powerHide ? scope.powerHide : $rootScope.o.APP.NAME == 'Beeline';
	    }
	  };
	};
	
	var _querystring = __webpack_require__(/*! querystring */ 425);
	
	var _querystring2 = _interopRequireDefault(_querystring);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 556 */
/*!*******************************************************************!*\
  !*** ./beeline/directives/poweredByBeeline/poweredByBeeline.html ***!
  \*******************************************************************/
/***/ function(module, exports) {

	module.exports = "<div class=\"item item-text-wrap text-center\">\n  <div ng-hide=\"suggestHide\">\n    Can't find a suitable route?</br>\n    <a href=\"#\" ng-click=\"openSuggestionLink($event)\">Suggest a new route</a>\n  </div>\n  <div class=\"powered-by\" ng-hide=\"powerHide\">\n  Powered by\n  <img src=\"img/poweredbybeeline.svg\" />\n  </div>\n</div>\n";

/***/ },
/* 557 */
/*!********************************************!*\
  !*** ./beeline/directives/autocomplete.js ***!
  \********************************************/
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (uiGmapGoogleMapApi) {
	  return {
	    scope: true,
	    link: function link(scope, element, attribute) {
	      uiGmapGoogleMapApi.then(function (googleMaps) {
	        scope.$autocomplete = new googleMaps.places.Autocomplete(element[0], {
	          componentRestrictions: { country: 'SG' }
	        });
	
	        scope.$autocomplete.addListener('place_changed', function (place) {
	          scope.$apply(function () {
	            scope.$eval(attribute['placeChanged'], {
	              '$event': scope.$autocomplete.getPlace()
	            });
	          });
	        });
	
	        scope.$watch(function () {
	          return scope.$eval(attribute['bounds']);
	        }, function (bounds) {
	          scope.$autocomplete.setBounds(bounds);
	        });
	
	        setTimeout(function () {
	          var pacContainers = document.querySelectorAll('.pac-container');
	
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = pacContainers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var pac = _step.value;
	
	              pac.dataset.tapDisabled = true;
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	        }, 2000);
	      });
	    }
	  };
	};

/***/ },
/* 558 */
/*!******************************************************!*\
  !*** ./beeline/directives/routeItem/regularRoute.js ***!
  \******************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    template: __webpack_require__(/*! ./regularRoute.html */ 559),
	    scope: {
	      'route': '<'
	    }
	  };
	};

/***/ },
/* 559 */
/*!********************************************************!*\
  !*** ./beeline/directives/routeItem/regularRoute.html ***!
  \********************************************************/
/***/ function(module, exports) {

	module.exports = "<route-item>\n  <route-item-bus-number>\n    {{ route.label }}\n  </route-item-bus-number>\n  <route-item-description>\n    {{ route.notes.description }}\n  </route-item-description>\n  <route-item-start-time>\n    {{ route | routeStartTime | formatTime:true }}\n  </route-item-start-time>\n  <route-item-start-location>\n    {{ route.from }}\n  </route-item-start-location>\n  <route-item-end-time>\n    {{ route | routeEndTime | formatTime:true }}\n  </route-item-end-time>\n  <route-item-end-location>\n    {{ route.to }}\n  </route-item-end-location>\n\n  <route-item-additional-info>\n    <company-info-broker company-id=\"route.transportCompanyId\"\n                          company=\"companyInfo\">\n    </company-info-broker>\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span company-logo\">\n        <img class=\"mini-icon\" ng-src=\"{{route.transportCompanyId | companyLogo}}\">\n      </span>\n      <span class=\"mini-info\">\n        {{companyInfo.name}}\n      </span>\n    </div>\n\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span\">\n        <img class=\"mini-icon\" src=\"img/icon_schedule.svg\">\n      </span>\n      <span class=\"mini-info\">\n        {{route.schedule}}\n      </span>\n    </div>\n\n    <div class=\"icon-and-schedule\" ng-if=\"route.ridesRemaining && route.ridesRemaining > 0\">\n      <span class=\"icon-span\">\n        <img class=\"mini-icon\" src=\"img/icon_kickstarter_activebid.svg\">\n      </span>\n      <span class=\"mini-info important\" >\n        You have {{ route.ridesRemaining }} trip(s) remaining in your Route Pass.\n      </span>\n    </div>\n  </route-item-additional-info>\n</route-item>\n";

/***/ },
/* 560 */
/*!********************************************************!*\
  !*** ./beeline/directives/routeItem/kickstartRoute.js ***!
  \********************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function (KickstarterService) {
	  return {
	    template: __webpack_require__(/*! ./kickstartRoute.html */ 561),
	    scope: {
	      'route': '<'
	    },
	    controller: function controller($scope) {
	      $scope.bids = {};
	      $scope.$watch(function () {
	        return KickstarterService.getBids();
	      }, function (bids) {
	        return $scope.bids = bids;
	      });
	    }
	  };
	};

/***/ },
/* 561 */
/*!**********************************************************!*\
  !*** ./beeline/directives/routeItem/kickstartRoute.html ***!
  \**********************************************************/
/***/ function(module, exports) {

	module.exports = "<route-item>\n  <route-item-bus-number>\n    {{ route.label }}\n  </route-item-bus-number>\n  <route-item-description>\n    {{ route.notes.description }}\n  </route-item-description>\n  <route-item-start-time>\n    {{ route | routeStartTime | formatTime:true }}\n  </route-item-start-time>\n  <route-item-start-location>\n    {{ route.from }}\n  </route-item-start-location>\n  <route-item-end-time>\n    {{ route | routeEndTime | formatTime:true }}\n  </route-item-end-time>\n  <route-item-end-location>\n    {{ route.to }}\n  </route-item-end-location>\n  <route-item-additional-info>\n    <company-info-broker company-id=\"route.transportCompanyId\" company=\"companyInfo\">\n    </company-info-broker>\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span company-logo\">\n          <img class=\"mini-icon\" ng-src=\"{{route.transportCompanyId | companyLogo}}\">\n        </span>\n      <span class=\"mini-info\">\n          {{companyInfo.name}}\n        </span>\n    </div>\n\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span\">\n          <img class=\"mini-icon\" src=\"img/icon_kickstarter_timeleft.svg\">\n        </span>\n      <span class=\"mini-info\" ng-if=\"route.daysLeft && route.daysLeft>1\">\n          Campaign ends in {{route.daysLeft}} days\n        </span>\n      <span class=\"mini-info\" ng-if=\"route.daysLeft && route.daysLeft==1\">\n          Campaign ends in {{route.daysLeft}} day\n        </span>\n      <span class=\"mini-info\" ng-if=\"route.isExpired\">\n          Campaign has expired\n        </span>\n    </div>\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span\">\n          <img class=\"mini-icon\" src=\"img/icon_schedule.svg\">\n        </span>\n      <span class=\"mini-info\">\n          Route starts on {{route.trips[0].date | date:'dd MMM yyyy' : 'Z'}} if activated\n        </span>\n    </div>\n\n    <progress-bar backer1=\"route.notes.tier[0].count \" price1=\"route.notes.tier[0].price\"\n      pax1=\"route.notes.tier[0].pax\" needed=\"route.notes.tier[0].moreNeeded\"\n      ng-if=\"!route.isConverted\">\n    </progress-bar>\n\n    <div class=\"icon-and-schedule item-text-wrap\">\n      <span class=\"icon-span\">\n          <img class=\"mini-icon\" src=\"img/icon_kickstarter_status.svg\">\n        </span>\n      <span class=\"mini-info\">\n          {{route.status}}\n        </span>\n    </div>\n    <div class=\"icon-and-schedule\" ng-if=\"bids[route.id]\">\n      <span class=\"icon-span\">\n        <img class=\"mini-icon\" src=\"img/icon_kickstarter_activebid.svg\">\n      </span>\n      <span class=\"mini-info\">\n          You pre-ordered a Route Pass for {{route.notes.noPasses}} trips.\n        </span>\n    </div>\n\n  </route-item-additional-info>\n</route-item>\n";

/***/ },
/* 562 */
/*!***************************************************!*\
  !*** ./beeline/directives/routeItem/liteRoute.js ***!
  \***************************************************/
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	exports.default = function () {
	  return {
	    template: __webpack_require__(/*! ./liteRoute.html */ 563),
	    scope: {
	      'route': '<'
	    }
	  };
	};

/***/ },
/* 563 */
/*!*****************************************************!*\
  !*** ./beeline/directives/routeItem/liteRoute.html ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = "<route-item class=\"lite\"\n            ng-class=\"{'lite-tracked': route.isSubscribed}\">\n  <route-item-bus-number>\n    {{ route.label }}\n  </route-item-bus-number>\n  <route-item-description>\n    {{ route.notes.description }}\n  </route-item-description>\n  <route-item-start-time>\n    {{ route.startTime | formatTime}}\n  </route-item-start-time>\n  <route-item-start-location>\n    {{ route.from }}\n  </route-item-start-location>\n  <route-item-end-time>\n    {{ route.endTime | formatTime}}\n  </route-item-end-time>\n  <route-item-end-location>\n    {{ route.to }}\n  </route-item-end-location>\n\n  <route-item-additional-info>\n    <company-info-broker company-id=\"route.transportCompanyId\"\n                          company=\"companyInfo\">\n    </company-info-broker>\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span company-logo\">\n        <img class=\"mini-icon\" ng-src=\"{{route.transportCompanyId | companyLogo}}\">\n      </span>\n      <span class=\"mini-info\">\n        {{companyInfo.name}}\n      </span>\n    </div>\n\n    <div class=\"icon-and-schedule\">\n      <span class=\"icon-span\">\n        <img class=\"mini-icon\" src=\"img/icon_schedule.svg\">\n      </span>\n      <span class=\"mini-info\">\n        {{route.schedule}}\n      </span>\n    </div>\n  </route-item-additional-info>\n</route-item>\n";

/***/ },
/* 564 */
/*!*****************************************!*\
  !*** ./www/templates/intro-slides.html ***!
  \*****************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view class=\"intro-slides\" cache-view=\"false\" can-swipe-back=\"false\">\n  <ion-content scroll=\"false\">\n    <ion-slides options=\"options\" slider=\"data.slider\">\n      <ion-slide-page ng-if=\"data.showHome\">\n        <h2>Add to home screen</h2>\n        <img ng-src=\"img/{{o.APP.PREFIX}}introHomeScreen.svg\">\n        <p>\n          Tap <i class=\"icon ion-ios-upload-outline\"></i> or go to your browser settings and select <strong>\"Add to Home Screen\"</strong> to quickly access {{o.APP.NAME}} on your home screen.\n        </p>\n      </ion-slide-page>\n\n      <ion-slide-page ng-if=\"data.showHome\">\n        <h2>Best viewed on mobile</h2>\n        <img src=\"img/introSuggest.svg\">\n        <p>\n          This web application is designed for mobile experience. We regret that desktop experience may be less optimal.\n        </p>\n      </ion-slide-page>\n\n      <ion-slide-page>\n        <h2>Book a ride</h2>\n        <img src=\"img/introActivate.svg\">\n        <p>\n          Browse for your routes and book a guaranteed seat on a\n          direct bus to your destination.\n        </p>\n      </ion-slide-page>\n\n      <ion-slide-page>\n        <h2>Tracking-only routes</h2>\n        <img ng-src=\"img/introTrackOnly.svg\">\n        <p>\n          Tracking-only routes are indicated by a \"map pin\" icon. You can track the bus and do not have to book seats via the app to ride the bus. Payment details for the ride can be found in the route information.\n        </p>\n      </ion-slide-page>\n\n      <ion-slide-page>\n        <h2>Crowdstart new routes</h2>\n        <img src=\"img/introKickstart.svg\">\n        <p>\n          Crowdstart routes are routes that are not in operation yet. Activate these routes by pre-ordering route passes. If enough people do so, the route will be activated.\n        </p>\n      </ion-slide-page>\n\n\n\n    </ion-slides>\n\n    <button class=\"button button-large button-clear button-royal\"\n            ui-sref='tabs.routes'>{{data.buttonLabel}}</button>\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 565 */
/*!*************************************!*\
  !*** ./www/templates/settings.html ***!
  \*************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view class=\"settings\" view-title=\"Settings\">\n  <ion-content>\n    <div class=\"account-section item item-word-wrap\">\n\n      <p ng-hide=\"user\">Log in to make and view your bookings.</p>\n      <button ng-hide=\"user\"\n              class=\"button button-block button-outline button-royal\"\n              ng-click=\"logIn()\">Log In</button>\n\n\n      <p ng-show=\"user\">You are currently logged in as {{ user.name }}.</p>\n\n      <button ng-show=\"user\"\n              class=\"button button-block button-outline button-royal\"\n              ng-click=\"logOut()\">Log Out</button>\n\n    </div>\n    <div class=\"list\">\n\n      <div ng-show=\"user\" class=\"item item-divider\">Account</div>\n      <div ng-show=\"user\" class=\"item\" on-tap=\"updateUserInfo('name')\">\n        Name <span class=\"item-note\">{{ user.name }}</span>\n      </div>\n      <div ng-show=\"user\" class=\"item\" on-tap=\"updateUserInfo('email')\">\n        Email <span class=\"item-note\">{{ user.email }}</span>\n      </div>\n      <div ng-show=\"user\" class=\"item\" on-tap=\"updateTelephone()\">\n        Phone Number <span class=\"item-note\">{{ user.telephone.slice(3)}}</span>\n      </div>\n      <!-- TODO: click to prompt to change or remove card -->\n      <div ng-show=\"user && hasPaymentInfo()\" class=\"item\" on-tap=\"promptChangeOrRemoveCard()\">\n        Payment Method  <span class=\"item-note\">{{user.savedPaymentInfo.sources.data[0].brand}} ending in {{user.savedPaymentInfo.sources.data[0].last4}}</span>\n      </div>\n        <!-- TODO: click to prompt to add card -->\n      <div ng-show=\"user && !hasPaymentInfo()\" class=\"item\" on-tap=\"addCard()\">\n        Payment Method <span class=\"item-note\">Add Payment Method</span>\n      </div>\n      <div ng-show=\"user\"\n           class=\"item item-icon-right\"\n           ui-sref=\"tabs.booking-history\">\n          Payment History <i class=\"icon ion-ios-arrow-right\"></i>\n      </div>\n<!--       <div ng-show=\"user\" class=\"item\" on-tap=\"shareReferralModal.show()\">\n        Invite Friends\n      </div> -->\n      <div class=\"item item-divider\">About {{o.APP.NAME}}</div>\n      <ion-item ui-sref='intro'>Quick Tour</ion-item>\n      <ion-item on-tap=\"faqModal.show()\">FAQ</ion-item>\n      <ion-item on-tap=\"showPrivacyPolicy()\">Privacy Policy</ion-item>\n      <ion-item on-tap=\"showTermsOfUse()\">Terms of Use</ion-item>\n      <ion-item on-tap=\"contactUsModal.show()\">Contact Us</ion-item>\n      <div class=\"item\" ng-show=\"hasCordova\">\n        Current Version <span class=\"item-note\">{{data.currentVersion}}</span>\n      </div>\n      <powered-by-beeline suggest-hide=\"true\" power-hide=\"false\"></powered-by-beeline>\n    </div>\n\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 566 */
/*!****************************************!*\
  !*** ./www/templates/routes-list.html ***!
  \****************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view class=\"routes-list\" view-title=\"Routes\">\n  <ion-content scroll=\"false\">\n    <div class=\"item item-text-wrap\" ng-if=\"error\">\n      <i class=\"icon ion-alert-circled\"></i>\n      There was a problem fetching the routes from the server.\n      Please try again later.\n    </div>\n\n    <!-- Region Filter  -->\n    <div class=\"region-filter\">\n      <search-button ui-sref=\"tabs.search({backPage: 'tabs.routes'})\"></search-button>\n      <label class=\"item item-input item-select\" data-tap-disabled=\"true\">\n        <select ng-model=\"data.selectedRegionId\">\n          <option value=\"\" disabled selected>Select Region</option>\n          <option value=\"\">All Regions</option>\n          <option ng-repeat=\"region in data.regions\" value=\"{{region.id}}\">{{region.name}}</option>\n        </select>\n      </label>\n    </div>\n\n    <ion-content class=\"list\">\n      <ion-refresher pulling-text=\"Pull to refresh...\"\n                     on-refresh=\"refreshRoutes(true)\">\n      </ion-refresher>\n\n      <!-- Recent Routes Section -->\n      <!-- ng-show doesn't work 100% reliably. angular bug? -->\n      <div class=\"item item-divider\" ng-if=\"data.filteredActivatedKickstarterRoutes && data.filteredActivatedKickstarterRoutes.length > 0\">\n        Your Activated Crowdstart Routes\n      </div>\n      <ion-item ng-repeat=\"route in data.filteredActivatedKickstarterRoutes\"\n                ui-sref=\"tabs.bookingPickup({\n                  routeId: route.id,\n                  boardStop:  data.recentRoutesById[route.id].boardStopStopId,\n                  alightStop: data.recentRoutesById[route.id].alightStopStopId,\n                  sessionId: data.nextSessionId,\n                })\"\n                ng-if=\"data.filteredActivatedKickstarterRoutes && data.filteredActivatedKickstarterRoutes.length > 0\"\n                class=\"item-icon-right\">\n        <regular-route route=\"route\"></regular-route>\n        <i class=\"icon ion-ios-arrow-right\"></i>\n      </ion-item>\n      <div class=\"item item-divider\"\n          ng-if=\"data.filteredRecentRoutes.length > 0\">\n        Recently Booked Routes\n      </div>\n      <ion-item ng-repeat=\"route in data.filteredRecentRoutes\"\n                ui-sref=\"tabs.bookingPickup({\n                  routeId: route.id,\n                  boardStop:  data.recentRoutesById[route.id].boardStopStopId,\n                  alightStop: data.recentRoutesById[route.id].alightStopStopId,\n                  sessionId: data.nextSessionId,\n                })\"\n                class=\"item-text-wrap item-icon-right\">\n        <regular-route route=\"route\"></regular-route>\n        <i class=\"icon ion-ios-arrow-right\"></i>\n      </ion-item>\n\n      <!-- Available Routes Section -->\n      <div class=\"item item-divider\"\n           ng-if=\"data.filteredLiteRoutes.length > 0 || data.filteredActiveRoutes.length > 0\">\n        Available Routes\n      </div>\n\n      <!-- Available regular routes -->\n      <ion-item ng-repeat=\"route in data.filteredActiveRoutes\"\n                ui-sref=\"tabs.bookingPickup({\n                  routeId: route.id,\n                  sessionId: data.nextSessionId,\n                })\"\n                class=\"item-text-wrap item-icon-right\">\n        <regular-route route=\"route\"></regular-route>\n        <i class=\"icon ion-ios-arrow-right\"></i>\n      </ion-item>\n\n      <!-- Available Lite Routes Section -->\n      <ion-item ng-repeat=\"route in data.filteredLiteRoutes\"\n                ui-sref=\"tabs.lite-summary({\n                  label: route.label,\n                })\"\n                class=\"item-icon-right\">\n        <lite-route route=\"route\"></lite-route>\n        <i class=\"icon ion-ios-arrow-right\"></i>\n      </ion-item>\n\n      <powered-by-beeline></powered-by-beeline>\n      <p ng-if=\"data.filteredActiveRoutes.length === 0 && data.filteredLiteRoutes.length === 0\n        && data.filterText\" class=\"not-found-message text-center\">\n          Sorry, we could not find any routes matching \"{{data.filterText}}\".\n      </p>\n    </ion-content>\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 567 */
/*!************************************!*\
  !*** ./www/templates/tickets.html ***!
  \************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view class=\"tickets\" view-title=\"Trips\">\n  <ion-content>\n    <ion-refresher pulling-text=\"Pull to refresh...\"\n                   on-refresh=\"refreshTickets(true)\"\n                   ng-if=\"user\">\n    </ion-refresher>\n\n    <div class=\"item item-text-wrap no-tickets\" ng-if=\"!user\">\n      <img src=\"./img/bgTickets.svg\">\n      <h2>You are not logged in</h2>\n      <p>Log in to see your upcoming trips!</p>\n      <button class=\"primary-button\" on-tap=\"logIn()\">\n        Log In\n      </button>\n    </div>\n\n    <!-- if no tickets -->\n    <div class=\"item item-text-wrap no-tickets\"\n         ng-if=\"user &&\n                tickets.today.length === 0 &&\n                tickets.soon.length === 0 &&\n                liteRouteSubscriptions.length === 0\">\n      <div class=\"item item-text-wrap\" ng-if=\"error\">\n        <i class=\"icon ion-alert-circled\"></i>\n        There was a problem fetching your tickets from the server.\n        Please try again later.\n      </div>\n\n      <img src=\"./img/bgTickets.svg\">\n      <h2>No upcoming trips</h2>\n      <p>Your tickets will appear here when you book a trip!</p>\n      <button class=\"primary-button\" ui-sref=\"tabs.routes\">\n        Search For Routes\n      </button>\n    </div>\n\n    <!-- if there are tickets -->\n    <div class=\"list\"\n         ng-if=\"user &&\n                tickets.today.length > 0 ||\n                tickets.soon.length > 0 ||\n                liteRouteSubscriptions.length > 0\">\n      <div class=\"item item-text-wrap\" ng-if=\"error\">\n        <i class=\"icon ion-alert-circled\"></i>\n        There was a problem fetching your tickets from the server.\n        Please try again later.\n      </div>\n\n      <div ng-if=\"tickets.today.length > 0\"\n           class=\"item item-divider\">Today's Trips</div>\n      <a ng-if=\"tickets.today.length > 0\"\n         class=\"item item-icon-right\"\n         ng-repeat=\"ticket in tickets.today\"\n         ui-sref=\"tabs.ticket-detail({ ticketId: ticket.id })\">\n        <span class=\"date\">{{ ticket.boardStop.time | date:'d MMM y' : '+0800' }}</span> {{ ticket.boardStop.time | date:'h:mm a' : '+0800' }}\n        <i class=\"icon ion-ios-arrow-right icon-accessory\"></i>\n      </a>\n      <div ng-if=\"tickets.soon.length > 0\"\n           class=\"item item-divider\">Upcoming Trips</div>\n      <a ng-if=\"tickets.soon.length > 0\"\n         class=\"item item-icon-right\"\n         ng-repeat=\"ticket in tickets.soon\"\n         ui-sref=\"tabs.ticket-detail({ ticketId: ticket.id })\">\n        <span class=\"date\">{{ ticket.boardStop.time | date:'d MMM y' : '+0800' }}</span> {{ ticket.boardStop.time | date:'h:mm a' : '+0800' }}\n        <i class=\"icon ion-ios-arrow-right icon-accessory\"></i>\n      </a>\n      <div ng-if=\"liteRouteSubscriptions.length > 0\"\n           class=\"item item-divider\">Routes You Are Tracking</div>\n      <a ng-if=\"liteRouteSubscriptions.length > 0\"\n         class=\"item item-icon-right\"\n         ng-repeat=\"subscription in liteRouteSubscriptions\"\n         ui-sref=\"tabs.lite-route-tracker({ liteRouteLabel: subscription.label })\">\n        <route-item class=\"lite lite-tracked\">\n          <route-item-bus-number>\n            {{ subscription.label }}\n          </route-item-bus-number>\n          <route-item-description>\n            {{ subscription.liteRoute.notes.description }}\n          </route-item-description>\n          <route-item-start-time>\n            {{ subscription.liteRoute.startTime | formatTime}}\n          </route-item-start-time>\n          <route-item-start-location>\n            {{ subscription.liteRoute.from }}\n          </route-item-start-location>\n          <route-item-end-time>\n            {{ subscription.liteRoute.endTime | formatTime}}\n          </route-item-end-time>\n          <route-item-end-location>\n            {{ subscription.liteRoute.to }}\n          </route-item-end-location>\n          <route-item-additional-info>\n            <company-info-broker company-id=\"subscription.liteRoute.transportCompanyId\"\n                                  company=\"companyInfo\">\n            </company-info-broker>\n            <div class=\"icon-and-schedule\">\n              <span class=\"icon-span company-logo\">\n                <img class=\"mini-icon\"\n                     ng-src=\"{{ subscription.liteRoute.transportCompanyId\n                       | companyLogo }}\">\n              </span>\n              <span class=\"mini-info\">\n                {{ companyInfo.name }}\n              </span>\n            </div>\n\n            <div class=\"icon-and-schedule\">\n              <span class=\"icon-span\">\n                <img class=\"mini-icon\" src=\"img/icon_schedule.svg\">\n              </span>\n              <span class=\"mini-info\">\n                {{ subscription.liteRoute.schedule }}\n              </span>\n            </div>\n          </route-item-additional-info>\n        </route-item>\n        <i class=\"icon ion-ios-arrow-right icon-accessory\"></i>\n      </a>\n    </div>\n\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 568 */
/*!******************************************!*\
  !*** ./www/templates/ticket-detail.html ***!
  \******************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view class=\"ticket-detail\" ng-init=\"activeTab=0\"\n  hide-back-button=\"true\" can-swipe-back=\"false\">\n  <ion-nav-buttons side=\"left\">\n    <button class=\"button button-clear back-button\"\n       ui-sref=\"tabs.tickets\">\n       <i class=\"icon ion-ios-arrow-back\"></i> Tickets\n    </button>\n  </ion-nav-buttons>\n\n  <ion-nav-title>Ticket for {{ticket.boardStop.time | date:'d MMM y' : '+0800'}}</ion-nav-title>\n  <div class=\"tabs tabs-top tabs-icon-left tabs-light tabs-striped tabs-color-royal\">\n    <a class=\"tab-item\" on-tap=\"activeTab=0\" ng-class=\"{active: activeTab===0}\">\n      <span class=\"tab-title-large\"><i class=\"ticket-nav-ticket\"></i>Ticket</a>\n    </span>\n      <a class=\"tab-item\" on-tap=\"activeTab=1\" ng-class=\"{active: activeTab===1}\">\n        <span class=\"tab-title-large\"><i class=\"ticket-nav-moreInfo\"></i>More Info</span>\n      </a>\n  </div>\n  <ion-content class=\"has-tabs-top\" scroll=false>\n\n    <!-- Ticket Tab -->\n    <div class=\"trip-info item item-text-wrap\" ng-show=\"activeTab===0\">\n      <div class=\"row\">\n        <div class=\"col col-20\">\n          <span class=\"bus-number\" ng-show=\"route.label\">{{route.label}}</span>\n        </div>\n        <div class=\"col\">\n          <h4>Trip Code </h4>\n          <trip-code class=\"trip-code\" code=\"info.code\" ng-if=\"info.code\">\n          </trip-code>\n          <span ng-if=\"!info.code\">Not available</span>\n          <!-- <div class=\"trip-code\"\n            ng-bind=\"info.trip.id\"></div> -->\n        </div>\n        <div class=\"col\">\n          <h4>Vehicle No.</h4>\n          <div ng-if=\"info.trip.vehicle.vehicleNumber\" class=\"vehicleNo\" ng-bind=\"info.trip.vehicle.vehicleNumber\">\n          </div>\n          <div ng-if=\"!info.trip.vehicle.vehicleNumber\">\n            Not provided\n          </div>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"route-info\">\n          <div class=\"start\">\n            <span class=\"time\" ng-bind=\"ticket.boardStop.time | date:'h:mm a' : '+0800'\"></span><img class=\"route-icon\" src=\"./img/RoutePairSmallStart.svg\" />\n              <div class=\"routeDetailDesc\">\n                {{ticket.boardStop.stop.description}}, {{ticket.boardStop.stop.road}}</div>\n          </div>\n            <div class=\"end\">\n            <span class=\"time\" ng-bind=\"ticket.alightStop.time | date:'h:mm a' : '+0800'\"></span><img class=\"route-icon\" src=\"./img/RoutePairSmallEnd.svg\" />\n              <div class=\"routeDetailDesc\">{{ticket.alightStop.stop.description}}, {{ticket.alightStop.stop.road}}</div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Driver Tab -->\n    <div class=\"trip-info item item-text-wrap\" ng-show=\"activeTab===1\">\n      <div class=\"row\">\n        <div class=\"col\">\n          <h4>Operated By</h4>\n          <span ng-bind=\"company.name\"></span>\n          <a ng-click=\"showTerms(company.id)\"><i class=\"icon ion-information-circled tnc\"></i></a>\n        </div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col\">\n          <h4>Driver</h4>\n          <div ng-bind=\"info.trip.tripDriver.name  || 'Not provided'\"></div>\n        </div>\n        <div class=\"col\">\n          <h4>Passenger</h4>\n          <div ng-bind=\"user.name\"></div>\n        </div>\n      </div>\n    </div>\n\n    <ui-gmap-google-map ng-if=\"info.trip.isRunning\" center=\"map.center\" pan=\"true\" zoom=\"map.zoom\" options=\"map.options\" events=\"map.events\" bounds=\"map.bounds\" dragging=\"map.dragging\" control=\"map.control\" data-tap-disabled=\"true\">\n      <my-location></my-location>\n      <ui-gmap-polyline path=\"map.lines.route.path\" stroke=\"map.pathOptions.routePath\"></ui-gmap-polyline>\n      <ui-gmap-polyline ng-if=\"map.lines.actualPath.path.length\"\n                        path=\"map.lines.actualPath.path\"\n                        stroke=\"map.pathOptions.actualPath\"></ui-gmap-polyline>\n      <ui-gmap-marker idkey=\"'boardstop'\"\n                      ng-if=\"map.markers.boardStop.stop\"\n                      coords=\"map.markers.boardStop.stop.coordinates\"\n                      options=\"map.markerOptions.startMarker\"></ui-gmap-marker>\n      <ui-gmap-marker idkey=\"'alightstop'\"\n                      ng-if=\"map.markers.alightStop.stop\"\n                      coords=\"map.markers.alightStop.stop.coordinates\"\n                      options=\"map.markerOptions.endMarker\"></ui-gmap-marker>\n      <ui-gmap-marker ng-if=\"map.busLocation.coordinates\"\n                      idkey=\"'bus-location'\"\n                      coords=\"map.busLocation.coordinates\"\n                      icon=\"map.busLocation.icon\"></ui-gmap-marker>\n      <ui-gmap-markers  ng-if=\"trip.tripStops\"\n                        models=\"trip.tripStops\"\n                        idkey=\"'id'\"\n                        options=\"'_markerOptions'\"\n                        coords=\"'stop.coordinates'\"\n                        ></ui-gmap-markers>\n    </ui-gmap-google-map>\n\n    <!-- Service cancellation when driver or ops press trip cancellation button, show the following -->\n    <ion-scroll class=\"service-cancellation\" ng-if=\"info.trip.status == 'cancelled'\">\n      <div class=\"item item-text-wrap\">\n        <div class=\"cancellation-content\">\n          <h2>Service is Cancelled</h2>\n          <img src=\"img/TicketCancelledTrip.svg\" />\n          <!-- <i class=\"icon ion-alert-circled\"></i> -->\n          <p>Today's trip has been cancelled. Sorry for the inconvenience caused. </p>\n          <p>\n            Please make alternative transport arrangements.\n            <strong>{{company.name}}</strong> will contact you and refund today's fare.\n          </p>\n          <p>\n            For enquiries, please contact\n            <strong>{{company.email}}</strong>\n            <strong ng-if=\"company.contactNo\">(Tel: {{company.contactNo}})</strong>\n          </p>\n        </div>\n      </div>\n    </ion-scroll>\n    <!-- Service cancellation section ends -->\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 569 */
/*!**********************************************!*\
  !*** ./www/templates/tab-booking-stops.html ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view id=\"pg_booking\" view-title=\"Select Stops\"\n  hide-back-button=\"true\" can-swipe-back=\"false\">\n  <ion-nav-buttons side=\"left\">\n    <button class=\"button button-clear back-button\"\n       ui-sref=\"tabs.routes\">\n       <i class=\"icon ion-ios-arrow-back\"></i> Routes\n    </button>\n  </ion-nav-buttons>\n  <ion-nav-buttons side=\"right\">\n    <button class=\"button button-clear\"\n       ui-sref=\"tabs.routes\">\n       <i class=\"icon ion-ios-close-outline\"></i>\n    </button>\n  </ion-nav-buttons>\n\n  <ion-content class=\"fullscreen-map\" scroll=\"false\">\n    <form class=\"stops-form\" name=\"stopsForm\">\n      <!-- <booking-breadcrumbs step=\"0\" class=\"flex-shrink\"></booking-breadcrumbs> -->\n      <div class=\"item item-icon-left item-text-wrap\" ng-if=\"book.route.ridesRemaining && book.route.ridesRemaining > 0\" >\n          <i class=\"icon activebid\">\n              <img src=\"img/icon_kickstarter_activebid.svg\">\n          </i>\n          You have {{ +book.route.ridesRemaining }} trip(s) remaining in your Route Pass. <!-- Use by DD/MM/YY. -->\n      </div>\n      <div class=\"route-info item\">\n        <route-item hide-additional-info=\"true\">\n          <route-item-bus-number>\n            {{ book.route.label }}\n          </route-item-bus-number>\n          <route-item-start-time>\n            {{ book.route | routeStartTime | formatTime:true }}\n          </route-item-start-time>\n          <route-item-start-location>\n            {{ book.route.from }}\n          </route-item-start-location>\n          <route-item-end-time>\n            {{ book.route | routeEndTime | formatTime:true }}\n          </route-item-end-time>\n          <route-item-end-location>\n            {{ book.route.to }}\n          </route-item-end-location>\n\n        </route-item>\n\n        <div class=\"price\">\n          <fancy-price value=\"book.route.trips[0].price\"></fancy-price>\n        </div>\n      </div>\n\n      <!-- contains the map, the stop selectors\n        and the locate me button -->\n      <div class=\"map-area\">\n        <ui-gmap-google-map\n            center=\"map.center\"\n            zoom=\"map.zoom\"\n            bounds=\"map.bounds\"\n            control=\"map.control\"\n            options=\"map.options\">\n          <my-location></my-location>\n\n          <ui-gmap-window ng-if=\"disp.popupStop\"\n                          coords=\"disp.popupStop.coordinates\"\n                          show=\"disp.popupStop\"\n                          closeClick=\"closeWindow\">\n            <div class=\"popUpStopSelect\">\n              <b>{{disp.popupStop.time | formatTime }}</b><br/>\n              {{disp.popupStop.description}}<br/>{{disp.popupStop.road}}<br/>\n              <a class=\"button button-block button-outline button-royal\"\n                ng-click=\"$parent.$parent.setStop($parent.$parent.disp.popupStop, $parent.$parent.disp.popupStopType)\">\n                Set {{disp.popupStopType === 'pickup' ? 'pick-up' : 'drop-off'}} stop\n              </a>\n            </div>\n          </ui-gmap-window>\n\n          <ui-gmap-marker\n            ng-repeat=\"stop in book.boardStops\"\n            idKey=\"stop.id\"\n            coords=\"stop.coordinates\"\n            options=\"map.markerOptions.boardMarker\"\n            click=\"applyTapBoard(stop)\"\n          ></ui-gmap-marker>\n          <ui-gmap-marker\n            ng-repeat=\"stop in book.alightStops\"\n            idKey=\"stop.id\"\n            coords=\"stop.coordinates\"\n            options=\"map.markerOptions.alightMarker\"\n            click=\"applyTapAlight(stop)\"\n          ></ui-gmap-marker>\n\n          <ui-gmap-polyline\n            path=\"routePath\"\n            static=\"true\"\n            stroke=\"map.pathOptions.routePath\"\n          >\n          </ui-gmap-polyline>\n\n          <ui-gmap-marker\n            idkey=\"'bs'\"\n            coords=\"book.boardStop.coordinates\"\n            options=\"map.markerOptions.startMarker\">\n          </ui-gmap-marker>\n\n          <ui-gmap-marker\n            idkey=\"'as'\"\n            coords=\"book.alightStop.coordinates\"\n            options=\"map.markerOptions.endMarker\">\n          </ui-gmap-marker>\n\n        </ui-gmap-google-map>\n      </div>\n\n      <ion-list class=\"stop-inputs\">\n        <bus-stop-selector\n          ng-model=\"book.boardStop\"\n          bus-stops=\"book.boardStops\"\n          placeholder=\"Select pick-up stop\"\n          title=\"Select pick-up stop\"\n          button=\"Select pick-up stop\"\n          marker-options=\"map.markerOptions.boardMarker\"\n          pin-options=\"map.markerOptions.startMarker\"\n          ng-required=\"true\"\n          name=\"boardStop\"\n          >\n        </bus-stop-selector>\n        <bus-stop-selector\n          ng-model=\"book.alightStop\"\n          bus-stops=\"book.alightStops\"\n          placeholder=\"Select drop-off stop\"\n          title=\"Select drop-off stop\"\n          button=\"Select drop-off stop\"\n          marker-options=\"map.markerOptions.alightMarker\"\n          pin-options=\"map.markerOptions.endMarker\"\n          ng-required=\"true\"\n          name=\"alightStop\"\n          >\n        </bus-stop-selector>\n      </ion-list>\n\n      <div class=\"item continue-button-item\">\n        <button class=\"button primary-button button-item\"\n          ui-sref=\"tabs.booking-dates({\n            routeId: book.routeId,\n            boardStop: book.boardStop.id,\n            alightStop: book.alightStop.id,\n            sessionId: session.sessionId,\n          })\"\n          ng-disabled=\"stopsForm.$invalid\">\n          Continue\n        </button>\n      </div>\n    </form> <!-- flex-col -->\n  </ion-content>\n\n  <script id=\"changes-message.html\" type=\"text/ng-template\">\n    <div class=\"changes-message modal\">\n      <ion-header-bar class=\"bar-royal\">\n        <h1 class=\"title\">Changes to Service #{{book.routeId}}</h1>\n        <button class=\"button icon ion-ios-close-outline button-clear\" ng-click=\"closeChangesModal()\">\n        </button>\n      </ion-header-bar>\n      <ion-content>\n        <table class=\"route-changes-table\">\n          <thead>\n            <tr>\n              <th><!--icon--></th>\n              <th>Date</th>\n              <th>Changes</th>\n            </tr>\n          </thead>\n          <tbody>\n              <tr ng-repeat=\"priceChange in book.changes.priceChanges\">\n              <td>$$</td>\n              <td>\n                {{priceChange.startDate | formatDate}}\n              </td>\n              <td>\n                {{priceChange.humanReadable[0]}}\n              </td>\n            </tr>\n              <tr ng-repeat=\"stopChange in book.changes.stopChanges\">\n              <td>S</td>\n              <td>\n                {{stopChange.startDate | formatDate}}\n              </td>\n              <td>\n                <ul>\n                  <li ng-repeat=\"hr in stopChange.humanReadable track by $index\">\n                {{hr}}\n                </li>\n                </ul>\n              </td>\n            </tr>\n              <tr ng-repeat=\"timeChange in book.changes.timeChanges\">\n              <td>T</td>\n              <td>\n                {{timeChange.startDate | formatDate}}\n              </td>\n              <td>\n                <ul>\n                  <li ng-repeat=\"hr in timeChange.humanReadable track by $index\">\n                {{hr}}\n                </li>\n                </ul>\n              </td>\n            </tr>\n          </tbody>\n        </table>\n      </ion-content>\n    </div>\n  </script>\n</ion-view>\n";

/***/ },
/* 570 */
/*!**********************************************!*\
  !*** ./www/templates/tab-booking-dates.html ***!
  \**********************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view id=\"pg_bookdate\" view-title=\"Select Dates\"\n  hide-back-button=\"true\">\n  <ion-nav-buttons side=\"left\">\n    <a class=\"button button-clear back-button\"\n       ui-sref=\"tabs.bookingPickup({\n        boardStop: book.boardStopId,\n        alightStop: book.alightStopId,\n        routeId: book.routeId,\n        sessionId: session.sessionId,\n      })\" nav-direction=\"back\">\n       <i class=\"icon ion-ios-arrow-back\"></i> Stops\n    </a>\n  </ion-nav-buttons>\n  <ion-nav-buttons side=\"right\">\n    <button class=\"button button-clear\"\n       ui-sref=\"tabs.routes\">\n       <i class=\"icon ion-ios-close-outline\"></i>\n    </button>\n  </ion-nav-buttons>\n\n  <ion-content>\n    <booking-breadcrumbs step=\"1\"></booking-breadcrumbs>\n    <div class=\"item datepickerIntro\">\n        Tap to select multiple days\n    </div>\n    <multiple-date-picker ng-model=\"disp.selectedDatesMoments\"\n                          days-allowed=\"disp.daysAllowed\"\n                          month=\"disp.month\"\n                          sunday-first-day=\"true\"\n                          highlight-days=\"disp.highlightDays\"\n                          disallow-back-past-months=\"true\"\n                          disable-days-before=\"disp.today\">\n    </multiple-date-picker>\n\n    <div class=\"datepicker\">\n      <table class=\"legend-table\">\n        <tr>\n          <td class=\"picker-day exemplar\">\n            #\n          </td>\n          <td class=\"label\">Available</td>\n          <td class=\"picker-day picker-off exemplar\">\n            #\n          </td>\n          <td class=\"label\">Not Available</td>\n        </tr>\n        <tr>\n          <td class=\"picker-day picker-selected activated exemplar\">\n            #\n          </td>\n          <td class=\"label\">Dates Selected</td>\n          <td class=\"picker-day picker-off previously-booked exemplar\">\n            #\n          </td>\n          <td class=\"label\">Your Previous Bookings</td>\n        </tr>\n        <tr>\n          <td class=\"picker-day picker-off sold-out examplar\">\n            #\n          </td>\n          <td class=\"label\">Sold out</td>\n        </tr>\n      </table>\n    </div>\n\n    <div class=\"item\">\n      <price-calculator booking=\"book\" show-promo-field=\"false\"></price-calculator>\n    </div>\n\n    <div class=\"item\">\n      <button class=\"button primary-button button-item\" ng-disabled=\"book.selectedDates.length == 0\" ui-sref=\"tabs.booking-summary({\n                routeId: book.routeId,\n                boardStop: book.boardStopId,\n                alightStop: book.alightStopId,\n                selectedDates: book.selectedDates,\n                sessionId: session.sessionId,\n                promoCode: book.promoCode,\n              })\">\n        Review Booking\n      </button>\n    </div>\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 571 */
/*!************************************************!*\
  !*** ./www/templates/tab-booking-summary.html ***!
  \************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view id=\"pg_summary\" view-title=\"Booking Summary\"\n  hide-back-button=\"true\">\n  <ion-nav-buttons side=\"left\">\n    <button class=\"button button-clear back-button\"\n       ui-sref=\"tabs.booking-dates({\n        boardStop: book.boardStopId,\n        alightStop: book.alightStopId,\n        routeId: book.routeId,\n        sessionId: session.sessionId,\n      })\">\n       <i class=\"icon ion-ios-arrow-back\"></i> Dates\n    </button>\n  </ion-nav-buttons>\n  <ion-nav-buttons side=\"right\">\n    <button class=\"button button-clear\"\n       ui-sref=\"tabs.routes\">\n       <i class=\"icon ion-ios-close-outline\"></i>\n    </button>\n  </ion-nav-buttons>\n  <ion-content>\n    <booking-breadcrumbs step=\"2\"></booking-breadcrumbs>\n    <!-- <div class=\"item item-text-wrap\">\n      Please review the route and bus stop selections you have made for this booking.<br />\n      To change any of the selections, please click its corresponding <b>Edit</b> button.\n    </div> -->\n\n    <section class=\"card\">\n      <h3 class=\"item item-divider\">\n        Selected Route\n      </h3>\n      <route-item class=\"item\" hide-additional-info=\"true\">\n        <route-item-bus-number>\n          {{ book.route.label }}\n        </route-item-bus-number>\n        <route-item-start-time>\n          {{book.boardStop.time | formatTime:true}}\n        </route-item-start-time>\n        <route-item-start-location>\n          <h4>Pick-up at</h4>\n          {{book.boardStop.stop.description}}<br/>\n          {{book.boardStop.stop.road}}<br/>\n          <br/>\n        </route-item-start-location>\n        <route-item-end-time>\n          {{book.alightStop.time | formatTime:true}}\n        </route-item-end-time>\n        <route-item-end-location>\n          <h4>Drop-off at</h4>\n          {{book.alightStop.stop.description}}<br/>\n          {{book.alightStop.stop.road}}<br/>\n          <br/>\n        </route-item-end-location>\n      </route-item>\n\n    </section>\n\n\n    <section class=\"card\">\n      <h3 class=\"item item-divider\">\n        Selected Dates\n      </h3>\n      <price-calculator id=\"priceCalc\" class=\"item\" booking=\"book\" price=\"book.price\" show-promo-field=\"true\">\n      </price-calculator>\n      <button class=\"button button-block button-outline button-royal\" ng-hide=\"book.promoCode\"\n              ng-click=\"promptPromoCode()\">\n        Enter Promo Code\n      </button>\n    </section>\n\n    <section class=\"card\">\n      <h3 class=\"item item-divider\">\n        Terms and Conditions of Service\n      </h3>\n      <company-tnc company-id=\"book.route.transportCompanyId\"\n                   features=\"book.features\"\n                   signage-text=\"book.route.notes.signage ? book.route.notes.signage : 'To ' + book.route.to\"></company-tnc>\n      <ion-checkbox class=\"item item-text-wrap\" ng-model=\"disp.termsChecked\">\n        Yes, I have read and agree to the Terms and Conditions of Service.\n      </ion-checkbox>\n      <ion-checkbox\n        class=\"item item-text-wrap\"\n        ng-model=\"disp.savePaymentChecked\"\n        ng-if=\"!hasSavedPaymentInfo && !disp.zeroDollarPurchase\">\n        Yes, I want to save this payment method for fast checkout in the future.\n      </ion-checkbox>\n    </section>\n\n    <section class=\"item item-text-wrap\"\n             ng-if=\"!isLoggedIn\">\n      You are not logged in. Please enter your mobile number to complete booking.\n\n      <button class=\"button primary-button\"\n              ng-click=\"login()\"\n              ng-disabled=\"!disp.termsChecked || isPaymentProcessing\">\n        Log In\n      </button>\n    </section>\n\n    <section class=\"item item-text-wrap assertive\"\n             ng-if=\"isLoggedIn && book.hasInvalidDate\">\n      You have invalid booking dates. Please re-select your dates.\n    </section>\n\n\n    <section ng-if=\"isLoggedIn && disp.zeroDollarPurchase\">\n      <button class=\"button primary-button\"\n              ng-click=\"payZeroDollar()\"\n              ng-disabled=\"!disp.termsChecked || isPaymentProcessing || book.hasInvalidDate || isPreviewCalculating\">\n        Complete purchase\n      </button>\n    </section>\n    <section ng-if=\"!disp.zeroDollarPurchase\">\n      <section class=\"item item-text-wrap\"\n               ng-if=\"isLoggedIn && !hasSavedPaymentInfo\">\n        Please ensure that your credit card is ready for the next step in the booking process.\n        <button class=\"button primary-button\"\n                ng-click=\"payHandler()\"\n                ng-disabled=\"!disp.termsChecked || isPaymentProcessing || book.hasInvalidDate || isPreviewCalculating || book.price===undefined\">\n          Confirm and Pay\n        </button>\n      </section>\n      <section class=\"item item-text-wrap\"\n               ng-if=\"isLoggedIn && hasSavedPaymentInfo\">\n        This payment will be charged to your <b>{{user.savedPaymentInfo.sources.data[0].brand}}</b>\n        ending in <b> {{user.savedPaymentInfo.sources.data[0].last4}} </b>.\n\n        <button class=\"button primary-button\"\n                ng-click=\"payWithSavedInfo()\"\n                ng-disabled=\"!disp.termsChecked || isPaymentProcessing || book.hasInvalidDate || isPreviewCalculating || book.price===undefined\">\n          Confirm and Pay\n        </button>\n        <div class=\"text-link-div\">\n          <a ng-class=\"(!disp.termsChecked || isPaymentProcessing || book.hasInvalidDate || isPreviewCalculating) ? 'text-link-disabled' : ''\"\n              ng-click=\"payWithoutSavingCard()\">\n              Use a different card for this payment\n          </a>\n        </div>\n      </section>\n    </section>\n  </ion-content>\n</ion-view>\n";

/***/ },
/* 572 */
/*!*****************************************************!*\
  !*** ./www/templates/tab-booking-confirmation.html ***!
  \*****************************************************/
/***/ function(module, exports) {

	module.exports = "<ion-view view-title=\"Booking Summary\" hide-back-button=\"true\">\n  <ion-nav-buttons side=\"right\">\n    <button class=\"button button-clear\"\n       ui-sref=\"tabs.routes\">\n       <i class=\"icon ion-ios-close-outline\"></i>\n    </button>\n  </ion-nav-buttons>\n  <ion-content class=\"booking-content\" scroll=false>\n    <ion-item class=\"item item-text-wrap\">\n      <div class=\"row\">\n        <div class=\"col-33 success-image\"><img src=\"img/paymentComplete_paid.svg\"></div>\n        <div class=\"col-67 success-text\">Success! Your payment has been processed.</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col-33 success-image\"><img src=\"img/paymentComplete_track.svg\"></div>\n        <div class=\"col-67 success-text\">Track your bus arrival on the day of the trip with the e-tickets</div>\n      </div>\n      <div class=\"row\">\n        <div class=\"col-33 success-image\"><img src=\"img/paymentComplete_showTicket.svg\"></div>\n        <div class=\"col-67 success-text\">Track your bus arrival on the day of the trip with the e-tickets</div>\n      </div>\n      <button class=\"primary-button button\" ui-sref=\"tabs.tickets\">\n        View Tickets\n      </button>\n    </ion-item>\n  </ion-content>\n</ion-view>\n";

/***/ }
/******/ ]);
//# sourceMappingURL=bundle.js.map